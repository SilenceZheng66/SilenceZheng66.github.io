<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenceZheng66-BLOG</title>
  
  <subtitle>silencezheng.top</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2025-02-02T07:54:07.905Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>SilenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>差分数组</title>
    <link href="http://silencezheng.top/2025/02/02/article155/"/>
    <id>http://silencezheng.top/2025/02/02/article155/</id>
    <published>2025-02-02T07:53:21.000Z</published>
    <updated>2025-02-02T07:54:07.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>差分数组利用空间换时间，实现在$O(1)$时间内完成对连续数组的增减操作。本次介绍一维、二维差分数组。</p><p>需要注意的是，差分数组对于查询频繁的场景并不适用，因为还原数组仍需全部遍历。<br><span id="more"></span></p><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>考虑数组 $a=[1,3,3,5,8]$，对其中的相邻元素两两作差（右边减左边），得到数组 $[2,0,2,3]$。然后在开头补上 $a[0]$，得到差分数组：$d=[1,2,0,2,3]$</p><p>这有什么用呢？如果从左到右累加 ddd 中的元素，我们就「还原」回了 $a$ 数组 $[1,3,3,5,8]$。这类似求导与积分的概念。</p><p>这又有什么用呢？现在把连续子数组 $a[1],a[2],a[3]$ 都加上 $10$，得到 $a’=[1,13,13,15,8]$。再次两两作差，并在开头补上 $a’[0]$，得到差分数组：$d’=[1,12,0,2,−7]$</p><p>对比 $d$ 和 $d’$，可以发现只有 $d[1]$ 和 $d[4]$ 变化了，这意味着<strong>对 $a$ 中连续子数组的操作，可以转变成对差分数组 $d$ 中两个数的操作</strong>。</p><h2 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h2><p>对于数组 $a$，定义其差分数组（difference array）为</p><script type="math/tex; mode=display">d[i] = \begin{cases} a[0],&i=0\\ a[i]-a[i-1],&i\ge 1 \end{cases}​</script><p>性质 1：从左到右累加 $d$ 中的元素，可以得到数组 $a$。</p><p>性质 2：如下两个操作是等价的。</p><ul><li>把 $a$ 的子数组 $a[i],a[i+1],\cdots,a[j]$ 都加上 $x$。</li><li>把 $d[i]$ 增加 $x$，把 $d[j+1]$ 减少 $x$。</li></ul><p>利用性质 2，我们只需要 $O(1)$ 的时间就可以完成对 $a$ 的子数组的操作。最后利用性质 1 从差分数组复原出数组 $a$。</p><p>注：也可以这样理解，$d[i]$ 表示把下标 $≥i$ 的数都加上 $d[i]$。</p><h2 id="二维差分数组"><a href="#二维差分数组" class="headerlink" title="二维差分数组"></a>二维差分数组</h2><p>对于二维数组 <code>a</code>，可以将其定义为差分数组 <code>d</code> 的<strong>二维前缀和</strong>数组。差分数组的每个元素 <code>d[i][j]</code> 反映了原数组中特定区域的增量变化，满足以下关系：</p><script type="math/tex; mode=display">a[i][j] = \sum_{x=0}^i \sum_{y=0}^j d[x][y]</script><p>构造差分数组时，初始化全为0。对原数组 <code>a</code> 的子矩阵操作（从 <code>(x1,y1)</code> 到 <code>(x2,y2)</code> 加 <code>x</code>）可转换为对差分数组 <code>d</code> 的四个关键点的操作：</p><ol><li><code>d[x1][y1] += x</code></li><li><code>d[x1][y2+1] -= x</code></li><li><code>d[x2+1][y1] -= x</code></li><li><code>d[x2+1][y2+1] += x</code></li></ol><p>这样，在后续计算前缀和时，该子矩阵内的所有元素都会正确增加 <code>x</code>。通过计算差分数组的二维前缀和即可还原出原数组。每个元素的值由其左上方的差分值累加得到。</p><p>示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDDifference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：根据原数组构造差分数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoDDifference</span><span class="params">(<span class="keyword">int</span>[][] a)</span> </span>&#123;</span><br><span class="line">        m = a.length;</span><br><span class="line">        n = a[<span class="number">0</span>].length;</span><br><span class="line">        d = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>]; <span class="comment">// 多开一行一列处理边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 将每个元素的初始化视为单点更新</span></span><br><span class="line">                add(i, j, i, j, a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对子矩阵 [x1,y1] 到 [x2,y2] 增加 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        d[x1][y1] += x;</span><br><span class="line">        d[x1][y2 + <span class="number">1</span>] -= x;</span><br><span class="line">        d[x2 + <span class="number">1</span>][y1] -= x;</span><br><span class="line">        d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并返回操作后的原数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] compute() &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="comment">// 计算二维前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                a[i][j] = d[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) a[i][j] += a[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) a[i][j] -= a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] original = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">TwoDDifference diff = <span class="keyword">new</span> TwoDDifference(original);</span><br><span class="line">diff.add(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>); <span class="comment">// 整个矩阵加 5</span></span><br><span class="line"><span class="keyword">int</span>[][] result = diff.compute(); </span><br><span class="line"><span class="comment">// 结果变为 [[6,7], [8,9]]</span></span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://silencezheng.top/2024/08/18/article133/">https://silencezheng.top/2024/08/18/article133/</a><br>[2] <a href="https://blog.csdn.net/qq_63786973/article/details/127667301">https://blog.csdn.net/qq_63786973/article/details/127667301</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;差分数组利用空间换时间，实现在$O(1)$时间内完成对连续数组的增减操作。本次介绍一维、二维差分数组。&lt;/p&gt;
&lt;p&gt;需要注意的是，差分数组对于查询频繁的场景并不适用，因为还原数组仍需全部遍历。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Trie字典树</title>
    <link href="http://silencezheng.top/2024/12/17/article154/"/>
    <id>http://silencezheng.top/2024/12/17/article154/</id>
    <published>2024-12-17T08:00:44.000Z</published>
    <updated>2024-12-17T08:02:36.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>字典树，英文名 trie。顾名思义，就是一个像字典一样的树。</p><p>PS：某砍一刀大厂的手撕题目…当时直接不会换题了，现在回来还债。<br><span id="more"></span></p><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p><img src="/assets/post_img/article154/trie1.png" alt="Trie"></p><p>Trie如图所示，可以发现，这棵字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子，$1\to4\to 8\to 12$ 表示的就是字符串 $caa$。</p><p>Trie 的结构非常好懂，我们用 $\delta(u,c)$ 表示结点 $u$ 的 $c$ 字符指向的下一个结点，或着说是结点 $u$ 代表的字符串后面添加一个字符 $c$ 形成的字符串的结点。（$c$ 的取值范围和字符集大小有关，不一定是 $0\sim 26$。）</p><p>有时需要标记插入进 trie 的是哪些字符串，每次插入完成时在这个字符串所代表的节点处打上标记即可。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li><p><strong><code>int[][] tree = new int[10000][26];</code></strong>：</p><ul><li>这是一个二维数组，模拟了字典树的节点。每个节点可以有最多26个子节点（对应于小写字母a-z）。<code>tree[p][c]</code> 表示从节点 <code>p</code> 出发，通过字符 <code>c</code> (‘a’ + c) 到达的下一个节点。</li></ul></li><li><p><strong><code>int cnt = 0;</code></strong>：</p><ul><li>计数器，用来分配新的节点编号。每当插入一个新的分支时，<code>cnt</code> 增加，并为新节点分配一个唯一的ID。</li></ul></li><li><p><strong><code>boolean[] end = new boolean[10000];</code></strong>：</p><ul><li>标记哪些节点是某个单词的结尾。<code>end[p] == true</code> 表示节点 <code>p</code> 是一个单词的结束位置。</li></ul></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p><strong><code>public void insert(String word)</code></strong>：</p><ul><li>插入一个单词到字典树中。<ul><li>从根节点开始（<code>p = 0</code>），遍历单词中的每一个字符。</li><li>对于每个字符，计算其相对于 ‘a’ 的偏移量 <code>c</code>，然后检查当前节点是否有对应的子节点。</li><li>如果没有，则创建一个新的子节点，并更新 <code>tree[p][c]</code> 指向这个新节点。</li><li>移动到下一个节点（<code>p = tree[p][c]</code>），继续处理下一个字符。</li><li>最后，将到达的节点标记为单词的结束位置（<code>end[p] = true</code>）。</li></ul></li></ul></li><li><p><strong><code>public boolean find(String word)</code></strong>：</p><ul><li>查找一个单词是否存在于字典树中。<ul><li>从根节点开始（<code>p = 0</code>），遍历单词中的每一个字符。</li><li>对于每个字符，计算其相对于 ‘a’ 的偏移量 <code>c</code>，并尝试移动到相应的子节点。</li><li>如果在某一步无法找到对应的子节点，则返回 <code>false</code>，表示单词不存在。</li><li>如果成功遍历完所有字符，最后检查到达的节点是否被标记为单词的结束位置（<code>end[p]</code>），如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] tree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] end = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = chars[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[p][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                tree[p][c] = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tree[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">        end[p] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = chars[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[p][c] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = tree[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end[p];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>高效性</strong>：插入和查找操作的时间复杂度都是 (O(L))，其中 (L) 是单词的长度。这是因为每次操作都只需要沿着路径逐层深入。</li><li><strong>节省空间</strong>：相比于直接使用哈希表来存储单词，字典树能够更有效地利用公共前缀，从而减少内存占用。</li><li><strong>支持前缀查询</strong>：除了完整单词的查找外，字典树还可以轻松扩展以支持前缀匹配或模糊查询等功能。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/string/trie/">https://oi-wiki.org/string/trie/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;字典树，英文名 trie。顾名思义，就是一个像字典一样的树。&lt;/p&gt;
&lt;p&gt;PS：某砍一刀大厂的手撕题目…当时直接不会换题了，现在回来还债。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://silencezheng.top/2024/12/17/article153/"/>
    <id>http://silencezheng.top/2024/12/17/article153/</id>
    <published>2024-12-17T07:40:32.000Z</published>
    <updated>2024-12-17T07:42:48.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配（在字符串中查找子串）的高效算法，由Donald Knuth、Vaughan Pratt 和 James H. Morris 独立发明，并在1977年被共同发表。它改进了朴素字符串匹配算法，在最坏情况下的时间复杂度为 $O(n + m)$，其中 $n$ 是文本字符串的长度，$m$ 是模式字符串的长度。<br><span id="more"></span></p><h1 id="子串、子序列、真前缀和真后缀"><a href="#子串、子序列、真前缀和真后缀" class="headerlink" title="子串、子序列、真前缀和真后缀"></a>子串、子序列、真前缀和真后缀</h1><ul><li><strong>子串</strong>：子串是由字符串中连续字符组成的新字符串。</li><li><strong>子序列</strong>：子序列是通过删除字符串中某些字符而不改变其余字符顺序得到的序列。</li><li><strong>真前缀</strong>：真前缀是指字符串的非空开头部分，不包括整个字符串本身。</li><li><strong>真后缀</strong>：真后缀是指字符串的非空结尾部分，同样不包括整个字符串本身。</li></ul><h1 id="前缀函数"><a href="#前缀函数" class="headerlink" title="前缀函数"></a>前缀函数</h1><p>给定一个长度为 $n$ 的字符串 $s$，其<strong>前缀函数</strong>被定义为一个长度为 $n$ 的数组 $\pi$。 其中 $\pi[i]$ 的定义是：</p><ol><li>如果子串 $s[0\dots i]$ 有一对相等的真前缀与真后缀：$s[0\dots k-1]$ 和 $s[i - (k - 1) \dots i]$，那么 $\pi[i]$ 就是这个相等的真前缀（或者真后缀，因为它们相等）的长度，也就是 $\pi[i]=k$；</li><li>如果不止有一对相等的，那么 $\pi[i]$ 就是其中最长的那一对的长度；</li><li>如果没有相等的，那么 $\pi[i]=0$。</li></ol><p>简单来说 $\pi[i]$ 就是，子串 $s[0\dots i]$ 最长的相等的真前缀与真后缀的长度。</p><p>用数学语言描述如下：</p><script type="math/tex; mode=display">\pi[i] = \max_{k = 0 \dots i}\{k: s[0 \dots k - 1] = s[i - (k - 1) \dots i]\}</script><p>特别地，规定 $\pi[0]=0$。</p><p>举例来说，字符串 $aabaaab$ 的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h1 id="计算前缀函数的算法"><a href="#计算前缀函数的算法" class="headerlink" title="计算前缀函数的算法"></a>计算前缀函数的算法</h1><p>最朴素的算法是双循环遍历，这个很容易想到。这种朴素算法的时间复杂度是$O(n^3)$，因为除去外层的双循环外，比对真前缀和真后缀的相等也需要进行一次遍历。</p><p>考虑到当取一个尽可能大的 $\pi[i+1]$ 时，必然要求新增的 $s[i+1]$ 也与之对应的字符匹配，即 $s[i+1]=s[\pi[i]]$, 此时 $\pi[i+1] = \pi[i]+1$。所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。则对于位置$i+1$的内部循环的起始位置可以从上一位置的$\pi[i]$开始，此时“内循环”和“子串对比”存在此消彼长的制约关系，即$\pi[i]$限制了求取$\pi[i+1]$的最大内循环次数，则时间复杂度下降至$O(n^2)$。</p><p>继续考虑当 $s[i+1] \neq s[\pi[i]]$ 时如何跳转，即对于新指向的位置，在第一次对比时发生了<strong>失配</strong>。此时希望找到“合适的第二长度$j$”，使得在位置 $i$ 的前缀性质仍得以保持，也即 $s[0 \dots j - 1] = s[i - j + 1 \dots i]$：</p><script type="math/tex; mode=display">\overbrace{\underbrace{s_0 ~ s_1}_j ~ s_2 ~ s_3}^{\pi[i]} ~ \dots ~ \overbrace{s_{i-3} ~ s_{i-2} ~ \underbrace{s_{i-1} ~ s_{i}}_j}^{\pi[i]} ~ s_{i+1}</script><p>如果我们找到了这样的长度 $j$，那么仅需要再次比较 $s[i + 1]$ 和 $s[j]$。如果它们相等，那么就有 $\pi[i + 1] = j + 1$。否则，我们需要找到子串 $s[0\dots i]$ 仅次于 $j$ 的第二长度 $j^{(2)}$，使得前缀性质得以保持，如此反复，直到 $j = 0$。如果 $s[i + 1] \neq s[0]$，则 $\pi[i + 1] = 0$。</p><p>可以发现，因为 $s[0\dots \pi[i]-1] = s[i-\pi[i]+1\dots i]$，所以对于 $s[0\dots i]$ 的第二长度 $j$，有这样的性质：</p><script type="math/tex; mode=display">s[0 \dots j - 1] = s[i - j + 1 \dots i]= s[\pi[i]-j\dots \pi[i]-1]</script><p>也就是说 $j$ 等价于子串 $s[\pi[i]-1]$ 的前缀函数值，即 $j=\pi[\pi[i]-1]$。同理，次于 $j$ 的第二长度等价于 $s[j-1]$ 的前缀函数值，$j^{(2)}=\pi[j-1]$。</p><p>显然我们可以得到一个关于 $j$ 的状态转移方程：$j^{(n)}=\pi[j^{(n-1)}-1], \ \ (j^{(n-1)}&gt;0)$。所以最终我们可以构建一个不需要进行任何字符串比较，并且只进行 $O(n)$ 次操作的算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] prefix_function(String s) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] pi = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = pi[i - <span class="number">1</span>]; <span class="comment">// 初始化 j</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">            j = pi[j - <span class="number">1</span>];  <span class="comment">// 无法匹配时，找到次长的 j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        pi[i] = j; <span class="comment">// 存储前缀函数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的算法优化过程可参考文献[1]。</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法用于在字符串中查找子串，该任务是前缀函数的一个典型应用。</p><p>给定一个文本 $t$ 和一个字符串 $s$，我们尝试找到并展示 $s$ 在 $t$ 中的所有出现（occurrence）。</p><p>为了简便起见，我们用 $n$ 表示字符串 $s$ 的长度，用 $m$ 表示文本 $t$ 的长度。</p><p>我们构造一个字符串 $s + # + t$，其中 $#$ 为一个既不出现在 $s$ 中也不出现在 $t$ 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 $n + 1$ 个值（即属于字符串 $s$ 和分隔符的函数值）后其余函数值的意义。根据定义，$\pi[i]$ 为右端点在 $i$ 且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与 $s$ 的前缀相同且右端点位于 $i$ 的最长子串的长度。由于分隔符的存在，该长度不可能超过 $n$。而如果等式 $\pi[i] = n$ 成立，则意味着 $s$ 完整出现在该位置（即其右端点位于位置 $i$）。注意该位置的下标是对字符串 $s + # + t$ 而言的。</p><p>因此如果在某一位置 $i$ 有 $\pi[i] = n$ 成立，则字符串 $s$ 在字符串 $t$ 的 $i - (n - 1) - (n + 1) = i - 2n$ 处出现。</p><p>可以先根据以上原理，写出用 $O(n + m)$ 的时间以及 $O(n + m)$ 的内存解决该问题的代码如下。注意$O$符号描述的是当输入规模趋向于无穷大时算法性能的上界，它忽略常数因子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">find_occurrences</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    String cur = pattern + <span class="string">&#x27;#&#x27;</span> + text;</span><br><span class="line">    <span class="keyword">int</span> sz1 = text.length(), sz2 = pattern.length();</span><br><span class="line">    List&lt;Integer&gt; v = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] lps = prefix_function(cur);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz2 + <span class="number">1</span>; i &lt;= sz1 + sz2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lps[i] == sz2) &#123;</span><br><span class="line">            v.add(i - <span class="number">2</span> * sz2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们知道前缀函数的值永远不超过一特定值（即模式串的长度），那么我们不需要存储整个字符串以及整个前缀函数，而只需要存储字符串 $ s + #$ 以及相应的前缀函数值即可。我们可以一次读入字符串 $t$ 的一个字符并计算当前位置的前缀函数值。可以更新代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title">find_occurrences</span><span class="params">(String text, String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算模式串加上分隔符的前缀函数</span></span><br><span class="line">    String cur = pattern + <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span>[] lps = prefix_function(cur);</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; v = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> sz1 = text.length(), sz2 = pattern.length();</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>; <span class="comment">// 在模式串上进行匹配的位置指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历文本串的每一个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz1; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果不匹配并且 q &gt; 0，则回溯到之前的一个可能匹配点继续尝试匹配</span></span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(q) != text.charAt(i)) &#123;</span><br><span class="line">            q = lps[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果匹配成功，则增加 q</span></span><br><span class="line">        <span class="keyword">if</span> (pattern.charAt(q) == text.charAt(i)) &#123;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 q 达到了模式串的长度，说明找到了一个完整匹配</span></span><br><span class="line">        <span class="keyword">if</span> (q == sz2) &#123;</span><br><span class="line">            <span class="comment">// 找到了一个匹配，记录匹配的起始位置</span></span><br><span class="line">            v.add(i - sz2 + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 准备找下一个匹配</span></span><br><span class="line">            q = lps[q - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 Knuth–Morris–Pratt 算法（简称 KMP 算法）用 $O(n + m)$ 的时间以及 $O(n)$ 的内存解决了该问题。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/string/kmp/">https://oi-wiki.org/string/kmp/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配（在字符串中查找子串）的高效算法，由Donald Knuth、Vaughan Pratt 和 James H. Morris 独立发明，并在1977年被共同发表。它改进了朴素字符串匹配算法，在最坏情况下的时间复杂度为 $O(n + m)$，其中 $n$ 是文本字符串的长度，$m$ 是模式字符串的长度。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP25</title>
    <link href="http://silencezheng.top/2024/12/16/article152/"/>
    <id>http://silencezheng.top/2024/12/16/article152/</id>
    <published>2024-12-15T16:25:28.000Z</published>
    <updated>2024-12-15T16:27:04.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本周主题：记忆化搜索、最小堆、快速幂</p><p>题目：</p><ul><li>241210每日一题—<a href="https://leetcode.cn/problems/knight-dialer/?envType=daily-question&amp;envId=2024-12-10">Knight Dialer</a></li><li>241214每日一题—<a href="https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/description/?envType=daily-question&amp;envId=2024-12-14">Final Array State After K Multiplication Operations II</a><span id="more"></span><h1 id="Knight-Dialer"><a href="#Knight-Dialer" class="headerlink" title="Knight Dialer"></a><a href="https://leetcode.cn/problems/knight-dialer/?envType=daily-question&amp;envId=2024-12-10">Knight Dialer</a></h1></li></ul><p>和上周的一道记忆化搜索的题目类似，每走一步可以变为规模更小的子问题，主要是找到递归状态。首先第一步打表，比较容易想到，然后定义原问题为$Q(n)$，则走一步后的问题规模变成了$Q(n-1)$，这一类问题一般可以抽象为这样。</p><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>这类问题的关键是找到状态定义，这类状态不仅要注意剩余部分，也要注意操作，由<code>前序操作+剩余问题</code>构成状态定义。状态的转移为<code>原状态-&gt;操作-&gt;新状态</code>。对于这道题来说，定义原问题的状态为：把马放在单元格$i$上，然后移动$n-1$步，一共有多少种移动方案？</p><p>假设$i=6, n=3$，则移动一步后的子问题状态为：把马放在单元格$6$上，然后移动$n-2=1$步，一共有多少种移动方案？</p><p>可以定义状态为$dfs(i, j)$，即把马放在单元格$i$上，然后移动$j$步，一共有多少种移动方案？枚举马能移动到的单元格 $k$, 问题变成: 把马放在单元格 $k$ 上, 然后移动 $j-1$ 步, 有多少种移动方案, 即 $d f s(k, j-1)$ 。</p><p>累加得</p><script type="math/tex; mode=display">d f s(i, j)=\sum_k d f s(k, j-1)</script><p>2个参数可以用二维数组进行记忆化。<br>递归边界： $dfs(i, 0)=1$ 。无法移动, 算作一种移动方案, 对应格子$i$。<br>递归入口: $\sum_{i=0}^9 d f s(i, n-1)$, 这是原问题, 也是答案。对本体根据打表可以注意到 $d f s(5,n-1)=0$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1_000_000_007</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] NEXT = &#123;</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">6</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">4</span>, <span class="number">8</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">9</span>&#125;, &#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">5000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knightDialer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ans = (ans + dfs(i, n-<span class="number">1</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k : NEXT[i]) &#123;</span><br><span class="line">            res = (res + dfs(k, j-<span class="number">1</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j] = res; <span class="comment">// 记忆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Final-Array-State-After-K-Multiplication-Operations-II"><a href="#Final-Array-State-After-K-Multiplication-Operations-II" class="headerlink" title="Final Array State After K Multiplication Operations II"></a><a href="https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/description/?envType=daily-question&amp;envId=2024-12-14">Final Array State After K Multiplication Operations II</a></h1><p>根据选择元素的规则，在值相同时要考虑下标靠前的元素，因此应将值与下标组合存储。随后就是利用最小堆进行模拟，这一步可以直接模拟如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getFinalState(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> multiplier) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiplier == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">1000000007L</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">long</span>[]&gt; v = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>] != y[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(x[<span class="number">1</span>], y[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            v.offer(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; k &gt; <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">long</span>[] x = v.poll();</span><br><span class="line">            x[<span class="number">0</span>] *= multiplier;</span><br><span class="line">            x[<span class="number">0</span>] %= m;  <span class="comment">// 这一步不加则存在单元素数组case无法通过</span></span><br><span class="line">            v.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span>[] x = v.poll();</span><br><span class="line">            nums[(<span class="keyword">int</span>)x[<span class="number">1</span>]] = (<span class="keyword">int</span>)(x[<span class="number">0</span>] % m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种模拟存在一些问题：</p><ol><li>乘法运算后直接取模会影响最小数的判断；</li><li><code>x[0] *= multiplier</code>和<code>x[0] %= m;</code>部分可基于数学规律优化；</li><li><code>k</code>较大时，可以由快速幂算法加速计算；</li></ol><h2 id="最小堆-快速幂"><a href="#最小堆-快速幂" class="headerlink" title="最小堆+快速幂"></a>最小堆+快速幂</h2><p>假如数组中的所有数都处于这样一个范围<code>[a, b]</code>，其中<code>b</code>是<code>nums数组中的最大值</code>，而<code>a</code> 是 <code>(b - 1) / multiplier + 1</code>，这个范围的含义是其中任何一个数乘以 multiplier 都会大于等于原数组最大值<code>b</code>，也就是说对于当前最小数<code>x</code>，乘完multiplier之后不会被连续再乘以multiplier。</p><p>对于操作次数 <code>k</code> 的分配是按下标从小到大一个一个依次分配，不断循环直达 <code>k</code> 分配完，令<code>t1 = k / n, t2 = k % n</code>，对于下标小于 <code>t2</code> 的数，会被分配到 <code>t1 + 1</code> 次，而大于大于 <code>t2</code> 的下标会被分配到 <code>t1</code> 次。</p><p>那么接下来就是考虑怎么把原数组过渡到这么一个范围了，通过优先队列，不断分配，因为这个范围的上界是数组的最大值，所以在采用优先级队列分配 <code>k</code> 时不用进行取模运算。分配直到</p><p>如果在将数组全部扩大到范围 <code>[a, b]</code> 之后 <code>k &gt;= 0</code>，则直接可以得出每个数组中每个数字应该被分配的次数，通过快速幂计算出最后的结果即可。</p><p>以上思路来源于<a href="https://leetcode.cn/u/rnf/">RnFreno</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res = (res * x) % m;</span><br><span class="line">            &#125;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            x = (x * x) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getFinalState(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> multiplier) &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiplier == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> m = <span class="number">1000000007L</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">long</span>[]&gt; v = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>] != y[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(x[<span class="number">0</span>], y[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Long.compare(x[<span class="number">1</span>], y[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mx = Math.max(mx, nums[i]);</span><br><span class="line">            v.offer(<span class="keyword">new</span> <span class="keyword">long</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; v.peek()[<span class="number">0</span>] &lt;= (mx-<span class="number">1</span>)/multiplier + <span class="number">1</span> &amp;&amp; k &gt; <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">long</span>[] x = v.poll();</span><br><span class="line">            x[<span class="number">0</span>] *= multiplier;</span><br><span class="line">            v.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span>[] x = v.poll();</span><br><span class="line">            <span class="keyword">int</span> t = k / n + (i &lt; k % n ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            nums[(<span class="keyword">int</span>)x[<span class="number">1</span>]] = (<span class="keyword">int</span>)((x[<span class="number">0</span>] % m) * quickMul(multiplier, t, m) % m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/knight-dialer/solutions/3004116/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-x06l/?envType=daily-question&amp;envId=2024-12-10">https://leetcode.cn/problems/knight-dialer/solutions/3004116/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-x06l/?envType=daily-question&amp;envId=2024-12-10</a><br>[2] <a href="https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/solutions/2892178/zui-xiao-dui-mo-ni-shu-xue-gong-shi-pyth-z4zw/?envType=daily-question&amp;envId=2024-12-14">https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/solutions/2892178/zui-xiao-dui-mo-ni-shu-xue-gong-shi-pyth-z4zw/?envType=daily-question&amp;envId=2024-12-14</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本周主题：记忆化搜索、最小堆、快速幂&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;241210每日一题—&lt;a href=&quot;https://leetcode.cn/problems/knight-dialer/?envType=daily-question&amp;amp;envId=2024-12-10&quot;&gt;Knight Dialer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241214每日一题—&lt;a href=&quot;https://leetcode.cn/problems/final-array-state-after-k-multiplication-operations-ii/description/?envType=daily-question&amp;amp;envId=2024-12-14&quot;&gt;Final Array State After K Multiplication Operations II&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP24</title>
    <link href="http://silencezheng.top/2024/12/08/article151/"/>
    <id>http://silencezheng.top/2024/12/08/article151/</id>
    <published>2024-12-08T15:14:00.000Z</published>
    <updated>2024-12-08T15:15:00.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近忙着做毕设实验，之前的周记都搁置了。实验有了些结果，还不错。这周是每日一棋。</p><p>本周主题：复杂回溯、记忆化搜索</p><p>题目：</p><ul><li>241204每日一题—<a href="https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/description/?envType=daily-question&amp;envId=2024-12-04">Number of Valid Move Combinations On Chessboard</a></li><li>241207每日一题—<a href="https://leetcode.cn/problems/knight-probability-in-chessboard/description/?envType=daily-question&amp;envId=2024-12-07">Knight Probability in Chessboard</a></li><li>241208每日一题—<a href="https://leetcode.cn/problems/transform-to-chessboard/description/?envType=daily-question&amp;envId=2024-12-08">Transform to Chessboard</a><span id="more"></span><h1 id="Number-of-Valid-Move-Combinations-On-Chessboard"><a href="#Number-of-Valid-Move-Combinations-On-Chessboard" class="headerlink" title="Number of Valid Move Combinations On Chessboard"></a><a href="https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/description/?envType=daily-question&amp;envId=2024-12-04">Number of Valid Move Combinations On Chessboard</a></h1></li></ul><p>就是说一个move combo就是一个<code>int[][] destinations</code>，代表每个棋子要移动到的位置，每秒每个棋子移动一个格子，且移动过程中不能发生抢占格子的情况。这个目的地是根据棋子的可移动方向选的，包括原地不动。</p><h2 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS+回溯"></a>DFS+回溯</h2><p>思路：先预处理每个棋子的所有合法移动。写一个回溯，暴力枚举每个棋子的每个合法移动，如果这些棋子没有重叠在一起，则答案加一。</p><p>具体来说, 合法移动包含:</p><ul><li>棋子的初始位置 $\left(x_0, y_0\right)$ 。</li><li>棋子的移动方向 $\left(d_x, d_y\right)$ 。</li><li>棋子的移动次数 step。</li></ul><p>在回溯时，可以剪枝：如果当前棋子的当前这个合法移动，与前面的棋子冲突，即同一时刻两个棋子重叠，那么不往下递归，枚举当前棋子的下一个合法移动。</p><p>这个回溯的特点是层数很多，把每个节点想象成神经网络的一层，每层的节点数量是合法移动的数量，最终计算是其全连接的结果累加。且在判断是否回溯时，要符合所有先前节点的移动，由于这些移动可能所处的时间步不同，所以需要模拟其发展过程，确认移动过程中不存在冲突即合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每种棋子的移动方向</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, <span class="keyword">int</span>[][]&gt; PIECE_DIRS = Map.of(</span><br><span class="line">        <span class="string">&#x27;r&#x27;</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;, <span class="comment">// 车</span></span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125;, <span class="comment">// 象</span></span><br><span class="line">        <span class="string">&#x27;q&#x27;</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">1</span>&#125;&#125; <span class="comment">// 皇后</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCombinations</span><span class="params">(String[] pieces, <span class="keyword">int</span>[][] positions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = pieces.length;</span><br><span class="line">        <span class="comment">// 预处理所有合法移动</span></span><br><span class="line">        Move[][] allMoves = <span class="keyword">new</span> Move[n][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            allMoves[i] = generateMoves(positions[i][<span class="number">0</span>], positions[i][<span class="number">1</span>], PIECE_DIRS.get(pieces[i].charAt(<span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Move[] path = <span class="keyword">new</span> Move[n]; <span class="comment">// 注意 path 的长度是固定的</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n, allMoves, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Java 14 引入的不可变的数据载体类，Java 16 成为正式特性</span></span><br><span class="line">    <span class="comment">// 起点 (x0,y0)，移动方向 (dx,dy)，移动次数 step</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> record <span class="title">Move</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算位于 (x0,y0) 的棋子在 dirs 这些方向上的所有合法移动</span></span><br><span class="line">    <span class="keyword">private</span> Move[] generateMoves(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span>[][] dirs) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">8</span>;</span><br><span class="line">        List&lt;Move&gt; moves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        moves.add(<span class="keyword">new</span> Move(x0, y0, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 原地不动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : dirs) &#123;</span><br><span class="line">            <span class="comment">// 往 d 方向走 1,2,3,... 步</span></span><br><span class="line">            <span class="keyword">int</span> x = x0 + d[<span class="number">0</span>], y = y0 + d[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 这里不限制step的大小，只是沿着一个方向一直走</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; <span class="number">0</span> &lt; x &amp;&amp; x &lt;= SIZE &amp;&amp; <span class="number">0</span> &lt; y &amp;&amp; y &lt;= SIZE; step++) &#123;</span><br><span class="line">                moves.add(<span class="keyword">new</span> Move(x0, y0, d[<span class="number">0</span>], d[<span class="number">1</span>], step));</span><br><span class="line">                x += d[<span class="number">0</span>];</span><br><span class="line">                y += d[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> moves.toArray(Move[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个移动是否合法，即不存在同一时刻两个棋子重叠的情况</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Move m1, Move m2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = m1.x0, y1 = m1.y0; <span class="comment">// 初始位置</span></span><br><span class="line">        <span class="keyword">int</span> x2 = m2.x0, y2 = m2.y0;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.max(m1.step, m2.step); i++) &#123;</span><br><span class="line">            <span class="comment">// 每一秒走一步</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; m1.step) &#123;</span><br><span class="line">                x1 += m1.dx;</span><br><span class="line">                y1 += m1.dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m2.step) &#123;</span><br><span class="line">                x2 += m2.dx;</span><br><span class="line">                y2 += m2.dy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x1 == x2 &amp;&amp; y1 == y2) &#123; <span class="comment">// 重叠</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n, Move[][] allMoves, Move[] path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i表示第i个棋子， 想象一共有3个节点，每个节点有三个合法方向，则该代码对其进行全连接累加。</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 标签语法，用于控制特定层次的循环或提前退出多层循环</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="comment">// 枚举当前棋子的所有合法移动</span></span><br><span class="line">        <span class="keyword">for</span> (Move move1 : allMoves[i]) &#123;</span><br><span class="line">            <span class="comment">// 判断合法移动 move1 是否有效</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isValid(move1, path[j])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> outer; <span class="comment">// 无效，枚举下一个 move1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            path[i] = move1; <span class="comment">// 直接覆盖，无需恢复现场</span></span><br><span class="line">            res += dfs(i + <span class="number">1</span>, n, allMoves, path); <span class="comment">// 枚举后续棋子的所有合法移动组合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Knight-Probability-in-Chessboard"><a href="#Knight-Probability-in-Chessboard" class="headerlink" title="Knight Probability in Chessboard"></a><a href="https://leetcode.cn/problems/knight-probability-in-chessboard/description/?envType=daily-question&amp;envId=2024-12-07">Knight Probability in Chessboard</a></h1><p>原问题是Knight走$k$步后留在棋盘上的概率，走出一步后，问题变为了Knight走$k-1$步后留在棋盘上的概率，是一个规模更小的子问题，可递归求解。直接递归超时，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] factor1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] factor2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        move(n, k, <span class="number">0</span>, row, column);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)total/(<span class="keyword">double</span>)Math.pow(<span class="number">8</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> cnt, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=n||c&gt;=n||r&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k)&#123;</span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合落点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> f1:factor1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> f2:factor2)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> f3:factor2)&#123;</span><br><span class="line">                    move(n, k, cnt+<span class="number">1</span>, r+f1*f2, c+(<span class="number">3</span>-f1)*f3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>上面的解法有一个问题：递归函数不可记忆，无法进行优化。因此需要重新确定状态和计算方式。</p><p>定义状态为 $dfs(k,i,j)$，表示从 $(i,j)$ 出发，走 $k$ 步后仍然在棋盘上的<strong>概率</strong>。</p><p>枚举可走的八个方向, 其中有 $\frac{1}{8}$ 概率走到了 $(x, y)$, 问题变成：</p><ul><li>从 $(x, y)$ 出发, 走 $k-1$ 步后仍然在棋盘上的概率, 即 $d f s(k-1, x, y)$</li></ul><p>八种情况累加，得</p><script type="math/tex; mode=display">d f s(k, i, j)=\frac{1}{8} \sum_{(x, y)} d f s(k-1, x, y)</script><p>递归边界：如果Knight出界, 那么在棋盘上的概率为 0 , 即 $d f s(k, i, j)=0$ 。如果 $k=0$ 时Knight仍然在棋盘上, 那么概率为 1 , 即 $d f s(0, i, j)=1$ 。</p><p>递归入口：$d f s(k, r o w, c o l u m n)$, 也就是答案。</p><p>三、递归搜索 + 保存递归返回值 = 记忆化搜索<br>考虑到整个递归过程中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用, 同样的入参无论计算多少次, 算出来的结果都是一样的, 因此可以用记忆化搜索来优化：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。</li><li>如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值), 那么可以直接返回 memo 中保存的结果。</li></ul><p>注意：memo 数组的初始值一定不能等于要记忆化的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;-<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">2</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;<span class="number">1</span>, -<span class="number">2</span>&#125;, &#123;<span class="number">2</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">double</span>[k + <span class="number">1</span>][n][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(k, row, column, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n, <span class="keyword">double</span>[][][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[k][i][j] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[k][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : DIRS) &#123;</span><br><span class="line">            res += dfs(k - <span class="number">1</span>, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>], n, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[k][i][j] = res / DIRS.length; <span class="comment">// 记忆化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Transform-to-Chessboard"><a href="#Transform-to-Chessboard" class="headerlink" title="Transform to Chessboard"></a><a href="https://leetcode.cn/problems/transform-to-chessboard/description/?envType=daily-question&amp;envId=2024-12-08">Transform to Chessboard</a></h1><p>超纲了，火速投降放过自己。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/knight-probability-in-chessboard/solutions/2997395/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-dgt6/?envType=daily-question&amp;envId=2024-12-07">https://leetcode.cn/problems/knight-probability-in-chessboard/solutions/2997395/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-dgt6/?envType=daily-question&amp;envId=2024-12-07</a><br>[2] <a href="https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solutions/1075478/go-mo-ni-by-endlesscheng-kjpt/?envType=daily-question&amp;envId=2024-12-04">https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solutions/1075478/go-mo-ni-by-endlesscheng-kjpt/?envType=daily-question&amp;envId=2024-12-04</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近忙着做毕设实验，之前的周记都搁置了。实验有了些结果，还不错。这周是每日一棋。&lt;/p&gt;
&lt;p&gt;本周主题：复杂回溯、记忆化搜索&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;241204每日一题—&lt;a href=&quot;https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/description/?envType=daily-question&amp;amp;envId=2024-12-04&quot;&gt;Number of Valid Move Combinations On Chessboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241207每日一题—&lt;a href=&quot;https://leetcode.cn/problems/knight-probability-in-chessboard/description/?envType=daily-question&amp;amp;envId=2024-12-07&quot;&gt;Knight Probability in Chessboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241208每日一题—&lt;a href=&quot;https://leetcode.cn/problems/transform-to-chessboard/description/?envType=daily-question&amp;amp;envId=2024-12-08&quot;&gt;Transform to Chessboard&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>并查集Disjoint Set Union</title>
    <link href="http://silencezheng.top/2024/10/28/article150/"/>
    <id>http://silencezheng.top/2024/10/28/article150/</id>
    <published>2024-10-27T16:54:36.000Z</published>
    <updated>2024-10-27T16:56:16.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近做笔试和刷题都遇到并查集（Disjoint Set Union, DSU）的题目了，学习一下。<br><span id="more"></span></p><h1 id="并查集（Disjoint-Set-Union-DSU）"><a href="#并查集（Disjoint-Set-Union-DSU）" class="headerlink" title="并查集（Disjoint Set Union, DSU）"></a>并查集（Disjoint Set Union, DSU）</h1><p>假设一个场景，$n$个人要么属于A帮派，要么属于B帮派，一个人属于某帮派的方式是直接或间接的给帮派老大打工，如何快速判断两人是否属于同一帮派呢？非常简单，看两人是否都给同一帮派老大打工就可以了。</p><p>由此引出一种数据结构：<strong>并查集</strong>。并查集用于解决一些元素分组的问题。它管理一系列<strong>不相交</strong>的集合，并支持两种操作：</p><ol><li>合并（Union）：把两个不相交的集合合并为一个集合。</li><li>查询（Find）：查询两个元素是否在同一个集合中。</li></ol><p>并查集的一个应用前提是某一成员只能归属到至多一个分组之中。将集合的初始状态设置为所有成员都认为自己是帮派老大（分组根节点），然后通过<strong>成员关系</strong>（例如图上的连接关系）进行分组合并，最终会得到如下形式的分组结果，这些树状子结构的集合称为并查集。</p><p><img src="/assets/post_img/article150/bcj.png" alt="并查集"></p><p>可以注意到每一个树状子结构存在唯一一个根节点，根节点自己也指向根节点，因此可以推出两种操作的实现：</p><ol><li>合并（Union）：将B合并进A中，只需要将B的根节点指向A中的任意一个节点即可，但直接指向A的根节点可以最大程度的减少树高。</li><li>查询（Find）：查询某节点属于哪个集合，只需要递归的向上查找，直到找到自身指向自身的根节点。由此也可以得出结论，树高越低，查询效率越高。</li></ol><h1 id="最简实现"><a href="#最简实现" class="headerlink" title="最简实现"></a>最简实现</h1><p>我们可以通过一个长度为$n$的数组来存储$n$个节点各自的父节点。初状态下各节点指向自身。操作的实现按照前面的分析进行，即“根合并到根”和”递归查询“。可以看到使用很少的代码量即可实现并查集结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDisjointSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个元素形成一个独立的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleDisjointSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 每个元素的父节点指向自己</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找给定元素所属的集合的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(parent[x]);  <span class="comment">// 递归查找直到找到根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            parent[rootX] = rootY;  <span class="comment">// 将x所在的集合连接到y所在的集合，根合并到根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDisjointSet dsu = <span class="keyword">new</span> SimpleDisjointSet(<span class="number">10</span>);  <span class="comment">// 创建一个大小为10的并查集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一些合并操作</span></span><br><span class="line">        dsu.union(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        dsu.union(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        dsu.union(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        dsu.union(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        dsu.union(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询一些元素是否属于同一个集合</span></span><br><span class="line">        System.out.println(dsu.find(<span class="number">1</span>) == dsu.find(<span class="number">3</span>));  <span class="comment">// true</span></span><br><span class="line">        System.out.println(dsu.find(<span class="number">1</span>) == dsu.find(<span class="number">5</span>));  <span class="comment">// false</span></span><br><span class="line">        System.out.println(dsu.find(<span class="number">6</span>) == dsu.find(<span class="number">8</span>));  <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h1><p>在上面的实现中，其实已经做到了所谓的路径压缩，即尽可能减少树高，让帮派成员都直接给老大打工。</p><p>一种方式是从合并方法入手，另一种方式是从查询上实现路径压缩，这里给出从查询角度实现的代码。核心思想就是在每一次查询的递归过程中重构树，此时合并部分可以不用做压缩处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="comment">// 查找给定元素所属的集合的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] == x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;  <span class="comment">// 找到根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        parent[x] = find(parent[x]); <span class="comment">// 递归过程中把非根节点都指向根节点</span></span><br><span class="line">        <span class="keyword">return</span> parent[x]; <span class="comment">// 返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    parent[find(x)] = find(y); <span class="comment">// 把x所在的集合合并到y所在的集合上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h1><p>并查集容易陷入一个思维误区：应用路径压缩后，产生的树都是”菊花图🌼“，即只有两层的树，一个根节点和若干一级子节点。</p><p>可以证明实际情况并非如此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line">dsu.union(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1 -&gt; 2</span></span><br><span class="line">dsu.union(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 1 -&gt; 2 -&gt; 3</span></span><br></pre></td></tr></table></figure></p><p>无论哪种路径压缩方法，在不执行查询的情况下，初始化并查集时仍会产生多层树。如下图所示，假设当前需要将节点$8$加入节点$7$的分组中，有两种情况。</p><p><img src="/assets/post_img/article150/rankUnion.png" alt="ru"></p><p>显然我们应该选择树高更低的合并方法，即把高度更低的树合并到更高的树上。</p><p>我们用一个数组$rank$记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的子树的深度）。一开始，把所有元素的rank（秩）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;  <span class="comment">// 用于记录每个节点所在树的高度（秩）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个元素形成一个独立的集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DisjointSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parent[i] = i;  <span class="comment">// 每个元素的父节点指向自己</span></span><br><span class="line">            rank[i] = <span class="number">0</span>;    <span class="comment">// 初始秩为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找给定元素所属的集合的根节点，并进行路径压缩</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 路径压缩：将x直接指向其最终的根节点</span></span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个集合，使用按秩合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rootX != rootY) &#123;</span><br><span class="line">            <span class="comment">// 按秩合并</span></span><br><span class="line">            <span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">                parent[rootX] = rootY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果秩相同，则任意选择一个作为新的根节点，并增加该根节点的秩</span></span><br><span class="line">                parent[rootY] = rootX;</span><br><span class="line">                rank[rootX]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径压缩和按秩合并如果一起使用，时间复杂度接近$O(n)$，但是很可能会破坏rank的准确性。原因如下：</p><ol><li>路径压缩的影响：<ul><li>路径压缩在查找过程中将路径上的所有节点直接指向根节点，这会改变树的结构。</li><li>由于路径压缩改变了树的高度，但 rank 值并没有相应更新，因此 rank 可能不再准确反映树的实际高度。</li></ul></li><li>按秩合并的假设：<ul><li>按秩合并基于一个假设：rank 值反映了树的高度（或深度）。</li><li>如果路径压缩导致 rank 不再准确，那么按秩合并的效果可能会受到影响，因为合并操作依赖于 rank 来决定如何连接两棵树。</li></ul></li></ol><p>因此在同时使用的情况下，rank值事实上是树的高度上限。可以灵活选择如何使用按秩合并，考虑路径压缩的扰乱对整体效率的影响。</p><h1 id="例题：Redundant-Connection"><a href="#例题：Redundant-Connection" class="headerlink" title="例题：Redundant Connection"></a>例题：<a href="https://leetcode.cn/problems/redundant-connection/description/?envType=daily-question&amp;envId=2024-10-27">Redundant Connection</a></h1><p>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] edge = edges[i];</span><br><span class="line">            <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class="line">                union(parent, node1, node2);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a><br>[2] <a href="https://leetcode.cn/problems/redundant-connection/solutions/557616/rong-yu-lian-jie-by-leetcode-solution-pks2/?envType=daily-question&amp;envId=2024-10-27">https://leetcode.cn/problems/redundant-connection/solutions/557616/rong-yu-lian-jie-by-leetcode-solution-pks2/?envType=daily-question&amp;envId=2024-10-27</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近做笔试和刷题都遇到并查集（Disjoint Set Union, DSU）的题目了，学习一下。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP6</title>
    <link href="http://silencezheng.top/2024/10/27/article149/"/>
    <id>http://silencezheng.top/2024/10/27/article149/</id>
    <published>2024-10-26T17:50:09.000Z</published>
    <updated>2024-10-27T15:28:19.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周好像是划水了，只有一道题。</p><p>本周主题：暴力搜索（DFS）、Dijkstra算法</p><p>题目：</p><ul><li>240702每日一题—<a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description">Maximum Path Quality of a Graph</a><span id="more"></span><h1 id="暴力搜索（DFS）"><a href="#暴力搜索（DFS）" class="headerlink" title="暴力搜索（DFS）"></a>暴力搜索（DFS）</h1>题目：<a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description">Maximum Path Quality of a Graph</a></li></ul><p>一个无向带权图，给定边和权，每个节点都有<code>value</code>。另给一参数<code>maxTime</code>，求<code>valid path(VP)</code>的最大<code>value</code>和。一个<code>VP</code>是一个<code>0</code>节点的环路，且路径时间消耗总和不超过<code>maxTime</code>，同时每个节点的<code>value</code>只计算一次。图中每个节点最多有$4$条边。</p><p>首先基于题目数据范围，可以采取暴力搜索的方式，一条<code>VP</code>的最大边数为$\frac{maxTime}{\min (time_j)}$，且图中每个节点最多有$4$条边，则可以得到搜索树的大小为$\frac{maxTime}{\min (time_j)}+1$层的$4$叉树。</p><p>在本题中，穷举的内容是一条环路，因此采用DFS暴力搜索：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = values.length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        Arrays.setAll(g, i -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> t = e[<span class="number">2</span>];</span><br><span class="line">            g[x].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;y, t&#125;);</span><br><span class="line">            g[y].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, t&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, values[<span class="number">0</span>], vis, g, values, maxTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sumTime, <span class="keyword">int</span> sumValue, <span class="keyword">boolean</span>[] vis, List&lt;<span class="keyword">int</span>[]&gt;[] g, <span class="keyword">int</span>[] values, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = x == <span class="number">0</span> ? sumValue : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : g[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> t = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sumTime + t &gt; maxTime) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 超时中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line">                res = Math.max(res, dfs(y, sumTime + t, sumValue, vis, g, values, maxTime));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 每个节点的价值至多算入价值总和中一次</span></span><br><span class="line">                res = Math.max(res, dfs(y, sumTime + t, sumValue + values[y], vis, g, values, maxTime));</span><br><span class="line">                vis[y] = <span class="keyword">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归实现的DFS，对于每个节点的所有邻接点逐线路进行访问，访问标记在递归过程中用于防止搜索已经过路径，在整条路径搜索结束后逐个恢复支持下一次搜索，当遇到已搜索过的节点时依然需要计算一次<code>max</code>值，因为我们要找的是<code>0</code>节点的环路，只有遇到<code>0</code>节点时才会贡献<code>sumValue</code>。</p><p>这个时间复杂度计算也可以学习一下，$O(n+m+4^k)$，主要是四叉树的复杂度。空间复杂度为$O(n+m+k)$，即一次只消耗一条路径的空间。</p><h2 id="Dijkstra算法优化搜索"><a href="#Dijkstra算法优化搜索" class="headerlink" title="Dijkstra算法优化搜索"></a>Dijkstra算法优化搜索</h2><p>用 Dijkstra 算法预处理起点 0 到每个节点的最短路，这也是每个节点到 0 的最短路。本题是稀疏图，可以使用堆优化的 Dijkstra 算法。</p><p>在递归到下一个节点之前，判断下一个节点在走最短路的前提下，能否在 maxTime 时间内回到起点 0，若不能则不递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = values.length;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] g = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        Arrays.setAll(g, i -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> t = e[<span class="number">2</span>];</span><br><span class="line">            g[x].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;y, t&#125;);</span><br><span class="line">            g[y].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, t&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dijkstra 算法</span></span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">        dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] p = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> dx = p[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> x = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dx &gt; dis[x]) &#123; <span class="comment">// x 之前出堆过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] e : g[x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> y = e[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newDis = dx + e[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newDis &lt; dis[y]) &#123;</span><br><span class="line">                    dis[y] = newDis; <span class="comment">// 更新 x 的邻居的最短路</span></span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newDis, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, values[<span class="number">0</span>], vis, g, values, maxTime, dis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> sumTime, <span class="keyword">int</span> sumValue, <span class="keyword">boolean</span>[] vis, List&lt;<span class="keyword">int</span>[]&gt;[] g, <span class="keyword">int</span>[] values, <span class="keyword">int</span> maxTime, <span class="keyword">int</span>[] dis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = x == <span class="number">0</span> ? sumValue : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : g[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> t = e[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 相比方法一，这里多了 dis[y]</span></span><br><span class="line">            <span class="keyword">if</span> (sumTime + t + dis[y] &gt; maxTime) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vis[y]) &#123;</span><br><span class="line">                res = Math.max(res, dfs(y, sumTime + t, sumValue, vis, g, values, maxTime, dis));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[y] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 每个节点的价值至多算入价值总和中一次</span></span><br><span class="line">                res = Math.max(res, dfs(y, sumTime + t, sumValue + values[y], vis, g, values, maxTime, dis));</span><br><span class="line">                vis[y] = <span class="keyword">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/solutions/1088414/bao-sou-jian-zhi-by-endlesscheng-iv6z/">https://leetcode.cn/problems/maximum-path-quality-of-a-graph/solutions/1088414/bao-sou-jian-zhi-by-endlesscheng-iv6z/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周好像是划水了，只有一道题。&lt;/p&gt;
&lt;p&gt;本周主题：暴力搜索（DFS）、Dijkstra算法&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240702每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description&quot;&gt;Maximum Path Quality of a Graph&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="http://silencezheng.top/2024/10/27/article148/"/>
    <id>http://silencezheng.top/2024/10/27/article148/</id>
    <published>2024-10-26T17:35:58.000Z</published>
    <updated>2024-10-26T17:42:14.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寻找图中单源最短路径的经典算法，死去的考研知识点在攻击我…理论与实践重新复习一下。<br><span id="more"></span></p><h1 id="Dijkstra-Algorithm"><a href="#Dijkstra-Algorithm" class="headerlink" title="Dijkstra Algorithm"></a>Dijkstra Algorithm</h1><p>Dijkstra算法是一种用于寻找图中单源最短路径的经典算法，由荷兰计算机科学家Edsger W. Dijkstra于1956年提出。该算法适用于有向图和无向图，并且要求图中的所有边权都是非负的。所谓单源最短路径，就是求某一点到其他各顶点的最短路径。</p><p>Dijkstra算法的基本思想是贪心算法。它从起点开始，逐步扩展到整个图，每次选择当前已知的最短路径进行扩展，直到找到从起点到所有其他顶点的最短路径。</p><p>算法步骤：</p><ol><li>对于图$G$，设辅助向量$S$和$D$，其中$S$记录已求出的最短路径，$D$记录各尚未求出最短路径的顶点到起点的距离；</li><li>初状态为$S$中仅有起点$a$，$D$中记录了与$a$相邻的顶点的距离（权值），不相邻元素则为无穷大；</li><li>从$D$中找出路径最短的顶点$k$加入$S$中，更新$D$中$k$的最短距离，从$D$中移除$k$（不再参与后续计算），重复至$D$中无可用顶点。</li></ol><p>上面的算法步骤讲述了Dijkstra算法的核心原理，考虑在编程语言下的具体实现，我们需要用合适的数据结构来构建算法的流程与上下文。</p><ol><li>定义 $g[i][j]$ 作为图$G$，表示节点 $i$ 到节点 $j$ 这条边的边权。如果没有 $i$ 到 $j$ 的边，则 $g[i][j]=∞$。</li><li>定义 $dis[i]$ 作为集合$D$，表示起点 $a$ 到节点 $i$ 的最短路长度，一开始 $dis[a]=0$，其余 $dis[i]=∞$ 表示尚未计算出。另开辟一数组 $finished[i]$ 用于标记$D$中已被移除的元素。</li><li>对于需要不仅需要最短路径距离，且需要存储最短路径本身的情况，选用合适的数据结构存放$S$，例如动态数组等。</li></ol><h1 id="朴素实现（适用稠密图）"><a href="#朴素实现（适用稠密图）" class="headerlink" title="朴素实现（适用稠密图）"></a>朴素实现（适用稠密图）</h1><blockquote><p>题目：现有一有向带权图，求从<code>k</code>节点出发到其他所有节点的最短路径和，若有节点无法到达则返回-1。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span>[][] edges, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE / <span class="number">2</span>; <span class="comment">// 防止加法溢出</span></span><br><span class="line">    <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[n][n]; <span class="comment">// 邻接矩阵 G</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] row : g) Arrays.fill(row, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : edges) &#123; </span><br><span class="line">        g[t[<span class="number">0</span>] - <span class="number">1</span>][t[<span class="number">1</span>] - <span class="number">1</span>] = t[<span class="number">2</span>]; <span class="comment">// edges节点编号从1开始，需要映射到0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 集合D，本题不需要存储最短路径细节，不需要S</span></span><br><span class="line">    Arrays.fill(dis, INF);</span><br><span class="line">    dis[k - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">    <span class="keyword">boolean</span>[] done = <span class="keyword">new</span> <span class="keyword">boolean</span>[n]; <span class="comment">// 标记D中被移除的元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 寻找最小值</span></span><br><span class="line">            <span class="keyword">if</span> (!done[i] &amp;&amp; (x &lt; <span class="number">0</span> || dis[i] &lt; dis[x])) x = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> maxDis; <span class="comment">// 最后一次算出的最短路就是最大的</span></span><br><span class="line">        <span class="keyword">if</span> (dis[x] == INF) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 有节点无法到达</span></span><br><span class="line">        maxDis = dis[x]; <span class="comment">// 求出的最短路会越来越大</span></span><br><span class="line">        done[x] = <span class="keyword">true</span>; <span class="comment">// 最短路长度已确定（无法变得更小）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">            <span class="comment">// 更新 x 的邻居的最短路</span></span><br><span class="line">            dis[y] = Math.min(dis[y], dis[x] + g[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$。</p><h1 id="堆优化（适用稀疏图）"><a href="#堆优化（适用稀疏图）" class="headerlink" title="堆优化（适用稀疏图）"></a>堆优化（适用稀疏图）</h1><p>寻找最小值的过程可以用一个最小堆来快速完成：</p><ul><li>一开始把 $(d i s[k], k)$ 二元组入堆。</li><li>当节点 $x$ 首次出堆时, $d i s[x]$ 就是写法一中寻找的最小最短路。</li><li>更新 $d i s[y]$ 时, 把 $(d i s[y], y)$ 二元组入堆。</li></ul><p>注意，如果一个节点 $x$ 在出堆前，其最短路长度 $d i s[x]$ 被多次更新，那么堆中会有多个重复的 $x$ ，并且包含 $x$ 的二元组中的 $d i s[x]$ 是互不相同的（因为我们只在找到更小的最短路时才会把二元组入堆）。</p><p>所以原实现中的 done 数组可以省去, 取而代之的是用出堆的最短路值（记作 $d x$ ）与当前的 $d i s[x]$ 比较，如果 $d x&gt;d i s[x]$ 说明 $x$ 之前出堆过，我们已经更新了 $x$ 的邻居的最短路，所以这次就不用更新了，继续外层循环。</p><p>对于同一个 $x$ ，例如先入堆一个比较大的 $\operatorname{dis}[x]=10$ ，后面又把 $\operatorname{dis}[x]$ 更新成 5 ，之后这个 5 会先出堆，然后再把 10 出堆。 10 出堆时候是没有必要去更新周围邻居的最短路的，因为 5 出堆之后，就已经把邻居的最短路更新过了，用 10 是无法把邻居的最短路变得更短的，所以直接 continue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span>[][] edges, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt;[] g = <span class="keyword">new</span> ArrayList[n]; <span class="comment">// 邻接表</span></span><br><span class="line">    Arrays.setAll(g, i -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] t : edges) &#123;</span><br><span class="line">        g[t[<span class="number">0</span>] - <span class="number">1</span>].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>] - <span class="number">1</span>, t[<span class="number">2</span>]&#125;); <span class="comment">// 终点, 距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxDis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = n; <span class="comment">// 未确定最短路的节点个数</span></span><br><span class="line">    <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">    dis[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, k - <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] p = pq.poll();</span><br><span class="line">        <span class="keyword">int</span> dx = p[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> x = p[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (dx &gt; dis[x]) &#123; <span class="comment">// x 之前出堆过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxDis = dx; <span class="comment">// 求出的最短路会越来越大</span></span><br><span class="line">        left--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : g[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newDis = dx + e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newDis &lt; dis[y]) &#123;</span><br><span class="line">                dis[y] = newDis; <span class="comment">// 更新 x 的邻居的最短路</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newDis, y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left == <span class="number">0</span> ? maxDis : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/">https://leetcode.cn/problems/network-delay-time/solutions/2668220/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;寻找图中单源最短路径的经典算法，死去的考研知识点在攻击我…理论与实践重新复习一下。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP16</title>
    <link href="http://silencezheng.top/2024/10/13/article147/"/>
    <id>http://silencezheng.top/2024/10/13/article147/</id>
    <published>2024-10-13T12:05:28.000Z</published>
    <updated>2024-10-27T15:28:26.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周AI喜提两项诺奖，工作定下来后还是要多研究一下AI应用。</p><p>本周主题：动态规划、滑动窗口、枚举</p><p>题目：</p><ul><li>241007每日一题—<a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/description">Minimum Number of Refueling Stops</a></li><li>241009每日一题—<a href="https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/description">Find Subarray With Bitwise OR Closest to K</a></li><li>241010每日一题—<a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description">Find the Number of Good Pairs II</a><span id="more"></span></li></ul><h1 id="Minimum-Number-of-Refueling-Stops"><a href="#Minimum-Number-of-Refueling-Stops" class="headerlink" title="Minimum Number of Refueling Stops"></a><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/description">Minimum Number of Refueling Stops</a></h1><p>这道题磕磕绊绊也是写出来了，只是优化的有些慢，还是记录一下。</p><p>下面是我解题过程中写的注释，包含了状态定义与状态转移：</p><blockquote><p>A pick or no-pick problem, can be solved by DP, stations is sorted<br>Define dp[i][j] = remain fuel at i when pick j stations<br>Final problem = dp[target][x] where x &gt;= 0 and no more y&gt;=0&amp;&amp;y&lt;x<br>dp[i][j] = max(dp[i-1][j]-1, dp[i-1][j-1] + stations[i][1] - 1), where stations[i][0]=i</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>从<code>dp[i-1][j-1]</code>转移，存在“代偿”情况，即<code>dp[i-1][j-1]</code>是一条不通的路，但由于后期遇到大station导致该路通行。为解决代偿，应仅从合法状态转移至新状态，实现方式是遇到不合法状态直接置为极小值后再参与比较。<br>定义好状态后，发现直接实现仍会超时，采取两步优化：</p><ol><li>通过转移方程可以了解到当前状态仅与上一状态有关，可采用滚动数组压缩为两行，优化空间。</li><li>基于<code>stations is sorted</code>和<code>stations[n-1]&lt;target</code>可采用优化遍历，转而遍历<code>stations</code>，优化时间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> startFuel, <span class="keyword">int</span>[][] stations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startFuel&gt;=target) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 边界处理1</span></span><br><span class="line">        <span class="keyword">int</span> n = stations.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 边界处理2</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n+<span class="number">1</span>]; <span class="comment">// 滚动数组</span></span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], startFuel);</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>, cur = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="comment">// 优化遍历</span></span><br><span class="line">            <span class="keyword">int</span> dist = stations[i][-<span class="number">1</span>] </span><br><span class="line">            dp[cur][-<span class="number">1</span>] </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[cur][j] = Math.max(dp[last][j]&gt;=dist?dp[last][j] - dist:Integer.MIN_VALUE, </span><br><span class="line">                dp[last][j-<span class="number">1</span>]&gt;=dist?dp[last][j-<span class="number">1</span>] + stations[i][<span class="number">0</span>] </span><br><span class="line">            &#125;</span><br><span class="line">            cnt = stations[i][<span class="number">0</span>]; <span class="comment">// 移动已走过的距离</span></span><br><span class="line">            <span class="keyword">int</span> t = last;</span><br><span class="line">            last = cur;</span><br><span class="line">            cur = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[last][j]&gt;=target-stations[n-<span class="number">1</span>][<span class="number">0</span>])&#123; <span class="comment">// 注意此时last才是cur</span></span><br><span class="line">                res = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-Subarray-With-Bitwise-OR-Closest-to-K"><a href="#Find-Subarray-With-Bitwise-OR-Closest-to-K" class="headerlink" title="Find Subarray With Bitwise OR Closest to K"></a><a href="https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/description">Find Subarray With Bitwise OR Closest to K</a></h1><p>连续子数组变形题，上来就应该想到滑窗的…但是我还是选择了枚举，尝试了一下卡到$O(n^2)$优化不出来了，尝试了用每一位计数的方式也没什么用，下面贴灵神思路，更优些。</p><p>基础枚举：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力算法，会超时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            ans = Math.min(ans, Math.abs(x - k)); <span class="comment">// 单个元素也算子数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                nums[j] |= x; <span class="comment">// 现在 nums[j] = 原数组 nums[j] 到 nums[i] 的 OR</span></span><br><span class="line">                ans = Math.min(ans, Math.abs(nums[j] - k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化思路：把二进制数看成集合，两个数的 <code>OR</code> 就是两个集合的并集。</p><p>在上述枚举过程中，<code>nums</code>中最左侧是最大的集合，从左向右依次是前序元素的子集，则当从右向左并入元素<code>x</code>的过程中，如果发现<code>x</code>已经是某元素的子集，则不需要再向左传播了，因为此时<code>x</code>已经是左侧所有元素的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i];</span><br><span class="line">            ans = Math.min(ans, Math.abs(x - k));</span><br><span class="line">            <span class="comment">// 如果 x 是 nums[j] 的子集，就退出循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; (nums[j] | x) != nums[j]; j--) &#123;</span><br><span class="line">                nums[j] |= x;</span><br><span class="line">                ans = Math.min(ans, Math.abs(nums[j] - k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>参考引文[2]的解法，再看一下滑动窗口，由于连续子数组的“OR和”有单调性，因此可以使用。滑动窗口右移，窗口内的元素“OR和”只能变大或者不变；滑动窗口左移，窗口内的元素“OR和”只能变小或者不变。</p><p>我们需要找到一个连续的子数组，使得它们的“OR和”的结果尽可能接近 k。通过滑动窗口的方式，我们可以不断扩大和缩小窗口来尝试找到符合条件的子数组。</p><p>由于按位或运算具有不可逆的特点（即不像加法有逆运算减法），一旦某个位被置为 1，即使移除某些数字，OR 的结果中该位仍然可能保持为 1。因此，我们需要仔细追踪每个位的<strong>最后贡献位置</strong>。</p><p>可以使用一个大小为 32 的数组 maxBitPos，记录每个位上最后一次贡献 1 的索引。当左边界移动时，我们检查是否需要移除某个位的贡献，如果该位的最后贡献位置是当前的 left，就可以安全地将该位清除。（这里太妙了，我也想到了用32位数组计数但是没想到和索引建立连接！）</p><p>最后，在滑动窗口过程中，计算当前窗口的“OR和”curr，并通过比较<code>abs(curr - k)</code>来更新最小的绝对差。如果当前curr正好等于 k，直接返回 0，因为绝对差已经最小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, left = <span class="number">0</span>, right = <span class="number">0</span>, ans = Integer.MAX_VALUE, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] maxBitPos = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">// 记录每个位的最大位置</span></span><br><span class="line">        Arrays.fill(maxBitPos, -<span class="number">1</span>); <span class="comment">// 初始化数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            curr |= nums[right]; <span class="comment">// 当前窗口内的 OR 值</span></span><br><span class="line">            <span class="comment">// 更新 maxBitPos，记录每个位的最后出现位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((nums[right] &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    maxBitPos[i] = right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans, Math.abs(curr - k));</span><br><span class="line">            <span class="keyword">if</span> (curr == k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果当前窗口正好匹配 k，直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 OR 值大于 k，开始收缩窗口</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; curr &gt; k) &#123;</span><br><span class="line">                <span class="comment">// 检查当前 left 是否在某个位上做出了贡献</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((nums[left] &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; maxBitPos[i] == left) &#123;</span><br><span class="line">                        curr &amp;= ~(<span class="number">1</span> &lt;&lt; i); <span class="comment">// 清除该位的贡献</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.min(ans, Math.abs(curr - k));</span><br><span class="line">                <span class="keyword">if</span> (curr == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 匹配到 k，返回</span></span><br><span class="line">                &#125;</span><br><span class="line">                left++; <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">            right++; <span class="comment">// 扩展窗口</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Number-of-Good-Pairs-II"><a href="#Find-the-Number-of-Good-Pairs-II" class="headerlink" title="Find the Number of Good Pairs II"></a><a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description">Find the Number of Good Pairs II</a></h1><p>优化枚举，暴力枚举对于每个<code>nums1[i]</code>都需要遍历<code>nums2</code>长度，优化思路是先组织两个Map把查找效率降低，再遍历<code>nums2</code>，对于每个<code>nums2[j]</code>，遍历它的<code>n*k</code>倍，其中<code>n</code>为正整数，上界为<code>nums1</code>中的最大值。此时底层遍历的时间复杂度由$O(nums2.length)$变为了$O(\max(nums1)/k \times \log nums2.length)$，其中$\log nums2.length$是调和级数求和的结果，因此在$nums2.length$大的情况下这种优化可以显著降低底层遍历的耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numberOfPairs</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; count2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            count.put(num, count.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            max1 = Math.max(max1, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            count2.put(num, count2.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : count2.keySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = a * k; b &lt;= max1; b += a * k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count.containsKey(b)) &#123;</span><br><span class="line">                    res += <span class="number">1L</span> * count.get(b) * count2.get(a); <span class="comment">// 避免乘积溢出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/solutions/2798206/li-yong-and-de-xing-zhi-pythonjavacgo-by-gg4d/?envType=daily-question&amp;envId=2024-10-09">https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/solutions/2798206/li-yong-and-de-xing-zhi-pythonjavacgo-by-gg4d/?envType=daily-question&amp;envId=2024-10-09</a><br>[2] <a href="https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/solutions/2943534/hua-dong-chuang-kou-by-hypnotised-e-3jcd/?envType=daily-question&amp;envId=2024-10-09">https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/solutions/2943534/hua-dong-chuang-kou-by-hypnotised-e-3jcd/?envType=daily-question&amp;envId=2024-10-09</a><br>[3] <a href="https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/solutions/2928182/you-zhi-shu-dui-de-zong-shu-ii-by-leetco-obro/?envType=daily-question&amp;envId=2024-10-11">https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/solutions/2928182/you-zhi-shu-dui-de-zong-shu-ii-by-leetco-obro/?envType=daily-question&amp;envId=2024-10-11</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周AI喜提两项诺奖，工作定下来后还是要多研究一下AI应用。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、滑动窗口、枚举&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;241007每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-number-of-refueling-stops/description&quot;&gt;Minimum Number of Refueling Stops&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241009每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-subarray-with-bitwise-or-closest-to-k/description&quot;&gt;Find Subarray With Bitwise OR Closest to K&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241010每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/description&quot;&gt;Find the Number of Good Pairs II&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP5</title>
    <link href="http://silencezheng.top/2024/10/12/article146/"/>
    <id>http://silencezheng.top/2024/10/12/article146/</id>
    <published>2024-10-12T11:01:13.000Z</published>
    <updated>2024-10-27T15:28:29.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周赛依然没打～</p><p>本周主题：图路径枚举、深度优先搜索、贪心、矩阵枚举</p><p>题目：</p><ul><li>240702每日一题—<a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description">Maximum Path Quality of a Graph</a></li><li>240704每日一题—<a href="https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/description/">Minimum Moves to Pick K Ones</a></li><li>240707每日一题—<a href="https://leetcode.cn/problems/check-if-move-is-legal/description">Check if Move is Legal</a><span id="more"></span><h1 id="图路径枚举（DFS）"><a href="#图路径枚举（DFS）" class="headerlink" title="图路径枚举（DFS）"></a>图路径枚举（DFS）</h1><blockquote><p>Maximum Path Quality of a Graph</p><p>There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime.</p><p>A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node’s value is added at most once to the sum).</p><p>Return the maximum quality of a valid path.</p><p>Note: There are at most four edges connected to each node.</p></blockquote></li></ul><p>这题直接作为学习枚举图路径的素材了，对于数据范围小的图路径题可以考虑，由于原题通过时间范围限制了路径最大长度为<code>10</code>且每个节点的度数不超过<code>4</code>，则枚举的范围较小。</p><p>可以使用<strong>递归 + 回溯</strong>的方法进行枚举。递归函数记录当前所在的节点编号，已经过的路径的总时间以及节点的价值之和。如果当前在节点 u，我们可以枚举与 u 直接相连的节点 v 进行递归搜索。在搜索的过程中，如果我们回到了节点 0，就可以对答案进行更新；如果总时间超过了 maxTime，我们需要停止搜索，进行回溯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] values;</span><br><span class="line">    <span class="keyword">int</span> maxTime;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt;[] g; <span class="comment">// 第二维可变长的二维数组</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited; <span class="comment">// 用于判断是否需要计算价值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="keyword">int</span>[] values, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">        <span class="keyword">this</span>.maxTime = maxTime;</span><br><span class="line">        <span class="keyword">int</span> n = values.length;</span><br><span class="line">        g = <span class="keyword">new</span> List[n]; <span class="comment">// 用于存储每个节点的邻接节点与代价</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            g[edge[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">            g[edge[<span class="number">1</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;edge[<span class="number">0</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, values[<span class="number">0</span>]); <span class="comment">// 初始节点，已经过时间，当前价值和</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> time, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = Math.max(ans, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : g[u]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = arr[<span class="number">0</span>], dist = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果时间允许则进行下一步</span></span><br><span class="line">            <span class="keyword">if</span> (time + dist &lt;= maxTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">                    <span class="comment">// 对于初次经过的节点，尝试所有可能路径后回溯</span></span><br><span class="line">                    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">                    dfs(v, time + dist, value + values[v]);</span><br><span class="line">                    visited[v] = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 已经走过就无所谓了反正也不计算value</span></span><br><span class="line">                    dfs(v, time + dist, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 时间不允许则结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵枚举"><a href="#矩阵枚举" class="headerlink" title="矩阵枚举"></a>矩阵枚举</h1><blockquote><p>Check if Move is Legal</p><p>You are given a 0-indexed 8 x 8 grid board, where board[r][c] represents the cell (r, c) on a game board. On the board, free cells are represented by ‘.’, white cells are represented by ‘W’, and black cells are represented by ‘B’.</p><p>Each move in this game consists of choosing a free cell and changing it to the color you are playing as (either white or black). However, a move is only legal if, after changing it, the cell becomes the endpoint of a good line (horizontal, vertical, or diagonal).</p><p>A good line is a line of three or more cells (including the endpoints) where the endpoints of the line are one color, and the remaining cells in the middle are the opposite color (no cells in the line are free).</p><p>Given two integers rMove and cMove and a character color representing the color you are playing as (white or black), return true if changing cell (rMove, cMove) to color color is a legal move, or false if it is not legal.</p></blockquote><p>由题意可知，当前操作合法当且仅当从该点开始的 8 个方向（上下左右与对角线）中，至少有一个方向存在一个以该点为起点的好线段。</p><p>那么，我们可以枚举这 8 个方向，并对于每个方向验证是否存在以该点为起点的好线段。如果该点与对应方向下一个相同颜色的格点之间的所有格点（至少一个）均为另一种颜色，那么它们构成一个好线段。</p><p>我们用数对 (dx,dy) 来表示每个方向下一个格点相对于当前格点的行列下标变化量，并用函数 check(dx,dy) 来判断该方向是否存在以操作位置为起点的好线段。如果我们寻找到了符合要求的好线段，则返回 true；反之亦然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMove</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> rMove, <span class="keyword">int</span> cMove, <span class="keyword">char</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 x 轴正方向开始逆时针枚举 8 个方向</span></span><br><span class="line">        <span class="keyword">int</span>[] dx = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;   <span class="comment">// 行改变量</span></span><br><span class="line">        <span class="keyword">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;   <span class="comment">// 列改变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(board, rMove, cMove, color, dx[k], dy[k])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断每个方向是否存在以操作位置为起点的好线段</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> rMove, <span class="keyword">int</span> cMove, <span class="keyword">char</span> color, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = rMove + dx;</span><br><span class="line">        <span class="keyword">int</span> y = cMove + dy;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;   <span class="comment">// 当前遍历到的节点序号</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">8</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 第一个点必须为相反颜色</span></span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;.&#x27;</span> || board[x][y] == color) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 好线段中不应存在空格子</span></span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历到好线段的终点，返回 true</span></span><br><span class="line">                <span class="keyword">if</span> (board[x][y] == color) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++step;</span><br><span class="line">            x += dx;</span><br><span class="line">            y += dy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在符合要求的好线段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>题目：<a href="https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/description/">Minimum Moves to Pick K Ones</a></p><p>这题首先要先读明白题…首先有一个“01串”，目标是用最少的<code>moves</code>捡起<code>k</code>个$1$，起始状态是从串中的某个$1$开始的，我们叫这个$1$的下标为<code>aliceIndex</code>，我们取走这个$1$使该位置变成$0$，此时还差<code>k-1</code>个$1$需要捡。怎么捡其他的$1$呢？我们通过如下两种操作：</p><ol><li>随便选一个$0$变成$1$，俗称点石成金，有最大操作数限制<code>maxChanges</code>；</li><li>选两个邻接的$1$和$0$，下标分别为$x$和$y$，交换值，如果$y==aliceIndex$则捡起这个$1$。</li></ol><p>因此，对于<code>aliceIndex</code>左右两侧有$1$的情况，我们只需要$1$个动作就可以捡起，当两侧都为$0$时，通过点石成金和交换的组合动作来捡$1$，这里的分情况思想比较重要，我第一次做时就错在了从动作角度考虑，实际上分情况时应该注意“普适性”与“靠近终态”（这是我瞎总结的），因此应该从所有的$1$所处的位置考虑。情况如下：</p><ul><li>情况一：先将 aliceIndex 邻近的数字设置为 1 ，然后交换数字，只需要两次行动就可以拾起一个 1 。</li><li>情况二：令 $n u m s[x]=1$ ，那么需要 $\mid x$-aliceIndex $\mid$ 次行动才可以拾起一个 1 ，根据 $x$ 的取值，又可以区分成两种类型:<ul><li>$x \in[$ aliceIndex -1 , aliceIndex +1$]$ ，那么最多需要 1 次行动就可以拾起一个 1 。</li><li>$x \notin[$ aliceIndex -1 , aliceIndex +1$]$ ，那么最少需要 2 次行动才可以拾起一个 1 。</li></ul></li></ul><p>令 $f($ aliceIndex $)$ 表示数组 nums 在区间 $[$ aliceIndex -1 , aliceIndex +1$]$ 内的元素之和。<br>如果 $f($ aliceIndex $)+maxChanges \geq k$ ，那么最少行动次数肯定是先将区间 [aliceIndex -1 , aliceIndex + 1] 内的所有 1 拾起, 然后剩余的 1 根据情况一来拾起。</p><p>如果 $f($ aliceIndex $)+maxChanges &lt;k$ ，那么可以贪心地先拾起情况一的所有 1 ，剩余 $k-maxChanges$个 1 根据情况二拾起。我们使用 $indexSum [i]$ 记录数组 $n u m s$ 在区间 $[0, i)$ 内所有值为 1 的元素下标之和，使用 $sum[i]$ 记录数组 nums 在区间 $[0, i)$ 所有元素之和。要使情况二的行动次数之和最少，那么拾起的 1 距离 aliceIndex 需要尽量近。我们使用二分算法来搜索最短距离 $d$ ，使得区间 $[aliceIndex-d, aliceIndex+d]$ 内的 1 数目大于等于 $k-maxChanges$ 。记选择的区间为 $\left[i_1, i_2\right]$, 那么最少行动次数为:</p><script type="math/tex; mode=display">\begin{aligned}& \text { indexSum }\left[i_2+1\right]-\text { indexSum }[\text { aliceIndex }+1]-\text { aliceIndex } \times\left(\operatorname{sum}\left[i_2+1\right]-\operatorname{sum}[aliceIndex+1]\right)+\text { aliceIndex } \times \\& \left(\operatorname{sum}[\text { aliceIndex }+1]-\operatorname{sum}\left[i_1\right]\right)-\left(\text { indexSum }[\text { aliceIndex }+1]-\text { indexSum }\left[i_1\right]\right)+2 \times \text { maxChanges }\end{aligned}</script><p>我们可以枚举 aliceIndex, 然后取所有结果的最小值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minimumMoves</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> maxChanges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span>[] indexSum = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>], sum = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indexSum[i + <span class="number">1</span>] = indexSum[i] + nums[i] * i;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f(i, nums) + maxChanges &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &lt;= f(i, nums)) &#123;</span><br><span class="line">                    res = Math.min(res, (<span class="keyword">long</span>)k - nums[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = Math.min(res, (<span class="keyword">long</span>)<span class="number">2</span> * k - f(i, nums) - nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> i1 = Math.max(i - mid, <span class="number">0</span>), i2 = Math.min(i + mid, n - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (sum[i2 + <span class="number">1</span>] - sum[i1] &gt;= k - maxChanges) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i1 = Math.max(i - left, <span class="number">0</span>), i2 = Math.min(i + left, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sum[i2 + <span class="number">1</span>] - sum[i1] &gt; k - maxChanges) &#123;</span><br><span class="line">                i1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> count1 = sum[i + <span class="number">1</span>] - sum[i1], count2 = sum[i2 + <span class="number">1</span>] - sum[i + <span class="number">1</span>];</span><br><span class="line">            res = Math.min(res, indexSum[i2 + <span class="number">1</span>] - indexSum[i + <span class="number">1</span>] - i * count2 + i * count1 - (indexSum[i + <span class="number">1</span>] - indexSum[i1]) + <span class="number">2</span> * maxChanges);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            x += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; nums.length) &#123;</span><br><span class="line">            x += nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/solutions/2827546/shi-qi-k-ge-1-xu-yao-de-zui-shao-xing-do-1c7m/">https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/solutions/2827546/shi-qi-k-ge-1-xu-yao-de-zui-shao-xing-do-1c7m/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;周赛依然没打～&lt;/p&gt;
&lt;p&gt;本周主题：图路径枚举、深度优先搜索、贪心、矩阵枚举&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240702每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description&quot;&gt;Maximum Path Quality of a Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240704每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/description/&quot;&gt;Minimum Moves to Pick K Ones&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240707每日一题—&lt;a href=&quot;https://leetcode.cn/problems/check-if-move-is-legal/description&quot;&gt;Check if Move is Legal&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP15</title>
    <link href="http://silencezheng.top/2024/10/07/article145/"/>
    <id>http://silencezheng.top/2024/10/07/article145/</id>
    <published>2024-10-06T19:10:16.000Z</published>
    <updated>2024-10-28T04:59:53.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>被最小问题爆杀的一周…</p><p>本周主题：动态规划、二分查找、记忆化搜索</p><p>题目：</p><ul><li>241001每日一题—<a href="https://leetcode.cn/problems/minimum-cost-for-tickets/description">Minimum Cost For Tickets</a></li><li>241003每日一题—<a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description">Minimum Cost to Reach Destination in Time</a></li><li>241005每日一题—<a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/description">Minimum Time to Complete Trips</a></li></ul><span id="more"></span><h1 id="Minimum-Cost-For-Tickets"><a href="#Minimum-Cost-For-Tickets" class="headerlink" title="Minimum Cost For Tickets"></a>Minimum Cost For Tickets</h1><blockquote><p>Minimum Cost For Tickets<br>You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.<br>Train tickets are sold in three different ways:</p><ul><li>a 1-day pass is sold for costs[0] dollars,</li><li>a 7-day pass is sold for costs[-1] </li><li>a 30-day pass is sold for costs[-1] </li></ul><p>The passes allow that many days of consecutive travel.<br>For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.<br>Return the minimum number of dollars you need to travel every day in the given list of days.</p></blockquote><p>无论记忆化搜索还是动态规划，都需要先<strong>划分子问题</strong>和<strong>定义状态转移</strong>。</p><p>假设第 100 天是旅行的最后一天，分类讨论：</p><ul><li>在第 100 天购买为期 1 天的通行证，接下来需要解决的问题为：1 到 99 天的最小花费。</li><li>在第 94 天购买为期 7 天的通行证，接下来需要解决的问题为：1 到 93 天的最小花费。</li><li>在第 71 天购买为期 30 天的通行证，接下来需要解决的问题为：1 到 70 天的最小花费。<br>这些问题都是和原问题相似的、规模更小的子问题，可以用递归解决。</li></ul><blockquote><p>动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。</p></blockquote><p>根据上面的讨论，定义 $dfs(i)$ 表示 $1$ 到 $i$ 天的最小花费。如果第 $i$ 天不在 days 中，那么问题变成 $1$ 到 $i−1$ 天的最小花费，即 $dfs(i)=dfs(i−1)$</p><p>如果第 $i$ 天在 days 中，分类讨论：</p><ul><li>在第 $i$ 天购买为期 $1$ 天的通行证，接下来需要解决的问题为：$1$ 到 $i−1$ 天的最小花费，即 $dfs(i)=dfs(i−1)+costs[0]$。</li><li>在第 $i−6$ 天购买为期 $7$ 天的通行证，接下来需要解决的问题为：$1$ 到 $i−7$ 天的最小花费，即 $dfs(i)=dfs(i−7)+costs[1]$。</li><li>在第 $i−29$ 天购买为期 $30$ 天的通行证，接下来需要解决的问题为：$1$ 到 $i−30$ 天的最小花费，即 $dfs(i)=dfs(i−30)+costs[2]$。</li></ul><p>这三种情况取最小值，就得到了 dfs(i)，即</p><script type="math/tex; mode=display">dfs(i)=min(dfs(i−1)+costs[0],dfs(i−7)+costs[1],dfs(i−30)+costs[2])</script><p>递归边界：$dfs(i)=0$，其中 $i≤0$。此时没有要旅行的天数。</p><p>递归入口：$dfs(D)$，其中 $D=days[n−1]$ 是最后一天。为了方便翻译成递推，我们从最后一天开始思考。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>采用递归+记忆化的方式自顶向下解决问题，所谓自顶向下，即从最终结果$dfs(D)$向下延伸至底层计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastDay = days[days.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] isTravel = <span class="keyword">new</span> <span class="keyword">boolean</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d : days) &#123;</span><br><span class="line">            isTravel[d] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dfs(lastDay, isTravel, costs, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">boolean</span>[] isTravel, <span class="keyword">int</span>[] costs, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTravel[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i] = dfs(i - <span class="number">1</span>, isTravel, costs, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i] = Math.min(dfs(i - <span class="number">1</span>, isTravel, costs, memo) + costs[<span class="number">0</span>],</span><br><span class="line">                         Math.min(dfs(i - <span class="number">7</span>, isTravel, costs, memo) + costs[<span class="number">1</span>],</span><br><span class="line">                                  dfs(i - <span class="number">30</span>, isTravel, costs, memo) + costs[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>自底向上遍历，即从days数组的左侧开始，状态 $f[i]$ 的定义和 $dfs(i)$ 的定义是一样的，都表示 $1$ 到 $i$ 天的最小花费。</p><p>相应的递推式（状态转移方程）也和 dfs 一样：</p><script type="math/tex; mode=display">f[i]=min(f[i−1]+costs[0],f[i−7]+costs[1],f[i−30]+costs[2])</script><p>由于 $f[0]=0$ 且负数 $i$ 的状态值也为 $0$，我们可以把负数 $i$ 视作 $0$，上式等价于</p><script type="math/tex; mode=display">f[i]=min(f[i−1]+costs[0],f[max(i−7,0)]+costs[1],f[max(i−30,0)]+costs[2])</script><p>初始值 $f[0]=0$，翻译自递归边界 $dfs(0)=0$。答案为 $f[D]$，翻译自递归入口 $dfs(D)$。所谓自底向上，即先计算底层结果，最后获得最终答案 $f[D]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastDay = days[days.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] isTravel = <span class="keyword">new</span> <span class="keyword">boolean</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d : days) &#123;</span><br><span class="line">            isTravel[d] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[lastDay + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lastDay; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isTravel[i]) &#123;</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[i] = Math.min(f[i - <span class="number">1</span>] + costs[<span class="number">0</span>],</span><br><span class="line">                       Math.min(f[Math.max(i - <span class="number">7</span>, <span class="number">0</span>)] + costs[<span class="number">1</span>],</span><br><span class="line">                                f[Math.max(i - <span class="number">30</span>, <span class="number">0</span>)] + costs[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[lastDay];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>对于本题，最理想的情况是时间复杂度仅与days数组的长度有关而与$D=days[n−1]$的大小无关。</p><p>重新定义 $f[i]$ 表示旅行了 $i$ 天的最小花费：</p><ul><li>$f[0]$ 表示旅行 $0$ 天的最小花费，根据定义，$f[0]=0$。</li><li>$f[1]$ 表示旅行 $1$ 天的最小花费，也就是完成 $days[0]$ 的最小花费。</li><li>$f[2]$ 表示旅行 $2$ 天的最小花费，也就是完成 $days[0]$ 和 $days[1]$ 的最小花费。</li><li>一般地，$f[i+1]$ 表示完成 $days[0]$ 到 $days[i]$ 的最小花费。</li></ul><p>分类讨论：</p><ul><li>在 $days[i]$ 购买为期 $1$ 天的通行证，接下来需要解决的问题为：完成 $days[0]$ 到 $days[i−1]$ 的最小花费，即 $f[i+1]=f[i]+costs[0]$。</li><li>在第 $days[j]$ 天购买为期 $7$ 天的通行证，满足 $days[j]+7&gt;days[i]$（注意不是 ≥），接下来需要解决的问题为：完成 $days[0]$ 到 $days[j−1]$ 的最小花费，即 $f[i+1]=f[j]+costs[1]$。</li><li>在第 $days[k]$ 天购买为期 $30$ 天的通行证，满足 $days[k]+30&gt;days[i]$，接下来需要解决的问题为：完成 $days[0]$ 到 $days[k−1]$ 的最小花费，即 $f[i+1]=f[k]+costs[2]$。 </li></ul><p>这三种情况取最小值，就得到了 $f[i+1]$，即</p><script type="math/tex; mode=display">f[i+1]=min(f[i]+costs[0],f[j]+costs[1],f[k]+costs[2])</script><p>其中：</p><ul><li>$j$ 是满足 $days[j]&gt;days[i]−7$ 的最小的 $j$。</li><li>$k$ 是满足 $days[k]&gt;days[i]−30$ 的最小的 $k$。<br>由于 $days$ 是有序数组，计算 $j$ 和 $k$ 可以用双指针（三指针）算法。初始值 $f[0]=0, j=0, k=0$。答案为 $f[n]$。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = days.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = days[i];</span><br><span class="line">            <span class="keyword">while</span> (days[j] &lt;= d - <span class="number">7</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (days[k] &lt;= d - <span class="number">30</span>) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i + <span class="number">1</span>] = Math.min(f[i] + costs[<span class="number">0</span>], Math.min(f[j] + costs[<span class="number">1</span>], f[k] + costs[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Minimum-Cost-to-Reach-Destination-in-Time"><a href="#Minimum-Cost-to-Reach-Destination-in-Time" class="headerlink" title="Minimum Cost to Reach Destination in Time"></a><a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description">Minimum Cost to Reach Destination in Time</a></h1><p>题意：从起点到终点，判断是否可在<code>maxTime</code>内到达，并计算最小过路费。</p><p>注意：在$[1, maxTime]$中任一时间到达终点，所花费的过路费多少不一定，即时间与花费无关，因此需要计算全部后筛选出最小花费。</p><h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><p>我们用 $f[t][i]$ 表示使用恰好 $t$ 分钟到达城市 $i$ 需要的最少通行费总和。<br>在状态转移时，我们考虑最后一次通行是从城市 $j$ 到达城市 $i$ 的，那么有状态转移方程：</p><script type="math/tex; mode=display">f[t][i]=\min _{(j, i) \in E}\{f[t-\operatorname{cost}(j, i)][j]+\text { passingFees }[i]\}</script><p>其中 $(j, i) \in E$ 表示城市 $j$ 与 $i$ 存在一条道路， $\operatorname{cost}(j, i)$ 表示这条道路的耗费时间。<br>最终的答案即为 $f[1][n-1], f[2][n-1], \cdots, f[\operatorname{maxTime}][n-1]$ 中的最小值。</p><p>初始状态为 $f[0][0]=passingFees[0]$, 即我们一开始位于 0 号城市, 需要交 $passingFees[0]$的通行费。</p><p>由于状态中存放最小值，因此对于其它的状态，我们可以在一开始赋予它们一个极大值 $\infty$ 。如果最终的答案为 $\infty$, 说明无法在 maxTime 及以内完成旅行, 返回 $-1$ 。</p><p>此外, 本题中的道路是以数组 $edges$ 的形式给定的, 在动态规划的过程中, 如果我们使用两重循环枚举 $t$ 和 $i$, 就不能利用 $edges$, 而需要使用额外的数据结构存储以 $i$ 为端点的所有道路。一种合理的解决方法是, 我们使用一重循环枚举 $t$, 另一重循环枚举 edges 中的每一条边 $(i, j, cost )$, 通过这条边更新 $f[t][i]$ 以及 $f[t][j]$ 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> maxTime, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span>[] passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = passingFees.length;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxTime + <span class="number">1</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxTime; i++) &#123;</span><br><span class="line">            Arrays.fill(f[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= maxTime; t++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = edge[<span class="number">0</span>], j = edge[<span class="number">1</span>], cost = edge[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (cost &lt;= t) &#123;</span><br><span class="line">                    <span class="comment">// 确保从前序更新过的状态转移，且双向都可以更新</span></span><br><span class="line">                    <span class="keyword">if</span> (f[t - cost][j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        f[t][i] = Math.min(f[t][i], f[t - cost][j] + passingFees[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (f[t - cost][i] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                        f[t][j] = Math.min(f[t][j], f[t - cost][i] + passingFees[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= maxTime; t++) &#123;</span><br><span class="line">            ans = Math.min(ans, f[t][n - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Minimum-Time-to-Complete-Trips"><a href="#Minimum-Time-to-Complete-Trips" class="headerlink" title="Minimum Time to Complete Trips"></a>Minimum Time to Complete Trips</h1><blockquote><p>Minimum Time to Complete Trips</p><p>You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.</p><p>Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.</p><p>You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.</p></blockquote><p>首先建立一个Map，其中key为时间，value为该时间对应的trip数量，假设该Map为<code>m</code>。假设当前存在的key为<code>k1, k2, k3,...,kn</code>，则对于时间<code>t</code>，完成的trip数量<code>f(t)</code>可如此计算：</p><script type="math/tex; mode=display">f(t) = t/k1*v1 + t/k2*v2 + ... + t/kn*vn</script><p>可以发现<code>f(t)</code>具有单调性，故考虑二分查找。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找的下界为$1$，上界为运行时间最短的bus运行<code>totalTrips</code>趟所用时间。实际测试中使用Map的方法时空效率均不如直接使用<code>time</code>数组进行<code>check</code>，在重复bus不多的情况下可以选择不使用Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span>[] time, <span class="keyword">int</span> totalTrips)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map</span></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:time) map.merge(x, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="comment">// 二分查找下界与上界</span></span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r = (<span class="keyword">long</span>) totalTrips * Arrays.stream(time).min().orElse(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 二分查找寻找满足要求的最小的 t</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid, totalTrips)) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 t 时间内是否可以完成 totalTrips 趟旅途</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> t, <span class="keyword">int</span> totalTrips)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> period : map.keySet()) &#123;</span><br><span class="line">            cnt += t / period * map.get(period);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= totalTrips;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/minimum-cost-for-tickets/solutions/2936177/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-tkw4/?envType=daily-question&amp;envId=2024-10-01">https://leetcode.cn/problems/minimum-cost-for-tickets/solutions/2936177/jiao-ni-yi-bu-bu-si-kao-dpcong-ji-yi-hua-tkw4/?envType=daily-question&amp;envId=2024-10-01</a><br>[2] <a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solutions/869919/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/?envType=daily-question&amp;envId=2024-10-03">https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solutions/869919/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/?envType=daily-question&amp;envId=2024-10-03</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;被最小问题爆杀的一周…&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、二分查找、记忆化搜索&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;241001每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-cost-for-tickets/description&quot;&gt;Minimum Cost For Tickets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241003每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/description&quot;&gt;Minimum Cost to Reach Destination in Time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;241005每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-time-to-complete-trips/description&quot;&gt;Minimum Time to Complete Trips&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP14</title>
    <link href="http://silencezheng.top/2024/10/05/article144/"/>
    <id>http://silencezheng.top/2024/10/05/article144/</id>
    <published>2024-10-05T09:58:33.000Z</published>
    <updated>2024-10-27T15:28:37.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面的有点麻了，做题反而有意思点。</p><p>本周主题：优化遍历、滑动窗口、线段树、集合</p><p>题目：</p><ul><li>240923每日一题—<a href="https://leetcode.cn/problems/best-sightseeing-pair/description">Best Sightseeing Pair</a></li><li>240925每日一题—<a href="https://leetcode.cn/problems/naming-a-company/description">Naming a Company</a></li><li>240927每日一题—<a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description">Take K of Each Character From Left and Right</a></li><li>240928每日一题—<a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/description">Booking Concert Tickets in Groups</a></li></ul><span id="more"></span><h1 id="Best-Sightseeing-Pair"><a href="#Best-Sightseeing-Pair" class="headerlink" title="Best Sightseeing Pair"></a>Best Sightseeing Pair</h1><blockquote><p>Best Sightseeing Pair</p><p>You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.</p><p>The score of a pair (i &lt; j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.</p><p>Return the maximum score of a pair of sightseeing spots.</p></blockquote><p>暴力超时，优化成排序还是超时…没想到如何优化遍历，于是记录一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = values.length;</span><br><span class="line">        <span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            arr1[i] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, values[i]-i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr1, (a,b)-&gt;b[<span class="number">1</span>]-a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] x:arr1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x[<span class="number">0</span>];i++)&#123;</span><br><span class="line">                res = Math.max(res, values[i]+i+x[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化遍历"><a href="#优化遍历" class="headerlink" title="优化遍历"></a>优化遍历</h2><p>其实对于每一个$values[j]-j$就是要找到$[0, j-1]$中最大的$values[i]+i$。所以其实从前往后遍历的过程中维护$mx = Max(values[i]+i)$即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mx = values[<span class="number">0</span>] + <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; values.length; ++j) &#123;</span><br><span class="line">            ans = Math.max(ans, mx + values[j] - j);</span><br><span class="line">            <span class="comment">// 边遍历边维护</span></span><br><span class="line">            mx = Math.max(mx, values[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Naming-a-Company"><a href="#Naming-a-Company" class="headerlink" title="Naming a Company"></a><a href="https://leetcode.cn/problems/naming-a-company/description">Naming a Company</a></h1><p>用哈希映射 names 存储所有的候选名字，它的键是首字母，值是去除首字母后，每个候选名字的剩余部分。因此，我们可以枚举两个不同的首字母 $p r e_A$ 和 $p r e_B$，计算以它们为首字母的有效的公司名字数量。</p><p>两集合$p r e_A$ 和 $p r e_B$的符合条件组合数量为：</p><script type="math/tex; mode=display">\left.\mid \text { names }\left[\text { pre }_A\right]-\text { names }\left[\text { pre }_B\right]|\times|{\text { names }\left[\text { pre }_B\right]-\text { names }[\text { pre }}_A\right] \mid</script><p>其中 $|\cdot|$ 表示集合大小， $-$ 表示集合的差集运算。枚举所有不同的 $\mathrm{pre}_A$ 和 $p r e_B$, 即可得到最终的答案。</p><p>需要注意的是上式需要计算两次集合的差集，但实际上我们只需要知道差集的大小而不是差集本身。对于集合 $A, B$, 有 $A-B=A \backslash(A \cap B)$, 其中 $\backslash$ 表示将元素去除, $\cap$ 表示集合的交集运算。因此，我们只需要计算一次集合的交集即可，通过 $|A|-|A \cap B|$ 以及 $|B|-|A \cap B|$ 即可快速得到两个差集的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">distinctNames</span><span class="params">(String[] ideas)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;String&gt;&gt; names = <span class="keyword">new</span> HashMap&lt;Character, Set&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String idea : ideas) names.computeIfAbsent(idea.charAt(<span class="number">0</span>), x-&gt;<span class="keyword">new</span> HashSet&lt;String&gt;()).add(idea.substring(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Set&lt;String&gt;&gt; entryA : names.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">char</span> preA = entryA.getKey();</span><br><span class="line">            Set&lt;String&gt; setA = entryA.getValue();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Set&lt;String&gt;&gt; entryB : names.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">char</span> preB = entryB.getKey();</span><br><span class="line">                Set&lt;String&gt; setB = entryB.getValue();</span><br><span class="line">                <span class="keyword">if</span> (preA == preB) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> intersect = getIntersectSize(setA, setB);</span><br><span class="line">                ans += (<span class="keyword">long</span>) (setA.size() - intersect) * (setB.size() - intersect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntersectSize</span><span class="params">(Set&lt;String&gt; a, Set&lt;String&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : a) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b.contains(s)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Take-K-of-Each-Character-From-Left-and-Right"><a href="#Take-K-of-Each-Character-From-Left-and-Right" class="headerlink" title="Take K of Each Character From Left and Right"></a>Take K of Each Character From Left and Right</h1><blockquote><p>Take K of Each Character From Left and Right</p><p>You are given a string s consisting of the characters ‘a’, ‘b’, and ‘c’ and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.</p><p>Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.</p></blockquote><p>一开始的思路是模拟，然后对于左右都可取的情况需要分支尝试，这样会造成分支太多超时。其实这也是正向模拟走不通的原因，我们在选取左右两边时无法了解后续情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCharacters</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ta = <span class="number">0</span>, tb = <span class="number">0</span>, tc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;a&#x27;</span>) ta++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;b&#x27;</span>) tb++;</span><br><span class="line">            <span class="keyword">else</span> tc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ta&lt;k||tb&lt;k||tc&lt;k) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// what is the problem?</span></span><br><span class="line">        <span class="comment">// let&#x27;s define the last pick index from left to right is f(i)</span></span><br><span class="line">        <span class="comment">// the penultimate valid pick index is f(i-1)</span></span><br><span class="line">        <span class="comment">// then the picks from f(i-1) to f(i) is redundant</span></span><br><span class="line">        <span class="comment">// if s[f(i)] == x and there is index j from right to left</span></span><br><span class="line">        <span class="comment">// where s[j] == x and rightEnd - j &lt; f(i)-f(i-1)</span></span><br><span class="line">        <span class="comment">// It&#x27;s a better solution to pick f(i-1) and j instead of f(i)</span></span><br><span class="line">        <span class="comment">// Let&#x27;s define f(i) is next pick, and the computation relys on following parameters:</span></span><br><span class="line">        <span class="comment">// 1. what we got, use count(&#x27;a&#x27;), count(&#x27;b&#x27;) and count(&#x27;c&#x27;)</span></span><br><span class="line">        <span class="comment">// 2. 2 pointers l and r, which means where we picked now</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">return</span> pick(s, l, r, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]&lt;k||cnt[<span class="number">1</span>]&lt;k||cnt[<span class="number">2</span>]&lt;k)&#123;</span><br><span class="line">            <span class="keyword">int</span> pl = l, pr = r, cl = <span class="number">0</span>, cr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pl+cl&lt;s.length()-<span class="number">1</span>&amp;&amp;!valid(s.charAt(pl+cl), cnt)) cl++;</span><br><span class="line">            <span class="keyword">while</span>(pr-cr&gt;<span class="number">0</span>&amp;&amp;!valid(s.charAt(pr-cr), cnt)) cr++;</span><br><span class="line">            <span class="keyword">if</span>(cl==cr)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] cnt1 = Arrays.copyOf(cnt, cnt.length);</span><br><span class="line">                <span class="keyword">int</span>[] cnt2 = Arrays.copyOf(cnt, cnt.length);</span><br><span class="line">                take(s.charAt(pl+cl), cnt1);</span><br><span class="line">                take(s.charAt(pr-cr), cnt2);</span><br><span class="line">                <span class="keyword">return</span> Math.min(pick(s, pl+cl+<span class="number">1</span>, r, cnt1), pick(s, l, pr-cr-<span class="number">1</span>, cnt2));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cl&gt;cr)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] cnt1 = Arrays.copyOf(cnt, cnt.length);</span><br><span class="line">                take(s.charAt(pr-cr), cnt1);</span><br><span class="line">                <span class="keyword">return</span> pick(s, l, pr-cr-<span class="number">1</span>, cnt1);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span>[] cnt1 = Arrays.copyOf(cnt, cnt.length);</span><br><span class="line">                take(s.charAt(pl+cl), cnt1);</span><br><span class="line">                <span class="keyword">return</span> pick(s, pl+cl+<span class="number">1</span>, r, cnt1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> s.length()-(r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span>[] cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((ch==<span class="string">&#x27;a&#x27;</span>&amp;&amp;cnt[<span class="number">0</span>]&lt;k)||(ch==<span class="string">&#x27;b&#x27;</span>&amp;&amp;cnt[<span class="number">1</span>]&lt;k)||(ch==<span class="string">&#x27;c&#x27;</span>&amp;&amp;cnt[<span class="number">2</span>]&lt;k)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span>[] cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;a&#x27;</span>) cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;b&#x27;</span>) cnt[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span> cnt[<span class="number">2</span>]++;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>可以这样考虑，假如 $s$ 中有 3 个 $\mathrm{a}, 4$ 个 $\mathrm{b}, 5$ 个 $\mathrm{c}, k=2$, 每种字母至少取走 2 个, 等价于剩下的字母至多有 1 个 $a, 2$ 个 $b$ 和 3 个 $c$ 。</p><p>由于只能从 $s$ 最左侧和最右侧取走字母, 所以剩下的字母是 $s$ 的子串。<br>设 $s$ 中的 $\mathrm{a}, \mathrm{b}, \mathrm{c}$ 的个数分别为 $x, y, z$, 可以转化问题为:</p><ul><li>计算 $s$ 的最长子串长度, 该子串满足 $\mathrm{a}, \mathrm{b}, \mathrm{c}$ 的个数分别至多为 $x-k, y-k, z-k$ 。</li></ul><p>由于子串越短越能满足要求, 越长越不能满足要求, <strong>有单调性, 可以用滑动窗口解决</strong>。</p><p>在实现上，与其维护窗口内的字母个数, 不如直接维护窗口外的字母个数, 这也是我们取走的字母个数。</p><ul><li>一开始, 假设我们取走了所有的字母。或者说, 初始窗口是空的, 窗口外的字母个数就是 $s$ 的每个字母的出现次数。</li><li>窗口从左向右滑动，右端点字母进入窗口后, 该字母取走的个数减一。</li><li>如果减一后, 窗口外该字母的个数小于 $k$, 说明子串太长了, 或者取走的字母个数太少了,那么就不断右移左端点, 把左端点字母移出窗口, 相当于我们取走移出窗口的字母, 直到该字母个数等于 $k$, 退出内层循环。</li><li>内层循环结束后, 用窗口长度 right - left +1 更新子串长度的最大值。</li></ul><p>最后, 原问题的答案为 $n$ 减去子串长度的最大值。特别地, 如果 $s$ 中某个字母的个数不足 $k$, 那么无法满足题目要求, 返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">takeCharacters</span><span class="params">(String S, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++; <span class="comment">// 一开始，把所有字母都取走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">0</span>] &lt; k || cnt[<span class="number">1</span>] &lt; k || cnt[<span class="number">2</span>] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 字母个数不足 k</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>; <span class="comment">// 子串最大长度</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; s.length; right++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[right] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            cnt[c]--; <span class="comment">// 移入窗口，相当于不取走 c</span></span><br><span class="line">            <span class="keyword">while</span> (cnt[c] &lt; k) &#123; <span class="comment">// 窗口之外的 c 不足 k</span></span><br><span class="line">                cnt[s[left] - <span class="string">&#x27;a&#x27;</span>]++; <span class="comment">// 移出窗口，相当于取走 s[left]</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            mx = Math.max(mx, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.length - mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Booking-Concert-Tickets-in-Groups"><a href="#Booking-Concert-Tickets-in-Groups" class="headerlink" title="Booking Concert Tickets in Groups"></a><a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/description">Booking Concert Tickets in Groups</a></h1><p>题目太长就不粘了，简单来说就是实现一个演唱会购票类，可以实现连座和散座订票。</p><p>按照题目原意写出基础解法并不难，只是会OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookMyShow</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用最后一个元素记录剩余容量, 剩余的0表示空座</span></span><br><span class="line">    <span class="keyword">int</span>[][] hall; </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookMyShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        hall = <span class="keyword">new</span> <span class="keyword">int</span>[n][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) hall[i][m] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">view</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] r:hall) System.out.println(Arrays.toString(r));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gather(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow) &#123;</span><br><span class="line">        <span class="keyword">if</span>(preBook(k, maxRow, <span class="keyword">false</span>)) <span class="keyword">return</span> book(k, maxRow, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scatter</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preBook(k, maxRow, <span class="keyword">true</span>))&#123;</span><br><span class="line">            book(k, maxRow, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">preBook</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow, <span class="keyword">boolean</span> isScatter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isScatter)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxRow;i++)&#123;</span><br><span class="line">                cnt+=hall[i][m];</span><br><span class="line">                <span class="keyword">if</span>(cnt&gt;=k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxRow;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hall[i][m]&gt;=k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] book(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow, <span class="keyword">boolean</span> isScatter)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> toDo = k;</span><br><span class="line">        <span class="keyword">if</span>(isScatter)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(toDo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hall[p][m]==<span class="number">0</span>)&#123;</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(hall[p][m]&gt;=toDo)&#123;</span><br><span class="line">                    doBook(p, m-hall[p][m], m-hall[p][m]+toDo);</span><br><span class="line">                    toDo = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    toDo-=hall[p][m];</span><br><span class="line">                    doBook(p, m-hall[p][m], m);</span><br><span class="line">                &#125;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxRow;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hall[i][m]&gt;=toDo)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = m-hall[i][m];</span><br><span class="line">                    doBook(i, m-hall[i][m], m-hall[i][m]+toDo);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doBook</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s;i&lt;e;i++) hall[row][i] = <span class="number">1</span>;</span><br><span class="line">        hall[row][m]-=(e-s);</span><br><span class="line">        <span class="comment">// view();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>将每一排座位看成一个整体，可将两种操作总结如下：</p><ul><li>gather：在前 maxRow 排中，找第一个还能至少有 k 个空座位的排，预定 k 个连续的座位。如果有这样的排，返回编号，以及在预定前有多少非空座位；如果没有这样的排，返回空列表。</li><li>scatter：在前 maxRow 个排中预定总量为 k 的座位。从左到右选择有空座位的排依次占座。如果无法预定总量为 k 的座位，则不执行操作，并返回 false；否则执行操作，并返回 true。</li></ul><p>此时将原问题压缩为一维数组，能这样做的原因是两种操作均不会产生“间隔的空座位”。因此需要的操作如下：</p><ul><li>求出前 maxRow 排中，第一个剩余容量 ≥k，也就是已预定量 ≤ m−k 的排。</li><li>维护每排的已预定量。</li><li>维护前 maxRow 排的已预定量之和，从而判断 scatter 能否实现。</li></ul><p>可以用线段树处理上述操作，线段树维护每个区间（区间即某几排）已预定量的最小值 $\min$ ，以及每个区间的已预定量之和 $sum$。</p><p>对于 gather，从线段树的根节点开始递归：</p><ul><li>如果当前区间 $\min &gt; m-k$, 则无法预定 $k$ 个连续座位，返回 0 。</li><li>如果当前区间长度为 1 ，返回区间端点。</li><li>如果左半区间 $\min \leq m-k$, 则答案在左半区间中, 递归左半区间。</li><li>否则如果 maxRow 在右半区间内, 递归右半区间。</li><li>否则返回 -1 ，表示没有符合条件的排。</li></ul><p>上述过程叫做<strong>线段树二分</strong>，</p><p>对于 scatter，如果区间 $[0$, maxRow] 的已预定量之和大于 $m \cdot(\operatorname{maxRow}+1)-k$ ，则无法执行操作。否则可以执行操作。从第一个没有装满，也就是已预定量 $\leq m-1$ 的排开始预定，这也可以用线段树二分求出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookMyShow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] min;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookMyShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(n)); <span class="comment">// 比 4n 更小</span></span><br><span class="line">        min = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gather(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow) &#123;</span><br><span class="line">        <span class="comment">// 找第一个能预定 k 个座位的row</span></span><br><span class="line">        <span class="keyword">int</span> r = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - k);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123; <span class="comment">// 没有这样的row</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, r);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, k); <span class="comment">// 预定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scatter</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0,maxRow] 的已预定量之和</span></span><br><span class="line">        <span class="keyword">long</span> s = querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, maxRow);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; (<span class="keyword">long</span>) m * (maxRow + <span class="number">1</span>) - k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 空座位不足</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个没有定满的row开始</span></span><br><span class="line">        <span class="keyword">int</span> i = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = Math.min(m - (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i), k);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, left); <span class="comment">// 预定</span></span><br><span class="line">            k -= left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把下标 i 上的元素值增加 val</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            min[o] += val;</span><br><span class="line">            sum[o] += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">            update(o * <span class="number">2</span>, l, m, i, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, i, val);</span><br><span class="line">        &#125;</span><br><span class="line">        min[o] = Math.min(min[o * <span class="number">2</span>], min[o * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        sum[o] = sum[o * <span class="number">2</span>] + sum[o * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [L,R] 内的元素和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[o];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= m) &#123;</span><br><span class="line">            res = querySum(o * <span class="number">2</span>, l, m, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            res += querySum(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [0,R] 中 &lt;= val 的最靠左的位置，不存在时返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> R, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min[o] &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 整个区间的元素值都大于 val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (min[o * <span class="number">2</span>] &lt;= val) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span>, l, m, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28">https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28</a><br>[2] <a href="https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/solutions/2031995/on-shuang-zhi-zhen-by-endlesscheng-4g9p/?envType=daily-question&amp;envId=2024-09-27">https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/solutions/2031995/on-shuang-zhi-zhen-by-endlesscheng-4g9p/?envType=daily-question&amp;envId=2024-09-27</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面的有点麻了，做题反而有意思点。&lt;/p&gt;
&lt;p&gt;本周主题：优化遍历、滑动窗口、线段树、集合&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240923每日一题—&lt;a href=&quot;https://leetcode.cn/problems/best-sightseeing-pair/description&quot;&gt;Best Sightseeing Pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240925每日一题—&lt;a href=&quot;https://leetcode.cn/problems/naming-a-company/description&quot;&gt;Naming a Company&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240927每日一题—&lt;a href=&quot;https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/description&quot;&gt;Take K of Each Character From Left and Right&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240928每日一题—&lt;a href=&quot;https://leetcode.cn/problems/booking-concert-tickets-in-groups/description&quot;&gt;Booking Concert Tickets in Groups&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://silencezheng.top/2024/10/05/article143/"/>
    <id>http://silencezheng.top/2024/10/05/article143/</id>
    <published>2024-10-04T17:55:12.000Z</published>
    <updated>2024-10-04T17:57:07.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线段树是算法竞赛中常用的用来维护“区间信息”的数据结构。线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><span id="more"></span><h1 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h1><p>线段树将每个长度不为$1$的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>有个大小为$5$的数组 a={10,11,12,13,14}，要将其转化为线段树，有以下做法：设线段树的根节点编号为$1$，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。这棵线段树的形态如下图所示：</p><p><img src="/assets/post_img/article143/segt1.svg" alt="segt1"></p><p>图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5]$（$a_1,a_2, \cdots ,a_5$），即 $d_1$ 所保存的值是 $a_1+a_2+ \cdots +a_5$，$d_1=60$ 表示的是 $a_1+a_2+ \cdots +a_5=60$。</p><p>通过观察不难发现，$d_i$ 的左儿子节点就是 $d_{2\times i}$，$d_i$ 的右儿子节点就是 $d_{2\times i+1}$。如果 $d_i$ 表示的是区间 $[s,t]$（即 $d_i=a_s+a_{s+1}+ \cdots +a_t$）的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$，$d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$。</p><h2 id="建树过程"><a href="#建树过程" class="headerlink" title="建树过程"></a>建树过程</h2><p>可以使用递归建树，设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 $1$，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><p>采用数组堆式存储（$2p$ 是 $p$ 的左儿子，$2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则数组的范围最大为 $2^{\left\lceil\log{n}\right\rceil+1}$。</p><p>分析：容易知道线段树的深度是 $\left\lceil\log{n}\right\rceil$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\left\lceil\log{n}\right\rceil}$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{\left\lceil\log{n}\right\rceil+1}-1$。当然也可以直接把数组长度设为 $4n$，因为 $\frac{2^{\left\lceil\log{n}\right\rceil+1}-1}{n}$ 的最大值在 $n=2^{x}+1(x\in N_{+})$ 时取到，此时节点数为 $2^{\left\lceil\log{n}\right\rceil+1}-1=2^{x+2}-1=4n-5$。</p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>仍然以最开始的图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值即可。</p><p>如果要查询的区间为 $[3,5]$，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$，可以通过合并这两个区间的答案来求得这个区间的答案。</p><p>一般地，如果要查询的区间是 $[l,r]$，则可以将其拆成最多为 $O(\log n)$ 个“极大”的区间，合并这些区间即可求出 $[l,r]$ 的答案。</p><h2 id="区间修改与懒惰标记"><a href="#区间修改与懒惰标记" class="headerlink" title="区间修改与懒惰标记"></a>区间修改与懒惰标记</h2><p>如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「懒惰标记」 的东西。</p><p>懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><h2 id="Java线段树模版（4n内存）"><a href="#Java线段树模版（4n内存）" class="headerlink" title="Java线段树模版（4n内存）"></a>Java线段树模版（4n内存）</h2><p>需要注意的是，Java的泛型由于存在擦除，因此在编译后实际上并不能拿到类型信息，所有的类型都是基类，导致不能实现算数运算，在限定<code>Number</code>的情况下，可以使用<code>double</code>值计算结果，需要在外部调用后进行类型转换。</p><p>可以区间加/求和的线段树模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegTreeLazyRangeAdd</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] tree; <span class="comment">// 使用 double 数组来存储树节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] lazy; <span class="comment">// 懒惰标记数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] arr; <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n, root, n4, end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegTreeLazyRangeAdd</span><span class="params">(T[] v)</span> </span>&#123;</span><br><span class="line">        n = v.length;</span><br><span class="line">        n4 = n * <span class="number">4</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        arr = v;</span><br><span class="line">        Arrays.fill(tree, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(lazy, <span class="number">0</span>);</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        build(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="keyword">null</span>; <span class="comment">// Clear reference to the original array</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != cr &amp;&amp; lazy[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            lazy[p * <span class="number">2</span>] += lazy[p]; <span class="comment">// 更新左子树的懒惰标记</span></span><br><span class="line">            lazy[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p]; <span class="comment">// 更新右子树的懒惰标记</span></span><br><span class="line">            tree[p * <span class="number">2</span>] += lazy[p] * (cm - cl + <span class="number">1</span>); <span class="comment">// 更新左子树的值</span></span><br><span class="line">            tree[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p] * (cr - cm); <span class="comment">// 更新右子树的值</span></span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">// 重置当前节点的懒惰标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p]; <span class="comment">// 当前子区间被查询区间完全覆盖</span></span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// 使用 double 类型进行求和</span></span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) sum += rangeSum(l, r, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) sum += rangeSum(l, r, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123; <span class="comment">// 如果当前区间是要更新区间的子区间</span></span><br><span class="line">            lazy[p] += val; <span class="comment">// 懒惰标记增加</span></span><br><span class="line">            tree[p] += (cr - cl + <span class="number">1</span>) * val; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rangeAdd(l, r, val, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) rangeAdd(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p] = arr[s].doubleValue(); <span class="comment">// 使用 double 类型</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, m, p * <span class="number">2</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSum(l, r, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        rangeAdd(l, r, val, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以区间修改/求和的线段树模板:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegTreeLazyRangeSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] tree; <span class="comment">// 存储树节点的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] lazy; <span class="comment">// 懒惰标记数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] ifLazy; <span class="comment">// 懒惰标记的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] arr; <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n, root, n4, end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegTreeLazyRangeSet</span><span class="params">(<span class="keyword">double</span>[] v)</span> </span>&#123;</span><br><span class="line">        n = v.length;</span><br><span class="line">        n4 = n * <span class="number">4</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        ifLazy = <span class="keyword">new</span> <span class="keyword">boolean</span>[n4];</span><br><span class="line">        arr = v;</span><br><span class="line">        Arrays.fill(tree, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(lazy, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(ifLazy, <span class="keyword">false</span>);</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        build(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != cr &amp;&amp; ifLazy[p]) &#123;</span><br><span class="line">            lazy[p * <span class="number">2</span>] = lazy[p];</span><br><span class="line">            ifLazy[p * <span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">            lazy[p * <span class="number">2</span> + <span class="number">1</span>] = lazy[p];</span><br><span class="line">            ifLazy[p * <span class="number">2</span> + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            tree[p * <span class="number">2</span>] = lazy[p] * (cm - cl + <span class="number">1</span>);</span><br><span class="line">            tree[p * <span class="number">2</span> + <span class="number">1</span>] = lazy[p] * (cr - cm);</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">            ifLazy[p] = <span class="keyword">false</span>; <span class="comment">// 重置当前节点的懒惰标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p]; <span class="comment">// 完全覆盖</span></span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// 使用 double 类型进行求和</span></span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) sum += rangeSum(l, r, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) sum += rangeSum(l, r, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            lazy[p] = val; <span class="comment">// 懒惰标记增加</span></span><br><span class="line">            ifLazy[p] = <span class="keyword">true</span>; <span class="comment">// 标记为懒惰</span></span><br><span class="line">            tree[p] = (cr - cl + <span class="number">1</span>) * val; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rangeSet(l, r, val, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) rangeSet(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p] = arr[s]; <span class="comment">// 使用 double 类型</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, m, p * <span class="number">2</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSum(l, r, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        rangeSet(l, r, val, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线段树优化"><a href="#线段树优化" class="headerlink" title="线段树优化"></a>线段树优化</h2><ol><li>在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。</li><li>下放懒惰标记可以写一个专门的函数<code>maintain</code>，降低代码编写难度。</li><li>标记永久化：如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。</li><li>动态开点线段树，即可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这种方式节省的空间有限（约$1/4$）。</li></ol><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>线段树的其他操作包括线段树合并、线段树分裂、线段树二分、线段树优化建图等，遇到相关题目时再做补充。</p><h1 id="例题1-Booking-Concert-Tickets-in-Groups"><a href="#例题1-Booking-Concert-Tickets-in-Groups" class="headerlink" title="例题1: Booking Concert Tickets in Groups"></a>例题1: <a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/description">Booking Concert Tickets in Groups</a></h1><p>将每一排座位看成一个整体，可将两种操作总结如下：</p><ul><li>gather：在前 maxRow 排中，找第一个还能至少有 k 个空座位的排，预定 k 个连续的座位。如果有这样的排，返回编号，以及在预定前有多少非空座位；如果没有这样的排，返回空列表。</li><li>scatter：在前 maxRow 个排中预定总量为 k 的座位。从左到右选择有空座位的排依次占座。如果无法预定总量为 k 的座位，则不执行操作，并返回 false；否则执行操作，并返回 true。</li></ul><p>此时将原问题压缩为一维数组，能这样做的原因是两种操作均不会产生“间隔的空座位”。因此需要的操作如下：</p><ul><li>求出前 maxRow 排中，第一个剩余容量 ≥k，也就是已预定量 ≤ m−k 的排。</li><li>维护每排的已预定量。</li><li>维护前 maxRow 排的已预定量之和，从而判断 scatter 能否实现。</li></ul><p>可以用线段树处理上述操作，线段树维护每个区间（区间即某几排）已预定量的最小值 $\min$ ，以及每个区间的已预定量之和 $sum$。</p><p>对于 gather，从线段树的根节点开始递归：</p><ul><li>如果当前区间 $\min &gt; m-k$, 则无法预定 $k$ 个连续座位，返回 0 。</li><li>如果当前区间长度为 1 ，返回区间端点。</li><li>如果左半区间 $\min \leq m-k$, 则答案在左半区间中, 递归左半区间。</li><li>否则如果 maxRow 在右半区间内, 递归右半区间。</li><li>否则返回 -1 ，表示没有符合条件的排。</li></ul><p>上述过程叫做<strong>线段树二分</strong>，</p><p>对于 scatter，如果区间 $[0$, maxRow] 的已预定量之和大于 $m \cdot(\operatorname{maxRow}+1)-k$ ，则无法执行操作。否则可以执行操作。从第一个没有装满，也就是已预定量 $\leq m-1$ 的排开始预定，这也可以用线段树二分求出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookMyShow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] min;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookMyShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(n)); <span class="comment">// 比 4n 更小</span></span><br><span class="line">        min = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gather(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow) &#123;</span><br><span class="line">        <span class="comment">// 找第一个能预定 k 个座位的row</span></span><br><span class="line">        <span class="keyword">int</span> r = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - k);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123; <span class="comment">// 没有这样的row</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, r);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, k); <span class="comment">// 预定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scatter</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0,maxRow] 的已预定量之和</span></span><br><span class="line">        <span class="keyword">long</span> s = querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, maxRow);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; (<span class="keyword">long</span>) m * (maxRow + <span class="number">1</span>) - k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 空座位不足</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个没有定满的row开始</span></span><br><span class="line">        <span class="keyword">int</span> i = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = Math.min(m - (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i), k);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, left); <span class="comment">// 预定</span></span><br><span class="line">            k -= left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把下标 i 上的元素值增加 val</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            min[o] += val;</span><br><span class="line">            sum[o] += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">            update(o * <span class="number">2</span>, l, m, i, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, i, val);</span><br><span class="line">        &#125;</span><br><span class="line">        min[o] = Math.min(min[o * <span class="number">2</span>], min[o * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        sum[o] = sum[o * <span class="number">2</span>] + sum[o * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [L,R] 内的元素和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[o];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= m) &#123;</span><br><span class="line">            res = querySum(o * <span class="number">2</span>, l, m, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            res += querySum(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [0,R] 中 &lt;= val 的最靠左的位置，不存在时返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> R, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min[o] &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 整个区间的元素值都大于 val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (min[o * <span class="number">2</span>] &lt;= val) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span>, l, m, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/ds/seg/#%E5%AE%9E%E7%8E%B0">https://oi-wiki.org/ds/seg/#%E5%AE%9E%E7%8E%B0</a><br>[2] <a href="https://en.wikipedia.org/wiki/Segment_tree">https://en.wikipedia.org/wiki/Segment_tree</a><br>[3] <a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28">https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;线段树是算法竞赛中常用的用来维护“区间信息”的数据结构。线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="http://silencezheng.top/2024/10/01/article142/"/>
    <id>http://silencezheng.top/2024/10/01/article142/</id>
    <published>2024-10-01T13:20:17.000Z</published>
    <updated>2024-10-01T13:24:40.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用于生成全局唯一ID（分布式ID）的算法有多种，雪花算法（SnowFlake）是其中一个经典的常用算法。</p><span id="more"></span><h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><p>分布式ID的特点：</p><ul><li><strong>全局唯一性</strong>：不能出现有重复的ID标识，这是基本要求。</li><li><strong>递增性</strong>：确保生成ID对于用户或业务是递增的。</li><li><strong>高可用性</strong>：确保任何时候都能生成正确的ID。</li><li><strong>高性能性</strong>：在高并发的环境下依然表现良好。</li></ul><p>分布式ID的应用场景包括但不限于：</p><ul><li><strong>分布式数据库</strong>：生成唯一主键。</li><li><strong>消息队列</strong>：标识消息的唯一性。</li><li><strong>用户注册</strong>：为新用户生成唯一标识。</li></ul><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p>SnowFlake最初是Twitter公司采用的一种算法，目的是在分布式系统中产生<strong>全局唯一且递增</strong>的ID。每一个雪花算法产生的ID都是一个的64bit的long类型的唯一ID。</p><h2 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h2><p><code>0 -- 41位时间戳 -- 10位机器ID -- 12位序列号</code></p><ol><li>最高1位是符号位，固定为0，表示id是正整数；</li><li>接下来41位存储毫秒级时间戳，表示从一个特定时间点（通常是 Unix 纪元时间）开始的毫秒数。这允许生成的 ID 持续大约 69 年，即 $2^{41} / (1000 <em> 60 </em> 60 * 24 \times 365) = 69$。</li><li>再接下10位存储机器码，包括高5位的<code>datacenterId</code>和低5位的<code>workerId</code>。最多可以部署$2^{10}=1024$台机器。</li><li>最后12位存储序列号，即在同一毫秒内生成的序列号，允许每个节点在同一毫秒内生成最多 4096 个 ID（$2^{12}$）。</li></ol><p>基于组成可以计算雪花算法在同一毫秒内最多可以生成的全局唯一ID数量为$1024 \times 4096 = 4194304$个。</p><h2 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h2><p>生成一个雪花 ID 的过程如下：</p><ol><li><strong>获取当前时间戳</strong>：计算当前的毫秒时间戳。</li><li><strong>检查时间戳是否回拨</strong>：如果当前时间小于上次生成 ID 的时间，说明时间回拨，可能会抛出异常或等待。</li><li><strong>生成序列号</strong>：如果当前时间与上次生成 ID 的时间相同且还有序列号可用，则序列号加1；否则阻塞至下一毫秒。</li><li><strong>拼接 ID</strong>：将时间戳、机器 ID 和序列号拼接成一个 64 位的整数。</li></ol><p>Java实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeIdWorker</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间截 (2015-01-01)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大数据标识id，结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列在id中占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID向左移12位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id向左移17位(12+5)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间截向左移22位(5+5+12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作机器ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒内序列(0~4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId     工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowflakeIdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">// 毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">// 移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idWorker.nextId();</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><ul><li>优点：<ul><li><strong>高并发</strong>：可以在分布式环境下高效生成唯一ID，支持高并发。</li><li><strong>有序性</strong>：生成的ID基于时间戳，具有一定的有序性，适合用于数据库的主键。</li><li><strong>低延迟</strong>：生成ID的速度快，通常在毫秒级别。</li></ul></li><li>缺点<ul><li><strong>时间回拨问题</strong>：如果服务器时间发生回拨，可能导致生成重复的ID，需要处理。</li><li><strong>机器 ID 管理</strong>：需要确保机器 ID 的唯一性，管理较为复杂。</li><li><strong>存储问题</strong>：ID 的长度较长（64 位），可能在某些系统中造成存储开销。</li></ul></li></ul><h2 id="部分开源的雪花算法实现"><a href="#部分开源的雪花算法实现" class="headerlink" title="部分开源的雪花算法实现"></a>部分开源的雪花算法实现</h2><ol><li>HuTool</li><li>百度UidGenerator</li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团Leaf</a></li></ol><p>各家对于时钟回拨都有不同的处理，以HuTool为例：</p><ul><li>如果时钟回拨不超过2秒，则会将现在的时间点置为上个产生id的时间点（超过2s就抛出异常了）；</li><li>如果上个时间点产生的id没有达到4095（超过4095就抛出异常了），即使产生了时钟回拨，也可以继续生成id。</li><li>如果出现时钟回拨，假设是5s，那么如果这5s内没有id需要生成，那么时钟回拨没有任何影响。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010">https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/85837641">https://zhuanlan.zhihu.com/p/85837641</a><br>[3] <a href="https://blog.csdn.net/weixin_43024834/article/details/135039159">https://blog.csdn.net/weixin_43024834/article/details/135039159</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用于生成全局唯一ID（分布式ID）的算法有多种，雪花算法（SnowFlake）是其中一个经典的常用算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="分布式系统" scheme="http://silencezheng.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法</title>
    <link href="http://silencezheng.top/2024/10/01/article141/"/>
    <id>http://silencezheng.top/2024/10/01/article141/</id>
    <published>2024-10-01T11:48:10.000Z</published>
    <updated>2024-10-01T11:52:43.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看分片算法的时候了解到了一致性哈希，梳理一下相关内容。</p><p>其主要的使用场景包括：分布式存储（缓存、DB、文件）、负载均衡、分布式计算等。<br><span id="more"></span></p><h1 id="简单哈希函数的“扩容困境”"><a href="#简单哈希函数的“扩容困境”" class="headerlink" title="简单哈希函数的“扩容困境”"></a>简单哈希函数的“扩容困境”</h1><p>对于简单哈希函数<code>m = hash(o) mod n</code>，其中，<code>o</code>为对象名称，<code>n</code>为机器的数量，<code>m</code>为机器编号。当<code>n</code>增大时，所有<code>o</code>对应的<code>m</code>都可能发生变化，这些变化意味着将对象<code>o</code>的数据迁移到新的机器<code>m</code>。</p><p>假设我们有以下对象和机器：</p><ul><li>对象：<code>o1</code>, <code>o2</code>, <code>o3</code>, <code>o4</code></li><li>初始机器数量：<code>n = 3</code></li></ul><p>假设对每个对象应用哈希函数得到的哈希值如下：</p><ul><li><code>hash(o1) = 10</code></li><li><code>hash(o2) = 15</code></li><li><code>hash(o3) = 20</code></li><li><code>hash(o4) = 25</code></li></ul><p>可计算出初始数据分布如下：</p><ul><li>机器 0：<code>o2</code></li><li>机器 1：<code>o1</code>, <code>o4</code></li><li>机器 2：<code>o3</code></li></ul><p>现在，我们将机器数量增加到 <code>n = 5</code>，使用相同的哈希值，重新计算每个对象的新机器编号，得到的数据分布如下：</p><ul><li>机器 0：<code>o1</code>, <code>o2</code>, <code>o3</code>, <code>o4</code></li><li>机器 1：无</li><li>机器 2：无</li><li>机器 3：无</li><li>机器 4：无</li></ul><p>可以发现，要迁移的数据将十分多。</p><h1 id="一致性哈希（Consistent-Hash）"><a href="#一致性哈希（Consistent-Hash）" class="headerlink" title="一致性哈希（Consistent Hash）"></a>一致性哈希（Consistent Hash）</h1><p>一致性哈希(Consistent Hash)算法是1997年提出，是一种特殊的哈希算法，目的是解决分布式系统的数据分区问题：当分布式集群移除或者添加一个服务器时，必须尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。</p><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>一致性哈希算法本质上也是一种取模算法。只不过是对固定值<code>2^32</code>取模，这就使得一致性算法具备良好的单调性，即不管集群中有多少个节点，只要key值固定，那所请求的服务器节点也同样是固定的。</p><p>其算法的工作原理如下：</p><ol><li>一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为<code>[0, 2^32 - 1]</code>；</li><li>计算各服务器节点的哈希值，并映射到哈希环上；</li><li>将服务发来的数据请求使用哈希算法算出对应的哈希值；</li><li>将计算的哈希值映射到哈希环上，同时沿圆环顺时针方向查找，遇到的第一台服务器就是所对应的处理请求服务器。</li><li>当增加或者删除一台服务器时，受影响的数据仅仅是新添加或删除的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。</li></ol><h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><p>算法原理其实很容易理解，但是这里面涉及到一些细节问题：</p><ol><li>数据请求如何寻找目标服务器？<ul><li>计算请求的哈希值后进行顺序查找，查找到哈希环末尾时跳回第一个元素继续顺序查找。</li></ul></li><li>在分布式存储的场景下扩容时，原定向到B节点的部分数据需要迁移到新节点C，如何对这部分存量数据进行迁移？<ol><li>从C节点逆序定位到上一个节点B；</li><li>对B中全部数据进行重哈希，识别出需迁移数据的范围；</li><li>将需迁移数据复制到C节点中，确认一致；</li><li>删除B节点上已迁移的数据。</li></ol></li><li>在分布式存储的场景下缩容时，原定向到B节点的所有数据需要迁移到新节点C，如何对这部分存量数据进行迁移？<ul><li>与扩容相似，先复制再删除，只是不需要确定数据范围，因为被删除节点的所有数据都需要迁移。</li></ul></li><li>在负载均衡场景下发生节点宕机时，一致性哈希有什么好处？<ul><li>仅宕机节点的流量会去到下一个节点，其余节点的流量不受影响。</li></ul></li><li>在分布式存储场景下发生节点故障怎么办？<ol><li>采用数据副本机制，在多个节点之间存储数据的副本，确保在节点失效时可以通过其他副本恢复数据。</li><li>实现健康检查机制，定期检测节点的状态，并在发现故障时快速重新分配数据。</li></ol></li></ol><h2 id="数据倾斜与虚拟节点"><a href="#数据倾斜与虚拟节点" class="headerlink" title="数据倾斜与虚拟节点"></a>数据倾斜与虚拟节点</h2><p><strong>数据倾斜</strong>（Data Skew）是指在分布式系统或大数据处理场景中，数据在某些节点或分片之间分布不均匀的现象。这种不均匀性导致某些节点或处理单元负载过重，而其他节点则相对空闲，从而影响系统的性能和响应时间。</p><p>有两种情况可能导致数据倾斜：</p><ol><li>当节点数量较少时，数据可能不均匀地分布在哈希环上，导致某些节点负载过重，而其他节点相对空闲。</li><li>如果节点在哈希环上的位置不够分散（用的哈希函数不够散列），可能导致某些节点的负载过高。</li></ol><p>可以通过<strong>虚拟节点</strong>的机制来解决数据倾斜问题。虚拟节点机制对每一个物理服务节点映射多个虚拟节点，将这些虚拟节点计算哈希值并映射到哈希环上，当请求找到某个虚拟节点后，将被重新映射到具体的物理节点。虚拟节点越多，哈希环上的节点就越多，数据分布就越均匀，从而避免了数据倾斜的问题。</p><p>假设一台服务器有 n 个虚拟节点。那么哈希计算时，可以使用<code>IP + 端口 + 编号</code>的形式进行哈希值计算。其中的编号就是 0 到 n 的数字。由于<code>IP + 端口</code>是一样的，所以这 n 个节点都是指向的同一台机器。</p><h2 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h2><p>数据节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODE_NO_PER_NODE = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; virtualNodeHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(VIRTUAL_NODE_NO_PER_NODE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(ip);</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        initVirtualNodes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVirtualNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String virtualNodeKey;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= VIRTUAL_NODE_NO_PER_NODE; i++) &#123;</span><br><span class="line">            virtualNodeKey = ip + <span class="string">&quot;#&quot;</span> + i;</span><br><span class="line">            virtualNodeHashes.add(HashUtils.hashcode(virtualNodeKey));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCacheItem</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        cacheMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCacheItem</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCacheItem</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        cacheMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getVirtualNodeHashes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeHashes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一致性哈希：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Integer, Node&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加节点</span></span><br><span class="line"><span class="comment">     * 每增加一个节点，就会在闭环上增加给定虚拟节点</span></span><br><span class="line"><span class="comment">     * 例如虚拟节点数是2，则每调用此方法一次，增加两个虚拟节点，这两个节点指向同一Node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(ip);</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(ip);</span><br><span class="line">        nodeList.add(node);</span><br><span class="line">        <span class="keyword">for</span> (Integer virtualNodeHash : node.getVirtualNodeHashes()) &#123;</span><br><span class="line">            hashRing.put(virtualNodeHash, node);</span><br><span class="line">            System.out.println(<span class="string">&quot;虚拟节点[&quot;</span> + node + <span class="string">&quot;] hash:&quot;</span> + virtualNodeHash + <span class="string">&quot;，被添加&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        nodeList.remove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存数据</span></span><br><span class="line"><span class="comment">     * 先找到对应的虚拟节点，然后映射到物理节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node node = findMatchNode(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到节点:&quot;</span> + node.getIp());</span><br><span class="line">        <span class="keyword">return</span> node.getCacheItem(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * 先找到hash环上的节点，然后在对应的节点上添加数据缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        Node node = findMatchNode(key);</span><br><span class="line"></span><br><span class="line">        node.addCacheItem(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        findMatchNode(key).removeCacheItem(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获得一个最近的顺时针节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 为给定键取Hash，取得顺时针方向上最近的一个虚拟节点对应的实际节点</span></span><br><span class="line"><span class="comment">     *      * <span class="doctag">@return</span> 节点对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findMatchNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Node&gt; entry = hashRing.ceilingEntry(HashUtils.hashcode(key));</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry = hashRing.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哈希函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FNV1_32_HASH</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     *         object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hashcode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        String str = obj.toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;hash computer:&quot; + hash);</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NODE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_COUNT = <span class="number">100</span> * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConsistentHash consistentHash = <span class="keyword">new</span> ConsistentHash();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODE_SIZE; i++) &#123;</span><br><span class="line">            String ip = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;10.2.1.&quot;</span>).append(i)</span><br><span class="line">                    .toString();</span><br><span class="line">            consistentHash.addNode(ip);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成需要缓存的数据;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STRING_COUNT; i++) &#123;</span><br><span class="line">            sList.add(RandomStringUtils.randomAlphanumeric(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据放入到缓存中。</span></span><br><span class="line">        <span class="keyword">for</span> (String s : sList) &#123;</span><br><span class="line">            consistentHash.put(s, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = RandomUtils.nextInt(<span class="number">0</span>, STRING_COUNT);</span><br><span class="line">            String key = sList.get(index);</span><br><span class="line">            String cache = (String) consistentHash.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;Random:&quot;</span>+index+<span class="string">&quot;,key:&quot;</span> + key + <span class="string">&quot;,consistentHash get value:&quot;</span> + cache +<span class="string">&quot;,value is:&quot;</span> + key.equals(cache));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出节点及数据分布情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : consistentHash.nodeList)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一个数据节点</span></span><br><span class="line">        consistentHash.addNode(<span class="string">&quot;10.2.1.110&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = RandomUtils.nextInt(<span class="number">0</span>, STRING_COUNT);</span><br><span class="line">            String key = sList.get(index);</span><br><span class="line">            String cache = (String) consistentHash.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;Random:&quot;</span>+index+<span class="string">&quot;,key:&quot;</span> + key + <span class="string">&quot;,consistentHash get value:&quot;</span> + cache +<span class="string">&quot;,value is:&quot;</span> + key.equals(cache));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出节点及数据分布情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : consistentHash.nodeList)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://developer.aliyun.com/article/1082388">https://developer.aliyun.com/article/1082388</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/129049724">https://zhuanlan.zhihu.com/p/129049724</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/636719716">https://zhuanlan.zhihu.com/p/636719716</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/53711866">https://zhuanlan.zhihu.com/p/53711866</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>下一篇：Chord协议，第一代分布式哈希表（DHT）。</p><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看分片算法的时候了解到了一致性哈希，梳理一下相关内容。&lt;/p&gt;
&lt;p&gt;其主要的使用场景包括：分布式存储（缓存、DB、文件）、负载均衡、分布式计算等。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="分布式系统" scheme="http://silencezheng.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP13</title>
    <link href="http://silencezheng.top/2024/09/23/article140/"/>
    <id>http://silencezheng.top/2024/09/23/article140/</id>
    <published>2024-09-22T17:00:46.000Z</published>
    <updated>2024-11-16T14:35:10.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周的bus题挺有意思，学习了。</p><p>本周主题：动态规划、组合数学、BFS、优化建图</p><p>题目：</p><ul><li>240917每日一题—<a href="https://leetcode.cn/problems/bus-routes/description">Bus Routes</a></li><li>240920每日一题—<a href="https://leetcode.cn/problems/count-special-integers/description">Count Special Integers</a></li></ul><span id="more"></span><h1 id="Bus-Routes"><a href="#Bus-Routes" class="headerlink" title="Bus Routes"></a>Bus Routes</h1><blockquote><p>Bus Routes</p><p>You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.</p><p>For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … forever.<br>You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.</p><p>Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.</p></blockquote><p>这道题和地图应用中的公交路线计算非常贴合，实用价值很高。题意就是给了若干公交线路和起点终点，求最小换乘策略。</p><h2 id="优化建图-BFS"><a href="#优化建图-BFS" class="headerlink" title="优化建图+BFS"></a>优化建图+BFS</h2><p>由于求解的目标是最少乘坐的公交车数量，对于同一辆公交车，乘客可以在其路线中的任意车站间无代价地移动，于是我们可以把公交路线当作点。如果两条公交路线有相同车站，则可以在这两条路线间换乘公交车，那么这两条公交路线之间可视作有一条长度为$1$的边。这样建出的图包含的点数即为公交路线的数量，记作$n$。</p><p>完成了建图后，我们需要先明确新的图的起点和终点，然后使用广度优先搜索，计算出的起点和终点的最短路径，从而得到最少换乘次数。</p><p>注意到原本的起点车站和终点车站可能同时位于多条公交路线上，因此在新图上可能有多个起点和终点。对于这种情况，我们初始可以同时入队多个点，并在广度优先搜索结束后检查到各个终点的最短路径，取其最小值才是最少换乘次数。</p><p>实际建图时, 我们有以下两种方案：</p><ul><li>方案一：我们直接枚举左右两端点，检查两点对应的两公交路线是否有公共车站。利用哈希表，我们可以将单次比较的时间复杂度优化到均摊 $O(n)$ 。</li><li>方案二：我们遍历所有公交路线，记录每一个车站属于哪些公交路线。然后我们遍历每一个车站，如果有多条公交路线经过该点，则在这些公交路线之间连边。</li></ul><p>本题中我们采用方案二，据此还可以直接得到起点和终点在新图中对应的点。实际代码中，我们使用哈希映射来实时维护「车站所属公交路线列表」。假设当前枚举到公交路线 $i$ 中的车站 $site$, 此时哈希映射中已记录若干条公交路线经过车站 $site$, 我们只需要让点 $i$ 与这些点公交路线对应的点相连即可。完成了连线后, 我们再将公交路线 $i$ 加入到「车站 $site$ 所属公交路线列表」中。</p><p>特别地, 起点和终点相同时, 我们可以直接返回 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = routes.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] edge = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">// key:车站, value:班次列表</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; rec = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> site : routes[i]) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = rec.getOrDefault(site, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : list) &#123;</span><br><span class="line">                    edge[i][j] = edge[j][i] = <span class="keyword">true</span>; <span class="comment">// 班次连线</span></span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                rec.put(site, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 记录从src到tgt的所有班次换乘数量</span></span><br><span class="line">        Arrays.fill(dis, -<span class="number">1</span>);</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bus : rec.getOrDefault(source, <span class="keyword">new</span> ArrayList&lt;Integer&gt;())) &#123;</span><br><span class="line">            dis[bus] = <span class="number">1</span>; <span class="comment">// 起点班次数量为1</span></span><br><span class="line">            que.offer(bus); <span class="comment">// 起点班次入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 广度优先搜索，所有班次每次仅向前探测一次，保证终点第一次被搜索到时路径最短</span></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.poll(); <span class="comment">// 队头出队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[x][y] &amp;&amp; dis[y] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(y); <span class="comment">// 加入队尾</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从能到终点的班次中筛选出最小距离</span></span><br><span class="line">        <span class="keyword">int</span> ret = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bus : rec.getOrDefault(target, <span class="keyword">new</span> ArrayList&lt;Integer&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[bus] != -<span class="number">1</span>) &#123;</span><br><span class="line">                ret = Math.min(ret, dis[bus]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret == Integer.MAX_VALUE ? -<span class="number">1</span> : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Count-Special-Integers"><a href="#Count-Special-Integers" class="headerlink" title="Count Special Integers"></a>Count Special Integers</h1><blockquote><p>Count Special Integers</p><p>We call a positive integer special if all of its digits are distinct.</p><p>Given a positive integer n, return the number of special integers that belong to the interval [1, n].</p></blockquote><p>到手首先考虑记忆化+暴力，用两个数组分别记录当前数字和每个数字的频次来避免重复计算，逐步从1增加到n计算，能过百分之八十，剩下超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 存放从1到10位的数字</span></span><br><span class="line">    <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 计算arr是否有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> waterLevel = <span class="number">0</span>; <span class="comment">// 表示当前到达过的最高位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">0</span>]++;</span><br><span class="line">        check[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            recur(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:check)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    valid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[p]&lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(waterLevel&gt;=p) check[arr[p]]--;</span><br><span class="line">            <span class="keyword">else</span> waterLevel++;</span><br><span class="line">            arr[p]++;</span><br><span class="line">            check[arr[p]]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[p] = <span class="number">0</span>;</span><br><span class="line">            check[<span class="number">0</span>]++;</span><br><span class="line">            check[<span class="number">9</span>]--;</span><br><span class="line">            recur(p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划-组合数学"><a href="#动态规划-组合数学" class="headerlink" title="动态规划+组合数学"></a>动态规划+组合数学</h2><p>另一种思路是通过组合数学拼出所有的特殊整数，这样就可以避免遍历所有可能的整数。将小于等于$n$的整数分为两种情况，记$n$十进制表示下位数为$k$：</p><ol><li>位数小于$k$的特殊整数。</li><li>位数等于$k$的特殊整数。</li></ol><p>对于位数小于 $k$ 的情况，分别计算位数为 1 到 $k-1$ 的情况下特殊整数的数量。考虑位数为 $k_0\left(k_0&lt;k\right)$的情况。因为 $k_0&lt;k$ ，所以任意放置数位上的数字，都能满足小于等于 $n$ 的条件。只需保证每一数位都互不相同。用组合数学的思路求解特殊整数的数量，从最高位开始考虑，可以有 9 种选择（除 0 外的任何整数），次高位也有 9 种选择（除最高位外的任何整数），接下来的数位的选择则依次减少 1 。把这些选择的可能性全部相乘则是位数为 $k_0$ 的特殊整数的数量。</p><p>接下来考虑位数等于 $k$ 的特殊整数。相同位数的数字比较大小，是从最高位开始比较，若不同，则最高位大的数字大；若相同，则比较次高位。次高位的比较原则和最高位一样。因此，我们在计算小于等于 $n$ 的特殊整数时，也需要按照这个原则。函数 $d p(mask, prefixSmaller)$ 用来计算以某些数字组合为前缀的特殊整数的数量。整数 mask 即表示了前叕中使用过的数字，二进制表示下，从最低位开始，第 $i$ 位如果为 1 则表示数字 $i$ 已经被使用过，在接下来的后缀中不能使用。布尔值 prefixSmaller 表示当前的前缀是否小于 $n$ 的前缀，如果是，则接下来的数字可以任意选择。如果不是，即当前的前缀等于 $n$ 的前缀，则接下来的数字只能小于或者等于 $n$ 同数位的数字。最后调用 $d p(0, f a l s e)$ 则为位数等于 $k$ 的特殊整数的数量。</p><p>最后把这两部分相加即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String nStr = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prod = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStr.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res += prod;</span><br><span class="line">            prod *= <span class="number">9</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dp(<span class="number">0</span>, <span class="keyword">false</span>, nStr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">boolean</span> prefixSmaller, String nStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.bitCount(mask) == nStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> key = mask * <span class="number">2</span> + (prefixSmaller ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// 用参数组合生成key用于记忆化</span></span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(key)) &#123; <span class="comment">// 如果还没计算过，则计算当前参数下的组合数量</span></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> lowerBound = mask == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 初始最高位时下界为1</span></span><br><span class="line">            <span class="keyword">int</span> upperBound = prefixSmaller ? <span class="number">9</span> : nStr.charAt(Integer.bitCount(mask)) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lowerBound; i &lt;= upperBound; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((mask &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 数字i未被使用过</span></span><br><span class="line">                    <span class="comment">// 把i加入mask列表表示使用过</span></span><br><span class="line">                    res += dp(mask | (<span class="number">1</span> &lt;&lt; i), prefixSmaller || i &lt; upperBound, nStr); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo.put(key, res); <span class="comment">// 在mask先进a后进b的情况下，后续mask先进b后进a的运算可以省略。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解记录"><a href="#题解记录" class="headerlink" title="题解记录"></a>题解记录</h1><p>还有一题有些意思不过写出来了，贴一下<a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/solutions/2921670/kuai-man-zhi-zhen-yi-ci-bian-li-ji-bai-9-bps8/">我的题解</a>。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/count-special-integers/solutions/2916434/tong-ji-te-shu-zheng-shu-by-leetcode-sol-7qai/?envType=daily-question&amp;envId=2024-09-20">https://leetcode.cn/problems/count-special-integers/solutions/2916434/tong-ji-te-shu-zheng-shu-by-leetcode-sol-7qai/?envType=daily-question&amp;envId=2024-09-20</a><br>[2] <a href="https://leetcode.cn/problems/bus-routes/solutions/847860/gong-jiao-lu-xian-by-leetcode-solution-yifz/?envType=daily-question&amp;envId=2024-09-17">https://leetcode.cn/problems/bus-routes/solutions/847860/gong-jiao-lu-xian-by-leetcode-solution-yifz/?envType=daily-question&amp;envId=2024-09-17</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周的bus题挺有意思，学习了。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、组合数学、BFS、优化建图&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240917每日一题—&lt;a href=&quot;https://leetcode.cn/problems/bus-routes/description&quot;&gt;Bus Routes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240920每日一题—&lt;a href=&quot;https://leetcode.cn/problems/count-special-integers/description&quot;&gt;Count Special Integers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP12</title>
    <link href="http://silencezheng.top/2024/09/15/article139/"/>
    <id>http://silencezheng.top/2024/09/15/article139/</id>
    <published>2024-09-15T15:32:15.000Z</published>
    <updated>2024-10-27T15:28:49.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周忙废了…挑战一天写完一周的题。</p><p>本周主题：双指针、枚举、单调队列</p><p>题目：</p><ul><li>240910每日一题—<a href="https://leetcode.cn/problems/count-increasing-quadruplets/description">Count Increasing Quadruplets</a></li><li>240912每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description">Find the Maximum Number of Marked Indices</a></li><li>240913每日一题—<a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description">Maximum Number of Robots Within Budget</a></li></ul><span id="more"></span><h1 id="Maximum-Number-of-Robots-Within-Budget"><a href="#Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="Maximum Number of Robots Within Budget"></a>Maximum Number of Robots Within Budget</h1><blockquote><p>Maximum Number of Robots Within Budget</p><p>You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.</p><p>The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.</p><p>Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.</p></blockquote><p>首先注意题目要求启动的机器人序列连续，则构成一个窗口，窗口内计算cost要小于budget且窗口尽量大。每次窗口移动可能会影响两个点进而影响窗口cost，一个是最大充电时间，一个是总体启动时间消耗。则这道题可以看为<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的变体题目。</p><p>因此先来把<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的<strong>单调队列</strong>做法搞懂。</p><p>PS：这道题我之前也写了一个<a href="https://leetcode.cn/problems/sliding-window-maximum/solutions/2795111/treemap-by-silencezheng66-kb1i/">TreeMap的题解</a>，比较复杂，正好这次学一下单调队列的解法。</p><p><strong>「单调队列」即满足单调性的双端队列</strong>，双端队列左侧为队首，右侧为队尾。</p><h2 id="前置题目：Sliding-Window-Maximum"><a href="#前置题目：Sliding-Window-Maximum" class="headerlink" title="前置题目：Sliding Window Maximum"></a>前置题目：Sliding Window Maximum</h2><blockquote><p>Sliding Window Maximum</p><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p><p>Return the max sliding window.</p></blockquote><p>题目比较容易理解，就是取一个定长的滑窗在数组上滑出若干个最值，难点就是用尽量少的时间计算每个窗口中的最值。</p><p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 $i$ 和 $j$, 其中 $i$ 在 $j$的左侧 $(i&lt;j)$ ，并且 $i$ 对应的元素不大于 $j$ 对应的元素（nums $[i] \leq n u m s[j]$） ，则当滑动窗口向右移动时，只要 $i$ 还在窗口中，那么 $j$ 一定也还在窗口中，这是 $i$ 在 $j$ 的左侧所保证的。因此, 由于 nums [j] 的存在, nums [i] 一定不会是滑动窗口中的最大值了, 我们可以将 nums [i]永久地移除。</p><p>因此我们可以<strong>使用一个队列存储所有还没有被移除的下标</strong>。在队列中, 这些<strong>下标按照从小到大的顺序被存储, 并且它们在数组 nums 中对应的值是严格单调递减的</strong>。因为如果队列中有两个相邻的下标, 它们对应的值相等或者递增, 那么令前者为 $i$, 后者为 $j$, 就对应了上面所说的情况, 即 $n u m s[i]$ 会被移除，这就产生了矛盾。</p><p>当滑动窗口向右移动时, 我们需要把一个新的元素放入队列中。为了保持队列的性质, 我们会不断地将新的元素与队尾的元素相比较, 如果前者大于等于后者, 那么队尾的元素就可以被永久地移除, 我们将其弹出队列。我们需要不断地进行此项操作, 直到队列为空或者新的元素小于队尾的元素。</p><p>由于队列中下标对应的元素是严格单调递减的, 因此此时队首下标对应的元素就是滑动窗口中的最大值。同时，隨着窗口向右移动，队首元素可能会不在窗口中，我们还需要不断从队首弹出元素, 直到队首元素在窗口中为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先填充第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[deque.peekFirst()]; <span class="comment">// 队首为窗口最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐元素移动窗口</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 抛弃不在窗口中的最值</span></span><br><span class="line">            <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出答案，注意peek只检查并不丢弃</span></span><br><span class="line">            ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解（单调队列）：Maximum-Number-of-Robots-Within-Budget"><a href="#题解（单调队列）：Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="题解（单调队列）：Maximum Number of Robots Within Budget"></a>题解（单调队列）：Maximum Number of Robots Within Budget</h2><p>本题相较于<code>Sliding Window Maximum</code>有几点需要注意：</p><ol><li>窗口大小不固定，队首弹出与budget相关而与窗口大小无关；</li><li><code>chargeTimes</code>的最值处理逻辑相同；</li><li>求解需要知道窗口左侧的位置，需要维护窗口左侧下标。</li></ol><p>队列中存储的还是<code>chargeTimes</code>的下标，因为下标与<code>runningCosts</code>一一对应，则计算总消耗时共用计算即可，本质上可以用单调队列还是因为两点，一是连续窗口，二是最值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumRobots</span><span class="params">(<span class="keyword">int</span>[] chargeTimes, <span class="keyword">int</span>[] runningCosts, <span class="keyword">long</span> budget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 维护左侧下标</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// 用于与预算比较</span></span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; chargeTimes.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 1. 入队，与前置题目逻辑相同</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[right] &gt;= chargeTimes[q.peekLast()]) &#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.addLast(right);</span><br><span class="line">            sum += runningCosts[right]; <span class="comment">// 累计cost</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 窗口左端右移，通过预算与消耗比较判断</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[q.peekFirst()] + (right - left + <span class="number">1</span>) * sum &gt; budget) &#123;</span><br><span class="line">                <span class="comment">// 出队逻辑，在左移过程中遇到最值要同步出队</span></span><br><span class="line">                <span class="keyword">if</span> (q.peekFirst() == left) &#123;</span><br><span class="line">                    q.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= runningCosts[left++]; <span class="comment">// 减去移出元素cost</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 更新答案</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Number-of-Marked-Indices"><a href="#Find-the-Maximum-Number-of-Marked-Indices" class="headerlink" title="Find the Maximum Number of Marked Indices"></a>Find the Maximum Number of Marked Indices</h1><blockquote><p>Find the Maximum Number of Marked Indices</p><p>You are given a 0-indexed integer array nums.</p><p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p><p>Pick two different unmarked indices i and j such that 2 * nums[i] &lt;= nums[j], then mark i and j.<br>Return the maximum possible number of marked indices in nums using the above operation any number of times.</p></blockquote><p>这题我一开始的思路是按值排序后从大到小匹配，但这样贪心还是不能获得最佳答案，需要从如何获得最优解的角度考虑。当可获得最优解时，长度为 $n$ 的数组最多只会产生 $\left\lfloor\frac{n}{2}\right\rfloor$ 对匹配, 因此对数组从小到大排序以后, 我们将数组一分为二, 左侧元素只会与右侧元素匹配。</p><p>这样操作就可以解决直接排序匹配中找不到最优配对的问题，对于右侧的一个元素，其最优配对的符合条件的元素既不是比他次大的元素，也不是全局最小的元素，而是划分成两半后左侧的符合条件的最大元素。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>具体的, 我们令 $m=\left\lfloor\frac{n}{2}\right\rfloor$, 尝试将下标在 $[0, m-1]$ 范围内的元素 $n u m s[i]$ 与下标在 $[m, n-1]$ 范围内的元素 $n u m s[j]$ 进行匹配。我们从小到大枚举 $i$ ，然后找到最小的 $j$ 使其满足 $2 \times$ $n u m s[i] \leq n u m s[j]$ 。那些末满足条件而被跳过的 nums $[j]$ 将被忽略。持续这一过程,直到 $i=m$ 或 $j=n$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumOfMarkedIndices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m; i &lt; m &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="number">2</span> * nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Count-Increasing-Quadruplets-HARD"><a href="#Count-Increasing-Quadruplets-HARD" class="headerlink" title="Count Increasing Quadruplets HARD"></a>Count Increasing Quadruplets <font color=#FF4500 size=4 face='黑体'>HARD</font></h1><blockquote><p>Count Increasing Quadruplets</p><p>Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.</p><p>A quadruplet (i, j, k, l) is increasing if:</p><ul><li>0 &lt;= i &lt; j &lt; k &lt; l &lt; n, and</li><li>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l].</li></ul></blockquote><p>这道题直接暴力能解决一半，剩下一半学习成本有点高了，直接看灵神题解即可，现在没时间学了，感觉意义不大。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12">https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12</a><br>[2] <a href="https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10">https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10</a><br>[3] <a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13">https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周忙废了…挑战一天写完一周的题。&lt;/p&gt;
&lt;p&gt;本周主题：双指针、枚举、单调队列&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240910每日一题—&lt;a href=&quot;https://leetcode.cn/problems/count-increasing-quadruplets/description&quot;&gt;Count Increasing Quadruplets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240912每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description&quot;&gt;Find the Maximum Number of Marked Indices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240913每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description&quot;&gt;Maximum Number of Robots Within Budget&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP11</title>
    <link href="http://silencezheng.top/2024/09/08/article138/"/>
    <id>http://silencezheng.top/2024/09/08/article138/</id>
    <published>2024-09-08T14:31:23.000Z</published>
    <updated>2024-10-27T15:28:52.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周感觉还可以吧，有两道周赛做过的题。</p><p>一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。</p><p>本周主题：滑动窗口、枚举、动态规划</p><p>题目：</p><ul><li>240902每日一题—<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description">Maximize the Confusion of an Exam</a></li><li>240905每日一题—<a href="https://leetcode.cn/problems/happy-students/description">Happy Students</a></li><li>240907每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description">Find the Maximum Length of a Good Subsequence II</a><span id="more"></span><h1 id="Maximize-the-Confusion-of-an-Exam"><a href="#Maximize-the-Confusion-of-an-Exam" class="headerlink" title="Maximize the Confusion of an Exam"></a>Maximize the Confusion of an Exam</h1><blockquote><p>Maximize the Confusion of an Exam</p><p>A teacher is writing a test with n true/false questions, with ‘T’ denoting true and ‘F’ denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).</p><p>You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:<br>Change the answer key for any question to ‘T’ or ‘F’ (i.e., set answerKey[i] to ‘T’ or ‘F’).</p><p>Return the maximum number of consecutive ‘T’s or ‘F’s in the answer key after performing the operation at most k times.</p></blockquote></li></ul><p>这道题本来想考虑DP，状态为“最后一个元素为i，替换次数为j时的最大连续子串长度”，但有问题，最后一个元素可能会被替换，且最大子串只在全替换为T或F时才出现，怎么弄怎么别扭，还是用滑窗吧。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在指定字符的情况下，可以计算其最大连续数目。使用滑动窗口的方法，从左到右枚举右端点，维护区间中另一种字符的数量为 sum，当 sum 超过 k，我们需要让左端点右移，直到 sum≤k。移动过程中，我们记录滑动窗口的最大长度，即为指定字符的最大连续数目。答案为分别指定字符为 T 和 F 时的最大连续数目的较大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxConsecutiveChar(answerKey, k, <span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveChar</span><span class="params">(String answerKey, <span class="keyword">int</span> k, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey.charAt(right) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey.charAt(left++) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Happy-Students"><a href="#Happy-Students" class="headerlink" title="Happy Students"></a>Happy Students</h1><blockquote><p>Happy Students</p><p>You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.</p><p>The ith student will become happy if one of these two conditions is met:</p><ul><li>The student is selected and the total number of selected students is strictly greater than nums[i].</li><li>The student is not selected and the total number of selected students is strictly less than nums[i].</li></ul><p>Return the number of ways to select a group of students so that everyone remains happy.</p></blockquote><p>一开始拿到没想出好办法，回溯暴力了一下，超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Set&lt;Integer&gt;&gt; mem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        mem = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        bt(nums, set, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bt</span><span class="params">(List&lt;Integer&gt; nums, Set&lt;Integer&gt; selected, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&lt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&gt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(success&amp;&amp;!mem.contains(selected))&#123;</span><br><span class="line">            mem.add(selected);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(selected.toString());</span></span><br><span class="line">        <span class="keyword">if</span>(p==nums.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line">            selected.add(i);</span><br><span class="line">            bt(nums, selected, p+<span class="number">1</span>);</span><br><span class="line">            selected.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上需要想明白选中人数为k时方案唯一，再按照这个思路去枚举就可以了。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>根据题意可知，假设数组 nums 的长度为 n，此时设选中学生人数为 k，此时 k∈[0,n]，k 应满足如下：</p><ul><li>所有满足 nums[i]&lt;k 的学生应被选中；</li><li>所有满足 nums[i]&gt;k 的学生不应被选中；</li><li>不能存在 nums[i]=k 的学生；</li></ul><p>这意味着在确定当前已择中学生人数的前提下，则此时选择方案是唯一的，为方便判断，我们把 nums 从小到大排序。我们枚举选中的人数 k，由于 nums 已有序，此时最优分组一定是前 k 个学生被选中，剩余的 n−k 个学生不被选中，此时只需要检测选中的 k 个学生中的最大值是否满足小于 k，未被选中的学生中的最小值是否满足大于 k 即可，如果同时满足上述两个条件，则该分配方案可行，最终返回可行的方案计数即可，需要注意处理好边界 0 与 n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="comment">// 前 k 个元素的最大值是否小于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums.get(k - <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后 n - k 个元素的最小值是否大于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; n &amp;&amp; nums.get(k) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Length-of-a-Good-Subsequence-II"><a href="#Find-the-Maximum-Length-of-a-Good-Subsequence-II" class="headerlink" title="Find the Maximum Length of a Good Subsequence II"></a>Find the Maximum Length of a Good Subsequence II</h1><blockquote><p>Find the Maximum Length of a Good Subsequence II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p></blockquote><p>周赛原题，当时DP都没想出来，这周把基础DP想通了，先写一下。</p><ol><li>拆分子问题：从seq中取出最后一个，则有两种情况<ul><li>情况一：seq中的前后不等对数量不变，则原问题变成了[0,i]上不超过k的</li><li>情况二：不等对数量减1，原问题变成了[0,i]上不超过k-1的</li></ul></li><li>定义状态<code>dp[i][j]</code>表示最后一个数为i时不超过j的最大长度</li><li>状态转移：<code>dp[i][j]</code> = Max(遍历0到i-1中和i位置元素相同的j取最大, 遍历[0,i-1][j-1]取最大)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> maxInd = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[o]==nums[i]&amp;&amp;max&lt;=dp[o][j])&#123;</span><br><span class="line">                        max = dp[o][j];</span><br><span class="line">                        maxInd = o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> max2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> maxInd2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(max2&lt;=dp[o][j-<span class="number">1</span>])&#123;</span><br><span class="line">                            max2 = dp[o][j-<span class="number">1</span>];</span><br><span class="line">                            maxInd2 = o;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(max2&gt;max)&#123;</span><br><span class="line">                        max = max2;</span><br><span class="line">                        maxInd = maxInd2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) res=Math.max(res, dp[i][k]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么这道题不能用01背包的状态来做呢？看起来不就是一个从一堆元素中选若干个的问题吗？这是因为01背包中，背包容量实际上包含了前序选择信息的最优解，即在当前背包容量支持放入当前物品时一定会选择放入。而对于本题来说，当前状态的前一个或上一个（指j-1和i-1）状态并不一定是对于本状态转移来说最优的，因为当前元素和前序元素中的某个值匹配时产生了更优解，而这个更优解是随遍历元素不断变动的。</p><p>想通了这一点，舒服多了。。。当时困扰我好几天。</p><p>然而上面的方法在大数据范围下还是不行，存在太多循环计算，下面介绍优化方案。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>PS：这题解写的依托，还是看我之前周赛时候的题解吧。</p><p>我们在上面的方案基础上优化，上面的时间复杂度是$O(n^2k)$。假设当前元素<code>i</code>的前序元素为<code>x</code>，可以枚举两种情况：</p><ul><li><p>nums $[i] \neq n u m s[x]$, 对于此情况, 可以维护一个长度为 $k$ 的辅助数组 $z d$ 。其中 $z d[j]$ 表示枚举到位置 $i$ 之前，有 $j$ 个数字与其在序列中的后一个不相等的最长合法序列的长度，那么可以直接写出转移 $d p[i][j]=z d[j-1]+1$ 。</p></li><li><p>nums $[i]=n u m s[x]$, 假设有下标 $a&lt;b&lt;c$, 并且 nums $[a]=$ $n u m s[b]=\operatorname{nums}[c]$, 对于 $c$ 来说如果选取由 $a$ 转移过来计算答案, 那么一定不如 $a \rightarrow b \rightarrow c$ 更优, 所以会选取下标最近的相同的数进行转移。针对这种情况， $d p$ 使用哈希表维护能节省一些空间，并且在哈希表中用 $n u m s[i]$ 替换 $i$ 。</p></li></ul><p>在每一次遍历 $i$ 计算完后更新 $z d$ ，最后的 $z d[k]$ 就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; dp = <span class="keyword">new</span> HashMap&lt;Integer, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] zd = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = nums[i];</span><br><span class="line">            dp.putIfAbsent(v, <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] tmp = dp.get(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                tmp[j] = tmp[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp[j] = Math.max(tmp[j], zd[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                zd[j] = Math.max(zd[j], tmp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zd[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04">https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周感觉还可以吧，有两道周赛做过的题。&lt;/p&gt;
&lt;p&gt;一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。&lt;/p&gt;
&lt;p&gt;本周主题：滑动窗口、枚举、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240902每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description&quot;&gt;Maximize the Confusion of an Exam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240905每日一题—&lt;a href=&quot;https://leetcode.cn/problems/happy-students/description&quot;&gt;Happy Students&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240907每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description&quot;&gt;Find the Maximum Length of a Good Subsequence II&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP10</title>
    <link href="http://silencezheng.top/2024/09/01/article137/"/>
    <id>http://silencezheng.top/2024/09/01/article137/</id>
    <published>2024-08-31T17:12:14.000Z</published>
    <updated>2024-10-27T15:28:55.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DPDPDP</p><p>本周主题：二分查找、动态规划、记忆化搜索</p><p>题目：</p><ul><li>240827每日一题—<a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description">Find the Median of the Uniqueness Array</a></li><li>240828每日一题—<a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description">Minimum Substring Partition of Equal Character Frequency</a><span id="more"></span><h1 id="Find-the-Median-of-the-Uniqueness-Array"><a href="#Find-the-Median-of-the-Uniqueness-Array" class="headerlink" title="Find the Median of the Uniqueness Array"></a>Find the Median of the Uniqueness Array</h1><blockquote><p>Find the Median of the Uniqueness Array</p><p>You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 &lt;= i &lt;= j &lt; nums.length.</p><p>Here, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j.</p><p>Return the median of the uniqueness array of nums.</p><p>Note that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.</p></blockquote></li></ul><p>容易分析出以下解题步骤：</p><ol><li>find out a way to express all the subarrays<ol><li>which means 0,0\1,1...\n-1,n-1; 0,1\1,2...\n-2,n-1; … 0,n-2\1,n-1; 0,n-1</li><li>we can find out there were n+n-1+…+2+1 subarrays in total.</li><li>which means there were (n*(n+1))/2 elements in uniqueness array.</li></ol></li><li>find out how many “distinctors” in there<ol><li>the max value of them should be 1,2,…,n</li><li>we can find a way to calculate them from the base subarrs, like from 1 number</li></ol></li></ol><p>总结一下：</p><ol><li>uniqueness array中一共有(n<em>(n+1))/2个元素，中位数位置在(n</em>(n+1))/4向下取整。</li><li>这些元素可以被分类，其中n个的范围为[1, 1]，n-1个的范围为[1, 2]，…，1个的范围为[1, n]。</li></ol><p>基于以上分析，可以写出暴力法，显然超时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt;[] sets = <span class="keyword">new</span> HashSet[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            sets[i].add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) list.add(sets[i].size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                sets[j].add(nums[i+j]);</span><br><span class="line">                list.add(sets[j].size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list.size()%<span class="number">2</span>==<span class="number">0</span>?list.get(list.size()/<span class="number">2</span>-<span class="number">1</span>):list.get(list.size()/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现上述总结2中存在单调性，考虑使用二分查找。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>设数组 nums 的长度为 $n$, 我们令 $c_t$ 表示数组 nums 中至多含有 $t$ 个不同元素的子数组数目，实际 $t$ 的取值范围为： $t \in[1, \operatorname{distinct}[0 \cdots n-1]]$ 。此时可以发现 $t$ 越大，则 $c_t$ 也越大, 且满足 $c_n=\frac{n \times(n+1)}{2}$ 。我们可以观察到 $c_t$ 呈现单调性, 因此可以考虑使用二分查找, 如果 $c_t&lt;$ median 则 $t$ 一定不是中位数, 因此利用二分查找找到 $t$ 的上限, 此时找到满足 $c_t \geq$ median 时最小的 $t$, 即为唯一性数组的中位数。</p><p>因此需要寻找一种方法计算$c_t$，注意到若数组$nums[i, j]$中至多含有 $t$ 个不同元素，则该数组的所有子数组也至多含有 $t$ 个不同元素。这里$nums[i, j]$可以用一个窗口表示，即双指针。$c_t$随$t$单调不减，可以用二分查找找到合适的t，判定是否合适的条件是是否$c_t \geq$ median，如果是的话则缩小$t$，否则增加$t$。</p><p>子数组越长, 则不同元素个数只会变大或不变，满足单调性。我们用哈希表 cnt 统计窗口子数组 $n u m s[i \cdots j]$ 中不同元素出现的次数。枚举窗口右端点 $i$ ，把 $n u m s[i]$ 加入到哈希表 cnt 中, 即此时 $n u m s[i]$ 出现次数加 1 。如果哈希表 cnt 中元素的数目超过 $t$ ，就不断移出窗口左端点元素 $n u m s[j]$ ，即此时 $n u m s[j]$ 出现的次数减去 1 ，如果 nums $[j]$ 出现次数等于 0 , 则将其从哈希表 cnt 中移除, 直到 cnt 中元素的数目等于 $t$ 为止。此时窗口的右端点为 $i$, 则此时子数组 nums $[j \cdots i]$, nums $[j+1 \cdots i]$, nums $[j+$ $2 \cdots i], \cdots$, nums $[i \cdots i]$ 都满足不同元素数目小于等于 $t$, 一共有 $i-j+1$ 个, 加到总数 tot 中, 最终的总数 $c_t=t o t$ 。我们每次检测是否满足 $c_t \geq$ median, 如果满足则缩小 $t$, 直到找到最小的 $t$ 返回即可。</p><p>实际二分查找时, $t$ 的下限取 1 , 此时一定不存在 0 个元素的子数组, $t$ 的上限为 $n$, 所有子数组的不同元素数目不超过 $n$ 。设 $m=\operatorname{distinct}[0 \cdots n-1]$ ，实际 $t$ 的取值范围为 $[1, m]$ ，且在该区间 $[1, m]$ 上的取值连续，因此一定可以找到属于某个子数组的 distinct 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">long</span> median = ((<span class="keyword">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, median)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测数组中不同元素数目小于等于 t 的连续子数组数目是否大于等于 median</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> t, <span class="keyword">long</span> median)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j，i为左右指针，遍历数组计算c_t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; t) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot &gt;= median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Minimum-Substring-Partition-of-Equal-Character-Frequency"><a href="#Minimum-Substring-Partition-of-Equal-Character-Frequency" class="headerlink" title="Minimum Substring Partition of Equal Character Frequency"></a>Minimum Substring Partition of Equal Character Frequency</h1><blockquote><p>Minimum Substring Partition of Equal Character Frequency</p><p>Given a string s, you need to partition it into one or more balanced<br>substrings. For example, if s == “ababcc” then (“abab”, “c”, “c”), (“ab”, “abc”, “c”), and (“ababcc”) are all valid partitions, but (“a”, “bab”, “cc”), (“aba”, “bc”, “c”), and (“ab”, “abcc”) are not. The unbalanced substrings are bolded.Return the minimum number of substrings that you can partition s into.</p><p>Note: A balanced string is a string where each character in the string occurs the same number of times.</p></blockquote><p>以后看到这种最值选元素的…直接开DP就完了，最差也是等同暴力吧。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先可以确定一定存在分割方案（都分成单字母）。</p><p>对于一个字符串<code>s</code>，从末尾分割出长度为<code>x</code>的平衡子串，则问题变成剩余字符串最少能分割出多少个平衡子串。这将原问题分解为<strong>相似且规模更小的子问题</strong>，可以递归求解。</p><blockquote><p>注 1：从右往左思考，主要是为了方便把递归翻译成递推。从左往右思考也是可以的。<br>注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。<br>注 3：这里的思考可以理解成从“最后一步”出发，划分子问题，即最后一步一定是划分出一个平衡子串，则考虑剩余部分的子问题即可，此时划分出最后一步不影响剩余部分的正确求解。反观贪心，如果尝试一次找到一个最长的平衡子串，则可能影响整体最优，因此这类问题最好通过DP+枚举解决。</p></blockquote><p>下面考虑<strong>状态定义与转移</strong>，假设剩余前缀字符串为<code>s[0...i]</code>，定义状态<code>f(i)</code>为剩余<code>s[0...i]</code>时最少能分割出多少平衡子串，则可以通过枚举<code>j=0,1,..,i</code>，找到平衡子串<code>s[j...i]</code>，则问题转化为求解状态 <code>f(j-1)</code>，实现递归求解<code>f(i)</code>。可以枚举所有<code>j</code>，找到最小的<code>f(j-1)</code>。</p><p>有一种方法可以<strong>快速判断子串平衡</strong>，即在倒序枚举<code>j</code>的同时，用一个哈希表（或者数组）统计子串<code>s[j...i]</code>每个字符的出现次数。如果子串中每个字母的出现次数都相等，那么子串是平衡的。进一步优化，设子串<code>s[j...i]</code>中有<code>k</code>种字母，字母出现次数的最大值为<code>maxCnt</code>。子串是平衡的，当且仅当子串长度<code>i−j+1</code>等于<code>k⋅maxCnt</code>。</p><p>原问题表示为<code>f(n-1)</code>，则可递归计算：<code>f(n-1) = 1+f(x) = ... = m + f(-1) = m</code>。其中<code>x</code>表示第一次求得的最小<code>f(j-1)</code>对应的<code>j</code>，<code>m</code>表示最终划分出的平衡子串数量。分析至此可以写出暴力递归解法一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力递归在数据范围大的情况下依然会TTL，注意到枚举<code>j</code>的过程中存在大量重复计算，考虑使用记忆化减少计算。由于递归函数幂等，可以对<code>入参+返回</code>的组合进行记忆化。使用一个数组<code>memo</code>来记录：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。</li><li>如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。</li></ul><p>注意<code>memo</code>数组的初始值一定不能等于要记忆化的值，否则会跳过首次计算。因为递归求解等同于递归搜索，此类算法亦可称为<strong>记忆化搜索</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = res; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化搜索为自顶向下计算，即从<code>f(n-1)</code>开始递归搜索。动态规划则是考虑自底向上的计算，即从<code>f(0)</code>开始计算。</p><p>定义状态<code>dp[i]</code>表示剩余字符串为<code>s[0...i]</code>时最少能分割出多少平衡子串，则有状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \min _{j=0}^i dp[j]+1，其中s[j...i]平衡</script><p>另外由于递归边界为<code>f(-1)</code>，则用<code>dp[0]</code>存放初始状态<code>dp[0] = 0</code>，剩余状态右移一位（递归边界对应DP初状态）。最终返回结果为<code>dp[n]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(cnt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28">https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;DPDPDP&lt;/p&gt;
&lt;p&gt;本周主题：二分查找、动态规划、记忆化搜索&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240827每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description&quot;&gt;Find the Median of the Uniqueness Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240828每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description&quot;&gt;Minimum Substring Partition of Equal Character Frequency&lt;/a&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP9</title>
    <link href="http://silencezheng.top/2024/08/25/article136/"/>
    <id>http://silencezheng.top/2024/08/25/article136/</id>
    <published>2024-08-24T17:08:04.000Z</published>
    <updated>2024-10-27T15:28:59.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。</p><p>本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP</p><p>题目：</p><ul><li>240819每日一题—<a href="https://leetcode.cn/problems/student-attendance-record-ii/description">Student Attendance Record II</a></li><li>240820每日一题—<a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description">Find Number of Ways to Reach the K-th Stair</a></li><li>240822每日一题—<a href="https://leetcode.cn/problems/minimum-array-end/description">Minimum Array End</a></li><li>240823每日一题—<a href="https://leetcode.cn/problems/find-products-of-elements-of-big-array/description">Find Products of Elements of Big Array</a></li><li>240824每日一题—<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description">Partition to K Equal Sum Subsets</a></li></ul><p>PS：腾子音乐的笔也忒难了<br><span id="more"></span></p><h1 id="Student-Attendance-Record-II-（HARD）"><a href="#Student-Attendance-Record-II-（HARD）" class="headerlink" title="Student Attendance Record II （HARD）"></a>Student Attendance Record II <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Student Attendance Record II</p><p>An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p><ul><li>‘A’: Absent.</li><li>‘L’: Late.</li><li>‘P’: Present.</li></ul><p>Any student is eligible for an attendance award if they meet both of the following criteria:</p><ul><li>The student was absent (‘A’) for strictly fewer than 2 days total.</li><li>The student was never late (‘L’) for 3 or more consecutive days.</li></ul><p>Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.</p></blockquote><p>初次分析时，可得到如下限制：</p><ol><li>最多只能有两个<code>A</code></li><li><code>L</code>可能被<code>A</code>或<code>P</code>隔开</li><li><code>L</code>只能出现单独的一个或连续的两个</li><li><code>L</code>的最大数量为<code>n/3*2 + n-(n/3*2)</code>，即把出勤分为若干个三元组与一个末尾，三元组中均存在两个<code>L</code>，末尾均为<code>L</code></li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>可以使用动态规划计算可奖励的出勤记录的数量。</p><p>由于可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定（由于不会记录连续迟到次数等于或多于 3 的情况，因此非结尾的连续迟到次数一定少于 3，只需要记录结尾连续迟到次数即可）。</p><p>定义 $d p[i][j][k]$ 表示前 $i$ 天有 $j$ 个 ‘$\mathrm{A}$’ 且结尾有连续 $k$ 个 ‘ L ‘ 的可奖励的出勤记录的数量, 其中 $0 \leq i \leq$ $n, 0 \leq j \leq 1,0 \leq k \leq 2$ 。</p><p>当 $i=0$ 时，没有任何出勤记录，此时 ‘ $A$ ‘的数量和结尾连续 ‘ $L$ ‘ 的数量一定是 0 ，因此动态规划的边界情况是 $d p[0][0][0]=1$ 。</p><p>当 $1 \leq i \leq n$ 时， $d p[i][][]$ 的值从 $d p[i-1][][]$ 的值转移得到，计算每个状态的值需要考虑第 $i$ 天的出勤记录:</p><ul><li>如果第 $i$ 天的出勤记录是 ‘ P ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量不变，结尾连续 ${ }^{\prime} \mathrm{L}$ ‘ 的数量清零，因此对 $0 \leq j \leq 1$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][0]:=d p[i][j][0]+\sum_{k=0}^2 d p[i-1][j][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ $A$ ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量加 1 ，结尾连续 ‘ $L$ ‘ 的数量清零，此时要求前 $i-1$ 天的出勤记录记录中的 ‘ $A$ ‘的数量必须为 0 ，否则前 $i$ 天的出勤记录至少有 2 个 ‘ $A$ ‘，不满足可奖励的条件，因此有</li></ul><script type="math/tex; mode=display">d p[i][1][0]:=d p[i][1][0]+\sum_{k=0}^2 d p[i-1][0][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ L ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘A’ 的数量不变，结尾连续 ${ }^{\prime} L$ ‘ 的数量加 1 , 此时要求前 $i-1$ 天的出勤记录记录中的结尾连续 ‘ $L$ ‘ 的数量不超过 1 ，否则前 $i$天的出勤记录的结尾至少有 3 个 ‘ $L$ ‘，不满足可奖励的条件，因此对 $0 \leq j \leq 1$ 和 $1 \leq k \leq 2$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][k]:=d p[i][j][k]+d p[i-1][j][k-1]</script><p>上述状态转移方程对于<code>i=1</code>也适用。计算长度为 n 的所有可奖励的出勤记录的数量，即为计算 <code>dp[n][][]</code> 的所有元素之和。计算过程中需要将结果对<code>10^9+7</code>取模。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[n][j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据状态转移，发现可以利用滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] dpNew = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][<span class="number">0</span>] = (dpNew[j][<span class="number">0</span>] + dp[j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dpNew[<span class="number">1</span>][<span class="number">0</span>] = (dpNew[<span class="number">1</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：逐渐理解DP似乎就是一种限制条件枚举的解法，列出限制，逐条件枚举，例如01背包就是在枚举背包容量。</p><h1 id="Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）"><a href="#Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）" class="headerlink" title="Find Number of Ways to Reach the K-th Stair （HARD）"></a>Find Number of Ways to Reach the K-th Stair <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Find Number of Ways to Reach the K-th Stair</p><p>You are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0.</p><p>Alice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:</p><ul><li>Go down to stair i - 1. This operation cannot be used consecutively or on stair 0.</li><li>Go up to stair i + 2jump. And then, jump becomes jump + 1.<br>Return the total number of ways Alice can reach stair k.<br>Note that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.</li></ul></blockquote><p>容易想到递归方式穷举所有可能性，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveMachine</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> jump, <span class="keyword">boolean</span> canDown, <span class="keyword">int</span> ops)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;ks+<span class="number">1</span>||ops&gt;<span class="number">61</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==ks)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        moveMachine(i+(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, jump), jump+<span class="number">1</span>, <span class="keyword">true</span>, ops+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(canDown) moveMachine(i-<span class="number">1</span>, jump, <span class="keyword">false</span>, ops+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToReachStair</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ks = k;</span><br><span class="line">        moveMachine(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> k==<span class="number">1</span>?<span class="number">4</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力穷举用例只能通过50%，组合数学法见官解。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>两道题都是组合+位运算的类型，例题一必须完全掌握，第二题以目前水平能写个七八十就可以了。</p><h2 id="例题一：Minimum-Array-End"><a href="#例题一：Minimum-Array-End" class="headerlink" title="例题一：Minimum Array End"></a>例题一：Minimum Array End</h2><blockquote><p>Minimum Array End</p><p>You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 &lt;= i &lt; n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.</p><p>Return the minimum possible value of nums[n - 1].</p></blockquote><p>题目还是很好理解的，仔细分析一下就知道是要从<code>x</code>开始逐步往<code>0</code>位上填1，直到填出第n-1个数，填充过程保持数组递增。我的第一次解法如下，会OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储低位到高位的0位置，后续按顺序拼mask就行了</span></span><br><span class="line">        List&lt;Long&gt; masks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(last&lt;=Long.MAX_VALUE&amp;&amp;masks.size()&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((last&amp;x)==<span class="number">0</span>)&#123;</span><br><span class="line">                masks.add(last);</span><br><span class="line">                <span class="keyword">int</span> len = masks.size();</span><br><span class="line">                <span class="comment">// 存储组合</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                    masks.add(last^masks.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>?x:(x^masks.get(n-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到的卡点是计算目标值需要存储前序值，需要压缩空间。可以用另一种视角来看填<code>0</code>位的过程，即把<code>x</code>上的<code>1</code>位都提出来，剩下的位置上按<code>1、2、...、n-1</code>的值去填即可，例如对于<code>x = 100010, n = 4</code>，可以看作是向<code>0000</code>上依次填<code>0001, 0010, 0011</code>，则可得出答案<code>100111</code>。因此，可以确定目标值为把<code>n-1</code>的二进制插入到<code>x</code>的<code>0</code>位中，解法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回值可能的最大位数，即两个long的长度减去各自的前导0，当x全是1时出现。</span></span><br><span class="line">        <span class="keyword">int</span> bitCount = <span class="number">128</span> - Long.numberOfLeadingZeros(n) - Long.numberOfLeadingZeros(x);</span><br><span class="line">        <span class="keyword">long</span> res = x;</span><br><span class="line">        <span class="keyword">long</span> m = n - <span class="number">1</span>; <span class="comment">// 要填到0位的所有bit</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录x中已经填过的bit</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐位查看是否是0</span></span><br><span class="line">            <span class="keyword">if</span> (((res &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 对于是0的位置，如果n-1也为0则不处理，如果为1则用异或填入</span></span><br><span class="line">                <span class="keyword">if</span> (((m &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    res |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二：Find-Products-of-Elements-of-Big-Array-（HARD）"><a href="#例题二：Find-Products-of-Elements-of-Big-Array-（HARD）" class="headerlink" title="例题二：Find Products of Elements of Big Array （HARD）"></a>例题二：Find Products of Elements of Big Array <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h2><blockquote><p>Find Products of Elements of Big Array</p><p>The powerful array of a non-negative integer x is defined as the shortest sorted array of powers of two that sum up to x. The table below illustrates examples of how the powerful array is determined. It can be proven that the powerful array of x is unique.</p><p>The array big_nums is created by concatenating the powerful arrays for every positive integer i in ascending order: 1, 2, 3, and so on. Thus, big_nums begins as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, …].</p><p>You are given a 2D integer matrix queries, where for queries[i] = [fromi, toi, modi] you should calculate (big_nums[fromi] <em> big_nums[fromi + 1] </em> … * big_nums[toi]) % modi.</p><p>Return an integer array answer such that answer[i] is the answer to the ith query.</p></blockquote><p>思路：首先看如何定位<code>bignums[i]</code>的值，从数位的角度考虑，对于<code>01000</code>来说，其之前的元素个数其实就是1、2、3个1在3个格子中有多少种排列，然后再乘元素数<code>C31*1+C32*2+C33*3 = 12</code>，可以应用<strong>组合数的加权求和公式</strong>。用<code>b(x)</code>表示<code>b(x)</code>位为1，其余为0的二进制数，<code>x</code>从0开始，则<code>b(x)</code>的下标为<code>n*2^(n-1)</code>。对于任意一个下标<code>y</code>，考虑遍历<code>i</code>，找到首个小于<code>y</code>的<code>i*2^(i-1)</code>，然后模拟遍历数位找到<code>bignums[from]</code>的值，继续模拟遍历，找到<code>bignums[to]</code>之间的若干值，求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findProductsOfElements(<span class="keyword">long</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">long</span> from = queries[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> to = queries[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> mod = queries[k][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lastSmallInd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> lastPower = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i&lt;=from)&#123;</span><br><span class="line">                    lastSmallInd = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i;</span><br><span class="line">                    lastPower = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> startOuterVal = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, lastPower);</span><br><span class="line">            <span class="keyword">int</span> startVal = startOuterVal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lastSmallInd&lt;from)&#123;</span><br><span class="line">                <span class="comment">// 模拟</span></span><br><span class="line">                <span class="keyword">int</span> startInd = lastSmallInd;</span><br><span class="line">                <span class="keyword">while</span>(startInd&lt;from)&#123;</span><br><span class="line">                    startOuterVal++;</span><br><span class="line">                    <span class="keyword">int</span> tmp = Integer.bitCount(startOuterVal); <span class="comment">// 减去最大的1</span></span><br><span class="line">                    <span class="keyword">if</span>(startInd+tmp&lt;from) startInd+=tmp;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 逐位右移寻找</span></span><br><span class="line">                        <span class="keyword">int</span> sov = startOuterVal;</span><br><span class="line">                        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 元素计数</span></span><br><span class="line">                        <span class="keyword">int</span> bitCnt = -<span class="number">1</span>; <span class="comment">// 位数计数</span></span><br><span class="line">                        <span class="keyword">while</span> (startInd+cnt&lt;from) &#123;</span><br><span class="line">                            <span class="comment">// 判断末位是否为1</span></span><br><span class="line">                            <span class="keyword">if</span>((sov&amp;<span class="number">1</span>)==<span class="number">1</span>) cnt++;</span><br><span class="line">                            sov&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                            bitCnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startVal = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, bitCnt);</span><br><span class="line">                        startInd+=cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始计算结果</span></span><br><span class="line">            <span class="keyword">long</span> mul = startVal;</span><br><span class="line">            <span class="keyword">long</span> remain = to-from; <span class="comment">// to-from个元素还没计算</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(remain&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(startVal&lt;startOuterVal)&#123;</span><br><span class="line">                    startVal&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 有重合的1</span></span><br><span class="line">                    <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>)&#123;</span><br><span class="line">                        remain--;</span><br><span class="line">                        mul*=startVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                startOuterVal++;</span><br><span class="line">                startVal = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>) remain--;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            ans[k] = (<span class="keyword">int</span>) (mul%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法可以通过95%的用例，全通的解法可以参考官解。</p><h1 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h1><blockquote><p>Partition to K Equal Sum Subsets</p><p>Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>1 &lt;= k &lt;= nums.length &lt;= 16<br>1 &lt;= nums[i] &lt;= 10^4<br>The frequency of each element is in the range [1, 4].</p></blockquote><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><blockquote><p>状态压缩就是使用某种方法，简明扼要地以最小代价来表示某种状态，通常是用一串01数字（二进制数）来表示各个点的状态。这就要求使用状态压缩的对象的点的状态必须只有两种，0 或 1；当然如果有三种状态用三进制来表示也未尝不可。</p><p>状态压缩的目的一方面是缩小了数据存储的空间，另一方面是在状态对比和状态整体处理时能够提高效率。这样就要求状态数据中的单元个数不能太大，比如用int来表示一个状态的时候，状态的单元个数不能超过32（32位的机器），所以题目一般都是至少有一维的数据范围很小。</p></blockquote><p>状压DP就是使用状态压缩的动态规划。动态规划问题通常有两种，一种是对递归问题的记忆化求解，另一种是把大问题看作是多阶段的决策求解。这里用的便是后一种，这带来一个需求，即存储之前的状态，再由状态及状态对应的值推演出状态转移方程最终得到最优解。</p><p>回到本题，题目给定长度为 $n$ 的数组 $nums$，和整数 $k$，我们需要判断是否能将数组分成 $k$ 个总和相等的非空子集。首先计算数组的和 $all$，如果 $all$ 不是 $k$ 的倍数，那么不可能能有合法方案，此时直接返回 $False$。否则我们需要得到 $k$ 个和为 $per= all/k$的集合。</p><p>数组长度在16以内，则可以用一个整数 $S$ 来表示当前可用的数字集合：从低位到高位, 第 $i$ 位为 0 则表示数字 nums $[i]$ 可以使用, 否则表示 nums [i] 已被使用。然后我们用 $d p[S]$ 来表示在可用的数字状态为 $S$ 的情况下是否可能可行, 初始全部状态为记录为不可行状态 False, 只记 $d p[0]=$ True 为可行状态。</p><p>我们每次对于当前状态下从可用的数字中选择一个数字, 若此时选择全部数字取模后小于等于 per。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终返回 $d p[U]$即可, 其中 $U$ 表示全部数字使用的集合状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> all = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (all % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> per = all / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; per) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始DP</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 所有可能的状态</span></span><br><span class="line">        <span class="keyword">int</span>[] curSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 状态对应的总和？</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 状态i中j物品可用</span></span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 定位下一个状态，即选了j物品后的状态</span></span><br><span class="line">                    <span class="keyword">int</span> next = i | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="comment">// 如果是不可用状态，说明还没更新过</span></span><br><span class="line">                    <span class="keyword">if</span> (!dp[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对per取余表示删除已存满的子集</span></span><br><span class="line">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class="line">                        dp[next] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全为1的状态下是否可用，即取走全部元素后是否可行</span></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/">https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/</a><br>[2] <a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve">https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。&lt;/p&gt;
&lt;p&gt;本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240819每日一题—&lt;a href=&quot;https://leetcode.cn/problems/student-attendance-record-ii/description&quot;&gt;Student Attendance Record II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240820每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description&quot;&gt;Find Number of Ways to Reach the K-th Stair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240822每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-array-end/description&quot;&gt;Minimum Array End&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240823每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-products-of-elements-of-big-array/description&quot;&gt;Find Products of Elements of Big Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240824每日一题—&lt;a href=&quot;https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description&quot;&gt;Partition to K Equal Sum Subsets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS：腾子音乐的笔也忒难了&lt;br&gt;</summary>
    
    
    
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
</feed>
