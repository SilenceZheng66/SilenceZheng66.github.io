<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenceZheng66-BLOG</title>
  
  <subtitle>silencezheng.top</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2024-09-15T15:32:55.793Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>SilenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode周记 EP12</title>
    <link href="http://silencezheng.top/2024/09/15/article139/"/>
    <id>http://silencezheng.top/2024/09/15/article139/</id>
    <published>2024-09-15T15:32:15.000Z</published>
    <updated>2024-09-15T15:32:55.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周忙废了…挑战一天写完一周的题。</p><p>本周主题：双指针、枚举、单调队列</p><p>题目：</p><ul><li>240910每日一题—<a href="https://leetcode.cn/problems/count-increasing-quadruplets/description">Count Increasing Quadruplets</a></li><li>240912每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description">Find the Maximum Number of Marked Indices</a></li><li>240913每日一题—<a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description">Maximum Number of Robots Within Budget</a></li></ul><span id="more"></span><h1 id="Maximum-Number-of-Robots-Within-Budget"><a href="#Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="Maximum Number of Robots Within Budget"></a>Maximum Number of Robots Within Budget</h1><blockquote><p>Maximum Number of Robots Within Budget</p><p>You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.</p><p>The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.</p><p>Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.</p></blockquote><p>首先注意题目要求启动的机器人序列连续，则构成一个窗口，窗口内计算cost要小于budget且窗口尽量大。每次窗口移动可能会影响两个点进而影响窗口cost，一个是最大充电时间，一个是总体启动时间消耗。则这道题可以看为<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的变体题目。</p><p>因此先来把<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的<strong>单调队列</strong>做法搞懂。</p><p>PS：这道题我之前也写了一个<a href="https://leetcode.cn/problems/sliding-window-maximum/solutions/2795111/treemap-by-silencezheng66-kb1i/">TreeMap的题解</a>，比较复杂，正好这次学一下单调队列的解法。</p><p><strong>「单调队列」即满足单调性的双端队列</strong>，双端队列左侧为队首，右侧为队尾。</p><h2 id="前置题目：Sliding-Window-Maximum"><a href="#前置题目：Sliding-Window-Maximum" class="headerlink" title="前置题目：Sliding Window Maximum"></a>前置题目：Sliding Window Maximum</h2><blockquote><p>Sliding Window Maximum</p><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p><p>Return the max sliding window.</p></blockquote><p>题目比较容易理解，就是取一个定长的滑窗在数组上滑出若干个最值，难点就是用尽量少的时间计算每个窗口中的最值。</p><p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 $i$ 和 $j$, 其中 $i$ 在 $j$的左侧 $(i&lt;j)$ ，并且 $i$ 对应的元素不大于 $j$ 对应的元素（nums $[i] \leq n u m s[j]$） ，则当滑动窗口向右移动时，只要 $i$ 还在窗口中，那么 $j$ 一定也还在窗口中，这是 $i$ 在 $j$ 的左侧所保证的。因此, 由于 nums [j] 的存在, nums [i] 一定不会是滑动窗口中的最大值了, 我们可以将 nums [i]永久地移除。</p><p>因此我们可以<strong>使用一个队列存储所有还没有被移除的下标</strong>。在队列中, 这些<strong>下标按照从小到大的顺序被存储, 并且它们在数组 nums 中对应的值是严格单调递减的</strong>。因为如果队列中有两个相邻的下标, 它们对应的值相等或者递增, 那么令前者为 $i$, 后者为 $j$, 就对应了上面所说的情况, 即 $n u m s[i]$ 会被移除，这就产生了矛盾。</p><p>当滑动窗口向右移动时, 我们需要把一个新的元素放入队列中。为了保持队列的性质, 我们会不断地将新的元素与队尾的元素相比较, 如果前者大于等于后者, 那么队尾的元素就可以被永久地移除, 我们将其弹出队列。我们需要不断地进行此项操作, 直到队列为空或者新的元素小于队尾的元素。</p><p>由于队列中下标对应的元素是严格单调递减的, 因此此时队首下标对应的元素就是滑动窗口中的最大值。同时，隨着窗口向右移动，队首元素可能会不在窗口中，我们还需要不断从队首弹出元素, 直到队首元素在窗口中为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先填充第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[deque.peekFirst()]; <span class="comment">// 队首为窗口最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐元素移动窗口</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 抛弃不在窗口中的最值</span></span><br><span class="line">            <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出答案，注意peek只检查并不丢弃</span></span><br><span class="line">            ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解（单调队列）：Maximum-Number-of-Robots-Within-Budget"><a href="#题解（单调队列）：Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="题解（单调队列）：Maximum Number of Robots Within Budget"></a>题解（单调队列）：Maximum Number of Robots Within Budget</h2><p>本题相较于<code>Sliding Window Maximum</code>有几点需要注意：</p><ol><li>窗口大小不固定，队首弹出与budget相关而与窗口大小无关；</li><li><code>chargeTimes</code>的最值处理逻辑相同；</li><li>求解需要知道窗口左侧的位置，需要维护窗口左侧下标。</li></ol><p>队列中存储的还是<code>chargeTimes</code>的下标，因为下标与<code>runningCosts</code>一一对应，则计算总消耗时共用计算即可，本质上可以用单调队列还是因为两点，一是连续窗口，二是最值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumRobots</span><span class="params">(<span class="keyword">int</span>[] chargeTimes, <span class="keyword">int</span>[] runningCosts, <span class="keyword">long</span> budget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 维护左侧下标</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// 用于与预算比较</span></span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; chargeTimes.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 1. 入队，与前置题目逻辑相同</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[right] &gt;= chargeTimes[q.peekLast()]) &#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.addLast(right);</span><br><span class="line">            sum += runningCosts[right]; <span class="comment">// 累计cost</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 窗口左端右移，通过预算与消耗比较判断</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[q.peekFirst()] + (right - left + <span class="number">1</span>) * sum &gt; budget) &#123;</span><br><span class="line">                <span class="comment">// 出队逻辑，在左移过程中遇到最值要同步出队</span></span><br><span class="line">                <span class="keyword">if</span> (q.peekFirst() == left) &#123;</span><br><span class="line">                    q.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= runningCosts[left++]; <span class="comment">// 减去移出元素cost</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 更新答案</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Number-of-Marked-Indices"><a href="#Find-the-Maximum-Number-of-Marked-Indices" class="headerlink" title="Find the Maximum Number of Marked Indices"></a>Find the Maximum Number of Marked Indices</h1><blockquote><p>Find the Maximum Number of Marked Indices</p><p>You are given a 0-indexed integer array nums.</p><p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p><p>Pick two different unmarked indices i and j such that 2 * nums[i] &lt;= nums[j], then mark i and j.<br>Return the maximum possible number of marked indices in nums using the above operation any number of times.</p></blockquote><p>这题我一开始的思路是按值排序后从大到小匹配，但这样贪心还是不能获得最佳答案，需要从如何获得最优解的角度考虑。当可获得最优解时，长度为 $n$ 的数组最多只会产生 $\left\lfloor\frac{n}{2}\right\rfloor$ 对匹配, 因此对数组从小到大排序以后, 我们将数组一分为二, 左侧元素只会与右侧元素匹配。</p><p>这样操作就可以解决直接排序匹配中找不到最优配对的问题，对于右侧的一个元素，其最优配对的符合条件的元素既不是比他次大的元素，也不是全局最小的元素，而是划分成两半后左侧的符合条件的最大元素。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>具体的, 我们令 $m=\left\lfloor\frac{n}{2}\right\rfloor$, 尝试将下标在 $[0, m-1]$ 范围内的元素 $n u m s[i]$ 与下标在 $[m, n-1]$ 范围内的元素 $n u m s[j]$ 进行匹配。我们从小到大枚举 $i$ ，然后找到最小的 $j$ 使其满足 $2 \times$ $n u m s[i] \leq n u m s[j]$ 。那些末满足条件而被跳过的 nums $[j]$ 将被忽略。持续这一过程,直到 $i=m$ 或 $j=n$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumOfMarkedIndices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m; i &lt; m &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="number">2</span> * nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Count-Increasing-Quadruplets-HARD"><a href="#Count-Increasing-Quadruplets-HARD" class="headerlink" title="Count Increasing Quadruplets HARD"></a>Count Increasing Quadruplets <font color=#FF4500 size=4 face='黑体'>HARD</font></h1><blockquote><p>Count Increasing Quadruplets</p><p>Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.</p><p>A quadruplet (i, j, k, l) is increasing if:</p><ul><li>0 &lt;= i &lt; j &lt; k &lt; l &lt; n, and</li><li>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l].</li></ul></blockquote><p>这道题直接暴力能解决一半，剩下一半学习成本有点高了，直接看灵神题解即可，现在没时间学了，感觉意义不大。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12">https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12</a><br>[2] <a href="https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10">https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10</a><br>[3] <a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13">https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周忙废了…挑战一天写完一周的题。&lt;/p&gt;
&lt;p&gt;本周主题：双指针、枚举、单调队列&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240910每日一题—&lt;a href=&quot;https://leetcode.cn/problems/count-increasing-quadruplets/description&quot;&gt;Count Increasing Quadruplets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240912每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description&quot;&gt;Find the Maximum Number of Marked Indices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240913每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description&quot;&gt;Maximum Number of Robots Within Budget&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP11</title>
    <link href="http://silencezheng.top/2024/09/08/article138/"/>
    <id>http://silencezheng.top/2024/09/08/article138/</id>
    <published>2024-09-08T14:31:23.000Z</published>
    <updated>2024-09-08T14:32:02.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周感觉还可以吧，有两道周赛做过的题。</p><p>一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。</p><p>本周主题：滑动窗口、枚举、动态规划</p><p>题目：</p><ul><li>240902每日一题—<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description">Maximize the Confusion of an Exam</a></li><li>240905每日一题—<a href="https://leetcode.cn/problems/happy-students/description">Happy Students</a></li><li>240907每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description">Find the Maximum Length of a Good Subsequence II</a><span id="more"></span><h1 id="Maximize-the-Confusion-of-an-Exam"><a href="#Maximize-the-Confusion-of-an-Exam" class="headerlink" title="Maximize the Confusion of an Exam"></a>Maximize the Confusion of an Exam</h1><blockquote><p>Maximize the Confusion of an Exam</p><p>A teacher is writing a test with n true/false questions, with ‘T’ denoting true and ‘F’ denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).</p><p>You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:<br>Change the answer key for any question to ‘T’ or ‘F’ (i.e., set answerKey[i] to ‘T’ or ‘F’).</p><p>Return the maximum number of consecutive ‘T’s or ‘F’s in the answer key after performing the operation at most k times.</p></blockquote></li></ul><p>这道题本来想考虑DP，状态为“最后一个元素为i，替换次数为j时的最大连续子串长度”，但有问题，最后一个元素可能会被替换，且最大子串只在全替换为T或F时才出现，怎么弄怎么别扭，还是用滑窗吧。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在指定字符的情况下，可以计算其最大连续数目。使用滑动窗口的方法，从左到右枚举右端点，维护区间中另一种字符的数量为 sum，当 sum 超过 k，我们需要让左端点右移，直到 sum≤k。移动过程中，我们记录滑动窗口的最大长度，即为指定字符的最大连续数目。答案为分别指定字符为 T 和 F 时的最大连续数目的较大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxConsecutiveChar(answerKey, k, <span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveChar</span><span class="params">(String answerKey, <span class="keyword">int</span> k, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey.charAt(right) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey.charAt(left++) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Happy-Students"><a href="#Happy-Students" class="headerlink" title="Happy Students"></a>Happy Students</h1><blockquote><p>Happy Students</p><p>You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.</p><p>The ith student will become happy if one of these two conditions is met:</p><ul><li>The student is selected and the total number of selected students is strictly greater than nums[i].</li><li>The student is not selected and the total number of selected students is strictly less than nums[i].</li></ul><p>Return the number of ways to select a group of students so that everyone remains happy.</p></blockquote><p>一开始拿到没想出好办法，回溯暴力了一下，超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Set&lt;Integer&gt;&gt; mem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        mem = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        bt(nums, set, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bt</span><span class="params">(List&lt;Integer&gt; nums, Set&lt;Integer&gt; selected, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&lt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&gt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(success&amp;&amp;!mem.contains(selected))&#123;</span><br><span class="line">            mem.add(selected);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(selected.toString());</span></span><br><span class="line">        <span class="keyword">if</span>(p==nums.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line">            selected.add(i);</span><br><span class="line">            bt(nums, selected, p+<span class="number">1</span>);</span><br><span class="line">            selected.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上需要想明白选中人数为k时方案唯一，再按照这个思路去枚举就可以了。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>根据题意可知，假设数组 nums 的长度为 n，此时设选中学生人数为 k，此时 k∈[0,n]，k 应满足如下：</p><ul><li>所有满足 nums[i]&lt;k 的学生应被选中；</li><li>所有满足 nums[i]&gt;k 的学生不应被选中；</li><li>不能存在 nums[i]=k 的学生；</li></ul><p>这意味着在确定当前已择中学生人数的前提下，则此时选择方案是唯一的，为方便判断，我们把 nums 从小到大排序。我们枚举选中的人数 k，由于 nums 已有序，此时最优分组一定是前 k 个学生被选中，剩余的 n−k 个学生不被选中，此时只需要检测选中的 k 个学生中的最大值是否满足小于 k，未被选中的学生中的最小值是否满足大于 k 即可，如果同时满足上述两个条件，则该分配方案可行，最终返回可行的方案计数即可，需要注意处理好边界 0 与 n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="comment">// 前 k 个元素的最大值是否小于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums.get(k - <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后 n - k 个元素的最小值是否大于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; n &amp;&amp; nums.get(k) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Length-of-a-Good-Subsequence-II"><a href="#Find-the-Maximum-Length-of-a-Good-Subsequence-II" class="headerlink" title="Find the Maximum Length of a Good Subsequence II"></a>Find the Maximum Length of a Good Subsequence II</h1><blockquote><p>Find the Maximum Length of a Good Subsequence II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p></blockquote><p>周赛原题，当时DP都没想出来，这周把基础DP想通了，先写一下。</p><ol><li>拆分子问题：从seq中取出最后一个，则有两种情况<ul><li>情况一：seq中的前后不等对数量不变，则原问题变成了[0,i]上不超过k的</li><li>情况二：不等对数量减1，原问题变成了[0,i]上不超过k-1的</li></ul></li><li>定义状态<code>dp[i][j]</code>表示最后一个数为i时不超过j的最大长度</li><li>状态转移：<code>dp[i][j]</code> = Max(遍历0到i-1中和i位置元素相同的j取最大, 遍历[0,i-1][j-1]取最大)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> maxInd = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[o]==nums[i]&amp;&amp;max&lt;=dp[o][j])&#123;</span><br><span class="line">                        max = dp[o][j];</span><br><span class="line">                        maxInd = o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> max2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> maxInd2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(max2&lt;=dp[o][j-<span class="number">1</span>])&#123;</span><br><span class="line">                            max2 = dp[o][j-<span class="number">1</span>];</span><br><span class="line">                            maxInd2 = o;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(max2&gt;max)&#123;</span><br><span class="line">                        max = max2;</span><br><span class="line">                        maxInd = maxInd2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) res=Math.max(res, dp[i][k]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么这道题不能用01背包的状态来做呢？看起来不就是一个从一堆元素中选若干个的问题吗？这是因为01背包中，背包容量实际上包含了前序选择信息的最优解，即在当前背包容量支持放入当前物品时一定会选择放入。而对于本题来说，当前状态的前一个或上一个（指j-1和i-1）状态并不一定是对于本状态转移来说最优的，因为当前元素和前序元素中的某个值匹配时产生了更优解，而这个更优解是随遍历元素不断变动的。</p><p>想通了这一点，舒服多了。。。当时困扰我好几天。</p><p>然而上面的方法在大数据范围下还是不行，存在太多循环计算，下面介绍优化方案。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>PS：这题解写的依托，还是看我之前周赛时候的题解吧。</p><p>我们在上面的方案基础上优化，上面的时间复杂度是$O(n^2k)$。假设当前元素<code>i</code>的前序元素为<code>x</code>，可以枚举两种情况：</p><ul><li><p>nums $[i] \neq n u m s[x]$, 对于此情况, 可以维护一个长度为 $k$ 的辅助数组 $z d$ 。其中 $z d[j]$ 表示枚举到位置 $i$ 之前，有 $j$ 个数字与其在序列中的后一个不相等的最长合法序列的长度，那么可以直接写出转移 $d p[i][j]=z d[j-1]+1$ 。</p></li><li><p>nums $[i]=n u m s[x]$, 假设有下标 $a&lt;b&lt;c$, 并且 nums $[a]=$ $n u m s[b]=\operatorname{nums}[c]$, 对于 $c$ 来说如果选取由 $a$ 转移过来计算答案, 那么一定不如 $a \rightarrow b \rightarrow c$ 更优, 所以会选取下标最近的相同的数进行转移。针对这种情况， $d p$ 使用哈希表维护能节省一些空间，并且在哈希表中用 $n u m s[i]$ 替换 $i$ 。</p></li></ul><p>在每一次遍历 $i$ 计算完后更新 $z d$ ，最后的 $z d[k]$ 就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; dp = <span class="keyword">new</span> HashMap&lt;Integer, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] zd = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = nums[i];</span><br><span class="line">            dp.putIfAbsent(v, <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] tmp = dp.get(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                tmp[j] = tmp[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp[j] = Math.max(tmp[j], zd[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                zd[j] = Math.max(zd[j], tmp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zd[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04">https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周感觉还可以吧，有两道周赛做过的题。&lt;/p&gt;
&lt;p&gt;一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。&lt;/p&gt;
&lt;p&gt;本周主题：滑动窗口、枚举、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240902每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description&quot;&gt;Maximize the Confusion of an Exam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240905每日一题—&lt;a href=&quot;https://leetcode.cn/problems/happy-students/description&quot;&gt;Happy Students&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240907每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description&quot;&gt;Find the Maximum Length of a Good Subsequence II&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP10</title>
    <link href="http://silencezheng.top/2024/09/01/article137/"/>
    <id>http://silencezheng.top/2024/09/01/article137/</id>
    <published>2024-08-31T17:12:14.000Z</published>
    <updated>2024-08-31T17:13:14.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DPDPDP</p><p>本周主题：二分查找、动态规划、记忆化搜索</p><p>题目：</p><ul><li>240827每日一题—<a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description">Find the Median of the Uniqueness Array</a></li><li>240828每日一题—<a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description">Minimum Substring Partition of Equal Character Frequency</a><span id="more"></span><h1 id="Find-the-Median-of-the-Uniqueness-Array"><a href="#Find-the-Median-of-the-Uniqueness-Array" class="headerlink" title="Find the Median of the Uniqueness Array"></a>Find the Median of the Uniqueness Array</h1><blockquote><p>Find the Median of the Uniqueness Array</p><p>You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 &lt;= i &lt;= j &lt; nums.length.</p><p>Here, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j.</p><p>Return the median of the uniqueness array of nums.</p><p>Note that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.</p></blockquote></li></ul><p>容易分析出以下解题步骤：</p><ol><li>find out a way to express all the subarrays<ol><li>which means 0,0\1,1...\n-1,n-1; 0,1\1,2...\n-2,n-1; … 0,n-2\1,n-1; 0,n-1</li><li>we can find out there were n+n-1+…+2+1 subarrays in total.</li><li>which means there were (n*(n+1))/2 elements in uniqueness array.</li></ol></li><li>find out how many “distinctors” in there<ol><li>the max value of them should be 1,2,…,n</li><li>we can find a way to calculate them from the base subarrs, like from 1 number</li></ol></li></ol><p>总结一下：</p><ol><li>uniqueness array中一共有(n<em>(n+1))/2个元素，中位数位置在(n</em>(n+1))/4向下取整。</li><li>这些元素可以被分类，其中n个的范围为[1, 1]，n-1个的范围为[1, 2]，…，1个的范围为[1, n]。</li></ol><p>基于以上分析，可以写出暴力法，显然超时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt;[] sets = <span class="keyword">new</span> HashSet[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            sets[i].add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) list.add(sets[i].size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                sets[j].add(nums[i+j]);</span><br><span class="line">                list.add(sets[j].size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list.size()%<span class="number">2</span>==<span class="number">0</span>?list.get(list.size()/<span class="number">2</span>-<span class="number">1</span>):list.get(list.size()/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现上述总结2中存在单调性，考虑使用二分查找。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>设数组 nums 的长度为 $n$, 我们令 $c_t$ 表示数组 nums 中至多含有 $t$ 个不同元素的子数组数目，实际 $t$ 的取值范围为： $t \in[1, \operatorname{distinct}[0 \cdots n-1]]$ 。此时可以发现 $t$ 越大，则 $c_t$ 也越大, 且满足 $c_n=\frac{n \times(n+1)}{2}$ 。我们可以观察到 $c_t$ 呈现单调性, 因此可以考虑使用二分查找, 如果 $c_t&lt;$ median 则 $t$ 一定不是中位数, 因此利用二分查找找到 $t$ 的上限, 此时找到满足 $c_t \geq$ median 时最小的 $t$, 即为唯一性数组的中位数。</p><p>因此需要寻找一种方法计算$c_t$，注意到若数组$nums[i, j]$中至多含有 $t$ 个不同元素，则该数组的所有子数组也至多含有 $t$ 个不同元素。这里$nums[i, j]$可以用一个窗口表示，即双指针。$c_t$随$t$单调不减，可以用二分查找找到合适的t，判定是否合适的条件是是否$c_t \geq$ median，如果是的话则缩小$t$，否则增加$t$。</p><p>子数组越长, 则不同元素个数只会变大或不变，满足单调性。我们用哈希表 cnt 统计窗口子数组 $n u m s[i \cdots j]$ 中不同元素出现的次数。枚举窗口右端点 $i$ ，把 $n u m s[i]$ 加入到哈希表 cnt 中, 即此时 $n u m s[i]$ 出现次数加 1 。如果哈希表 cnt 中元素的数目超过 $t$ ，就不断移出窗口左端点元素 $n u m s[j]$ ，即此时 $n u m s[j]$ 出现的次数减去 1 ，如果 nums $[j]$ 出现次数等于 0 , 则将其从哈希表 cnt 中移除, 直到 cnt 中元素的数目等于 $t$ 为止。此时窗口的右端点为 $i$, 则此时子数组 nums $[j \cdots i]$, nums $[j+1 \cdots i]$, nums $[j+$ $2 \cdots i], \cdots$, nums $[i \cdots i]$ 都满足不同元素数目小于等于 $t$, 一共有 $i-j+1$ 个, 加到总数 tot 中, 最终的总数 $c_t=t o t$ 。我们每次检测是否满足 $c_t \geq$ median, 如果满足则缩小 $t$, 直到找到最小的 $t$ 返回即可。</p><p>实际二分查找时, $t$ 的下限取 1 , 此时一定不存在 0 个元素的子数组, $t$ 的上限为 $n$, 所有子数组的不同元素数目不超过 $n$ 。设 $m=\operatorname{distinct}[0 \cdots n-1]$ ，实际 $t$ 的取值范围为 $[1, m]$ ，且在该区间 $[1, m]$ 上的取值连续，因此一定可以找到属于某个子数组的 distinct 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">long</span> median = ((<span class="keyword">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, median)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测数组中不同元素数目小于等于 t 的连续子数组数目是否大于等于 median</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> t, <span class="keyword">long</span> median)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j，i为左右指针，遍历数组计算c_t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; t) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot &gt;= median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Minimum-Substring-Partition-of-Equal-Character-Frequency"><a href="#Minimum-Substring-Partition-of-Equal-Character-Frequency" class="headerlink" title="Minimum Substring Partition of Equal Character Frequency"></a>Minimum Substring Partition of Equal Character Frequency</h1><blockquote><p>Minimum Substring Partition of Equal Character Frequency</p><p>Given a string s, you need to partition it into one or more balanced<br>substrings. For example, if s == “ababcc” then (“abab”, “c”, “c”), (“ab”, “abc”, “c”), and (“ababcc”) are all valid partitions, but (“a”, “bab”, “cc”), (“aba”, “bc”, “c”), and (“ab”, “abcc”) are not. The unbalanced substrings are bolded.Return the minimum number of substrings that you can partition s into.</p><p>Note: A balanced string is a string where each character in the string occurs the same number of times.</p></blockquote><p>以后看到这种最值选元素的…直接开DP就完了，最差也是等同暴力吧。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先可以确定一定存在分割方案（都分成单字母）。</p><p>对于一个字符串<code>s</code>，从末尾分割出长度为<code>x</code>的平衡子串，则问题变成剩余字符串最少能分割出多少个平衡子串。这将原问题分解为<strong>相似且规模更小的子问题</strong>，可以递归求解。</p><blockquote><p>注 1：从右往左思考，主要是为了方便把递归翻译成递推。从左往右思考也是可以的。<br>注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。<br>注 3：这里的思考可以理解成从“最后一步”出发，划分子问题，即最后一步一定是划分出一个平衡子串，则考虑剩余部分的子问题即可，此时划分出最后一步不影响剩余部分的正确求解。反观贪心，如果尝试一次找到一个最长的平衡子串，则可能影响整体最优，因此这类问题最好通过DP+枚举解决。</p></blockquote><p>下面考虑<strong>状态定义与转移</strong>，假设剩余前缀字符串为<code>s[0...i]</code>，定义状态<code>f(i)</code>为剩余<code>s[0...i]</code>时最少能分割出多少平衡子串，则可以通过枚举<code>j=0,1,..,i</code>，找到平衡子串<code>s[j...i]</code>，则问题转化为求解状态 <code>f(j-1)</code>，实现递归求解<code>f(i)</code>。可以枚举所有<code>j</code>，找到最小的<code>f(j-1)</code>。</p><p>有一种方法可以<strong>快速判断子串平衡</strong>，即在倒序枚举<code>j</code>的同时，用一个哈希表（或者数组）统计子串<code>s[j...i]</code>每个字符的出现次数。如果子串中每个字母的出现次数都相等，那么子串是平衡的。进一步优化，设子串<code>s[j...i]</code>中有<code>k</code>种字母，字母出现次数的最大值为<code>maxCnt</code>。子串是平衡的，当且仅当子串长度<code>i−j+1</code>等于<code>k⋅maxCnt</code>。</p><p>原问题表示为<code>f(n-1)</code>，则可递归计算：<code>f(n-1) = 1+f(x) = ... = m + f(-1) = m</code>。其中<code>x</code>表示第一次求得的最小<code>f(j-1)</code>对应的<code>j</code>，<code>m</code>表示最终划分出的平衡子串数量。分析至此可以写出暴力递归解法一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力递归在数据范围大的情况下依然会TTL，注意到枚举<code>j</code>的过程中存在大量重复计算，考虑使用记忆化减少计算。由于递归函数幂等，可以对<code>入参+返回</code>的组合进行记忆化。使用一个数组<code>memo</code>来记录：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。</li><li>如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。</li></ul><p>注意<code>memo</code>数组的初始值一定不能等于要记忆化的值，否则会跳过首次计算。因为递归求解等同于递归搜索，此类算法亦可称为<strong>记忆化搜索</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = res; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化搜索为自顶向下计算，即从<code>f(n-1)</code>开始递归搜索。动态规划则是考虑自底向上的计算，即从<code>f(0)</code>开始计算。</p><p>定义状态<code>dp[i]</code>表示剩余字符串为<code>s[0...i]</code>时最少能分割出多少平衡子串，则有状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \min _{j=0}^i dp[j]+1，其中s[j...i]平衡</script><p>另外由于递归边界为<code>f(-1)</code>，则用<code>dp[0]</code>存放初始状态<code>dp[0] = 0</code>，剩余状态右移一位（递归边界对应DP初状态）。最终返回结果为<code>dp[n]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(cnt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28">https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;DPDPDP&lt;/p&gt;
&lt;p&gt;本周主题：二分查找、动态规划、记忆化搜索&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240827每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description&quot;&gt;Find the Median of the Uniqueness Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240828每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description&quot;&gt;Minimum Substring Partition of Equal Character Frequency&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP9</title>
    <link href="http://silencezheng.top/2024/08/25/article136/"/>
    <id>http://silencezheng.top/2024/08/25/article136/</id>
    <published>2024-08-24T17:08:04.000Z</published>
    <updated>2024-08-24T17:45:52.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。</p><p>本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP</p><p>题目：</p><ul><li>240819每日一题—<a href="https://leetcode.cn/problems/student-attendance-record-ii/description">Student Attendance Record II</a></li><li>240820每日一题—<a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description">Find Number of Ways to Reach the K-th Stair</a></li><li>240822每日一题—<a href="https://leetcode.cn/problems/minimum-array-end/description">Minimum Array End</a></li><li>240823每日一题—<a href="https://leetcode.cn/problems/find-products-of-elements-of-big-array/description">Find Products of Elements of Big Array</a></li><li>240824每日一题—<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description">Partition to K Equal Sum Subsets</a></li></ul><p>PS：腾子音乐的笔也忒难了<br><span id="more"></span></p><h1 id="Student-Attendance-Record-II-（HARD）"><a href="#Student-Attendance-Record-II-（HARD）" class="headerlink" title="Student Attendance Record II （HARD）"></a>Student Attendance Record II <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Student Attendance Record II</p><p>An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p><ul><li>‘A’: Absent.</li><li>‘L’: Late.</li><li>‘P’: Present.</li></ul><p>Any student is eligible for an attendance award if they meet both of the following criteria:</p><ul><li>The student was absent (‘A’) for strictly fewer than 2 days total.</li><li>The student was never late (‘L’) for 3 or more consecutive days.</li></ul><p>Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.</p></blockquote><p>初次分析时，可得到如下限制：</p><ol><li>最多只能有两个<code>A</code></li><li><code>L</code>可能被<code>A</code>或<code>P</code>隔开</li><li><code>L</code>只能出现单独的一个或连续的两个</li><li><code>L</code>的最大数量为<code>n/3*2 + n-(n/3*2)</code>，即把出勤分为若干个三元组与一个末尾，三元组中均存在两个<code>L</code>，末尾均为<code>L</code></li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>可以使用动态规划计算可奖励的出勤记录的数量。</p><p>由于可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定（由于不会记录连续迟到次数等于或多于 3 的情况，因此非结尾的连续迟到次数一定少于 3，只需要记录结尾连续迟到次数即可）。</p><p>定义 $d p[i][j][k]$ 表示前 $i$ 天有 $j$ 个 ‘$\mathrm{A}$’ 且结尾有连续 $k$ 个 ‘ L ‘ 的可奖励的出勤记录的数量, 其中 $0 \leq i \leq$ $n, 0 \leq j \leq 1,0 \leq k \leq 2$ 。</p><p>当 $i=0$ 时，没有任何出勤记录，此时 ‘ $A$ ‘的数量和结尾连续 ‘ $L$ ‘ 的数量一定是 0 ，因此动态规划的边界情况是 $d p[0][0][0]=1$ 。</p><p>当 $1 \leq i \leq n$ 时， $d p[i][][]$ 的值从 $d p[i-1][][]$ 的值转移得到，计算每个状态的值需要考虑第 $i$ 天的出勤记录:</p><ul><li>如果第 $i$ 天的出勤记录是 ‘ P ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量不变，结尾连续 ${ }^{\prime} \mathrm{L}$ ‘ 的数量清零，因此对 $0 \leq j \leq 1$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][0]:=d p[i][j][0]+\sum_{k=0}^2 d p[i-1][j][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ $A$ ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量加 1 ，结尾连续 ‘ $L$ ‘ 的数量清零，此时要求前 $i-1$ 天的出勤记录记录中的 ‘ $A$ ‘的数量必须为 0 ，否则前 $i$ 天的出勤记录至少有 2 个 ‘ $A$ ‘，不满足可奖励的条件，因此有</li></ul><script type="math/tex; mode=display">d p[i][1][0]:=d p[i][1][0]+\sum_{k=0}^2 d p[i-1][0][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ L ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘A’ 的数量不变，结尾连续 ${ }^{\prime} L$ ‘ 的数量加 1 , 此时要求前 $i-1$ 天的出勤记录记录中的结尾连续 ‘ $L$ ‘ 的数量不超过 1 ，否则前 $i$天的出勤记录的结尾至少有 3 个 ‘ $L$ ‘，不满足可奖励的条件，因此对 $0 \leq j \leq 1$ 和 $1 \leq k \leq 2$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][k]:=d p[i][j][k]+d p[i-1][j][k-1]</script><p>上述状态转移方程对于<code>i=1</code>也适用。计算长度为 n 的所有可奖励的出勤记录的数量，即为计算 <code>dp[n][][]</code> 的所有元素之和。计算过程中需要将结果对<code>10^9+7</code>取模。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[n][j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据状态转移，发现可以利用滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] dpNew = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][<span class="number">0</span>] = (dpNew[j][<span class="number">0</span>] + dp[j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dpNew[<span class="number">1</span>][<span class="number">0</span>] = (dpNew[<span class="number">1</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：逐渐理解DP似乎就是一种限制条件枚举的解法，列出限制，逐条件枚举，例如01背包就是在枚举背包容量。</p><h1 id="Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）"><a href="#Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）" class="headerlink" title="Find Number of Ways to Reach the K-th Stair （HARD）"></a>Find Number of Ways to Reach the K-th Stair <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Find Number of Ways to Reach the K-th Stair</p><p>You are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0.</p><p>Alice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:</p><ul><li>Go down to stair i - 1. This operation cannot be used consecutively or on stair 0.</li><li>Go up to stair i + 2jump. And then, jump becomes jump + 1.<br>Return the total number of ways Alice can reach stair k.<br>Note that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.</li></ul></blockquote><p>容易想到递归方式穷举所有可能性，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveMachine</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> jump, <span class="keyword">boolean</span> canDown, <span class="keyword">int</span> ops)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;ks+<span class="number">1</span>||ops&gt;<span class="number">61</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==ks)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        moveMachine(i+(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, jump), jump+<span class="number">1</span>, <span class="keyword">true</span>, ops+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(canDown) moveMachine(i-<span class="number">1</span>, jump, <span class="keyword">false</span>, ops+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToReachStair</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ks = k;</span><br><span class="line">        moveMachine(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> k==<span class="number">1</span>?<span class="number">4</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力穷举用例只能通过50%，组合数学法见官解。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>两道题都是组合+位运算的类型，例题一必须完全掌握，第二题以目前水平能写个七八十就可以了。</p><h2 id="例题一：Minimum-Array-End"><a href="#例题一：Minimum-Array-End" class="headerlink" title="例题一：Minimum Array End"></a>例题一：Minimum Array End</h2><blockquote><p>Minimum Array End</p><p>You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 &lt;= i &lt; n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.</p><p>Return the minimum possible value of nums[n - 1].</p></blockquote><p>题目还是很好理解的，仔细分析一下就知道是要从<code>x</code>开始逐步往<code>0</code>位上填1，直到填出第n-1个数，填充过程保持数组递增。我的第一次解法如下，会OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储低位到高位的0位置，后续按顺序拼mask就行了</span></span><br><span class="line">        List&lt;Long&gt; masks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(last&lt;=Long.MAX_VALUE&amp;&amp;masks.size()&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((last&amp;x)==<span class="number">0</span>)&#123;</span><br><span class="line">                masks.add(last);</span><br><span class="line">                <span class="keyword">int</span> len = masks.size();</span><br><span class="line">                <span class="comment">// 存储组合</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                    masks.add(last^masks.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>?x:(x^masks.get(n-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到的卡点是计算目标值需要存储前序值，需要压缩空间。可以用另一种视角来看填<code>0</code>位的过程，即把<code>x</code>上的<code>1</code>位都提出来，剩下的位置上按<code>1、2、...、n-1</code>的值去填即可，例如对于<code>x = 100010, n = 4</code>，可以看作是向<code>0000</code>上依次填<code>0001, 0010, 0011</code>，则可得出答案<code>100111</code>。因此，可以确定目标值为把<code>n-1</code>的二进制插入到<code>x</code>的<code>0</code>位中，解法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回值可能的最大位数，即两个long的长度减去各自的前导0，当x全是1时出现。</span></span><br><span class="line">        <span class="keyword">int</span> bitCount = <span class="number">128</span> - Long.numberOfLeadingZeros(n) - Long.numberOfLeadingZeros(x);</span><br><span class="line">        <span class="keyword">long</span> res = x;</span><br><span class="line">        <span class="keyword">long</span> m = n - <span class="number">1</span>; <span class="comment">// 要填到0位的所有bit</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录x中已经填过的bit</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐位查看是否是0</span></span><br><span class="line">            <span class="keyword">if</span> (((res &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 对于是0的位置，如果n-1也为0则不处理，如果为1则用异或填入</span></span><br><span class="line">                <span class="keyword">if</span> (((m &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    res |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二：Find-Products-of-Elements-of-Big-Array-（HARD）"><a href="#例题二：Find-Products-of-Elements-of-Big-Array-（HARD）" class="headerlink" title="例题二：Find Products of Elements of Big Array （HARD）"></a>例题二：Find Products of Elements of Big Array <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h2><blockquote><p>Find Products of Elements of Big Array</p><p>The powerful array of a non-negative integer x is defined as the shortest sorted array of powers of two that sum up to x. The table below illustrates examples of how the powerful array is determined. It can be proven that the powerful array of x is unique.</p><p>The array big_nums is created by concatenating the powerful arrays for every positive integer i in ascending order: 1, 2, 3, and so on. Thus, big_nums begins as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, …].</p><p>You are given a 2D integer matrix queries, where for queries[i] = [fromi, toi, modi] you should calculate (big_nums[fromi] <em> big_nums[fromi + 1] </em> … * big_nums[toi]) % modi.</p><p>Return an integer array answer such that answer[i] is the answer to the ith query.</p></blockquote><p>思路：首先看如何定位<code>bignums[i]</code>的值，从数位的角度考虑，对于<code>01000</code>来说，其之前的元素个数其实就是1、2、3个1在3个格子中有多少种排列，然后再乘元素数<code>C31*1+C32*2+C33*3 = 12</code>，可以应用<strong>组合数的加权求和公式</strong>。用<code>b(x)</code>表示<code>b(x)</code>位为1，其余为0的二进制数，<code>x</code>从0开始，则<code>b(x)</code>的下标为<code>n*2^(n-1)</code>。对于任意一个下标<code>y</code>，考虑遍历<code>i</code>，找到首个小于<code>y</code>的<code>i*2^(i-1)</code>，然后模拟遍历数位找到<code>bignums[from]</code>的值，继续模拟遍历，找到<code>bignums[to]</code>之间的若干值，求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findProductsOfElements(<span class="keyword">long</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">long</span> from = queries[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> to = queries[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> mod = queries[k][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lastSmallInd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> lastPower = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i&lt;=from)&#123;</span><br><span class="line">                    lastSmallInd = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i;</span><br><span class="line">                    lastPower = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> startOuterVal = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, lastPower);</span><br><span class="line">            <span class="keyword">int</span> startVal = startOuterVal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lastSmallInd&lt;from)&#123;</span><br><span class="line">                <span class="comment">// 模拟</span></span><br><span class="line">                <span class="keyword">int</span> startInd = lastSmallInd;</span><br><span class="line">                <span class="keyword">while</span>(startInd&lt;from)&#123;</span><br><span class="line">                    startOuterVal++;</span><br><span class="line">                    <span class="keyword">int</span> tmp = Integer.bitCount(startOuterVal); <span class="comment">// 减去最大的1</span></span><br><span class="line">                    <span class="keyword">if</span>(startInd+tmp&lt;from) startInd+=tmp;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 逐位右移寻找</span></span><br><span class="line">                        <span class="keyword">int</span> sov = startOuterVal;</span><br><span class="line">                        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 元素计数</span></span><br><span class="line">                        <span class="keyword">int</span> bitCnt = -<span class="number">1</span>; <span class="comment">// 位数计数</span></span><br><span class="line">                        <span class="keyword">while</span> (startInd+cnt&lt;from) &#123;</span><br><span class="line">                            <span class="comment">// 判断末位是否为1</span></span><br><span class="line">                            <span class="keyword">if</span>((sov&amp;<span class="number">1</span>)==<span class="number">1</span>) cnt++;</span><br><span class="line">                            sov&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                            bitCnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startVal = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, bitCnt);</span><br><span class="line">                        startInd+=cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始计算结果</span></span><br><span class="line">            <span class="keyword">long</span> mul = startVal;</span><br><span class="line">            <span class="keyword">long</span> remain = to-from; <span class="comment">// to-from个元素还没计算</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(remain&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(startVal&lt;startOuterVal)&#123;</span><br><span class="line">                    startVal&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 有重合的1</span></span><br><span class="line">                    <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>)&#123;</span><br><span class="line">                        remain--;</span><br><span class="line">                        mul*=startVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                startOuterVal++;</span><br><span class="line">                startVal = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>) remain--;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            ans[k] = (<span class="keyword">int</span>) (mul%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法可以通过95%的用例，全通的解法可以参考官解。</p><h1 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h1><blockquote><p>Partition to K Equal Sum Subsets</p><p>Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>1 &lt;= k &lt;= nums.length &lt;= 16<br>1 &lt;= nums[i] &lt;= 10^4<br>The frequency of each element is in the range [1, 4].</p></blockquote><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><blockquote><p>状态压缩就是使用某种方法，简明扼要地以最小代价来表示某种状态，通常是用一串01数字（二进制数）来表示各个点的状态。这就要求使用状态压缩的对象的点的状态必须只有两种，0 或 1；当然如果有三种状态用三进制来表示也未尝不可。</p><p>状态压缩的目的一方面是缩小了数据存储的空间，另一方面是在状态对比和状态整体处理时能够提高效率。这样就要求状态数据中的单元个数不能太大，比如用int来表示一个状态的时候，状态的单元个数不能超过32（32位的机器），所以题目一般都是至少有一维的数据范围很小。</p></blockquote><p>状压DP就是使用状态压缩的动态规划。动态规划问题通常有两种，一种是对递归问题的记忆化求解，另一种是把大问题看作是多阶段的决策求解。这里用的便是后一种，这带来一个需求，即存储之前的状态，再由状态及状态对应的值推演出状态转移方程最终得到最优解。</p><p>回到本题，题目给定长度为 $n$ 的数组 $nums$，和整数 $k$，我们需要判断是否能将数组分成 $k$ 个总和相等的非空子集。首先计算数组的和 $all$，如果 $all$ 不是 $k$ 的倍数，那么不可能能有合法方案，此时直接返回 $False$。否则我们需要得到 $k$ 个和为 $per= all/k$的集合。</p><p>数组长度在16以内，则可以用一个整数 $S$ 来表示当前可用的数字集合：从低位到高位, 第 $i$ 位为 0 则表示数字 nums $[i]$ 可以使用, 否则表示 nums [i] 已被使用。然后我们用 $d p[S]$ 来表示在可用的数字状态为 $S$ 的情况下是否可能可行, 初始全部状态为记录为不可行状态 False, 只记 $d p[0]=$ True 为可行状态。</p><p>我们每次对于当前状态下从可用的数字中选择一个数字, 若此时选择全部数字取模后小于等于 per。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终返回 $d p[U]$即可, 其中 $U$ 表示全部数字使用的集合状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> all = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (all % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> per = all / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; per) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始DP</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 所有可能的状态</span></span><br><span class="line">        <span class="keyword">int</span>[] curSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 状态对应的总和？</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 状态i中j物品可用</span></span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 定位下一个状态，即选了j物品后的状态</span></span><br><span class="line">                    <span class="keyword">int</span> next = i | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="comment">// 如果是不可用状态，说明还没更新过</span></span><br><span class="line">                    <span class="keyword">if</span> (!dp[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对per取余表示删除已存满的子集</span></span><br><span class="line">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class="line">                        dp[next] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全为1的状态下是否可用，即取走全部元素后是否可行</span></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/">https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/</a><br>[2] <a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve">https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。&lt;/p&gt;
&lt;p&gt;本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240819每日一题—&lt;a href=&quot;https://leetcode.cn/problems/student-attendance-record-ii/description&quot;&gt;Student Attendance Record II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240820每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description&quot;&gt;Find Number of Ways to Reach the K-th Stair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240822每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-array-end/description&quot;&gt;Minimum Array End&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240823每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-products-of-elements-of-big-array/description&quot;&gt;Find Products of Elements of Big Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240824每日一题—&lt;a href=&quot;https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description&quot;&gt;Partition to K Equal Sum Subsets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS：腾子音乐的笔也忒难了&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job源码阅读（一）：定时任务执行链路分析</title>
    <link href="http://silencezheng.top/2024/08/19/article135/"/>
    <id>http://silencezheng.top/2024/08/19/article135/</id>
    <published>2024-08-19T15:15:50.000Z</published>
    <updated>2024-08-19T15:25:11.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>xxl-job源码阅读第一章：定时任务执行链路分析</p><p>一时兴起，花一下午看了一遍这部分源码，写的不错。</p><p>PS：写完才发现有官方文档讲解…尴尬😅<br><span id="more"></span></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="部署xxl-job-admin"><a href="#部署xxl-job-admin" class="headerlink" title="部署xxl-job-admin"></a>部署xxl-job-admin</h2><p>官网文档秒了。</p><p>地址：<a href="https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8</a></p><h2 id="装载配置类"><a href="#装载配置类" class="headerlink" title="装载配置类"></a>装载配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandlerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses:http://ip:8008/xxl-job-admin-1.8.2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname:appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath:./xxlLogs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        XxlJobExecutor xxlJobExecutor = <span class="keyword">new</span> XxlJobExecutor();</span><br><span class="line">        xxlJobExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobExecutor.setAppName(appName);</span><br><span class="line">        xxlJobExecutor.setLogPath(logPath);</span><br><span class="line">        <span class="keyword">return</span> xxlJobExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现任务接口"><a href="#实现任务接口" class="headerlink" title="实现任务接口"></a>实现任务接口</h2><p>注意两点：</p><ol><li><code>@JobHandler</code>注解用于唯一识别任务</li><li>实现了<code>IJobHandler</code>接口才会被加载到任务列表中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@JobHandler(value = &quot;AutoSendEmailScheduler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoSendEmailScheduler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdenAutoUpdateAndSendEmail uniqueIdenAutoUpdateAndSendEmail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String startDate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler start, startDate:&#123;&#125;&quot;</span>, startDate);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ReturnT&lt;String&gt; result = <span class="keyword">new</span> ReturnT&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uniqueIdenAutoUpdateAndSendEmail.autoSendEmail(startDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;AutoSendEmailScheduler fail, startDate:&#123;&#125;&quot;</span>, startDate, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setCode(SUCCESS_CODE);</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler end, cost &#123;&#125;ms&quot;</span>, System.currentTimeMillis() - start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Xxl-job-Server端源码分析"><a href="#Xxl-job-Server端源码分析" class="headerlink" title="Xxl-job Server端源码分析"></a>Xxl-job Server端源码分析</h1><p>版本：xxl-job-core1.9.1</p><h2 id="统一入口-—-执行器"><a href="#统一入口-—-执行器" class="headerlink" title="统一入口 — 执行器"></a>统一入口 — 执行器</h2><p>执行器即<code>XxlJobExecutor</code>，被注册为上下文，主要是为了能用<code>ApplicationContext</code>获取各种信息，例如Bean信息等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="加载任务处理器"><a href="#加载任务处理器" class="headerlink" title="加载任务处理器"></a>加载任务处理器</h3><p>把刚才自己定义的定时任务处理器和其他所有加入了<code>@JobHandler</code>注解的类加载进来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, IJobHandler&gt; jobHandlerRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IJobHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IJobHandler <span class="title">registJobHandler</span><span class="params">(String name, IJobHandler jobHandler)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobHandlerRepository.put(name, jobHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initJobHandlerRepository</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init job handler action</span></span><br><span class="line">    Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceBeanMap!=<span class="keyword">null</span> &amp;&amp; serviceBeanMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (serviceBean <span class="keyword">instanceof</span> IJobHandler)&#123;</span><br><span class="line">                String name = serviceBean.getClass().getAnnotation(JobHandler.class).value();</span><br><span class="line">                IJobHandler handler = (IJobHandler) serviceBean;</span><br><span class="line">                <span class="keyword">if</span> (loadJobHandler(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;xxl-job jobhandler naming conflicts.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                registJobHandler(name, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化客户端（调度中心）"><a href="#初始化客户端（调度中心）" class="headerlink" title="初始化客户端（调度中心）"></a>初始化客户端（调度中心）</h3><p>xxl-job是C/S架构的，客户端是RPC服务的调用者，即<code>xxl-job-admin</code>，带有一个前端。这里可以有多个调度中心，是因为支持集群部署。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adminAddresses!=<span class="keyword">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (address!=<span class="keyword">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// http://ip:port/xxl-job-admin-1.8.2 + /api</span></span><br><span class="line">                String addressUrl = address.concat(AdminBiz.MAPPING);</span><br><span class="line">                AdminBiz adminBiz = (AdminBiz) <span class="keyword">new</span> NetComClientProxy(AdminBiz.class, addressUrl, accessToken).getObject();</span><br><span class="line">                <span class="keyword">if</span> (adminBizList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    adminBizList = <span class="keyword">new</span> ArrayList&lt;AdminBiz&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                adminBizList.add(adminBiz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; <span class="title">getAdminBizList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminBizList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化RPC服务器工厂"><a href="#初始化RPC服务器工厂" class="headerlink" title="初始化RPC服务器工厂"></a>初始化RPC服务器工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetComServerFactory serverFactory = <span class="keyword">new</span> NetComServerFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExecutorServer</span><span class="params">(<span class="keyword">int</span> port, String ip, String appName, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// valid param</span></span><br><span class="line">    port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start server</span></span><br><span class="line">    NetComServerFactory.putService(ExecutorBiz.class, <span class="keyword">new</span> ExecutorBizImpl());   <span class="comment">// rpc-service, base on jetty</span></span><br><span class="line">    NetComServerFactory.setAccessToken(accessToken);</span><br><span class="line">    serverFactory.start(port, ip, appName); <span class="comment">// jetty + registry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务执行线程池"><a href="#任务执行线程池" class="headerlink" title="任务执行线程池"></a>任务执行线程池</h3><p>并没有用线程池，而是一个并发哈希表。这里有个疑问，如果并发线程量过大是不是有安全问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, JobThread&gt; JobThreadRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">registJobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread newJobThread = <span class="keyword">new</span> JobThread(jobId, handler);</span><br><span class="line">    newJobThread.start();</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job regist JobThread success, jobId:&#123;&#125;, handler:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;jobId, handler&#125;);</span><br><span class="line"></span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.put(jobId, newJobThread);  <span class="comment">// putIfAbsent | oh my god, map&#x27;s put method return the old value!!!</span></span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newJobThread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeJobThread</span><span class="params">(<span class="keyword">int</span> jobId, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.remove(jobId);</span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">loadJobThread</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>&#123;</span><br><span class="line">    JobThread jobThread = JobThreadRepository.get(jobId);</span><br><span class="line">    <span class="keyword">return</span> jobThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>该服务器用于获取请求、执行任务，是核心的执行逻辑。</p><p>主体是封装了一个jetty服务器（servlet容器，HTTP协议），利用反射实现服务调用。</p><p>相关类如下：</p><ul><li>NetComServerFactory：RPC服务器工厂类，同时负责维护RPC服务。</li><li>JettyServer：核心类，真正运行的服务器。</li><li>JettyServerHandler：jetty的handler，负责执行任务。</li><li>ExecutorBiz：包含RPC方法的接口，被工厂类加载并执行请求调用的RPC方法。</li><li>ExecutorBizImpl：真正提供服务的类，实现了ExecutorBiz接口。</li><li>JobThread：真正执行任务（完成Job）的线程，维护一个阻塞队列用于执行任务。</li><li>ExecutorRegistryThread：用于将服务器注册到客户端上，或取消注册。</li><li>TriggerCallbackThread：维护一个阻塞队列，用于对任务执行结果实施callback。</li></ul><h3 id="NetComServerFactory"><a href="#NetComServerFactory" class="headerlink" title="NetComServerFactory"></a>NetComServerFactory</h3><p>入口中初始化的就是这个Server工厂，工厂里面内容很简单，简化后如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器，核心类</span></span><br><span class="line">JettyServer server = <span class="keyword">new</span> JettyServer(); <span class="comment">//有start(), destroy()两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC服务存储，通过反射加载进来</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 认证token，携带正确token的请求才能被执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中放入ExecutorBiz的方法，Key是接口名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putService</span><span class="params">(Class&lt;?&gt; iface, Object serviceBean)</span></span>&#123;</span><br><span class="line">    serviceMap.put(iface.getName(), serviceBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化中设置token的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAccessToken</span><span class="params">(String accessToken)</span> </span>&#123;</span><br><span class="line">    NetComServerFactory.accessToken = accessToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正实现RPC服务调用的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcResponse <span class="title">invokeService</span><span class="params">(RpcRequest request, Object serviceBean)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">        String methodName = request.getMethodName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] parameters = request.getParameters();</span><br><span class="line"></span><br><span class="line">        FastClass serviceFastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">        Object result = serviceFastMethod.invoke(serviceBean, parameters);</span><br><span class="line"></span><br><span class="line">        response.setResult(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        response.setError(t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JettyServer"><a href="#JettyServer" class="headerlink" title="JettyServer"></a>JettyServer</h3><p><code>JettyServer</code>包含服务器（非阻塞线程池）、注册线程、回调线程三部分。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> String ip, <span class="keyword">final</span> String appName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The Server</span></span><br><span class="line">                server = <span class="keyword">new</span> Server(<span class="keyword">new</span> ExecutorThreadPool());  <span class="comment">// 非阻塞</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// HTTP connector</span></span><br><span class="line">                ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);</span><br><span class="line">                connector.setHost(ip);</span><br><span class="line">                connector.setPort(port);</span><br><span class="line">                server.setConnectors(<span class="keyword">new</span> Connector[]&#123;connector&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set a handler</span></span><br><span class="line">                HandlerCollection handlerc =<span class="keyword">new</span> HandlerCollection();</span><br><span class="line">                handlerc.setHandlers(<span class="keyword">new</span> Handler[]&#123;<span class="keyword">new</span> JettyServerHandler()&#125;);</span><br><span class="line">                server.setHandler(handlerc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start server</span></span><br><span class="line">                server.start();</span><br><span class="line">                <span class="comment">// Start Registry-Server</span></span><br><span class="line">                ExecutorRegistryThread.getInstance().start(port, ip, appName);</span><br><span class="line">                <span class="comment">// Start Callback-Server</span></span><br><span class="line">                TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">                server.join();  <span class="comment">// block until thread stopped</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// daemon, service jvm, user thread leave &gt;&gt;&gt; daemon leave &gt;&gt;&gt; jvm leave</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destroy Registry-Server</span></span><br><span class="line">        ExecutorRegistryThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// destroy Callback-Server</span></span><br><span class="line">        TriggerCallbackThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// 关闭服务器</span></span><br><span class="line">        server.stop();</span><br><span class="line">        server.destroy();</span><br><span class="line">        <span class="comment">// 关闭总线程</span></span><br><span class="line">        <span class="keyword">if</span> (thread.isAlive()) &#123;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是这里的<code>ExecutorThreadPool</code>是jetty自己封装的<code>ThreadPoolExecutor</code>，最大线程池大小为256, 线程timeout为1分钟，并使用了<code>Unbounded LinkedBlockingQueue</code>作为任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using an unbounded queue makes the maxThreads parameter useless</span></span><br><span class="line">    <span class="comment">// Refer to ThreadPoolExecutor javadocs for details</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">256</span>, <span class="number">256</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JettyServerHandler"><a href="#JettyServerHandler" class="headerlink" title="JettyServerHandler"></a>JettyServerHandler</h3><p>这个类就是用来衔接jetty接到的请求和实际处理方法<code>NetComServerFactory#invokeService</code>的，对入参出参和异常进行一些处理。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServerHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// invoke</span></span><br><span class="line">        RpcResponse rpcResponse = doInvoke(request);</span><br><span class="line">        <span class="comment">// serialize response</span></span><br><span class="line">        <span class="keyword">byte</span>[] responseBytes = HessianSerializer.serialize(rpcResponse);</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        baseRequest.setHandled(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        out.write(responseBytes);</span><br><span class="line">        out.flush();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RpcResponse <span class="title">doInvoke</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// deserialize request</span></span><br><span class="line">            <span class="keyword">byte</span>[] requestBytes = HttpClientUtil.readBytes(request);</span><br><span class="line">            <span class="keyword">if</span> (requestBytes == <span class="keyword">null</span> || requestBytes.length==<span class="number">0</span>) &#123;</span><br><span class="line">                RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                rpcResponse.setError(<span class="string">&quot;RpcRequest byte[] is null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> rpcResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) HessianSerializer.deserialize(requestBytes, RpcRequest.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// invoke</span></span><br><span class="line">            RpcResponse rpcResponse = NetComServerFactory.invokeService(rpcRequest, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            rpcResponse.setError(<span class="string">&quot;Server-error:&quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ExecutorBizImpl"><a href="#ExecutorBizImpl" class="headerlink" title="ExecutorBizImpl"></a>ExecutorBizImpl</h3><p>真正执行任务的类，实现了<code>ExecutorBiz</code>接口。</p><p><code>ExecutorBiz</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorBiz</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 心跳，用于确认服务器状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">beat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 判断任务是否在执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">idleBeat</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 终止任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">kill</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 读日志，返回日志内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;LogResult&gt; <span class="title">log</span><span class="params">(<span class="keyword">long</span> logDateTim, <span class="keyword">int</span> logId, <span class="keyword">int</span> fromLineNum)</span></span>;</span><br><span class="line">    <span class="comment">// 根据参数执行任务，TriggerParam里携带jobId</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ExecutorBizImpl</code>通过上下文<code>XxlJobExecutor</code>获取资源（例如<code>JobThread</code>）实现各个功能，这里我们只关注<code>run</code>方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加载已有线程，没有则都置为空</span></span><br><span class="line">    <span class="comment">// load old：jobHandler + jobThread</span></span><br><span class="line">    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());</span><br><span class="line">    IJobHandler jobHandler = jobThread!=<span class="keyword">null</span>?jobThread.getHandler():<span class="keyword">null</span>;</span><br><span class="line">    String removeOldReason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有几种执行模式，bean、glue和script，通常自己实现的是用bean模式，需要验证一下</span></span><br><span class="line">    <span class="comment">// 验证如果原来的jobHandler不对，那么也要置空</span></span><br><span class="line">    <span class="comment">// valid：jobHandler + jobThread</span></span><br><span class="line">    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());</span><br><span class="line">    <span class="keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// new jobhandler</span></span><br><span class="line">        IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        <span class="keyword">if</span> (jobThread!=<span class="keyword">null</span> &amp;&amp; jobHandler != newJobHandler) &#123;</span><br><span class="line">            <span class="comment">// change handler, need kill old thread</span></span><br><span class="line">            removeOldReason = <span class="string">&quot;更换JobHandler或更换任务模式,终止旧任务线程&quot;</span>;</span><br><span class="line">            jobThread = <span class="keyword">null</span>;</span><br><span class="line">            jobHandler = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = newJobHandler;</span><br><span class="line">            <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job handler [&quot;</span> + triggerParam.getExecutorHandler() + <span class="string">&quot;] not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());</span><br><span class="line">                jobHandler = <span class="keyword">new</span> GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (glueTypeEnum!=<span class="keyword">null</span> &amp;&amp; glueTypeEnum.isScript()) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = <span class="keyword">new</span> ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;glueType[&quot;</span> + triggerParam.getGlueType() + <span class="string">&quot;] is not valid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据设置的阻塞策略，选择是否丢弃已有线程</span></span><br><span class="line">    <span class="comment">// executor block strategy</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// discard when running</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;阻塞处理策略-生效：&quot;</span>+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// kill running jobThread</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                removeOldReason = <span class="string">&quot;阻塞处理策略-生效：&quot;</span> + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();</span><br><span class="line">                jobThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just queue trigger</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册新的任务线程并添加任务</span></span><br><span class="line">    <span class="comment">// replace thread (new or exists invalid)</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push data to queue</span></span><br><span class="line">    ReturnT&lt;String&gt; pushResult = jobThread.pushTriggerQueue(triggerParam);</span><br><span class="line">    <span class="keyword">return</span> pushResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JobThread"><a href="#JobThread" class="headerlink" title="JobThread"></a>JobThread</h3><p>这是最终执行任务的线程，通过前面的分析可以看到，一项任务被最终交付给了TriggerQueue，并等待完成执行回调实现异步执行。</p><p>那么什么是TriggerQueue？它是一个存放Trigger参数的<code>LinkedBlockingQueue</code>阻塞队列，用于存放待执行的任务。</p><p><code>JobThread</code>会按指定的时间间隔轮询该队列，尝试取出任务执行。任务执行结束后，将结果交给Callback线程执行回调。</p><p>还有一些其他细节，例如唯一日志ID的维护（通过Set），终止任务的实现（多种情况），可以参考代码分析。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(JobThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> jobId;</span><br><span class="line">    <span class="keyword">private</span> IJobHandler handler;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;TriggerParam&gt; triggerQueue;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashSet&lt;Integer&gt; triggerLogIdSet;     <span class="comment">// avoid repeat trigger for the same TRIGGER_LOG_ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String stopReason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;    <span class="comment">// if running job</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleTimes = <span class="number">0</span>;          <span class="comment">// idel times</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobId = jobId;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.triggerQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;TriggerParam&gt;();</span><br><span class="line">        <span class="keyword">this</span>.triggerLogIdSet = <span class="keyword">new</span> ConcurrentHashSet&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IJobHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new trigger to queue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> triggerParam</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">pushTriggerQueue</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// avoid repeat</span></span><br><span class="line">        <span class="keyword">if</span> (triggerLogIdSet.contains(triggerParam.getLogId())) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; repeate trigger job, logId:&#123;&#125;&quot;</span>, triggerParam.getLogId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;repeate trigger job, logId:&quot;</span> + triggerParam.getLogId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        triggerLogIdSet.add(triggerParam.getLogId());</span><br><span class="line">        triggerQueue.add(triggerParam);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kill job thread</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stopReason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">(String stopReason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread.interrupt只支持终止线程的阻塞状态(wait、join、sleep)，</span></span><br><span class="line"><span class="comment">         * 在阻塞出抛出InterruptedException异常,但是并不会终止运行的线程本身；</span></span><br><span class="line"><span class="comment">         * 所以需要注意，此处彻底销毁本线程，需要通过共享变量方式；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.stopReason = stopReason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is running job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunningOrHasQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> running || triggerQueue.size()&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute</span></span><br><span class="line">        <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">            idleTimes++;</span><br><span class="line"></span><br><span class="line">            TriggerParam triggerParam = <span class="keyword">null</span>;</span><br><span class="line">            ReturnT&lt;String&gt; executeResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// to check toStop signal, we need cycle, so wo cannot use queue.take(), instand of poll(timeout)</span></span><br><span class="line">                triggerParam = triggerQueue.poll(<span class="number">3L</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    running = <span class="keyword">true</span>;</span><br><span class="line">                    idleTimes = <span class="number">0</span>;</span><br><span class="line">                    triggerLogIdSet.remove(triggerParam.getLogId());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// log filename, like &quot;logPath/yyyy-MM-dd/9999.log&quot;</span></span><br><span class="line">                    String logFileName = XxlJobFileAppender.makeLogFileName(<span class="keyword">new</span> Date(triggerParam.getLogDateTim()), triggerParam.getLogId());</span><br><span class="line">                    XxlJobFileAppender.contextHolder.set(logFileName);</span><br><span class="line">                    ShardingUtil.setShardingVo(<span class="keyword">new</span> ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// execute</span></span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute start -----------&lt;br&gt;----------- Param:&quot;</span> + triggerParam.getExecutorParams());</span><br><span class="line">                    executeResult = handler.execute(triggerParam.getExecutorParams());</span><br><span class="line">                    <span class="keyword">if</span> (executeResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        executeResult = IJobHandler.FAIL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(finish) -----------&lt;br&gt;----------- ReturnT:&quot;</span> + executeResult);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (idleTimes &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                        XxlJobExecutor.removeJobThread(jobId, <span class="string">&quot;excutor idel times over limit.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (toStop) &#123;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread toStop, stopReason:&quot;</span> + stopReason);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">                e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));</span><br><span class="line">                String errorMsg = stringWriter.toString();</span><br><span class="line">                executeResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, errorMsg);</span><br><span class="line"></span><br><span class="line">                XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread Exception:&quot;</span> + errorMsg + <span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(error) -----------&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(triggerParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// callback handler info</span></span><br><span class="line">                    <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                        <span class="comment">// commonm</span></span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), executeResult));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// is killed</span></span><br><span class="line">                        ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [业务运行中，被强制终止]&quot;</span>);</span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback trigger request in queue</span></span><br><span class="line">        <span class="keyword">while</span>(triggerQueue !=<span class="keyword">null</span> &amp;&amp; triggerQueue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TriggerParam triggerParam = triggerQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// is killed</span></span><br><span class="line">                ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [任务尚未执行，在调度队列中被终止]&quot;</span>);</span><br><span class="line">                TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// destroy</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job JobThread stoped, hashCode:&#123;&#125;&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TriggerCallbackThread"><a href="#TriggerCallbackThread" class="headerlink" title="TriggerCallbackThread"></a>TriggerCallbackThread</h3><p>回调线程，用于处理执行完的任务结果，通知调度中心执行完毕。</p><p>同样的，使用一个阻塞队列存放待回调的执行结果。</p><p>代码简化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriggerCallbackThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TriggerCallbackThread instance = <span class="keyword">new</span> TriggerCallbackThread();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TriggerCallbackThread <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// job results callback queue</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt; callBackQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pushCallBack</span><span class="params">(HandleCallbackParam callback)</span></span>&#123;</span><br><span class="line">        getInstance().callBackQueue.add(callback);</span><br><span class="line">        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, push callback request, logId:&#123;&#125;&quot;</span>, callback.getLogId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callback thread</span></span><br><span class="line">    <span class="keyword">private</span> Thread triggerCallbackThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        triggerCallbackThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// normal callback</span></span><br><span class="line">                <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        HandleCallbackParam callback = getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// callback list param</span></span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line">                            <span class="comment">// callback, will retry if error</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// last callback</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                    <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                    <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        doCallback(callbackParamList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        triggerCallbackThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        triggerCallbackThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// interrupt and wait</span></span><br><span class="line">        triggerCallbackThread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerCallbackThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do callback, will retry if error</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span></span>&#123;</span><br><span class="line">        <span class="comment">// callback, will retry if error</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="keyword">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackResult = ReturnT.SUCCESS;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback success, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback fail, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback error, callbackParamList：&#123;&#125;&quot;</span>, callbackParamList, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>总结一下，一个定时任务（run请求）从调度中心出发到执行完毕的链路为：<br><code>JettyServer</code>-&gt;<br>    <code>JettyServerHandler</code>-&gt;<br>        <code>NetComServerFactory#invokeService</code>-&gt;<br>            <code>ExecutorBizImpl#run</code>-&gt;<br>                    <code>JobThread</code>-&gt;<br>                        <code>TriggerCallbackThread</code>-&gt;<br>                            <code>AdminBiz#callback</code></p><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;xxl-job源码阅读第一章：定时任务执行链路分析&lt;/p&gt;
&lt;p&gt;一时兴起，花一下午看了一遍这部分源码，写的不错。&lt;/p&gt;
&lt;p&gt;PS：写完才发现有官方文档讲解…尴尬😅&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="xxl-job" scheme="http://silencezheng.top/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP3</title>
    <link href="http://silencezheng.top/2024/08/18/article134/"/>
    <id>http://silencezheng.top/2024/08/18/article134/</id>
    <published>2024-08-18T15:32:17.000Z</published>
    <updated>2024-08-18T15:33:52.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。</p><p>本周主题：动态规划、贪心</p><p>题目：</p><ul><li>240619每日一题—<a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description">Maximum Strictly Increasing Cells in a Matrix</a></li><li>240622每日一题—<a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">Lexicographically Smallest Beautiful String</a><span id="more"></span>这两道Hard题稍微看看理解一下就行了，暂时没太多可归纳的，可记忆的点就是二维排序和回文判别（只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串）。</li></ul><h1 id="动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix"><a href="#动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix" class="headerlink" title="动态规划 — Maximum Strictly Increasing Cells in a Matrix"></a>动态规划 — Maximum Strictly Increasing Cells in a Matrix</h1><blockquote><p>Maximum Strictly Increasing Cells in a Matrix</p><p>Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell.</p><p>From the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p><p>Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.</p><p>Return an integer denoting the maximum number of cells that can be visited.</p></blockquote><p>设 <strong>$d[i][j]$ 为移动到单元格 $(i, j)$ 的最大步数</strong>, 其中 $(i, j)$ 可以作为起始单元格, 也可以是从其他单元格移动而来。那么我们会考虑从第 $i$ 行以及第 $j$ 列上矩阵数值小于 $\operatorname{mat}[i][j]$ 的位置进行转移, 即取以下数值中的最大值:</p><ul><li>第 $i$ 行： $\max \left(d[i]\left[j^{\prime}\right]+1\right)$ ，其中 $\operatorname{mat}[i]\left[j^{\prime}\right]&lt;\operatorname{mat}[i][j]$ ；</li><li>第 $j$ 列： $\max \left(d\left[l^{\prime}\right][j]+1\right)$ ，其中 $\operatorname{mat}\left[i^{\prime}\right][j]&lt;\operatorname{mat}[[][j]$ 。</li></ul><p>因此, 整个状态空间在进行转移时是有序的, 我们可以对 mat 进行排序, 从小到大进行转移。但在转移时, 每个状态都要扫描一遍对应的行和列, 时间复杂度为 $O(n+m)$, 而整体求解的时间复杂度为 $O(n m(n+m))$, 可能会超时, 因此需要进行优化。</p><p>考虑到所有的 $d[i][j]$ 在更新时, 值只会越来越大, 而转移过程中我们只考虑对应行和对应列上 $d$ 的最大值（由于大于 mat $[i][j]$ 的位置还末遍历到, 它们的状态还末更新, 可设置为 0 )。因此, 设置长度为 $m$ 的数组 row 来维护每一行 $d$ 的最大值, 设置长度为 $n$ 的数组 $c o l$ 来维护每一列的最大值，这样一来:</p><script type="math/tex; mode=display">d[i][j]=\max (\operatorname{row}[i], \operatorname{col}[j])+1</script><p>在每次更新了 $d[i][j]$ 后, 需要更新 $r o w[i]$ 和 $col[j]$ 。另外需要注意的是, 由于 mat 中可能包含相同数字, 我们需要同时更新它们的 $d$ 值, 然后再同时更新它们对应的 row 和 col。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIncreasingCells</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                mp.putIfAbsent(mat[i][j], <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">                mp.get(mat[i][j]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(mp.keySet());</span><br><span class="line">        Collections.sort(keys);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keys) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; pos = mp.get(key);</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 存放相同数值的答案，便于后续更新 row 和 col</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : pos) &#123;</span><br><span class="line">                res.add(Math.max(row[arr[<span class="number">0</span>]], col[arr[<span class="number">1</span>]]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pos.get(i);</span><br><span class="line">                <span class="keyword">int</span> d = res.get(i);</span><br><span class="line">                row[arr[<span class="number">0</span>]] = Math.max(row[arr[<span class="number">0</span>]], d);</span><br><span class="line">                col[arr[<span class="number">1</span>]] = Math.max(col[arr[<span class="number">1</span>]], d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(row).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心-—-Lexicographically-Smallest-Beautiful-String"><a href="#贪心-—-Lexicographically-Smallest-Beautiful-String" class="headerlink" title="贪心 — Lexicographically Smallest Beautiful String"></a>贪心 — Lexicographically Smallest Beautiful String</h1><blockquote><p>Lexicographically Smallest Beautiful String</p><p>A string is beautiful if:</p><ul><li>It consists of the first k letters of the English lowercase alphabet.</li><li>It does not contain any substring of length 2 or more which is a palindrome.</li></ul><p>You are given a beautiful string s of length n and a positive integer k.</p><p>Return the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.</p><p>A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.</p><ul><li>For example, “abcd” is lexicographically larger than “abcc” because the first position they differ is at the fourth character, and d is greater than c.</li></ul></blockquote><p>首先分析一下美丽字符串的第二个条件：不包含任何长度为 2 或者更长的回文字符串。长度为 2 的回文字符串是两个相同字符构成的字符串。长度为 3 的回文字符串中也有两个相同字符，但下标之差为 2。而任何长度为 2 或者更长的回文字符串，都包含一个长度为 2 或者 3 的回文字符串。因此，<strong>只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串</strong>。</p><p>接下来看其他要求，返回的美丽字符串需要字典序大于 s 并且字典序最小。贪心的思路是修改 s 的末尾字符，一点点将字符变大，如果在变大的同时能够满足美丽字符串的两个条件，那么我们就找到了要求的美丽字符串。修改后的字符不能与前两个字符相同，因此我们在将字符变大的时候只需要将字符逐步变大三次，就能判断出修改当前字符能否满足美丽字符串的条件。如果修改末尾字符达不到美丽字符串的条件，则我们需要将被修改的字符改为倒数第二个字符，仍然按照之前的思路一点点增大，并判断是否满足美丽字符串的两个条件。我们从末尾字符开始，往前一点点判断是否可以修改当前字符来找到目标美丽字符串。一旦我们第一次找到了合适的下标，我们就可以来修改字符来达到目标条件。</p><p>首先我们需要修改寻找到的下标的字符，将其修改为最小的满足美丽字符串条件的字符。接下来需要修改它右边的字符。因为之前修改的字符已经能保证返回的字符串在字典序上大于 s，我们只需要将后续的字符修改得尽可能小即可，因为每个字符需要与前两个字符不同，因此每个字符只需要遍历 <code>‘a’∼‘c’</code> 即可。因为 $k≥ 4$，所以接下来修改的字符一定都能满足美丽字符串的条件。</p><p>在代码实现上，我们先用一个循环从 $n−1$ 开始，往前遍历来寻找第一个被修改的字符，找到之后，再用另一个函数 $generate(s,idx,offset)$ 来生成修改后的字符，其中 $idx$ 是我们找到的下标，$offset$ 是将这个下标的字符增大的偏移量。最后返回修改后的字符，如果我们未能找到目标下标，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestBeautifulString</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(s.charAt(i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// s.charAt(i) - &#x27;a&#x27; + j 需要+1才能与k比较，因为k从1计数</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) - <span class="string">&#x27;a&#x27;</span> + j + <span class="number">1</span> &lt;= k &amp;&amp; !blockedCharacters.contains((<span class="keyword">char</span>) (s.charAt(i) + j))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> generate(s, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        res[idx] += offset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(res[i - j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// abc里面一定有一个可用的，因为blockedCharacters只有两个字符</span></span><br><span class="line">                <span class="keyword">if</span> (!blockedCharacters.contains((<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j))) &#123;</span><br><span class="line">                    res[i] = (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/">https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/</a><br>[2] <a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/">https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、贪心&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240619每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description&quot;&gt;Maximum Strictly Increasing Cells in a Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240622每日一题—&lt;a href=&quot;https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/&quot;&gt;Lexicographically Smallest Beautiful String&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP2</title>
    <link href="http://silencezheng.top/2024/08/18/article133/"/>
    <id>http://silencezheng.top/2024/08/18/article133/</id>
    <published>2024-08-18T10:44:02.000Z</published>
    <updated>2024-08-18T10:52:27.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周周赛菜了…赶紧记一下。</p><p>本周主题：差分数组、动态规划</p><p>题目：</p><ul><li>240615每日一题—<a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">Maximum Beauty of an Array After Applying Operation</a></li><li>240616周赛第三题—<a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/">Maximum Total Damage With Spell Casting</a></li><li>LC198打家劫舍—<a href="https://leetcode.cn/problems/house-robber/description/">House Robber</a><span id="more"></span></li></ul><h1 id="差分数组（Difference-Array）"><a href="#差分数组（Difference-Array）" class="headerlink" title="差分数组（Difference Array）"></a>差分数组（Difference Array）</h1><p>作用：开辟一块空间用于压缩对原数组上连续子数组的操作。</p><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>考虑数组 $a=[1,3,3,5,8]$，对其中的相邻元素两两作差（右边减左边），得到数组 $[2,0,2,3]$。然后在开头补上 $a[0]$，得到差分数组：$d=[1,2,0,2,3]$</p><p>这有什么用呢？如果从左到右累加 ddd 中的元素，我们就「还原」回了 $a$ 数组 $[1,3,3,5,8]$。这类似求导与积分的概念。</p><p>这又有什么用呢？现在把连续子数组 $a[1],a[2],a[3]$ 都加上 $10$，得到 $a’=[1,13,13,15,8]$。再次两两作差，并在开头补上 $a’[0]$，得到差分数组：$d’=[1,12,0,2,−7]$</p><p>对比 $d$ 和 $d’$，可以发现只有 $d[1]$ 和 $d[4]$ 变化了，这意味着<strong>对 $a$ 中连续子数组的操作，可以转变成对差分数组 $d$ 中两个数的操作</strong>。</p><h2 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h2><p>对于数组 $a$，定义其差分数组（difference array）为</p><script type="math/tex; mode=display">d[i] = \begin{cases} a[0],&i=0\\ a[i]-a[i-1],&i\ge 1 \end{cases}​</script><p>性质 1：从左到右累加 $d$ 中的元素，可以得到数组 $a$。</p><p>性质 2：如下两个操作是等价的。</p><ul><li>把 $a$ 的子数组 $a[i],a[i+1],\cdots,a[j]$ 都加上 $x$。</li><li>把 $d[i]$ 增加 $x$，把 $d[j+1]$ 减少 $x$。</li></ul><p>利用性质 2，我们只需要 $O(1)$ 的时间就可以完成对 $a$ 的子数组的操作。最后利用性质 1 从差分数组复原出数组 $a$。</p><p>注：也可以这样理解，$d[i]$ 表示把下标 $≥i$ 的数都加上 $d[i]$。</p><h2 id="例题：Maximum-Beauty-of-an-Array-After-Applying-Operation"><a href="#例题：Maximum-Beauty-of-an-Array-After-Applying-Operation" class="headerlink" title="例题：Maximum Beauty of an Array After Applying Operation"></a>例题：Maximum Beauty of an Array After Applying Operation</h2><blockquote><p><strong>Maximum Beauty of an Array After Applying Operation</strong></p><p>You are given a 0-indexed array nums and a non-negative integer k.</p><p>In one operation, you can do the following:</p><p>Choose an index i that hasn’t been chosen before from the range [0, nums.length - 1].<br>Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].<br>The beauty of the array is the length of the longest subsequence consisting of equal elements.</p><p>Return the maximum possible beauty of the array nums after applying the operation any number of times.</p><p>Note that you can apply the operation to each index only once.</p><p>A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p><p>Constraints:</p><ul><li>1 &lt;= nums.length &lt;= 1e5</li><li>0 &lt;= nums[i], k &lt;= 1e5</li></ul></blockquote><p>自然想到的思路是把每个元素看作是一个可换空间，将所有可换空间在一个足够大的空间中进行叠加，被最多可换空间覆盖到的地方即为所求结果。或者，把每个元素考虑为对其对应可换空间中的每一个位置投一票，最终票数最多的位置为所求结果。</p><p>从数据范围上分析，区间大小应该为[-1e5, 2e5]。将区间为负数的部分用<code>offset</code>来表示，则可以写出以下解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumBeauty</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="comment">// 多开3个空间，为了存0、存差分数组上限和匹配下标</span></span><br><span class="line">        <span class="keyword">int</span>[] diffArr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> ofst = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">1</span>; <span class="comment">// diffArr[ofst]为0所在位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            diffArr[x-k+ofst]++;</span><br><span class="line">            diffArr[x+k+ofst+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;diffArr.length;i++)&#123;</span><br><span class="line">            diffArr[i] += diffArr[i-<span class="number">1</span>];</span><br><span class="line">            res = Math.max(res, diffArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>周赛第三题属于值域上的打家劫舍，因此先来了解一下打家劫舍类型题目，其特点是<strong>对某一元素的选择会对其相邻区域造成影响</strong>。此类问题通常可以通过动态规划求解。</p><blockquote><p>House Robber</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p></blockquote><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 $k(k&gt;2)$ 间房屋，有两个选项:</p><ol><li>偷窃第 $k$ 间房屋，那么就不能偷窃第 $k-1$ 间房屋，偷窃总金额为前 $k-2$ 间房屋的最高总金额与第 $k$ 间房屋的金额之和。</li><li>不偷窃第 $k$ 间房屋，偷窃总金额为前 $k-1$ 间房屋的最高总金额。</li></ol><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 $k$ 间房屋能偷窃到的最高总金额。</p><p>用 $d p[i]$ 表示前 $i$ 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><script type="math/tex; mode=display">d p[i]=\max (d p[i-2]+\operatorname{nums}[i], d p[i-1])</script><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=\operatorname{nums}[0] & \text { 只有一间房屋，则偷窃该房屋 } \\ d p[1]=\max (n u m s[0], n u m s[1]) & \text { 只有两间房屋，选择其中金额较高的房屋进行偷窃 }\end{cases}</script><p>最终的答案即为 $d p[n-1]$, 其中 $n$ 是数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，可以考虑使用滚动数组优化空间使用。上述方法使用了数组存储结果，考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。得到优化解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：Maximum-Total-Damage-With-Spell-Casting"><a href="#例题：Maximum-Total-Damage-With-Spell-Casting" class="headerlink" title="例题：Maximum Total Damage With Spell Casting"></a>例题：Maximum Total Damage With Spell Casting</h2><blockquote><p>Maximum Total Damage With Spell Casting</p><p>A magician has various spells.</p><p>You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p><p>It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.</p><p>Each spell can be cast only once.</p><p>Return the maximum possible total damage that a magician can cast.</p></blockquote><p>这道题不是从空间上限制选取，而是从值域上限制，因此我们可以考虑对原数组进行排序，使元素选取与空域产生一定相关性，方便状态记录。排序后，考虑聚合相等值的元素，每一步选取实际上都是选取了一组元素。</p><p>用$nums$表示聚合后的排序数组，$total(nums[k])$表示元素$nums[k]$的值总和，用 $dp[i]$ 表示前 $i$ 个元素能造成的最高总伤害，那么对于$nums[k]$选或不选：</p><ul><li>不选，$dp[i] = dp[i-1]$;</li><li>选，则值在$[nums[k]-2, nums[k]-1]$的元素不能选，令$j$为最小满足$nums[j]&gt;=nums[k]-2$的元素，则$dp[i] = dp[j-1] + total(nums[k])$。</li></ul><p>对两种情况取最大值，有如下的状态转移方程：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1], dp[j-1] + total(nums[i]))</script><p>假设一种最坏的情况，$nums$中所有的元素都是连续的，那么在遇到元素$nums[i]$时，我们至少要保存三个状态才能够完成状态转移，即$dp[i-1], dp[i-2], dp[i-3]$，此时他们的末尾值分别对应$nums[i]-1,nums[i]-2,nums[i]-3$，则$j = i-2$，状态可能从$dp[i-3]$转移。也就是说，$dp[j-1]$的取值范围是$dp[i-1], dp[i-2], dp[i-3]$。</p><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=total(\operatorname{nums}[0]) \\ d p[1]=\begin{cases} \max (total(\operatorname{nums}[0]), total(\operatorname{nums}[1])),&nums[0]-2<=nums[1]<nums[0] \\ dp[0]+total(\operatorname{nums}[1]), &nums[0]<nums[1]-2 \end{cases}\end{cases}</script><p>此时发现问题：面对下标为$2$的元素，并不存在状态$dp[-1]$供其转移（$dp[j-1]$的下界）。于是如果从$nums[2]$开始遍历则应该添加此状态（置0），或从$nums[3]$开始遍历。</p><p>注意到当前状态仅与前三个状态有关，则可以用长度为$3$的滚动数组进行优化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maximumTotalDamage</span><span class="params">(<span class="keyword">int</span>[] power)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : power) &#123;</span><br><span class="line">            map.merge(x, (<span class="keyword">long</span>) x, Long::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer[] nums = map.keySet().toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 三个状态</span></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = map.get(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">2</span>] = nums[<span class="number">0</span>]&lt;nums[<span class="number">1</span>]-<span class="number">2</span>?dp[<span class="number">1</span>]+map.get(nums[<span class="number">1</span>]):Math.max(dp[<span class="number">1</span>], map.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j放到外面，可以避免每次都从0开始查</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 定位j</span></span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt; nums[i]-<span class="number">2</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = j==i?<span class="number">2</span>:(j==i-<span class="number">1</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> tmp = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[pos]+map.get(nums[i]));</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果把2换为k呢？一样的，多增加几个状态就行了，滚动数组法只需要k+1个状态。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/">https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/">https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周周赛菜了…赶紧记一下。&lt;/p&gt;
&lt;p&gt;本周主题：差分数组、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240615每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/&quot;&gt;Maximum Beauty of an Array After Applying Operation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240616周赛第三题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/&quot;&gt;Maximum Total Damage With Spell Casting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LC198打家劫舍—&lt;a href=&quot;https://leetcode.cn/problems/house-robber/description/&quot;&gt;House Robber&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP1</title>
    <link href="http://silencezheng.top/2024/08/18/article132/"/>
    <id>http://silencezheng.top/2024/08/18/article132/</id>
    <published>2024-08-17T16:14:09.000Z</published>
    <updated>2024-08-17T16:15:40.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。</p><p>本周主题：记忆化搜索、动态规划、01背包</p><p>题目：</p><ul><li>240609每日一题—<a href="https://leetcode.cn/problems/burst-balloons/description/">Burst Balloons</a></li><li>240608双周赛最后两题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/">Find the Maximum Length of a Good Subsequence</a></li><li>240609周赛最后两题—<a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/">Maximum Total Reward Using Operations</a><span id="more"></span><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><blockquote><p><strong>Burst Balloons</strong><br>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.</p><p>If you burst the ith balloon, you will get nums[i - 1] <em> nums[i] </em> nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</p><p>Return the maximum coins you can collect by bursting the balloons wisely.</p></blockquote></li></ul><p>这道题的第一个关键思路是逆向思维，戳气球的操作会导致两个气球从不相邻变成相邻，使后续操作处理困难，将戳气球的过程反过来看成每次添加一个气球，直到形成原数组。定义方法 $solve$，令 $solve(i,j)$ 表示将开区间 $(i,j)$ 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 $i$ 和 $j$，对应着 $val[i]$ 和 $val[j]$。</p><p>第二个思路比较简单，在原数组左右各增加一个$1$，即左右边界时的得分。</p><p>下面，对于$solve(i,j)$：</p><ul><li>当 $i≥j−1$ 时，开区间中没有气球，$solve(i,j)$ 的值为 0；</li><li>当 $i&lt;j−1$ 时，我们枚举开区间内的全部位置 $mid$，令 $mid$ 为当前区间第一个添加的气球，该操作能得到的硬币数为 $val[i]×val[mid]×val[j]$。同时我们递归地计算分割出的两区间对 $solve(i,j)$ 的贡献，这三项之和的最大值，即为 $solve(i,j)$ 的值。这样问题就转化为求 $solve(i,mid)$ 和 $solve(mid,j)$ ，可以写出方程：<script type="math/tex; mode=display">{solve}(i,j)= \begin{cases}{} \displaystyle \max_{\textit{mid} = i + 1}^{j - 1}val[i] \times \textit{val}[\textit{mid}] \times \textit{val}[j] + \textit{solve}(i, \textit{mid}) + \textit{solve}(\textit{mid}, j) ,&i < j - 1 \\ 0, & i \geq j - 1 \end{cases}</script></li></ul><p>由于在枚举mid的过程中，一定会产生相同子区间，即存在重复计算，此时可以采用记忆化的方式存储计算结果，优化时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>]; <span class="comment">// 增加边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>]; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right]; <span class="comment">// 已计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/burst-balloons/solutions/336390/chuo-qi-qiu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h1><blockquote><p>有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>在上述例题中，若每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。</p><p>例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。</p><p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的容量会增大 $w_{i}$，即前一个状态的背包容量必须是 $j-w_{i}$，通过本轮加上 $w_{i}$ 达到 $j$，同时背包中物品的总价值会增大 $v_{i}$，故这种情况下的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。</p><p>由此可以得出状态转移方程：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})</script><p>依据该状态转移方程可以写出解法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = w.length;</span><br><span class="line"><span class="comment">// 容量维度多开辟一个位置，因为要用索引表示容量，需要匹配到 W</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][W+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 对于dp[0][j]，所有j&lt;w[0]的位置初始化为0，其余位置初始化为 v[0]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;w[<span class="number">0</span>])&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于dp[i][0]，背包容量为0时无法装物，价值为0，对于其余位置，是由其上层的状态计算出的，也一并初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Arrays.fills(dp[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[n-1][W]即为结果</span></span><br></pre></td></tr></table></figure><p>如果直接采用二维数组对状态进行记录，可能会出现 MLE（Memory Limit Exceeded）。可以考虑改用<strong>滚动数组</strong>的形式来优化。</p><blockquote><p>滚动数组</p><p>在动态规划问题中，通常需要存储一系列状态值，每个状态值可能依赖于前几个状态。随着计算的进行，较早的状态值可能不再需要。例如，在求解斐波那契数列时，只需要保留最近两个值即可计算下一个值，之前的值则可以被覆盖重用。</p><p>思想：通过观察dp方程来判断需要使用哪些数据，可以抛弃哪些数据，一旦找到关系，就可以用新的数据不断覆盖旧的数据量来减少空间的使用。</p></blockquote><p>由于在二维解法中，对于当前层（当前物品）状态有影响的只有上一层（前一物品），即对 $f_i$ 有影响的只有 $f_{i-1}$，则可以去掉第一维，用一个重复更新的一维数组记录状态，直接用 $f_{j}$ 来表示处理到当前物品时背包容量为 $j$ 的最大价值，得出以下方程：</p><script type="math/tex; mode=display">f_j=\max \left(f_j,f_{j-w_i}+v_i\right)</script><p>这里，$f_{j-w_i} + v_i$代表如果选择放入第$i$个物品，则在背包容量为$j-w_i$时的价值加上这个物品的价值。而$max$操作保证了在是否选择放入第$i$个物品之间取最优解。</p><p>大部分背包问题的转移方程都是在此基础上推导出来的。</p><p>对于代码实现方面，<strong>滚动数组的实现要注意内层循环应从后向前逆序遍历</strong>，这可以避免在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 被 $f_{i,j-w_{i}}$ 所影响，即避免小背包容量下取物对后续大背包容量下状态计算的影响。</p><p>举例来说，假设<em>物品4</em>的重量为$1$，在二维解法中<code>dp[4][5]</code>应该由<code>dp[3][5]</code>和<code>dp[3][4]</code>得出，<code>dp[4][6]</code>应该由<code>dp[3][6]</code>和<code>dp[3][5]</code>得出，而在正序遍历的一维解法中，<code>f[5]</code>会先被计算，可能存在<code>f[5]</code>存储<code>dp[3][4]</code>状态的情况，此时<code>f[6]</code>的计算就无法获取<code>dp[3][5]</code>，造成计算错误。这个计算错误事实上是对<strong>同一物品的多次装包</strong>，因为<code>dp[3][4]</code>表示取<em>物品4</em>(下标为3)，若下一步<code>f[6]</code>再选择<code>f[5]+v[3]</code>则表示又取了一次<em>物品4</em>，这在01背包中是不允许的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">13010</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];  <span class="comment">// 读入数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = W; l &gt;= w[i]; l--) <span class="comment">// l &gt;= w[i]保证背包能装下，防止越界</span></span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的：</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//   for (int l = 0; l &lt;= W - w[i]; l++)</span></span><br><span class="line"><span class="comment">//     f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);</span></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。</p><p>可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)</script><p>考虑进行优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)</script><p>理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。</p><p>实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxW = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxW];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; W &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = w[i]; l &lt;= W; l++)</span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 核心状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题1-Maximum-Total-Reward-Using-Operations"><a href="#例题1-Maximum-Total-Reward-Using-Operations" class="headerlink" title="例题1: Maximum Total Reward Using Operations"></a>例题1: Maximum Total Reward Using Operations</h2><blockquote><p><strong>Maximum Total Reward Using Operations I &amp; II</strong></p><p>You are given an integer array rewardValues of length n, representing the values of rewards.</p><p>Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:</p><ul><li>Choose an unmarked index i from the range [0, n - 1].</li><li>If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.</li></ul><p>Return an integer denoting the maximum total reward you can collect by performing the operations optimally.</p></blockquote><p>首先，<code>rewardValues</code>中的数应该从小到大选，于是可以对其进行排序。排序后，可以看作01背包问题处理，背包的重量限制转化成了<code>rewardValues[i]</code>与reward<code>x</code>的制约关系。因此定义 <code>f[i][j]</code> 表示选取前<code>i</code>个<code>rewardValues</code>下<code>x</code>能达到的最大值<code>j</code>。由于<code>x</code>所能达到的最大值不确定，在实现中应选取一个尽可能大的值。</p><p>考虑转移，对于<code>f[i][j]</code>，是否选择<code>rewardValues[i]</code>：</p><ul><li>不选，<code>f[i][j] = f[i-1][j]</code>，即分数与上轮相同。</li><li>选择，<code>f[i][j] = f[i-1][j-rewardValues[i]]</code>，即上一轮的分数 <code>j-rewardValues[i]</code> 必须满足 <code>j-rewardValues[i]&lt;rewardValues[i]</code>, 同时为防止越界，<code>j-rewardValues[i]</code>需要大于等于0。综上，需满足 <code>rewardValues[i] &lt;= j &lt; 2*rewardValues[i]</code>。</li></ul><p>这里由于<code>f[i][j]</code>不需要存储“价值”，<code>j</code>自然表示了可以达到的最大值，因此<code>f[i][j]</code>通过布尔值表示是否可达即可，则有<code>f[i][j] = f[i-1][j] || f[i-1][j-rewardValues[i]]</code>。</p><p>写出二维解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rewardValues.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// int m = Integer.MAX_VALUE;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对物品从小到大排序</span></span><br><span class="line">        Arrays.sort(rewardValues);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 全部初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 不选</span></span><br><span class="line">        dp[<span class="number">0</span>][rewardValues[<span class="number">0</span>]] = <span class="keyword">true</span>; <span class="comment">// 选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化第一列，即一直不选。</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 对于[1, rewardValues[i]]区间，复制上一层表示可以不选。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于可选取区间，计算新得分。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=rewardValues[i];j&lt;<span class="number">2</span>*rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-rewardValues[i]]);</span><br><span class="line">                <span class="comment">// if(dp[i][j]) System.out.println(i+&quot;, &quot;+j);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后一行的最大真值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n-<span class="number">1</span>][i]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维解法对于数据范围大的情况会存在MLE，因此参照01背包问题，考虑使用滚动数组进行优化。原计算可以简化为：<code>f[j] = f[j] || f[j-rewardValues[i]]</code>，同时注意逆序遍历。另外，由于最终结果可以由<code>j</code>的值表示，故可以进一步优化数组为位运算，采用一个<code>BigInteger</code>表示布尔数组。</p><p>下面考虑如何用位运算表示布尔运算，假设之前已经遍历过的元素为<code>1, 2, 3</code>，则此时状态应为：<code>0000 0011 1111</code>，即可达分数区间为<code>[0, 5]</code>，此时假设下一个元素为<code>5</code>，则需要对区间<code>[5, 10)</code>进行布尔计算，计算的本质是将当前状态的区间<code>[0, 5)</code>与区间<code>[5, 10)</code>进行<code>or</code>运算。因此可以通过构造一个“<em>把区间<code>[0, 5)</code>移动到区间<code>[5, 10)</code>位置上且其余部分为<code>0</code></em>”的mask来与原状态进行<code>or</code>运算，既计算了目标区间，又不影响其他状态。构造的方法是先构造区间<code>[0, 5)</code>上全为<code>1</code>的mask，而后与原状态进行<code>and</code>操作提取目标区间，再将目标区间左移到<code>[5, 10)</code>的位置上得到最终的mask。</p><p>对于上面的例子来说，我们首先构造一个初始mask<code>0000 0000 0001</code>，而后对其左移<code>rewardValues[i]</code>位，这里即$5$位，得到<code>0000 0001 0000</code>，减$1$得到目标区间全真值mask<code>0000 0000 1111</code>，再左移<code>rewardValues[i]</code>位到目标区间，得到<code>0001 1110 0000</code>，与原状态进行<code>or</code>运算，得到：<code>0001 1111 1111</code>，即可取的分数范围为<code>[0, 8]</code>，符合题意。参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        BigInteger f = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : Arrays.stream(rewardValues).distinct().sorted().toArray()) &#123;</span><br><span class="line">            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);</span><br><span class="line">            f = f.or(f.and(mask).shiftLeft(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.bitLength() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2-Find-the-Maximum-Length-of-a-Good-Subsequence"><a href="#例题2-Find-the-Maximum-Length-of-a-Good-Subsequence" class="headerlink" title="例题2: Find the Maximum Length of a Good Subsequence"></a>例题2: Find the Maximum Length of a Good Subsequence</h2><blockquote><p>Find the Maximum Length of a Good Subsequence I &amp; II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p><p>A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p></blockquote><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>这道01背包没想清楚，先来特殊思路：<strong>处理相邻元素不同的DP问题</strong></p><p>把有$k$个相邻下标元素不同的子序列称为k序列。用 $c n t[k]$ 记录以 $x$ 结尾的 $k$ 序列的最大长度。考虑以 $nums[i]$ 结尾的 $k$ 序列, $nums [i]$ 要么接在以 $nums[i]$ 结尾的 $k$ 序列后，要么接在某个以 $n u m s<a href="j&lt;i">j</a>$ 结尾的 $k-1$ 序列后。所以状态转移方程即为</p><script type="math/tex; mode=display">\operatorname{cnt}[k][\operatorname{nums}[i]]=\max \left(\operatorname{cnt}[k][\operatorname{nums}[i]], \max _{j<i}\{\operatorname{cnt}[k-1][\operatorname{nums}[j]]\}\right)+1</script><p>这里我们不需要关心是否 $n u m s[j] \neq n u m s[i]$ ，即 $k-1$ 序列是否已经以 $nums[i]$ 结尾，因为在同样以 $nums[i]$ 结尾的情况下， $k-1$ 序列的长度一定小于 $k$ 序列的长度。</p><p>$c n t[k-1]$ 的最大值可以在哈希表基础上维护值有序来实现。但实际上，我们不需要维护 $c n t[k-1]$ 的所有值, 由于 $k-1$ 序列的最大长度单调不减, 所以只需要维护 $c n t[k-1]$ 的最大值就可以了。</p><p>在一些要求相邻状态不同的DP问题中，在处理当前状态时，不一定非要与所有前置状态比较, 只需要记录 $d p$ 最大和次大值对应的前置状态即可。这样的思路同样适用于本题。</p><p>注意由于$nums[i]$的范围比较大，Java实现的时候要用Map来存防止OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] mx = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            cnt.put(i, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> kk = k; kk &gt;= <span class="number">0</span>; kk--) &#123;</span><br><span class="line">                <span class="comment">// 考虑到更新顺序，需要倒序枚举</span></span><br><span class="line">                <span class="keyword">int</span> currentValue = kk&gt;<span class="number">0</span>?mx[kk - <span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">                currentValue = Math.max(currentValue, cnt.get(kk).getOrDefault(x, <span class="number">0</span>))+<span class="number">1</span>;</span><br><span class="line">                cnt.get(kk).put(x, currentValue);</span><br><span class="line">                mx[kk] = Math.max(mx[kk], cnt.get(kk).getOrDefault(x, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMax(mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : mx) &#123;</span><br><span class="line">            max = Math.max(max, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/dp">https://oi-wiki.org/dp</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/">https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/</a><br>[3] <a href="https://blog.csdn.net/txyyt_wst/article/details/130206572">https://blog.csdn.net/txyyt_wst/article/details/130206572</a><br>[4] <a href="https://blog.csdn.net/m0_46427179/article/details/107419492">https://blog.csdn.net/m0_46427179/article/details/107419492</a><br>[5] <a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/">https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p><p><strong>关于最后一个例题我自己的思考如下（不知道为什么是错的），没时间浪费了先存档以后再思考，先理解正确解法：</strong></p><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>由于 k 是非负整数，因此长度等于 1 的子序列一定是好子序列。对于任意一个子序列，在后面添加一个元素之后，子序列的长度增加 1，相邻不同元素对的数量不变或增加 1，因此可以使用动态规划计算最长好子序列的长度。</p><p>由于是”子序列“问题，其实也还是从全集中选择若干元素的问题，由于元素不能重复选，则还是0-1背包问题。这里背包的重量限制转化为<strong>前后不相同元素对</strong>数量的限制，对于元素<code>x = nums[i]</code>，定义<code>dp[i][j]</code>为遍历前<code>i</code>个元素时<strong>前后不相同元素对</strong>数量不超过<code>j</code>时的子序列最大长度。</p><p><strong>TODO:如果定义为前<code>i</code>个元素，则实现时遇到相等长度情况应该如何处理？即dp[a][j]==dp[b][j]，如果只取最后一个，那么后面和dp[?][j-1]比的时候也是相同亦可？</strong></p><p>这里需要注意一下如何定义，参考01背包问题，“前i个元素”一致，“背包容量”与“前后不相同元素对数量”一致，且此约束条件应转换为不超过<code>j</code>而不是等于<code>j</code>。</p><p>则对于<code>x</code>的选取分为三种情况：</p><ol><li>不选，<code>dp[i][j] = dp[i-1][j]</code>；</li><li>选择，且<code>x</code>与子序列的前一个数相同，则<code>dp[i][j] = dp[?][j]+1</code>；</li><li>选择，且<code>x</code>与子序列的前一个数不同，则<code>dp[i][j] = dp[?][j-1]+1</code>。</li></ol><p>这里使用了<code>?</code>来表示前一个数<code>y</code>的下标，<code>y</code>需要通过遍历得到。</p><p>由此可以得到状态转移方程为：</p><ul><li>情况A（不选）：<code>dp[i][j] = dp[i-1][j]+1</code></li><li>情况B（选）：<code>dp[i][j] = max(dp[?][j], dp[?][j-1])+1</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。&lt;/p&gt;
&lt;p&gt;本周主题：记忆化搜索、动态规划、01背包&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240609每日一题—&lt;a href=&quot;https://leetcode.cn/problems/burst-balloons/description/&quot;&gt;Burst Balloons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240608双周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/&quot;&gt;Find the Maximum Length of a Good Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240609周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/&quot;&gt;Maximum Total Reward Using Operations&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP7</title>
    <link href="http://silencezheng.top/2024/08/07/article131/"/>
    <id>http://silencezheng.top/2024/08/07/article131/</id>
    <published>2024-08-07T06:28:14.000Z</published>
    <updated>2024-08-19T16:23:04.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回国了，开始好好准备找工。</p><p>本周主题：快速幂</p><p>题目：</p><ul><li>240730每日一题—<a href="https://leetcode.cn/problems/double-modular-exponentiation/description">Double Modular Exponentiation</a><span id="more"></span></li></ul><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^8 \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}</script><p>的顺序，从 $x$ 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 $x^{64}$ 的值，而不需要对 $x$ 乘 63 次 $x$ 。</p><p>再举一个例子，如果我们要计算 $x^{77}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^9 \rightarrow x^{19} \rightarrow x^{38} \rightarrow x^{77}</script><p>的顺序, 在 $x \rightarrow x^2, x^2 \rightarrow x^4, x^{19} \rightarrow x^{38}$ 这些步骤中, 我们直接把上一次的结果进行平方，而在 $x^4 \rightarrow x^9, x^9 \rightarrow x^{19}, x^{38} \rightarrow x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 $x$ 。</p><p>直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后, 还需不需要额外乘 $x$ 。但如果我们从右往左看, 分治的思想就十分明显了：</p><ul><li>当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y=x^{\lfloor n / 2\rfloor}$ ，其中 $\lfloor a\rfloor$表示对 $a$ 进行下取整；</li><li>根据递归计算的结果, 如果 $n$ 为偶数, 那么 $x^n=y^2$; 如果 $n$ 为奇数,那么 $x^n=y^2 \times x$ ；</li><li>递归的边界为 $n=0$, 任意数的 0 次方均为 1 。</li></ul><p>由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</p><p>下面是快速幂算法的递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步，由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们还是以 $x^{77}$ 作为例子：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow^{+} x^9 \rightarrow^{+} x^{19} \rightarrow x^{38} \rightarrow^{+} x^{77}</script><p>并且把需要额外乘 $x$ 的步骤打上了 + 标记。可以发现：</p><ul><li>$x^{38} \rightarrow^{+} x^{77}$ 中额外乘的 $x$ 在 $x^{77}$ 中贡献了 $x$ ；</li><li>$x^9 \rightarrow^{+} x^{19}$ 中额外乘的 $x$ 在之后被平方了 2 次，因此在 $x^{77}$ 中贡献了 $x^{2^2}=x^4$</li><li>$x^4 \rightarrow^{+} x^9$ 中额外乘的 $x$ 在之后被平方了 3 次，因此在 $x^{77}$ 中贡献了 $x^{2^3}=x^8$</li><li>最初的 $x$ 在之后被平方了 6 次，因此在 $x^{77}$ 中贡献了 $x^{2^6}=x^{64}$ 。</li></ul><p>我们把这些贡献相乘， $x \times x^4 \times x^8 \times x^{64}$ 恰好等于 $x^{77}$ 。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 $x$ 在之后都会被平方若干次。而这些指数 $1 ， 4 ， 8$ 和 $64 ，$ 恰好就对应了 77 的二进制表示 $(1001101)_2$ 中的每个 1 ！</p><p>因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 $n$ 的二进制拆分为</p><script type="math/tex; mode=display">n=2^{i_0}+2^{i_1}+\cdots+2^{i_k}</script><p>那么</p><script type="math/tex; mode=display">x^n=x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}</script><p>这样以来, 我们从 $x$ 开始不断地进行平方, 得到 $x^2, x^4, x^8, x^{16}, \cdots$, 如果 $n$的第 $k$ 个（从右往左，从 0 开始计数）二进制位为 1 ，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。</p><p>下面是快速幂的迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x0</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题：Double-Modular-Exponentiation"><a href="#例题：Double-Modular-Exponentiation" class="headerlink" title="例题：Double Modular Exponentiation"></a>例题：Double Modular Exponentiation</h2><blockquote><p>Double Modular Exponentiation</p><p>You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.</p><p>An index i is good if the following formula holds:</p><ul><li>0 &lt;= i &lt; variables.length</li><li>((ai^bi % 10)^ci) % mi == target</li></ul><p>Return an array consisting of good indices in any order.</p></blockquote><p>计算式中重复出现的模式是“幂+取模”，于是可以把快速幂和取模融合在一起。</p><p>另一个知识点是“加法和乘法”的取模，有如下公式：<br>$(a+b) \bmod m=((a \bmod m)+(b \bmod m)) \bmod m$ $(a \cdot b) \bmod m=((a \bmod m) \cdot(b \bmod m)) \bmod m$</p><p>因此我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。</p><p>更多模相关的内容请看：<a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getGoodIndices</span><span class="params">(<span class="keyword">int</span>[][] variables, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; variables.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = variables[i];</span><br><span class="line">            <span class="keyword">if</span> (powMod(powMod(v[<span class="number">0</span>], v[<span class="number">1</span>], <span class="number">10</span>), v[<span class="number">2</span>], v[<span class="number">3</span>]) == target) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// (a*b) mod c = ((a mod c) * (b mod c)) mod c</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * x % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; <span class="comment">// 相当于y/=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a><br>[2] <a href="https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/">https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回国了，开始好好准备找工。&lt;/p&gt;
&lt;p&gt;本周主题：快速幂&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240730每日一题—&lt;a href=&quot;https://leetcode.cn/problems/double-modular-exponentiation/description&quot;&gt;Double Modular Exponentiation&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（速食版）</title>
    <link href="http://silencezheng.top/2024/06/06/article130/"/>
    <id>http://silencezheng.top/2024/06/06/article130/</id>
    <published>2024-06-05T19:43:00.000Z</published>
    <updated>2024-06-05T19:44:07.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快速计算任意连续子数组元素和的数据结构。</p><p>树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为<br>Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。<br><span id="more"></span></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><blockquote><p>给你一个数组，如何快速地计算任意一段连续子数组的元素和？</p></blockquote><p><img src="/assets/post_img/article130/szsz.png" alt="bit"></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>下标从 $left$ 到 $right$ 的子数组元素和，可以看成是下标从 1 到 $right$ 的子数组元素和，减去下标从 1 到 $left−1$ 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。</p><p>按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 $O(1)$ 地查询（计算任意连续子数组的元素和）了。</p><h2 id="如果更新呢？"><a href="#如果更新呢？" class="headerlink" title="如果更新呢？"></a>如果更新呢？</h2><p>如果修改下标为1的元素，则所有前缀都需要更新（因为所有前缀包含该元素），意味着更新操作时间复杂度为$O(n)$。此时查询与更新的综合时间复杂度还是$O(n)$。</p><p>自然的，想到应该将前缀元素和继续进行拆分，令更新某元素时，仅影响部分“子前缀”，此时只需要更新影响到的部分即可。</p><p>因此，需要找到一种合适的拆分方法，能够把任意前缀拆分成若干<strong>子前缀</strong>，使更新操作的执行范围缩小到部分子前缀中。</p><h2 id="对于想继续探索的同学"><a href="#对于想继续探索的同学" class="headerlink" title="对于想继续探索的同学"></a>对于想继续探索的同学</h2><p>推荐文献[3]，较为全面的阐述了树状数组的来世今生，本文以让读者尽快掌握用法为主，不过多展开深入。</p><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>BIT的重要概念，抛开相关性质不谈，先说计算，lowbit(x)表示取数x的最低位1，常用<code>lowbit(x) = x &amp; -x</code>计算。</p><p>举例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span><span class="punctuation">,</span> lowbit(<span class="keyword">x</span>) <span class="operator">=</span> <span class="keyword">x</span> &amp; -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">计算过程：</span><br><span class="line">   <span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span></span><br><span class="line">  -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0110</span></span><br><span class="line"><span class="keyword">x</span>&amp;-<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><h2 id="树状数组-c-n-的查询与更新"><a href="#树状数组-c-n-的查询与更新" class="headerlink" title="树状数组 c[n] 的查询与更新"></a>树状数组 <code>c[n]</code> 的查询与更新</h2><p>对于原数组<code>a[n]</code>构建对应的树状数组<code>c[n]</code>，可推导得出：<code>c[x] = a[x-lowbit(x)+1] + ... + a[x]</code>，即区间<code>[x-lowbit(x)+1, x]</code>的元素和。</p><p>定义<code>query(x)</code>为查询原数组区间<code>[1, x]</code>上的元素和，则可写出利用<code>c[n]</code>实现$O(logn)$的查询代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 减去所有的lowbit后i为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))</span><br><span class="line">            ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>add(x, v)</code>为修改位置为在索引<code>x</code>的元素，加上<code>v</code>。则可写出利用<code>c[n]</code>实现$O(logn)$的更新代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = 树状数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)&#123;</span><br><span class="line">        c[x] += v;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容很好理解，抓住<code>c[x]</code>的定义就行了。</p><h2 id="树状数组-c-n-的构造"><a href="#树状数组-c-n-的构造" class="headerlink" title="树状数组 c[n] 的构造"></a>树状数组 <code>c[n]</code> 的构造</h2><p>最简单的，遍历原数组，调用<code>n</code>次<code>add</code>方法进行构造，时间复杂度$O(nlogn)$：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更快速的，考虑<code>c[x]</code>表示原数组区间<code>[x-lowbit(x)+1, x]</code>的元素和，可以先对原数组求一个前缀和数组<code>s[n]</code>，利用前缀和来更新树状数组，即<code>c[x] = s[x] - s[x-lowbit(x)]</code>，此时构造的时间复杂度为$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 求a的前缀和</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 用前缀和求出c</span></span><br><span class="line">c[i] = s[i] - s[i - lowbit(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分规则—逆序"><a href="#拆分规则—逆序" class="headerlink" title="拆分规则—逆序"></a>拆分规则—逆序</h2><p>按照逆序处理，每次处理的bit都是当前编号的最后的为1位。将每次处理的bit定义为<strong>lowbit</strong>。</p><p>对于前缀 $[1,i]$：</p><ul><li>如果 $i$ 是 2 的幂，那么 $[1,i]$ 无需拆分。</li><li>如果 $i$ 不是 2 的幂，那么先拆分出一个长为 $lowbit(i)$ 的关键区间 $[i−lowbit(i)+1,i]$，问题转换成剩下的 $[1,i−lowbit(i)]$ 如何拆分，这是一个规模更小的子问题。</li></ul><h1 id="例题一：分数字到两个数组"><a href="#例题一：分数字到两个数组" class="headerlink" title="例题一：分数字到两个数组"></a>例题一：<a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">分数字到两个数组</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; tree.length) &#123;</span><br><span class="line">            tree[i]++;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] resultArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            index.put(sortedNums[i], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Integer&gt; arr2 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">1</span>]));</span><br><span class="line">        BinaryIndexedTree tree1 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        BinaryIndexedTree tree2 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        tree1.add(index.get(nums[<span class="number">0</span>]));</span><br><span class="line">        tree2.add(index.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = arr1.size() - tree1.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">int</span> count2 = arr2.size() - tree2.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr1.size() &lt;= arr2.size())) &#123;</span><br><span class="line">                arr1.add(nums[i]);</span><br><span class="line">                tree1.add(index.get(nums[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.add(nums[i]);</span><br><span class="line">                tree2.add(index.get(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr1) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr2) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/">https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/</a><br>[2] <a href="https://blog.csdn.net/qq_63786973/article/details/127416700">https://blog.csdn.net/qq_63786973/article/details/127416700</a><br>[3] <a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">https://www.cnblogs.com/Last--Whisper/p/13823614.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;快速计算任意连续子数组元素和的数据结构。&lt;/p&gt;
&lt;p&gt;树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为&lt;br&gt;Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排列组合</title>
    <link href="http://silencezheng.top/2024/06/01/article129/"/>
    <id>http://silencezheng.top/2024/06/01/article129/</id>
    <published>2024-06-01T12:59:03.000Z</published>
    <updated>2024-08-23T17:06:48.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排列组合计算公式推导及代码实现。<br><span id="more"></span></p><h1 id="加法原理、乘法原理"><a href="#加法原理、乘法原理" class="headerlink" title="加法原理、乘法原理"></a>加法原理、乘法原理</h1><p><strong>分类计数原理</strong>：完成一件事情，存在$n$类方法，第1类有$m_1$种方式，第2类有$m_2$种方式，…，第$n$类有$m_n$种方式，则完成此事共有$N = m_1 + m_2 + … + m_n$种不同方法。 </p><p><strong>分步计数原理</strong>：若完成某事需经过$n$个步骤，第1步有$m_1$种方法，第2步有$m_2$种方法，…，第$n$步有$m_n$种方法，则总共有$N = m_1 \times m_2 \times \cdots \times m_n$种不同方法。</p><p><strong>区别</strong>：分类计数原理是加法规则，各类方法数相加求和；分步计数原理是乘法规则，各步骤方法数相乘得总数。</p><h1 id="排列（Arrangement）"><a href="#排列（Arrangement）" class="headerlink" title="排列（Arrangement）"></a>排列（Arrangement）</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>从$n$个不同元素中选取$m(m \leq n)$个元素的所有不同排列的个数，叫做从$n$个不同元素中选取$m$个元素的排列数，记作$\mathrm{A}_n^m$。 </p><h2 id="排列数公式"><a href="#排列数公式" class="headerlink" title="排列数公式"></a>排列数公式</h2><script type="math/tex; mode=display">\mathrm{A}_n^m = n(n-1)(n-2)\cdots(n-m+1) = \frac{n!}{(n-m)!}, \quad n, m \in \mathbb{N}^*, m \leq n</script><p>推导：从$n$个不同元素中选取$m$个元素进行排序，按计数原理分布进行，取第一个有$n$种取法，取第二个有$n-1$种取法…取第$m$个有$n-m+1$种取法，根据分步乘法原理推导出上式。</p><h2 id="排列数性质"><a href="#排列数性质" class="headerlink" title="排列数性质"></a>排列数性质</h2><ul><li>$\mathrm{A}_n^m = n\mathrm{A}_{n-1}^{m-1}$：为“某特定位置”先安排，再安排其余位置。</li><li>$\mathrm{A}_n^m = m\mathrm{A}_{n-1}^{m-1} + \mathrm{A}_{n-1}^m$：含特定元素的排列有$m\mathrm{A}_{n-1}^{m-1}$种，不含特定元素的排列有$\mathrm{A}_{n-1}^m$种。</li></ul><h1 id="组合（Combination）"><a href="#组合（Combination）" class="headerlink" title="组合（Combination）"></a>组合（Combination）</h1><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>从$n$个不同元素中选取$m$（$m \leq n$）个元素的所有不同组合的数目，称为从$n$个不同元素中取出$m$个元素的组合数，用符号$\mathrm{C}_n^m$表示。</p><h2 id="组合数公式"><a href="#组合数公式" class="headerlink" title="组合数公式"></a>组合数公式</h2><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!},\quad n,m\in \mathbb{N}^*,m\leq n</script><script type="math/tex; mode=display">\mathrm{C}_n^0=\mathrm{C}_n^n=1</script><p>证明：通过排列与组合的关系以及排列公式推导证明。</p><p>将排列问题$\mathrm{A}_n^m$分为两步：</p><ol><li><p><strong>第一步</strong>：从$n$个球中抽取$m$个，不考虑顺序，即组合问题$\mathrm{C}_n^m$；</p></li><li><p><strong>第二步</strong>：将抽出的$m$个球排序，即全排列$\mathrm{A}_m^m$。</p></li></ol><p>依据乘法原理，$\mathrm{A}_n^m=\mathrm{C}_n^m \mathrm{A}_m^m$，因此</p><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}</script><h2 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h2><ul><li>$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$：反转组合，未选的变选，选了的变未选，组合数相同。</li><li>递推公式$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$：含特定元素组合数为$\mathrm{C}_{n-1}^{m-1}$，不含特定元素组合数为$\mathrm{C}_{n-1}^m$。</li></ul><p><strong>示例</strong><br>令（$n=5$），($m=2$)。</p><p>从1，2，3，4，5中取出2个元素的组合$\mathrm{C}_n^m$：</p><p>12 13 14 15 23 24 25 34 35 45</p><p>这些组合要么含”1”，要么不含。</p><ul><li>含”1”的组合：12 13 14 15 → 挖去”1”得2 3 4 5 → 等价于从2，3，4，5中取出1个元素的组合。（此处m-1为1）</li><li>不含”1”的组合：23 24 25 34 35 45 → 等价于从2，3，4，5中取出2个元素的组合。（此处m为2）</li></ul><p>总方案数是上述两种情况的和，即$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$。</p><h2 id="组合数求和公式"><a href="#组合数求和公式" class="headerlink" title="组合数求和公式"></a>组合数求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><p>直观理解：从$n$个球中抽取0到$n$个球的组合数之和。</p><p>严谨证明可采用数学归纳法：</p><ol><li>当$n=1$，$\mathrm{C}_1^0+\mathrm{C}_1^1=2=2$成立。</li><li>假设$n=k$时公式成立，$\sum_{i=0}^{k} \mathrm{C}_k^i=2^n$，则$n=k+1$时亦成立。</li><li>由1、2归纳得公式对所有$n\in \mathbb{N}^*$成立。</li></ol><p>或用二项式定理简证：</p><script type="math/tex; mode=display">(a+b)^n=\sum_{k=0}^{n}\mathrm{C}_n^k a^{n-k}b^k</script><p>设$a=b=1$，</p><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><h3 id="相关公式"><a href="#相关公式" class="headerlink" title="相关公式"></a>相关公式</h3><p>由$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$推导：</p><script type="math/tex; mode=display">\mathrm{C}_n^0 + \mathrm{C}_n^2 + \mathrm{C}_n^4 + ... = \mathrm{C}_n^1 + \mathrm{C}_n^3 + \mathrm{C}_n^5 + ... =2^{n-1}</script><h2 id="Java：组合求和"><a href="#Java：组合求和" class="headerlink" title="Java：组合求和"></a>Java：组合求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">factorialWithRecursion</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorialWithRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">combination</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> numerator = factorialWithRecursion(n);</span><br><span class="line">    <span class="keyword">long</span> denominator1 = factorialWithRecursion(m);</span><br><span class="line">    <span class="keyword">long</span> denominator2 = factorialWithRecursion(n-m);</span><br><span class="line">    <span class="keyword">return</span> numerator/(denominator1*denominator2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展：组合数的加权求和公式"><a href="#拓展：组合数的加权求和公式" class="headerlink" title="拓展：组合数的加权求和公式"></a>拓展：组合数的加权求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>通常被称为 <strong>组合数的加权求和公式</strong> 或者 <strong>组合数的加权和公式</strong>。这个公式用于计算组合数 $\binom{n}{i}$ 与下标 $i$ 的乘积之和。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>二项式系数</strong>：$\binom{n}{i}$ 是从 $n$ 个元素中选择 $i$ 个元素的不同方式的数量。</li><li><strong>二项式定理</strong>：$\sum_{i=0}^{n} \binom{n}{i} = 2^n$，表示所有二项式系数的和等于 $2^n$。</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol><li><strong>简化求和</strong>：从 $i=1$ 开始求和，因为 $i=0$ 时 $i \binom{n}{i} = 0$。</li><li><strong>利用组合数性质</strong>：$i \binom{n}{i} = n \binom{n-1}{i-1}$。</li><li><strong>改变求和变量</strong>：令 $j = i-1$，则 $i = j + 1$。</li><li><strong>利用二项式定理</strong>：$\sum_{j=0}^{n-1} \binom{n-1}{j} = 2^{n-1}$。</li></ol><p>最终得到公式：</p><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>这个公式是组合数学中的一个重要结论，有助于快速计算组合数的加权求和。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/1024th/p/10623541.html">https://www.cnblogs.com/1024th/p/10623541.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;排列组合计算公式推导及代码实现。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之预定义CRUD</title>
    <link href="http://silencezheng.top/2024/03/24/article128/"/>
    <id>http://silencezheng.top/2024/03/24/article128/</id>
    <published>2024-03-24T08:54:43.000Z</published>
    <updated>2024-08-19T15:18:57.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>探究MyBatis Plus提供的预定义CRUD接口的实现方式。<br><span id="more"></span></p><h1 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h1><p>MBP提供两种包含预定义CRUD的接口：</p><ol><li><code>com.baomidou.mybatisplus.extension.service.IService</code></li><li><code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code></li></ol><p>其中<code>IService</code>接口是针对业务逻辑层的封装，并提供了批处理操作。<code>BaseMapper</code>则是对DAO层CRUD的封装。</p><h1 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h1><p><code>BaseMapper</code>的接口规范很简单，看代码就能明白，重点是了解MBP如何实现的<code>BaseMapper</code>。</p><p>在使用MyBatis的情况下，我们定义了Mapper接口，然后会在对应的XML文件中提供动态SQL及映射关系，或者直接在Mapper接口方法上添加注解，MyBatis将XML中的配置或者注解作为元数据进行解析，然后将解析后的SQL语句存至<code>org.apache.ibatis.session.Configuration</code>。MBP在MyBatis的基础上只做增强不做改变，则只要能够实现原pipeline将元数据解析成动态SQL存至<code>org.apache.ibatis.session.Configuration</code>即可。</p><p>MyBatis Plus的整体思路是使用自己的组件替换MyBatis中的组件，以实现自定义的逻辑。其中<code>MybatisPlusAutoConfiguration</code>类替代了MyBatis的自动配置类，这个类中包含<code>MybatisPlusProperties</code>属性。<code>MybatisPlusProperties</code>包含<code>mapperLocations</code>字段用于解析Mapper XML文件的位置，并汇总为<code>Resource</code>数组。</p><p>在<code>MybatisPlusAutoConfiguration#sqlSessionFactory</code>函数中，包含XML位置的<code>Resource</code>数组被设置到<code>MybatisSqlSessionFactoryBean.mapperLocations</code>下（<code>MybatisSqlSessionFactoryBean</code>也是MBP替换组件）。而后在<code>MybatisSqlSessionFactoryBean#buildSqlSessionFactory</code>函数中，XML文件被逐个读取并解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>XMLMapperBuilder</code>在解析过程中会调用<code>XMLMapperBuilder#bindMapperForNamespace</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">            <span class="keyword">this</span>.configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>configuration</code>为<code>MybatisSqlSessionFactoryBean</code>传入的<code>targetConfiguration</code>，即<code>MybatisConfiguration</code>（MBP替换组件）。此时<code>MybatisMapperRegistry#addMapper</code>调用<code>MybatisMapperRegistry#addMapper</code>方法。</p><p><code>MybatisMapperRegistry</code>也是一个MBP替换组件，继承并替换掉原本的<code>MapperRegistry</code>，其<code>addMapper</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MybatisMapperProxyFactory(type));</span><br><span class="line">            MybatisMapperAnnotationBuilder parser = <span class="keyword">new</span> MybatisMapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用MBP自定义的<code>MybatisMapperAnnotationBuilder#parse</code>方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入 CURD 动态 SQL</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过全局缓存工具<code>GlobalConfigUtils</code>获取<code>ISqlInjector</code>实例，调用<code>ISqlInjector#inspectInject</code>方法进行CRUD方法注入。在实现上，实际上是由<code>AbstractSqlInjector</code>实现了<code>ISqlInjector</code>接口，然后又由<code>DefaultSqlInjector</code>继承<code>AbstractSqlInjector</code>实现最终注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; modelClass = ReflectionKit.getSuperClassGenericType(mapperClass, Mapper.class, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 注入的方法</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperClass 当前mapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入的方法集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.1.2 add  mapperClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass,TableInfo tableInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> DeleteById(),</span><br><span class="line">                <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> UpdateById(),</span><br><span class="line">                <span class="keyword">new</span> SelectById(),</span><br><span class="line">                <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(String.format(<span class="string">&quot;%s ,Not found @TableId annotation, Cannot use Mybatis-Plus &#x27;xxById&#x27; Method.&quot;</span>,</span><br><span class="line">                tableInfo.getEntityType()));</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每一个函数都是继承了<code>com.baomidou.mybatisplus.core.injector.AbstractMethod</code>的类，包含一个<code>inject</code>注入方法。</p><h1 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h1><p><code>IService</code>的实现在<code>com.baomidou.mybatisplus.extension.service.impl.ServiceImpl</code>。</p><p><code>IService</code>依赖于Spring容器，而<code>BaseMapper</code>不依赖，原因是<code>IService</code>实例中会注入一个<code>BaseMapper</code>实例用于做CRUD操作，也就是上面的那一套。</p><p><code>IService</code>还支持批量操作，这部分源码比较好看，调用链路是：<code>com.baomidou.mybatisplus.extension.toolkit.SqlHelper#executeBatch -&gt; org.apache.ibatis.session#flushStatements</code></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/wjw465150/article/details/126896276">https://blog.csdn.net/wjw465150/article/details/126896276</a><br>[2] <a href="https://blog.csdn.net/zzuhkp/article/details/120174101">https://blog.csdn.net/zzuhkp/article/details/120174101</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;探究MyBatis Plus提供的预定义CRUD接口的实现方式。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>回归问题指标计算</title>
    <link href="http://silencezheng.top/2024/03/10/article127/"/>
    <id>http://silencezheng.top/2024/03/10/article127/</id>
    <published>2024-03-10T10:56:26.000Z</published>
    <updated>2024-05-01T17:34:10.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回归问题指标计算入门。<br><span id="more"></span></p><h1 id="RSE-Relative-Squared-Error"><a href="#RSE-Relative-Squared-Error" class="headerlink" title="RSE (Relative Squared Error)"></a><strong>RSE (Relative Squared Error)</strong></h1><p>相对平方误差是预测值与实际值之间的平方差与实际值的平方差的比率。计算公式如下：</p><script type="math/tex; mode=display">RSE = \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}</script><p>其中，$ y_i $ 是第 $ i $ 个观测值，$ \hat{y}_i $ 是对应的预测值，$ \bar{y} $ 是观测值的均值，$ n $ 是样本数量。</p><h1 id="RAE-Relative-Absolute-Error"><a href="#RAE-Relative-Absolute-Error" class="headerlink" title="RAE (Relative Absolute Error)"></a><strong>RAE (Relative Absolute Error)</strong></h1><p>相对绝对误差是预测值与实际值之间的绝对差与实际值的绝对差的比率。计算公式如下：</p><script type="math/tex; mode=display">RAE = \frac{\sum_{i=1}^{n} |y_i - \hat{y}_i|}{\sum_{i=1}^{n} |y_i - \bar{y}|}</script><h1 id="MSE-Mean-Squared-Error"><a href="#MSE-Mean-Squared-Error" class="headerlink" title="MSE (Mean Squared Error)"></a><strong>MSE (Mean Squared Error)</strong></h1><p>均方误差是预测值与实际值之间的平方差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2</script><h1 id="RMSE-Root-Mean-Squared-Error"><a href="#RMSE-Root-Mean-Squared-Error" class="headerlink" title="RMSE (Root Mean Squared Error)"></a><strong>RMSE (Root Mean Squared Error)</strong></h1><p>均方根误差是均方误差的平方根，它提供了预测误差的标准化度量。计算公式如下：</p><script type="math/tex; mode=display">RMSE = \sqrt{MSE}</script><h1 id="MAE-Mean-Absolute-Error"><a href="#MAE-Mean-Absolute-Error" class="headerlink" title="MAE (Mean Absolute Error)"></a><strong>MAE (Mean Absolute Error)</strong></h1><p>平均绝对误差是一种常用的回归问题评价指标，用于衡量预测值与真实值之间的偏差程度。它的计算基于所有预测值与对应真实值之间绝对误差的平均值，因此对所有个体错误给予相同权重，不考虑误差的方向，只关注其大小。MAE的计算公式如下：</p><script type="math/tex; mode=display">\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|</script><p>其中：</p><ul><li>$n$ 表示样本的数量。</li><li>$y_i$ 表示第 $ i $ 个样本的真实值。</li><li>$ \hat{y}_i $ 表示第 $ i $ 个样本的预测值。</li><li>$ | \cdot | $ 表示绝对值函数，确保误差值为非负。</li></ul><h1 id="MAPE-Mean-Absolute-Percentage-Error"><a href="#MAPE-Mean-Absolute-Percentage-Error" class="headerlink" title="MAPE (Mean Absolute Percentage Error)"></a><strong>MAPE (Mean Absolute Percentage Error)</strong></h1><p>平均绝对百分比误差是预测值与实际值之间的绝对百分比误差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MAPE = \frac{100}{n} \sum_{i=1}^{n} \left| \frac{y_i - \hat{y}_i}{y_i} \right|</script><h1 id="Correlation-Pearson-Correlation-Coefficient"><a href="#Correlation-Pearson-Correlation-Coefficient" class="headerlink" title="Correlation (Pearson Correlation Coefficient)"></a><strong>Correlation (Pearson Correlation Coefficient)</strong></h1><p>相关系数衡量了预测值与实际值之间的线性关系强度和方向。计算公式如下：</p><script type="math/tex; mode=display">\text{Correlation} = \frac{\sum_{i=1}^{n} (y_i - \bar{y})(\hat{y}_i - \bar{\hat{y}})}{\sqrt{\sum_{i=1}^{n} (y_i - \bar{y})^2 \sum_{i=1}^{n} (\hat{y}_i - \bar{\hat{y}})^2}}</script><p>其中，$ \bar{y} $ 和 $ \bar{\hat{y}} $ 分别是观测值和预测值的均值。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回归问题指标计算入门。&lt;br&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://silencezheng.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发体验</title>
    <link href="http://silencezheng.top/2024/02/08/article126/"/>
    <id>http://silencezheng.top/2024/02/08/article126/</id>
    <published>2024-02-07T18:40:36.000Z</published>
    <updated>2024-02-07T18:44:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。</p><p>但在做课题调研时我习惯使用<code>[n]</code>作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫<code>Reference Extension</code>吧。<br><span id="more"></span></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>0、更新npm、cnpm：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cnpm</span></span><br><span class="line">npm install -g cnpm -registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>1、安装 Yeoman 和 VS Code Extension Generator：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g yo generator-code</span><br></pre></td></tr></table></figure></p><p>2、创建一个新的插件项目<code>Reference Extension</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Reference Extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? reference-extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? Literature Citation Extension</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? Yes</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? npm</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> reference-extension</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>主要实现两个功能：</p><ol><li><code>[n]</code>格式索引增加项时自动递增（实际只实现了一部分）。</li><li><code>[n]</code>格式索引重新索引，包含删除项与增加项（实际只实现了一部分）。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 VSCode 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活插件的入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令：自动递增索引</span></span><br><span class="line">    <span class="keyword">let</span> disposableAutoIncrement = vscode.commands.registerTextEditorCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前光标位置</span></span><br><span class="line">            <span class="keyword">const</span> currentPosition = editor.selection.active;</span><br><span class="line">            <span class="keyword">const</span> currentLine = currentPosition.line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前行的文本内容，并匹配是否以 [n] 格式结尾</span></span><br><span class="line">            <span class="keyword">const</span> currentLineText = editor.document.lineAt(currentLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = currentLineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="comment">// 获取匹配到的数字，并计算下一个数字</span></span><br><span class="line">                <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> nextNumber = currentNumber + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自增逻辑</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// TODO： 这段有问题，要修改，而且还是没有做到回车前触发。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = currentLine + <span class="number">1</span>; line &lt; editor.document.lineCount; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> matchBelow = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (matchBelow) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentNumberBelow = <span class="built_in">parseInt</span>(matchBelow[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndexBelow = currentNumberBelow + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 替换下方方括号中的数字</span></span><br><span class="line">                            <span class="keyword">const</span> startPosBelow = <span class="keyword">new</span> vscode.Position(line, <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">const</span> endPosBelow = <span class="keyword">new</span> vscode.Position(line, matchBelow[<span class="number">0</span>].length);</span><br><span class="line">                            editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPosBelow, endPosBelow), <span class="string">`[<span class="subst">$&#123;newIndexBelow&#125;</span>] <span class="subst">$&#123;matchBelow[<span class="number">2</span>]&#125;</span>`</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果下方没有符合 [n] 格式索引的项，结束循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> newPosition = <span class="keyword">new</span> vscode.Position(currentLine + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    editBuilder.insert(newPosition, <span class="string">`[<span class="subst">$&#123;nextNumber&#125;</span>] `</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册命令：重新索引所有行的方括号</span></span><br><span class="line">    <span class="comment">// TODO：实际上只实现了删除一个索引时将下方索引都自动减1</span></span><br><span class="line">    <span class="keyword">let</span> disposableReindex = vscode.commands.registerCommand(<span class="string">&#x27;rext.reindex&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前行的行号</span></span><br><span class="line">            <span class="keyword">const</span> currentLine = editor.selection.active.line;</span><br><span class="line">            <span class="keyword">const</span> startLine = currentLine;</span><br><span class="line">            <span class="keyword">const</span> endLine = editor.document.lineCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义当前列表的索引</span></span><br><span class="line">            <span class="keyword">let</span> currentListIndex: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：匹配一下</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 查找当前列表的索引</span></span><br><span class="line">            <span class="keyword">const</span> lineText = editor.document.lineAt(startLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                currentListIndex = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：自动减1</span></span><br><span class="line">            <span class="keyword">if</span> (currentListIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// TODO：重新索引列表中的方括号数字</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = startLine; line &lt; endLine; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                            <span class="comment">// 获取当前方括号中的数字和新索引</span></span><br><span class="line">                            <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndex = currentNumber - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果当前数字不等于新索引，替换方括号中的数字</span></span><br><span class="line">                            <span class="keyword">if</span> (currentNumber !== newIndex) &#123;</span><br><span class="line">                                <span class="keyword">const</span> startPos = <span class="keyword">new</span> vscode.Position(line, match.index!);</span><br><span class="line">                                <span class="keyword">const</span> endPos = <span class="keyword">new</span> vscode.Position(line, match.index! + match[<span class="number">0</span>].length);</span><br><span class="line">                                editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPos, endPos), <span class="string">`[<span class="subst">$&#123;newIndex&#125;</span>] `</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听文档内容变化事件</span></span><br><span class="line">    vscode.workspace.onDidChangeTextDocument(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.document.languageId === <span class="string">&#x27;markdown&#x27;</span> &amp;&amp; event.document.fileName.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> range = event.contentChanges[<span class="number">0</span>].range;</span><br><span class="line">            <span class="comment">// 检查是否按下了回车键</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否删除了某一行</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;&#x27;</span> &amp;&amp; range.start.line !== range.end.line) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.reindex&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令注册到上下文订阅中，确保插件在激活期间有效</span></span><br><span class="line">    context.subscriptions.push(disposableAutoIncrement, disposableReindex);</span><br><span class="line"></span><br><span class="line">    process.stdout.write(<span class="string">&#x27;Debugging message\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件被停用时调用的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这代码写的很糙，只实现了部分功能，但是也确实没时间去学<code>markdown-it</code>的插件实现了，以后再去实现吧（正常来说我要实现的东西通过<code>markdown-it</code>自定义插件插入的形式实现更方便…在插件上写插件😂）。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>项目F5进行调试，创建一个Markdown文件，写入对应情景内容，别忘了在<code>package.json</code>中设置触发条件。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>要想发布插件到市场，需要创建在Azure DevOps上创建个人访问令牌，如果没有组织则需要先创建组织。可以用GitHub账户登陆Azure DevOps创建组织，比如<code>dev.azure.com/SilenceZheng66</code>。</p><p>然后创建项目，在项目中创建PAT（Personal Access Tokens）并记住它。下面需要在<a href="https://marketplace.visualstudio.com/manage/createpublisher">Visual Studio Marketplace</a>创建一个publisher，这里需要注意的是这里必须使用刚才创建个人访问令牌的微软账号，这里的publisher需要和package.json里的publisher字段一致。</p><p>准备就绪后，下载<code>vsce</code>，用来打包/发布/管理插件的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g vsce</span><br></pre></td></tr></table></figure><p>执行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">vsce login SilenceZheng66</span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">vsce publish --no-dependencies</span><br></pre></td></tr></table></figure><p>使用webpack打包插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnpm i --save-dev webpack webpack-cli ts-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># package.json 脚本如下：</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;vscode:prepublish&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>,</span><br><span class="line"><span class="string">&quot;compile&quot;</span>: <span class="string">&quot;webpack --mode none&quot;</span>,</span><br><span class="line"><span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --mode none --watch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html">https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html</a><br>[2] <a href="https://github.com/yzhang-gh/vscode-markdown">https://github.com/yzhang-gh/vscode-markdown</a><br>[3] <a href="https://juejin.cn/post/7327570230775201826">https://juejin.cn/post/7327570230775201826</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/459554765">https://zhuanlan.zhihu.com/p/459554765</a><br>[5] <a href="https://juejin.cn/post/6844903921555603470">https://juejin.cn/post/6844903921555603470</a><br>[6] <a href="https://markdown-it.github.io">https://markdown-it.github.io</a><br>[7] <a href="https://juejin.cn/post/7076649162653040647">https://juejin.cn/post/7076649162653040647</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。&lt;/p&gt;
&lt;p&gt;但在做课题调研时我习惯使用&lt;code&gt;[n]&lt;/code&gt;作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫&lt;code&gt;Reference Extension&lt;/code&gt;吧。&lt;br&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://silencezheng.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>SpEL使用入门</title>
    <link href="http://silencezheng.top/2023/12/30/article125/"/>
    <id>http://silencezheng.top/2023/12/30/article125/</id>
    <published>2023-12-29T17:00:25.000Z</published>
    <updated>2023-12-29T17:02:59.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。</p><p>SpEL是单独模块（<code>org.springframework.expression</code>），只依赖于core模块，不依赖于其他模块，可以单独使用。<br><span id="more"></span></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先从一个简单的“literal string expression”例子引入，所谓“literal string”就是指代码中直接使用双引号括起来的字符串（起码在Java下是这样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先创建了解析器<code>ExpressionParser</code>，负责解析表达式字符串，表达式字符串是由周围的单引号表示的字符串字面量。而后解析表达式，<code>Expression</code>接口负责评估所定义的表达式字符串。最后对表达式进行求值，获取信息。</p><p>通过这一流程可以总结SpEL在求表达式值时的一般步骤：</p><ol><li>创建解析器</li><li>解析表达式</li><li>构造上下文</li><li>表达式求值</li></ol><p>其中第三步构造上下文是一个可选步骤，当需要准备上下文变量时会使用。</p><p>PS：在调用 <code>parser.parseExpression</code> 和 <code>exp.getValue</code> 时，可能分别抛出两个异常：<code>ParseException</code> 和 <code>EvaluationException</code>。<br>PPS：Evaluate可以理解为“求值”或“计算”。</p><h2 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h2><p>SpEL支持多种功能，如调用方法、访问属性和调用构造函数，这里用一个例子快速过一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用concat方法</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();  <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性，invokes &#x27;getBytes()&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套属性，invokes &#x27;getBytes().length&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes.length&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> length = (Integer) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;new String(&#x27;hello world&#x27;).toUpperCase()&quot;</span>);</span><br><span class="line">String message = exp.getValue(String.class); <span class="comment">// HELLO WORLD</span></span><br></pre></td></tr></table></figure><h2 id="更常见的用法"><a href="#更常见的用法" class="headerlink" title="更常见的用法"></a>更常见的用法</h2><p>SpEL更常见的用法是提供一个表达式字符串，针对特定对象实例（称为根对象）进行求值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并设置一个日历对象</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数分别为name, birthday, nationality</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">// 将&quot;name&quot;解析为表达式</span></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br></pre></td></tr></table></figure><h2 id="全部语法"><a href="#全部语法" class="headerlink" title="全部语法"></a>全部语法</h2><p>关于如何编写正确的表达式，可以参见 <a href="https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html">https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html</a></p><h1 id="EvaluationContext（求值上下文）"><a href="#EvaluationContext（求值上下文）" class="headerlink" title="EvaluationContext（求值上下文）"></a>EvaluationContext（求值上下文）</h1><p><code>EvaluationContext</code>接口用于计算表达式，以解析属性、方法或字段，并帮助执行类型转换。Spring 提供了两种实现：</p><ul><li><p><code>SimpleEvaluationContext</code>：该接口公开了基本 SpEL 功能和配置选项的子集，适用于不需要完整 SpEL 语言语法且应受到有意义限制的表达式类别，包括但不限于数据绑定表达式和基于属性的过滤器。</p></li><li><p><code>StandardEvaluationContext</code>：提供全套 SpEL 功能和配置选项，可以用它来指定默认根对象，并配置所有可用的求值相关策略。</p></li></ul><p><code>SimpleEvaluationContext</code> 只支持 SpEL 语法的一个子集。它不包括 Java 类型引用、构造函数和 Bean 引用。它还要求使用者明确选择对表达式中属性和方法的支持级别，默认情况下，<code>create()</code>静态工厂方法只能对属性进行读取访问。用户还可以获取一个构建器来配置所需的特定支持级别，针对以下一种或几种组合：</p><ul><li>Custom PropertyAccessor only (no reflection)</li><li>Data binding properties for read-only access</li><li>Data binding properties for read and write</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>默认情况下，SpEL 使用 Spring core 中的转换服务（org.springframework.core.convert.ConversionService）。该转换服务为常见转换提供了许多内置转换器，但也具有完全可扩展性，因此您可以在类型间添加自定义转换。此外，它还具有泛型感知功能。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换，以保持遇到的任何对象的类型正确性。</p><p>举个例子，假设使用 <code>setValue()</code> 进行赋值是为了设置 List 属性。该属性的类型实际上是 <code>List&lt;Boolean&gt;</code>。SpEL会识别到在将列表元素放入其中之前，需要将其转换为布尔值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Boolean&gt; booleanList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">simple.booleanList.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;false&quot; is passed in here as a String. SpEL and the conversion service</span></span><br><span class="line"><span class="comment">// will recognize that it needs to be a Boolean and convert it accordingly.</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;booleanList[0]&quot;</span>).setValue(context, simple, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b is false</span></span><br><span class="line">Boolean b = simple.booleanList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h1><p>可以使用解析器配置对象（org.springframework.expression.spel.SpelParserConfiguration）来配置 SpEL 表达式解析器，该配置对象可控制某些表达式组件的行为。例如，在对数组或集合进行索引时，指定索引处的元素为空，SpEL 会自动创建该元素。这在使用由一连串属性引用组成的表达式时非常有用。如果用户对数组或列表进行索引，并指定一个超出数组或列表当前大小的索引，SpEL 可以自动增长数组或列表以容纳该索引。为了在指定的索引处添加元素，SpEL 将尝试使用元素类型的默认构造函数创建元素，然后再设置指定的值。如果元素类型没有默认构造函数，则会将空值添加到数组或列表中。如果没有转换器（内置或自定义的）知道如何设置值，空值将保留在数组或列表的指定索引处。</p><p>下面的示例演示了如何自动增长列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn on:</span></span><br><span class="line"><span class="comment">// - auto null reference initialization</span></span><br><span class="line"><span class="comment">// - auto collection growing</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">&quot;list[3]&quot;</span>);</span><br><span class="line"></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">Object o = expression.getValue(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.list will now be a real collection of 4 entries</span></span><br><span class="line"><span class="comment">// Each entry is a new empty String</span></span><br></pre></td></tr></table></figure><h1 id="表达式编译（提升求值速度）"><a href="#表达式编译（提升求值速度）" class="headerlink" title="表达式编译（提升求值速度）"></a>表达式编译（提升求值速度）</h1><p>Spring Framework 4.1 包含一个基本的表达式编译器。表达式通常是<strong>解释型</strong>的，这在求值过程中提供了很大的动态灵活性，但无法提供最佳性能。对于偶尔使用表达式的情况，这并无大碍，但当其他组件（如 Spring Integration）使用表达式时，性能可能会变得非常重要，而且对动态性也没有真正的需求。</p><p>SpEL 编译器旨在满足这一需求。在评估过程中，编译器会生成一个 Java 类，在运行时体现表达式的行为，并使用该类实现更快的表达式求值。由于缺乏围绕表达式的类型，编译器在执行编译时会使用在表达式的解释求值过程中收集到的信息。例如，编译器并不能纯粹从表达式中知道属性引用的类型，但在第一次解释求值时，编译器就能知道它是什么类型。当然，如果各种表达式元素的类型随着时间的推移而发生变化，那么根据这些派生信息进行编译就会带来麻烦。因此，编译最适合类型信息不会在重复求值时发生变化的表达式。</p><p>例如对于基本表达式<code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code>来说，由于涉及数组访问、一些属性去引用和数值操作，因此性能提升非常明显。在一个迭代 50000 次的微型基准运行示例中，使用解释器求值需要 75 毫秒，而使用该表达式的编译版本仅需 3 毫秒。</p><h2 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h2><p>编译器默认情况下是不开启的，可以通过两种不同的方式开启它。</p><ol><li>通过使用解析器配置过程打开</li><li>在将SpEL嵌入到其他组件中时，还可以使用Spring属性来打开</li></ol><p>编译器可以在三种模式下运行，这些模式在 org.springframework.expression.spel.SpelCompilerMode 枚举中：</p><ul><li><code>OFF</code> (默认)：编译器关闭。</li><li><code>IMMEDIATE</code>：在立即模式下，表达式会尽快编译。通常是在第一次解释求值之后。如果编译表达式失败（通常是由于类型改变），表达式求值的调用者将收到异常。</li><li><code>MIXED</code>：在混合模式下，表达式会随着时间的推移在解释模式和编译模式之间默默切换。经过一定次数的解释运行后，它们会切换到编译形式，如果编译形式出了问题（如前面所述的类型改变），表达式会自动再次切换回解释形式。之后，它可能会生成另一个编译形式并切换到它。基本上，用户在 <code>IMMEDIATE</code> 模式下获得的异常会在内部处理。</li></ul><p><code>IMMEDIATE</code> 模式之所以存在，是因为 <code>MIXED</code> 模式可能会给有副作用的表达式造成问题。如果一个编译表达式在部分成功后崩溃，那么它可能已经执行了影响系统状态的操作。如果发生了这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能会运行两次。</p><p>选择模式后，使用 <code>SpelParserConfiguration</code> 配置解析器。下面的示例演示了如何进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,</span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expr = parser.parseExpression(<span class="string">&quot;payload&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyMessage message = <span class="keyword">new</span> MyMessage();</span><br><span class="line"></span><br><span class="line">Object payload = expr.getValue(message);</span><br></pre></td></tr></table></figure><p>在指定编译器模式时，还可以指定一个类加载器（允许传递空值）。编译后的表达式将定义在一个子类加载器中，该类加载器将根据所提供的任何类型创建。重要的是，如果指定了类加载器，要确保它能看到表达式求值过程中涉及的所有类型。如果未指定类加载器，则会使用默认类加载器（通常是表达式求值过程中运行线程的上下文类加载器）。</p><p>配置编译器的第二种方法适用于 SpEL 嵌入其他组件的情况，这种情况下可能无法通过配置对象进行配置。在这种情况下，可以通过 JVM 系统属性（或 SpringProperties 机制）将 <code>spring.expression.compiler.mode</code> 属性设置为<code>SpelCompilerMode</code>枚举值。</p><h2 id="编译器的局限性"><a href="#编译器的局限性" class="headerlink" title="编译器的局限性"></a>编译器的局限性</h2><p>自 Spring Framework 4.1 以来，基本的编译框架已经到位。不过，该框架还不支持编译所有类型的表达式。最初的重点是可能在性能关键型上下文中使用的常见表达式。以下几种表达式暂时无法编译：</p><ul><li>涉及赋值的表达式</li><li>依赖转换服务的表达式</li><li>使用自定义解析器或访问器的表达式</li><li>使用选择或投影的表达式</li></ul><h1 id="使用SpEL定义Bean"><a href="#使用SpEL定义Bean" class="headerlink" title="使用SpEL定义Bean"></a>使用SpEL定义Bean</h1><p>用户可以在基于XML或注解的配置元数据中使用SpEL表达式来定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法形式为<code>#&#123; &lt;expression string&gt; &#125;</code>。这里忽略XML配置方式，用的不多了。</p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>要指定默认值，可在字段、方法、方法或构造函数参数上添加<code>@Value</code>注解。</p><p>1、设置一个字段的默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> <span class="comment">// 读取的是服务部署机器的region</span></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、注入属性set方法默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方式，当Spring容器创建 <code>PropertyValueTestBean</code> 对象时，它将调用 <code>setDefaultLocale</code> 方法并传入系统属性中 ‘user.region’ 对应的值，从而设置 <code>defaultLocale</code> 成员变量的值。</p><p>3、<code>@Autowired</code>和构造函数也可以使用 <code>@Value</code> 注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.country&#x27;]&#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>一些值得关注的功能…</p><h2 id="ClassType表达式"><a href="#ClassType表达式" class="headerlink" title="ClassType表达式"></a>ClassType表达式</h2><p>使用<code>T(Type)</code>来表示<code>java.lang.Class</code>实例，<code>Type</code>必须是类全限定名（<code>java.lang</code>包下的类除外）。使用ClassType表达式还可以访问类静态方法及类静态字段。</p><p>下面的例子展示了如何使用ClassType表达式和如何进行条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang包内的不需要使用全限定名</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(String)&quot;</span>).getValue(Class.class);</span><br><span class="line"><span class="comment">// 类静态字段访问</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(Integer).MAX_VALUE&quot;</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 类静态方法调用</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;</span>, ParserContext.TEMPLATE_EXPRESSION).getValue(Double.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：</span></span><br><span class="line"><span class="comment">// 算数运算表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;1 + 1&quot;</span>).getValue(Integer.class);</span><br><span class="line"><span class="comment">// 关系表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2==2&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 逻辑表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2&gt;1 and (NOT true or NOT false)&quot;</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="comment">// instanceof表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(Integer)&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="函数、对象、变量的定义及引用"><a href="#函数、对象、变量的定义及引用" class="headerlink" title="函数、对象、变量的定义及引用"></a>函数、对象、变量的定义及引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;路人甲java&quot;</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;lesson&quot;</span>, <span class="string">&quot;Spring系列&quot;</span>);</span><br><span class="line">        <span class="comment">//获取name变量，lesson变量</span></span><br><span class="line">        String name = parser.parseExpression(<span class="string">&quot;#name&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(name);</span><br><span class="line">        String lesson = parser.parseExpression(<span class="string">&quot;#lesson&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(lesson);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象</span></span><br><span class="line">        <span class="comment">// StandardEvaluationContext构造器传入root对象，可以通过#root来访问root对象</span></span><br><span class="line">        context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">&quot;我是root对象&quot;</span>);</span><br><span class="line">        String rootObj = parser.parseExpression(<span class="string">&quot;#root&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(rootObj);</span><br><span class="line">        <span class="comment">// #this用来访问当前上下文中的对象</span></span><br><span class="line">        String thisObj = parser.parseExpression(<span class="string">&quot;#this&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(thisObj);</span><br><span class="line">        <span class="comment">// 定义List对象，过滤List并做投影运算</span></span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>));</span><br><span class="line">        context.setVariable(<span class="string">&quot;primes&quot;</span>, primes);  <span class="comment">// 注册对象变量</span></span><br><span class="line">        List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(<span class="string">&quot;#primes.?[#this&gt;10]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(primesGreaterThanTen.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义方法</span></span><br><span class="line">        context.registerFunction(<span class="string">&quot;reverseString&quot;</span>, SpELTest.class.getDeclaredMethod(<span class="string">&quot;reverseString&quot;</span>, String.class));</span><br><span class="line">        log.info(parser.parseExpression(<span class="string">&quot;#reverseString(&#x27;hello&#x27;)&quot;</span>).getValue(context, String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><p>SpEL引入了Groovy语言中的安全导航运算符<code>(对象|属性)?.属性</code>，用来避免<code>?.</code>前边的表达式为null时抛出空指针异常，转而返回null。还可以使用<code>?:</code>选择在表达式为null时返回默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">tesla.setName(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// null时取默认值</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?:&#x27;Unknown&#x27;&quot;</span>).getValue(context, String.class));</span><br><span class="line"><span class="comment">// null时安全调用</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?.length()&quot;</span>).getValue(context, Integer.class).toString());</span><br></pre></td></tr></table></figure><h2 id="List运算"><a href="#List运算" class="headerlink" title="List运算"></a>List运算</h2><p>在 SpEL 中，<code>?[]</code> 和 <code>![]</code> 分别表示集合选择（collection selection）和集合投影（collection projection）。<code>?[]</code> 表达式用于选择满足指定条件的集合元素，<code>![]</code> 表达式用于对集合进行投影操作。</p><blockquote><p>集合投影或集合映射的基本思想是：通过对集合中的每个元素应用一个表达式，生成一个新的集合，该集合包含了原始集合中的元素经过某种转换后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELCollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inventor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Bei Jin&quot;</span>);</span><br><span class="line">        Inventor tesla1 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla1&quot;</span>, <span class="string">&quot;Shang Hai&quot;</span>);</span><br><span class="line">        Inventor tesla2 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla2&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Inventor tesla3 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla3&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        Inventor tesla4 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla4&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        List&lt;Inventor&gt; inventors = Arrays.asList(tesla, tesla1, tesla2, tesla3, tesla4);</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">&quot;inventors&quot;</span>, inventors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对List做各类运算：</span></span><br><span class="line">        <span class="comment">// 过滤，选择所有 nationality 字段为 &#x27;Serbian&#x27; 的 Inventor 对象</span></span><br><span class="line">        List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.?[nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 nationality 字段，并返回一个新的 List</span></span><br><span class="line">        List&lt;Inventor&gt; list1 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list1.toString());</span><br><span class="line">        <span class="comment">// 投影，对所有对象的 nationality 字段是否为 &#x27;Serbian&#x27; 进行判断，并返回一个新的布尔类型List</span></span><br><span class="line">        List&lt;Inventor&gt; list2 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list2.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 serbian 字段，并返回一个新的 List，与list1等同。</span></span><br><span class="line">        List&lt;Inventor&gt; list3 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![#this.getNationality()]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问Map"><a href="#访问Map" class="headerlink" title="访问Map"></a>访问Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问map</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">params.put(<span class="string">&quot;backOrderCode&quot;</span>, <span class="string">&quot;H12345764564&quot;</span>);</span><br><span class="line">context.setVariable(<span class="string">&quot;params&quot;</span>, params);</span><br><span class="line">Object object = parser.parseExpression(<span class="string">&quot;#params[backOrderCode]&quot;</span>).getValue(context);</span><br><span class="line">log.info(object.toString());</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/174786047">https://zhuanlan.zhihu.com/p/174786047</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/149920813">https://zhuanlan.zhihu.com/p/149920813</a><br>[3] <a href="https://docs.spring.io/spring-framework/reference/core/expressions.html">https://docs.spring.io/spring-framework/reference/core/expressions.html</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。&lt;/p&gt;
&lt;p&gt;SpEL是单独模块（&lt;code&gt;org.springframework.expression&lt;/code&gt;），只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>空洞卷积</title>
    <link href="http://silencezheng.top/2023/12/25/article124/"/>
    <id>http://silencezheng.top/2023/12/25/article124/</id>
    <published>2023-12-24T18:01:57.000Z</published>
    <updated>2023-12-24T18:07:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。<br><span id="more"></span></p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>空洞卷积最初的提出是为了解决图像分割的问题，常见的图像分割算法通常使用池化层和卷积层来增加感受域，同时也缩小了特征图尺寸(resolution)，然后再利用上采样还原图像尺寸，特征图缩小再放大的过程造成了精度上的损失，因此需要一种操作可以在增加感受域的同时保持特征图的尺寸不变，从而代替下采样和上采样操作，在这种需求下，空洞卷积就诞生了。当然，跳跃连接（skip connection）也是另一种弥补信息损失的方法。</p><p>空洞卷积自2016在ICLR上被提出后，本身是用在图像分割领域，但立马被Deepmind拿来应用到语音(WaveNet)和NLP领域，它在物体检测也发挥了重要的作用。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在常规卷积运算中，固定大小的滤波器在输入特征图上滑动，滤波器中的值与输入特征图中的相应值相乘以产生单个输出值。输出特征图中神经元的感受域被定义为滤波器可以“看到”的输入特征图中的区域。感受域的大小由滤波器的大小和卷积的步长决定。</p><p>相反，在膨胀卷积运算中，通过在滤波器值之间插入间隙来“扩张”滤波器。<strong>膨胀率</strong>(dilation rate) 决定了间隙的大小，它是一个可以调整的超参数。当膨胀率为 1 时，膨胀卷积简化为常规卷积。</p><p>膨胀率在不增加参数数量的情况下有效地增加了滤波器的感受域，因为滤波器的大小仍然相同，但值之间有间隙。这在需要更大感受域的情况下很有用，但增加滤波器的大小会导致参数数量和计算复杂性的增加。</p><p>下图描述了正常卷积与扩张卷积之间的差异，附加参数$l$（膨胀因子）表示输入扩张了多少。换句话说，根据该参数的值，滤波器中会跳过$(l-1)$个像素。</p><p><img src="/assets/post_img/article124/normalvsdilatedconv.png" alt="dc"></p><p>膨胀卷积的公式可表示如下：</p><script type="math/tex; mode=display">\left(F_{* l} k\right)(p)=\sum_{(s+l t=p)} F(s) k(t)</script><p>其中，$F(s)$为输入特征，$s$为各采样位置，$k(t)$表示卷积核$k$在$t$处的权重，${*l}$表示膨胀因子为$l$的膨胀卷积。</p><p>$(F_{* l} k)(p)$为在位置$p$处的输出。求和条件还需要再看下…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在Pytorch中实现空洞卷积十分简单，只需要指定dilation参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DilatedCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(DilatedCNN,self).__init__()</span><br><span class="line">    self.convlayers = nn.Sequential(</span><br><span class="line">      nn.Conv2d(in_channels = <span class="number">3</span>, out_channels = <span class="number">6</span>, kernel_size = <span class="number">9</span>, stride = <span class="number">1</span>, padding = <span class="number">0</span>, dilation=<span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding= <span class="number">0</span>, dilation = <span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">    )</span><br><span class="line">    self.fclayers = nn.Sequential(</span><br><span class="line">      nn.Linear(<span class="number">2304</span>,<span class="number">120</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">120</span>,<span class="number">84</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line">    )</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    x = self.convlayers(x)</span><br><span class="line">    x = x.view(-<span class="number">1</span>,<span class="number">2304</span>)</span><br><span class="line">    x = self.fclayers(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>网格效应（The Gridding Effect）</li><li>Long-ranged information might be not relevant.</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/113285797">https://zhuanlan.zhihu.com/p/113285797</a><br>[2] <a href="https://www.geeksforgeeks.org/dilated-convolution/">https://www.geeksforgeeks.org/dilated-convolution/</a><br>[3] <a href="https://developer.orbbec.com.cn/v/blog_detail/892">https://developer.orbbec.com.cn/v/blog_detail/892</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在Spring项目中使用数据库事务</title>
    <link href="http://silencezheng.top/2023/11/24/article123/"/>
    <id>http://silencezheng.top/2023/11/24/article123/</id>
    <published>2023-11-24T15:48:44.000Z</published>
    <updated>2023-11-24T15:57:36.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。</p><p>相关内容：InnoDB事务实现、Spring事务传播机制等。<br><span id="more"></span></p><h1 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong>。事务是一种用于维护数据一致性的机制，它确保了数据库在多个并发操作下仍然保持一致性。</p><p>事务（最小操作单元）存在的主要意图：</p><ul><li>在最小操作单元中保持稳定的操作，即使在故障时也能恢复到操作之前的状态保持数据一致性。</li><li>保持各个最小操作单元之间互相隔离，以防止互相交互产生的覆盖性错误。</li></ul><p>事务结束的两种可能方式：</p><ul><li><code>commit</code>：提交最小操作单元中的所有操作。</li><li><code>terminate</code>：操作终止，最小操作单元中所有修改无效。</li></ul><p>数据库操作的环境：</p><ul><li>共享-多用户并发访问</li><li>不稳定-潜在的硬件/软件故障</li></ul><p>事务所需环境：</p><ul><li>不共享 - 一个事务内的操作不受其他事务影响</li><li>稳定 - 即使面对系统故障，当前事务的操作也能保留现场</li></ul><p>一个事务一旦开始，则必须确保：</p><ul><li>所有操作必须可回溯</li><li>所有操作对后续操作的影响必须是可见的</li></ul><p>一个事务开始的过程中必须确保：在该事务结束之前其他事务看不到它的结果。如果事务中止，必须确保当前事务所有可能影响数据一致性的操作都会被清理。如果系统出现故障，必须确保重新启动时所有未提交的事务都会被清理。</p><p>关系型数据库大多遵循事务的四大特性：</p><ol><li>原子性（Atomicity）：事务是最小的执行单位，事务中的所有操作要么全部成功执行，要么全部失败回滚。如果其中任何一个操作失败，那么整个事务都会被回滚到初始状态。</li><li>一致性（Consistency）：事务在执行前后，数据库必须保持一致性状态。这意味着事务执行后，数据库的完整性约束仍然得以维护，以转账业务为例，双方存款总额应不变。</li><li>隔离性（Isolation）：事务的执行应该与其他事务相互隔离，即一个事务的执行不应该影响其他事务的执行。这确保了并发事务之间的数据不会互相干扰。</li><li>持久性（Durability）：一旦事务提交成功，对数据库的修改应该永久保存，即使数据库发生故障也不应该对其有影响。</li></ol><p>关于四大特性的一些理解：</p><blockquote><p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。只有保证了事务的持久性、原子性、隔离性之后，一致性才可能得到保障。</p></blockquote><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久性是为了能应对数据库崩溃的情况。</li></ul><h1 id="InnoDB事务实现"><a href="#InnoDB事务实现" class="headerlink" title="InnoDB事务实现"></a>InnoDB事务实现</h1><p>MySQL提供插件式存储引擎，这些存储引擎是基于表的，而不是数据库。</p><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。它的特点是行锁设计，支持外键，并支持非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是MySQL默认的存储引擎。</p><p>在InnoDB引擎中实现事务最重要的东西就是日志系统，保证事务的四大特性主要依靠这两大日志：</p><ul><li><strong>redo log</strong>：保证事务持久性</li><li><strong>undo log</strong>：回滚日志，保证事务原子性</li></ul><p>两大日志系统分别保证了持久性和原子性，隔离性则是通过<strong>MVCC机制</strong>和<strong>锁机制</strong>来控制实现。</p><h2 id="Logical-logs-amp-Physical-logs"><a href="#Logical-logs-amp-Physical-logs" class="headerlink" title="Logical logs &amp; Physical logs"></a>Logical logs &amp; Physical logs</h2><p><strong>逻辑日志（Logical Logs）：</strong></p><ol><li><strong>记录内容</strong>：逻辑日志记录的是数据库操作的逻辑信息，例如SQL语句、表和列的名称、数据的逻辑结构等。它不关心底层数据的物理存储方式。</li><li><strong>用途</strong>：逻辑日志主要用于数据导入、导出、备份和恢复等高层次的数据操作。它允许将数据从一个数据库复制到另一个数据库，而不必考虑底层数据的物理结构。</li><li><strong>示例</strong>：MySQL的二进制日志（binlog）是一种逻辑日志，记录了SQL语句的执行顺序，以便在复制数据或进行数据备份时使用。</li></ol><p><strong>物理日志（Physical Logs）：</strong></p><ol><li><strong>记录内容</strong>：物理日志记录的是数据库操作对底层物理数据的实际修改，包括数据页的读写、磁盘块的分配和释放等。它关注数据的物理存储细节。</li><li><strong>用途</strong>：物理日志主要用于确保事务的持久性和恢复能力。它允许在系统崩溃或故障后恢复未提交的事务，以及将事务的修改应用到数据库中。</li><li><strong>示例</strong>：MySQL的重做日志（redo log）是一种物理日志，记录了事务对数据页的修改，以便在事务提交后将这些修改应用到数据文件中，或者在系统故障时恢复数据一致性。</li></ol><p>以上只是简要的概念解释，更多信息可以参见[6]。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>在介绍InnoDB的两大核心日志前，先简单聊一下MySQL的二进制日志，对理解Redo log的作用有帮助。</p><p>binlog = binary log，二进制日志，它记录了除了 select 之外所有的 DDL 和 DML 语句。以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL都会记录binlog日志。</p><p>binlog日志有两个最重要的使用场景：</p><ul><li>主从复制：mysql replication 在 master 端开启 binlog，master 把它的二进制日志传递给 slaves 来达到 master-slave 数据一致的目的。</li><li>数据恢复：通过 mysqlbinlog 工具来恢复数据。</li></ul><p>binlog 日志包括两类文件：</p><ol><li>二进制日志索引文件（文件名后缀为 .index）用于记录所有的二进制文件。</li><li>二进制日志文件（文件名后缀为 .00000*）记录数据库所有的 DDL 和 DML 语句事件。</li></ol><p>binlog文件是通过追加的方式写入的，可通过配置参数<code>max_binlog_size</code>设置每个 binlog 文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。</p><p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。在 MySQL 5.7.7之前，默认的格式是STATEMENT，MySQL 5.7.7之后，默认值是ROW。日志格式通过<code>binlog-format</code>指定。</p><p>我们假设数据库只有 binlog，那么数据文件的更新和写入 binlog 只有两种情况：</p><ol><li>先更新数据文件，再写入 binlog。</li><li>先写入 binlog，再更新数据文件。</li></ol><p>如果先更新数据文件，接着服务器宕机，则导致 binlog 中缺少最后的更新信息；如果先写 binlog 再更新数据则可能导致数据文件未被更新。所以在只有 binlog 的环境中的 MySQL 是不具备 crash-safe 的能力。</p><p>PS：这里关于binlog的写入机制不做过多展开，但也是分write和fsync两个步骤，时机由参数<code>sync_binlog</code>控制。</p><h2 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h2><p>Write-Ahead Logging策略是一种用于确保数据一致性和恢复能力的重要技术，为了保证恢复时可以从日志中看到最新的数据库状态，要求日志先于数据内容落盘。其核心思想是在修改数据之前，首先将这些修改操作记录到一个持久性的日志文件中，然后再将这些操作应用到实际的数据文件。注意这里的日志是比binlog更细粒度的日志。</p><p>除此之外，事务完成提交前还需要在日志中记录对应的Commit标记，以供恢复时了解当前的事务状态，因此还需要关注Commit标记和事务中数据内容的落盘顺序。根据日志中记录的内容可以分为三类：<strong>Undo-Only</strong>，<strong>Redo-Only</strong>，<strong>Redo-Undo</strong>。</p><h3 id="Undo-Only-Logging"><a href="#Undo-Only-Logging" class="headerlink" title="Undo-Only Logging"></a>Undo-Only Logging</h3><p>Undo-Only Logging的Log记录可以表示为<code>&lt;T, X, v&gt;</code>，事务$T$修改了$X$的值，$X$的旧值是v。事务提交时，需要通过强制Flush保证Commit标记落盘前，对应事务的所有数据落盘，即落盘顺序为Log记录-&gt;Data-&gt;Commit标记。恢复时可以根据Commit标记判断事务的状态，并通过Undo Log中记录的旧值将未提交事务的修改回滚。我们来审视一下Undo-Only对Durability及Atomic的保证：</p><ul><li>Durability of Updates：Data强制刷盘保证，已经Commit的事务由于其所有Data都已经在Commit标记之前落盘，因此会一直存在；</li><li>Failure Atomic：Undo Log内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>然而Undo-Only依然有不能Page内并发的问题，如果两个事务的修改落到一个Page中，一个事务提交前需要的强制Flush操作，会导致同Page所有事务的Data落盘，可能会早于对应的Log项从而损害WAL。同时，也会导致关键路径上过于频繁的磁盘随机访问。</li></ul><h3 id="Redo-Only-Logging"><a href="#Redo-Only-Logging" class="headerlink" title="Redo-Only Logging"></a>Redo-Only Logging</h3><p>不同于Undo-Only，采用Redo-Only的Log中记录的是修改后的新值。对应地，Commit时需要保证，Log中的Commit标记在事务的任何数据之前落盘，即落盘顺序为Log记录-&gt;Commit标记-&gt;Data。恢复时同样根据Commit标记判断事务状态，并通过Redo Log中记录的新值将已经Commit，但数据没有落盘的事务修改重放。</p><ul><li>Durability of Updates：Redo Log内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：阻止Commit前Data落盘保证，失败事务的修改不会出现在磁盘上，自然不可见。<br>Redo-Only同样有不能Page内并发的问题，Page中的多个不同事务，<strong>只要有一个未提交就不能刷盘，这些数据全部都需要维护在内存中，造成较大的内存压力</strong>。</li></ul><h3 id="Redo-Undo-Logging"><a href="#Redo-Undo-Logging" class="headerlink" title="Redo-Undo Logging"></a>Redo-Undo Logging</h3><p>可以看出的只有Undo或Redo的问题，主要来自于对Commit标记及Data落盘顺序的限制，而这种限制归根结底来源于Log信息中对新值或旧值的缺失。因此Redo-Undo采用同时记录新值和旧值的方式，来消除Commit和Data之间刷盘顺序的限制。</p><ul><li>Durability of Updates：Redo 内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：Undo内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>如此一来，同Page的不同事务提交就变得非常简单。同时可以将连续的数据攒着进行批量的刷盘已利用磁盘较高的顺序写性能。</li></ul><h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入磁盘后，内存和磁盘上的数据页内容就一致了，称为“干净页”。刷脏页，即把脏页（内存中的修改过的数据页）刷新（flush）到磁盘上。</p><p>对于 InnoDB 存储引擎，缓冲池（buffer pool）是内存中的一个重要组成部分。当查询需要读取数据时，数据库首先查看缓冲池中是否已经有相应的数据页。如果数据页在缓冲池中，查询可以立即从内存中获取数据，而不必进行磁盘读取，这大大提高了性能。如果数据页不在缓冲池中（缓冲池未命中），数据库系统将从磁盘读取该数据页，并将其放入缓冲池中，以便将来的查询可以更快地访问。缓冲池的大小通常是可以配置的，数据库管理员可以根据系统的内存和性能需求来调整缓冲池的大小。</p><p>对于事务处理，数据的修改通常首先在内存中进行，然后等待事务提交。在事务提交之前，数据在内存中被认为是脏的，因为它们还未被写入到磁盘。下面有一段文字可以也可以帮助引出Redo log的作用。</p><blockquote><p>InnoDB 有 缓冲池（buffer pool）。缓冲池是物理页的缓存，对 InnoDB 的任何修改操作都会首先在缓冲池的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的 flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO操作，同时异步写入也降低了访问的时延。</p><p>然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了缓冲池页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。</p></blockquote><h2 id="Redo-log-Durability"><a href="#Redo-log-Durability" class="headerlink" title="Redo log (Durability)"></a>Redo log (Durability)</h2><p>Redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p><p>在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer写入redo log file实际上是先写入文件系统page cache，然后再通过系统调用fsync将其刷到redo log file中。由此可以得到redo log的三种状态：</p><ol><li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中。</li><li>写到磁盘 (write)，但是没有持久化，物理上是在文件系统的 page cache 里面。</li><li>调用fsync，持久化到磁盘。</li></ol><p>事务在执行过程中，对内存中数据页进行修改将生成redo log，生成的 redo log 是先写到 redo log buffer 中，然后通过某些方式刷入磁盘。这里所指的方式，个人理解主要有五种：</p><ol><li>后台线程每秒一次执行刷盘，并行轮询。</li><li>每个事务提交时依据策略刷盘。</li><li>当redo log buffer缓存可用空间小于一半的时候刷盘，整体空间受<code>innodb_log_buffer_size</code>控制。这个情况的刷盘仅指write，然后可能被后台线程刷盘，这也是未提交redo log刷盘的可能情况之一。</li><li>数据库服务器正常关闭时。</li><li>检查点，<strong>checkpoints</strong>。</li></ol><p>PS：另外两种情况是：1、事务执行过程中的 redo log 也是直接写在 redo log buffer 中的，即将事务的修改暂时保存于内存中，这些 redo log 也会被后台线程一起持久化到磁盘。即一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。2、事务并行，先提交的事务把其他事务的redo log buffer刷盘。</p><p>Redo log的在事务提交时的写入策略由参数<code>innodb_flush_log_at_trx_commit</code>控制，有以下三种取值选项：</p><ol><li>设置为<code>0</code>的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为<code>1</code>的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘（默认）；</li><li>设置为<code>2</code>的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>（TODO：这一部分应该有问题，内存中的数据也会写入，不过这时候落盘的脏数据就靠undo了）那么了解了redo log的写入机制后，它到底是如何实现保证数据库持久性的呢？下面我尝试从一个事务的开始进行分析。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Chain1:</span> 事务开始 -&gt; 数据页读取 -&gt; 事务执行（数据页修改 &amp; <span class="keyword">redo</span> log生成）-&gt; 事务提交 -&gt; 事务结束</span><br><span class="line"><span class="symbol">Chain2:</span>                           执行过程中会发生<span class="keyword">redo</span> log刷盘  依据策略决定是否直接刷盘    </span><br></pre></td></tr></table></figure><p>我把执行流程分为了两个链条，chain1是事务执行的流程，chain2是redo log部分InnoDB在对应位置可能采取的操作。下面我们在chain1的每个部分模拟掉电关机，看会发生什么事情。由于这一块内容实际上是崩溃恢复相关内容，我们先定义<strong>正常状态</strong>，<strong>正常状态</strong>指的是 MySQL 崩溃之前，数据页最后一次正确的刷新到磁盘的状态。</p><p>1、数据页读取：对数据库完整性无影响。<br>2、事务执行（redo log生成未落盘）：无影响，事务未提交。<br>3、事务执行（redo log生成已落盘）：无影响，事务未提交。<br>4、事务提交（redo log写入策略=1）：任意时间崩溃，都可以通过redo log执行恢复，损坏的数据页可以通过<strong>double write</strong>修复后再执行恢复。<br>5、事务提交（redo log写入策略=2）：如果在redo log刚写入未刷盘时断电，则会丢失上一秒的数据，仅mysqld崩溃不会丢失数据。<br>6、事务提交（redo log写入策略=0）：与上一情况相同，但如果崩溃情况降级，例如mysqld崩溃，也会丢失数据。</p><p>注意以上分析仅是简化版，更多细节如Checkpoints、Double write、LSN、Mini-Transaction等…需要多读书实践才能通透了，需要时再学习吧。</p><h2 id="Undo-log-Atomicity"><a href="#Undo-log-Atomicity" class="headerlink" title="Undo log (Atomicity)"></a>Undo log (Atomicity)</h2><p>Undo Log是InnoDB十分重要的组成部分，它的作用横贯InnoDB中两个最主要的部分，并发控制（Concurrency Control）和故障恢复（Crash Recovery），InnoDB中undo log的实现亦日志亦数据。</p><p>为保证原子性，InnoDB会在正常事务进行中，就不断的连续写入undo log，来记录本次修改之前的历史值。当故障真正发生时，可以在recovery过程中通过回放undo log将未提交事务的修改抹掉。此外，undo log也可以用来支持死锁处理或用户请求的事务回滚。</p><p>在并发控制中，主流数据库采用多版本并发控制，为每条记录保存多份历史数据供读事务访问，新的写入只需要添加新的版本即可，InnoDB利用undo log提供此功能。</p><p>在设计方面，undo log需要的是事务之间的并发，以及方便的多版本数据维护，其重放逻辑不希望因数据库物理存储变化而变化，因此InnoDB中的undo log采用<strong>逻辑日志</strong>。同时，InnoDB是把undo log当做一种数据来维护和使用的，其本身也像其他的数据库数据一样，会写自己对应的redo log，以此保证自己不出错。</p><h3 id="Undo-Record的内容"><a href="#Undo-Record的内容" class="headerlink" title="Undo Record的内容"></a>Undo Record的内容</h3><p>每当InnoDB中需要修改某条记录时，都会将其历史版本写入一个undo log中，对应的undo record是Update类型。当插入新的记录时，还没有一个历史版本，但为了方便事务回滚时做逆向（Delete）操作，还是会写入一个Insert类型的undo record。</p><p>对于Insert类型的undo record，它仅仅是为了可能的事务回滚准备的，并不在MVCC功能中承担作用，因此只需要用<strong>Key Fields</strong>记录对应数据库记录的主键，供回滚时查找记录位置即可。</p><p><img src="/assets/post_img/article123/insert_undo_record.png" alt=""></p><p>其中Undo Number是Undo的一个递增编号，Table ID用来表示是哪张表的修改。下面一组Key Fields的长度不定，因为对应表的主键可能由多个field组成，这里需要存储数据库记录完整的主键信息，回滚的时候可以通过这个信息在索引中定位到对应的记录。除此之外，在Undo Record的头尾还各留了两个字节用户记录其前序和后继Undo Record的位置。</p><p>对于Update类型的undo record，情况稍微复杂一些，由于MVCC需要保留记录的多个历史版本，当某个记录的历史版本还在被使用时，这个记录是不能被真正的删除的。因此，当需要删除时，其实只是修改对应记录的Delete Mark标记。对应的，如果这时这个记录又重新插入，其实也只是修改一下Delete Mark标记，也就是将这两种情况的删除和插入转变成了更新操作。再加上常规的更新记录，这种类型的undo record存在三种类型：<code>TRX_UNDO_UPD_EXIST_REC, TRX_UNDO_DEL_MARK_REC, TRX_UNDO_UPD_DEL_REC</code>。</p><p><img src="/assets/post_img/article123/update_undo_record.png" alt=""></p><p>除了<strong>Key Fields</strong>外，Update类型的undo record增加了以下内容：</p><ol><li>Transaction Id，记录了产生这个历史版本事务ID，用作后续MVCC中的版本可见性判断。</li><li>RollPtr，指向的是该记录的上一个版本的位置，沿着RollPtr可以找到一个记录的所有历史版本。</li><li>Update Fields，其中记录的就是当前这个记录版本相对于其之后的一次修改的Delta信息，包括所有被修改的Field的编号，长度和历史值。</li></ol><h3 id="Undo-Record的组织方式"><a href="#Undo-Record的组织方式" class="headerlink" title="Undo Record的组织方式"></a>Undo Record的组织方式</h3><p>每一次的修改都会产生至少一个Undo Record，现在考虑大量Undo Record如何组织起来支持高效访问与管理。首先是在不考虑物理存储的情况下的逻辑组织方式；之后，物理组织方式介绍如何将其存储到到实际16KB物理块中；然后文件组织方式介绍整体的文件结构；最后再介绍其在内存中的组织方式。</p><h4 id="逻辑组织方式-Undo-Log"><a href="#逻辑组织方式-Undo-Log" class="headerlink" title="逻辑组织方式 - Undo Log"></a>逻辑组织方式 - Undo Log</h4><p>每个事务会修改一组数据库记录，对应的会产生一组Undo Record，这些Undo Record首尾相连组成了这个事务的Undo Log。除了一个个的Undo Record之外，还在开头增加了一个Undo Log Header来记录一些必要的控制信息，因此，一个Undo Log的结构如下所示：</p><p><img src="/assets/post_img/article123/undo_log.png" alt=""></p><p><strong>Undo Log Header</strong>中记录了产生这个Undo Log的事务的Trx ID；Trx No是事务的提交顺序，也会用这个来判断是否能Purge，这个在后面会详细介绍；Delete Mark标明该Undo Log中有没有<code>TRX_UNDO_DEL_MARK_REC</code>类型的Undo Record，避免Purge时不必要的扫描；Log Start Offset中记录Undo Log Header的结束位置，方便之后Header中增加内容时的兼容；之后是一些Flag信息；Next Undo Log及Prev Undo Log标记前后两个Undo Log，这个会在接下来介绍；最后通过History List Node将自己挂载到为Purge准备的History List中。</p><p>索引中的同一个数据库记录被不同事务修改，会产生不同的历史版本，这些历史版本又通过<strong>Rollptr</strong>穿成一个链表，供MVCC使用。如下图所示：</p><p><img src="/assets/post_img/article123/undo_logical.png" alt=""></p><p>示例中有三个事务操作了表$t$上，主键id是1的记录，首先事务$I$插入了这条记录并且设置字段$a$的值为A，之后事务$J$和事务$K$分别将这条id为1的记录中的字段$a$的值修改为了B和C。$I$，$J$，$K$三个事务分别有自己的逻辑上连续的三条Undo Log，每条Undo Log有自己的Undo Log Header。从索引中的这条数据库记录沿着<strong>Rollptr</strong>可以依次找到这三个事务Undo Log中关于这条记录的历史版本。同时可以看出，Insert类型Undo Record中只记录了对应的主键值：<code>id=1</code>，而Update类型的Undo Record中还记录了对应的历史版本的生成事务Trx_id，以及被修改的字段$a$的历史值。</p><h4 id="物理组织格式-Undo-Segment"><a href="#物理组织格式-Undo-Segment" class="headerlink" title="物理组织格式 - Undo Segment"></a>物理组织格式 - Undo Segment</h4><p>一个事务会产生多大的Undo Log本身是不可控的，而最终写入磁盘却是按照固定的块大小为单位的，InnoDB中默认是16KB，因此需要考虑如何用固定的块大小承载不定长的Undo Log，以实现高效的空间分配、复用，避免空间浪费。InnoDB的基本思路是让多个较小的Undo Log紧凑存在一个Undo Page中，而对较大的Undo Log则随着不断的写入，按需分配足够多的Undo Page分散承载。下面来看这部分的物理存储方式：</p><p><img src="/assets/post_img/article123/undo_physical.png" alt=""></p><p>每个写事务开始写操作之前都需要持有一个Undo Segment，一个Undo Segment中的所有磁盘空间的分配和释放，也就是16KB Page的申请和释放，都是由一个FSP Segment管理的。</p><blockquote><p>FSP（File Space Page）是InnoDB存储引擎中的一个概念，表示文件空间段（Segment）。每个FSP Segment对应于一个表空间（tablespace），用于存储数据和索引。</p><p>在InnoDB中，数据和索引被组织为一个个页面（Page），而这些页面又按照一定的方式来组织并保存在FSP Segment中。FSP Segment是InnoDB存储引擎管理存储空间的基本单位。</p><p>FSP Segment包含多个连续的文件空间页（File Space Pages），这些页面可以是数据页、索引页或其他类型的页，以满足不同的存储需求。每个FSP Segment都有自己的FSP ID（File Space Page ID），用于唯一标识它。</p></blockquote><p>Undo Segment会持有至少一个Undo Page，每个Undo Page会在开头38字节到56字节记录Undo Page Header，其中记录Undo Page的类型、最后一条Undo Record的位置，当前Page还空闲部分的开头，也就是下一条Undo Record要写入的位置。Undo Segment中的第一个Undo Page还会在56字节到86字节记录<strong>Undo Segment Header</strong>，这就是这个Undo Segment中磁盘空间管理的Handle，其中记录的是这个Undo Segment的状态（State），包括TRX_UNDO_CACHED、TRX_UNDO_TO_PURGE等，还记录了这个Undo Segment中最后一条Undo Record的位置、这个FSP Segment的Header以及当前分配出来的所有Undo Page的链表。</p><p>Undo Page剩余的空间都是用来存放Undo Log的，对于像上图Undo Log 1，Undo Log 2这种较短的Undo Log，为了避免Page内的空间浪费，InnoDB会复用Undo Page来存放多个Undo Log，而对于像Undo Log 3这种比较长的Undo Log可能会分配多个Undo Page来存放。需要注意的是Undo Page的复用只会发生在第一个Page。</p><h4 id="文件组织方式-Undo-Tablespace"><a href="#文件组织方式-Undo-Tablespace" class="headerlink" title="文件组织方式 - Undo Tablespace"></a>文件组织方式 - Undo Tablespace</h4><p>每一时刻一个Undo Segment都是被一个事务独占的。每个写事务都会持有至少一个Undo Segment，当有大量写事务并发运行时，就需要存在多个Undo Segment。InnoDB中的Undo文件中准备了大量的Undo Segment的槽位，按照1024一组划分为<strong>Rollback Segment</strong>。每个<strong>Undo Tablespace</strong>最多会包含128个Rollback Segment，Undo Tablespace文件中的第三个Page会固定作为这128个Rollback Segment的目录，也就是<strong>Rollback Segment Arrary Header</strong>，其中最多会有128个指针指向各个Rollback Segment Header所在的Page。Rollback Segment Header是按需分配的，其中包含1024个Slot，每个<strong>Slot</strong>占四个字节，指向一个Undo Segment的First Page。除此之前还会记录该Rollback Segment中已提交事务的History List，后续的Purge过程会顺序从这里开始回收工作。</p><p>可以看出Rollback Segment的个数会直接影响InnoDB支持的最大事务并发数。MySQL 8.0由于支持了最多127个独立的Undo Tablespace，一方面避免了ibdata1的膨胀，方便undo空间回收，另一方面也大大增加了最大的Rollback Segment的个数，增加了可支持的最大并发写事务数。如下图所示：</p><p><img src="/assets/post_img/article123/undo_tablespace.png" alt=""></p><h4 id="内存组织结构"><a href="#内存组织结构" class="headerlink" title="内存组织结构"></a>内存组织结构</h4><p>上面介绍的都是Undo数据在磁盘上的组织结构，除此之外，在内存中也会维护对应的数据结构来管理Undo Log，如下图所示：</p><p><img src="/assets/post_img/article123/undo_memory.png" alt=""></p><p>对应每个磁盘Undo Tablespace会有一个<strong>undo::Tablespace</strong>的内存结构，其中最主要的就是一组<strong>trx_rseg_t</strong>的集合，trx_rseg_t对应的就是上面介绍过的一个Rollback Segment Header（目录），除了一些基本的元信息之外，trx_rseg_t中维护了四个trx_undo_t的链表，Update List中是正在被使用的用于写入Update类型Undo的Undo Segment；Update Cache List中是空闲空间比较多，可以被后续事务复用的Update类型Undo Segment;对应的，Insert List和Insert Cache List分别是正在使用中的Insert类型Undo Segment，和空间空间较多，可以被后续复用的Insert类型Undo Segment。因此<strong>trx_undo_t对应的就是上面介绍过的Undo Segment</strong>。接下来，我们就从Undo的写入、Undo用于Rollback、MVCC、Crash Recovery以及如何清理Undo等方面来介绍InnoDB中Undo的角色和功能。</p><h3 id="Undo-Log的写入"><a href="#Undo-Log的写入" class="headerlink" title="Undo Log的写入"></a>Undo Log的写入</h3><p>当写事务开始时，会先通过<strong>trx_assign_rseg_durable</strong>操作分配一个Rollback Segment，该事务的内存结构<strong>trx_t</strong>也会通过rsegs指针指向对应的trx_rseg_t内存结构，这里的分配策略很简单，就是依次尝试下一个Active的Rollback Segment。之后当第一次真正产生修改需要写Undo Record的时，会调用<strong>trx_undo_assign_undo</strong>操作来获得一个Undo Segment。这里会优先复用trx_rseg_t上<strong>Cached List</strong>中的trx_undo_t，也就是已经分配出来但没有被正在使用的Undo Segment，如果没有才调用<strong>trx_undo_create</strong>操作创建新的Undo Segment，trx_undo_create中会轮询选择当前Rollback Segment中可用的Slot，也是就值FIL_NUL的Slot，申请新的Undo Page，初始化Undo Page Header，Undo Segment Header等信息，创建新的trx_undo_t内存结构并挂到trx_rseg_t的对应List中。</p><p>获得了可用的Undo Segment之后，该事务会在合适的位置初始化自己的Undo Log Header，之后，其所有修改产生的Undo Record都会顺序的通过<strong>trx_undo_report_row_operation</strong>操作顺序的写入当前的Undo Log，其中会根据是insert还是update类型，分别调用trx_undo_page_report_insert或者trx_undo_page_report_modify。本文开始已经介绍过了具体的Undo Record内容。简单的讲，insert类型会记录插入Record的主键，update类型除了记录主键以外还会有一个update fileds记录这个历史值跟索引值的diff。之后指向当前Undo Record位置的Rollptr会返回写入索引的Record上。</p><p>当一个Page写满后，会调用<strong>trx_undo_add_page</strong>来在当前的Undo Segment上添加新的Page，新Page写入Undo Page Header之后继续供事务写入Undo Record，为了方便维护，这里有一个限制就是单条Undo Record不跨page，如果当前Page放不下，会将整个Undo Record写入下一个Page。</p><p>当事务结束（commit或者rollback）之后，如果只占用了一个Undo Page，且当前Undo Page使用空间小于page的3/4，这个Undo Segment会保留并加入到对应的insert/update cached list中。否则，insert类型的Undo Segment会直接回收，而update类型的Undo Segment会等待后台的Purge做完后回收。根据不同的情况，Undo Segment Header中的State会被从<code>TRX_UNDO_ACTIVE</code>改成<code>TRX_UNDO_TO_FREE</code>，<code>TRX_UNDO_TO_PURGE</code>或<code>TRX_UNDO_CACHED</code>，这个修改其实就是InnoDB的事务结束的标志，无论是Rollback还是Commit，在这个修改对应的Redo落盘之后，就可以返回用户结果，并且Crash Recovery之后也不会再做回滚处理。</p><h3 id="Undo-Log之回滚"><a href="#Undo-Log之回滚" class="headerlink" title="Undo Log之回滚"></a>Undo Log之回滚</h3><p>InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或者发生Crash，重启后对未提交的事务回滚。在Undo层面来看，这些回滚的操作是一致的，基本的过程就是从该事务的Undo Log中，从后向前依次读取Undo Record，并根据其中内容做逆向操作，恢复索引记录。</p><p>回滚的入口是函数<strong>row_undo</strong>，其中会先调用trx_roll_pop_top_rec_of_trx获取并删除该事务的最后一条Undo Record。如下图例子中的Undo Log包括三条Undo Records，其中Record 1在Undo Page 1中，Record 2，3在Undo Page 2中，先通过从Undo Segment Header中记录的Page List找到当前事务的最后一个Undo Page的Header，并根据Undo Page 2的Header上记录的Free Space Offset定位最后一条Undo Record结束的位置，当然实际运行时，这两个值是缓存在trx_undo_t的top_page_no和top_offset中的。利用Prev Record Offset可以找到Undo Record 3，做完对应的回滚操作之后，再通过前序指针Prev Record Offset找到前一个Undo Record，依次进行处理。处理完当前Page中的所有Undo Records后，再沿着Undo Page Header中的List找到前一个Undo Page，重复前面的过程，完成一个事务所有Page上的所有Undo Records的回滚。</p><p><img src="/assets/post_img/article123/undo_rollback.png" alt=""></p><p>拿到一个Undo Record之后，自然地，就是对其中内容的解析，这里会调用row_undo_ins_parse_undo_rec，从Undo Record中获取修改行的table，解析出其中记录的主键信息，如果是update类型，还会拿到一个update vector记录其相对于更新的一个版本的变化。</p><p><code>TRX_UNDO_INSERT_REC</code>类型的Undo回滚在row_undo_ins中进行，insert的逆向操作当然就是delete，根据从Undo Record中解析出来的主键，用row_undo_search_clust_to_pcur定位到对应的ROW， 分别调用row_undo_ins_remove_sec_rec和row_undo_ins_remove_clust_rec在二级索引和主索引上将当前行删除。</p><p>update类型的undo包括<code>TRX_UNDO_UPD_EXIST_REC</code>，<code>TRX_UNDO_DEL_MARK_REC</code>和<code>TRX_UNDO_UPD_DEL_REC</code>三种情况，他们的Undo回滚都是在row_undo_mod中进行，首先会调用row_undo_mod_del_unmark_sec_and_undo_update，其中根据从Undo Record中解析出的update vector来回退这次操作在所有二级索引上的影响，可能包括重新插入被删除的二级索引记录、去除其中的Delete Mark标记，或者用update vector中的diff信息将二级索引记录修改之前的值。之后调用row_undo_mod_clust同样利用update vector中记录的diff信息将主索引记录修改回之前的值。</p><p>完成回滚的Undo Log部分，会调用trx_roll_try_truncate进行回收，对不再使用的page调用trx_undo_free_last_page将磁盘空间交还给Undo Segment，这个是写入过程中trx_undo_add_page的逆操作。</p><h3 id="Undo-Log之故障恢复"><a href="#Undo-Log之故障恢复" class="headerlink" title="Undo Log之故障恢复"></a>Undo Log之故障恢复</h3><p>Crash Recovery时，需要利用Undo中的信息将未提交的事务的所有影响回滚，以保证数据库的Failure Atomic。前面提到过，InnoDB中的Undo其实是像数据一样处理的，也从上面的组织结构中可以看出来，Undo本身有着比Redo Log复杂得多、按事务分配而不是顺序写入的组织结构，其本身的Durability像InnoDB中其他的数据一样，需要靠Redo来保证。除了通用的一些MLOG_2BYTES、MLOG_4BYTES类型之外，Undo本身也有自己对应的Redo Log类型：<strong>MLOG_UNDO_INIT</strong>类型在Undo Page舒适化的时候记录初始化；在分配Undo Log的时候，需要重用Undo Log Header或需要创建新的Undo Log Header的时候，会分别记录<strong>MLOG_UNDO_HDR_REUSE</strong>和<strong>MLOG_UNDO_HDR_CREATE</strong>类型的Redo Record；<strong>MLOG_UNDO_INSERT</strong>是最常见的，在Undo Log里写入新的Undo Record都对应的写这个日志记录写入Undo中的所有内容；最后，<strong>MLOG_UNDO_ERASE_END</strong>对应Undo Log跨Undo Page时抹除最后一个不完整的Undo</p><blockquote><p>ARIES（Algorithms for Recovery and Isolation Exploiting Semantics）是一种事务恢复协议，用于数据库系统中的崩溃恢复和并发控制。它是一个经典的恢复算法，并被广泛应用于许多关系型数据库管理系统（RDBMS）。</p><p>ARIES本质是一种Redo-Undo的WAL实现。其正常运行过程为：修改数据之前先追加Log记录，Log内容同时包括Redo和Undo信息，每个日志记录产生一个标记其在日志中位置的递增LSN（Log Sequence Number）；数据页中记录最后修改的日志项LSN，以此来判断Page中的内容的新旧程度，实现幂等。故障恢复阶段需要通过Log中的内容恢复数据库状态，为了减少恢复时需要处理的日志量，ARIES会在正常运行期间周期性的生成Checkpoint，Checkpoint中除了当前的日志LSN之外，还需要记录当前活跃事务的最新LSN，以及所有脏页，供恢复时决定重放Redo的开始位置。需要注意的是，由于生成Checkpoint时数据库还在正常提供服务（Fuzzy Checkpoint），其中记录的活跃事务及脏页信息并不一定准确，因此需要Recovery阶段通过Log内容进行修正。</p><p>Recover过程：故障恢复包含三个阶段：Analysis，Redo和Undo。Analysis阶段的任务主要是利用Checkpoint及Log中的信息确认后续Redo和Undo阶段的操作范围，通过Log修正Checkpoint中记录的脏页集合信息，并用其中涉及最小的LSN位置作为下一步Redo的开始位置RedoLSN。同时修正Checkpoint中记录的活跃事务集合（未提交事务），作为Undo过程的回滚对象；Redo阶段从Analysis获得的RedoLSN出发，重放所有的Log中的Redo内容，注意这里也包含了未Commit事务；最后Undo阶段对所有未提交事务利用Undo信息进行回滚，通过Log的PrevLSN可以顺序找到事务所有需要回滚的修改。</p></blockquote><p>以ARIES过程为例，Crash Recovery的过程中会先重放所有的Redo Log，整个Undo的磁盘组织结构，也会作为一种数据类型也会通过上面讲到的这些Redo类型的重放恢复出来。之后在trx_sys_init_at_db_start操作中会扫描Undo的磁盘结构，遍历所有的Rollback Segment和其中所有的Undo Segment，通过读取Undo Segment Header中的State，可以知道在Crash前，最后持有这个Undo Segment的事务状态。如果是<code>TRX_UNDO_ACTIVE</code>，说明当时事务需要回滚，否则说明事务已经结束，可以继续清理Undo Segment的逻辑。之后，就可以恢复出Undo Log的内存组织模式，包括活跃事务的内存结构trx_t，Rollback Segment的内存结构trx_rseg_t，以及其中的trx_undo_t的四个链表。</p><p>Crash Recovery完成之前，会启动在srv_dict_recover_on_restart中启动异步回滚线程trx_recovery_rollback_thread，其中对Crash前还活跃的事务，通过trx_rollback_active进行回滚，这个过程与上面提到的Undo回滚是一致的。</p><h3 id="Undo-Log的清理"><a href="#Undo-Log的清理" class="headerlink" title="Undo Log的清理"></a>Undo Log的清理</h3><p>InnoDB在Undo Log中保存了多份历史版本来实现MVCC，当某个历史版本已经确认不会被任何现有的和未来的事务看到的时候，就应该被清理掉。因此就需要有办法判断哪些Undo Log不会再被看到。InnoDB中每个写事务结束时都会拿一个递增的编号trx_no作为事务的提交序号，而每个读事务会在自己的ReadView中记录自己开始的时候看到的最大的trx_no为m_low_limit_no。那么，如果一个事务的trx_no小于当前所有活跃的读事务Readview中的这个m_low_limit_no，说明这个事务在所有的读开始之前已经提交了，其修改的新版本是可见的， 因此不再需要通过undo构建之前的版本，这个事务的Undo Log也就可以被清理了。</p><p>这里不多深入，暂时用处不大，相关内容：Undo Purge、Undo Truncate、Undo Tablespace Truncate。</p><h2 id="MVCC和锁-Isolation"><a href="#MVCC和锁-Isolation" class="headerlink" title="MVCC和锁 (Isolation)"></a>MVCC和锁 (Isolation)</h2><p>多版本的目的是为了避免写事务和读事务的互相等待，那么每个读事务都需要在不对数据库记录加锁的情况下，找到对应的应该看到的历史版本。所谓历史版本就是假设在该只读事务开始的时候对整个DB打一个快照，之后该事务的所有读请求都从这个快照上获取。当然实现上不能真正去为每个事务打一个快照，这个时间空间都太高了。InnoDB的做法，是在读事务第一次读取的时候获取一份ReadView，并一直持有，其中记录所有当前活跃的写事务ID，由于写事务的ID是自增分配的，通过这个ReadView我们可以知道在这一瞬间，哪些事务已经提交哪些还在运行，根据Read Committed的要求，未提交的事务的修改就是不应该被看见的，对应地，已经提交的事务的修改应该被看到。</p><p>作为存储历史版本的Undo Record，其中记录的trx_id就是做这个可见性判断的，对应的数据库主索引的记录上也有这个值。当一个读事务拿着自己的ReadView访问某个表索引上的记录时，会通过比较记录上的trx_id确定是否是可见的版本，如果不可见就沿着Record或Undo Record中记录的rollptr一路找更老的历史版本。如下图所示，事务$R$开始需要查询表$t$上的id为1的记录，$R$开始时事务$I$已经提交，事务$J$还在运行，事务$K$还没开始，这些信息都被记录在了事务$R$的ReadView中。事务$R$从索引中找到对应的这条$Record_{1,C}$，对应的trx_id是$K$，不可见。沿着rollptr找到Undo中的前一版本$Record_{1,B}$，对应的trx_id是$J$，不可见。继续沿着rollptr找到$Record_{1,A}$，trx_id是$I$可见，返回结果。</p><p><img src="/assets/post_img/article123/undo_mvcc.png" alt=""></p><p>前面提到过，作为逻辑日志，Undo中记录的其实是前后两个版本的diff信息，而读操作最终是要获得完整的Record内容的，也就是说这个沿着rollptr指针一路查找的过程中需要用Undo Record中的diff内容依次构造出对应的历史版本，这个过程在函数row_search_mvcc中，其中trx_undo_prev_version_build会根据当前的rollptr找到对应的Undo Record位置，这里如果是rollptr指向的是insert类型，或者找到了已经Purge了的位置，说明到头了，会直接返回失败。否则，就会解析对应的Undo Record，恢复出trx_id、指向下一条Undo Record的rollptr、主键信息和diff信息update vector等信息。之后通过row_upd_rec_in_place，用update vector修改当前持有的Record拷贝中的信息，获得Record的这个历史版本。之后调用自己ReadView的changes_visible判断可见性，如果可见则返回用户。完成这个历史版本的读取。</p><p>TODO：补充关于锁的内容和MVCC的相关内容，并发事务问题-&gt;事务隔离级别-&gt;（隔离级别设置）-&gt;隔离级别的实现-&gt;锁（表、行、页）-&gt;MVCC（隐藏字段、undo、read view）。[3]</p><h1 id="Spring事务使用"><a href="#Spring事务使用" class="headerlink" title="Spring事务使用"></a>Spring事务使用</h1><p>先介绍Spring支持的两种事务管理方式，然后介绍Spring提供的主要事务管理接口。在实际开发中，我们通常使用<code>@Transactional</code>注解来开启事务，于是我们介绍这个注解中包含的事务属性参数（包括隔离级别、传播行为等等重要内容），并介绍如何使用该注解。</p><h2 id="两种事务管理方式"><a href="#两种事务管理方式" class="headerlink" title="两种事务管理方式"></a>两种事务管理方式</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过 <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用。使用 <code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务管理（常用）"><a href="#声明式事务管理（常用）" class="headerlink" title="声明式事务管理（常用）"></a>声明式事务管理（常用）</h3><p>代码侵入性最小，实际是通过 AOP 实现（基于<code>@Transactional</code>的全注解方式使用最多）。</p><p>使用<code>@Transactional</code>注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-事务管理接口"><a href="#Spring-事务管理接口" class="headerlink" title="Spring 事务管理接口"></a>Spring 事务管理接口</h2><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：<code>PlatformTransactionManager</code>，（平台）事务管理器，Spring 事务策略的核心；<code>TransactionDefinition</code>，事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)；<code>TransactionStatus</code>，事务运行状态。我们可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。<code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="PlatformTransactionManager-事务管理器接口"><a href="#PlatformTransactionManager-事务管理器接口" class="headerlink" title="PlatformTransactionManager - 事务管理器接口"></a><code>PlatformTransactionManager</code> - 事务管理器接口</h3><p>Spring 并不直接管理事务，而是提供了多种事务管理器，通过这个接口，Spring 为各个平台如：JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。将事务管理行为抽象出来方便程序扩展。</p><p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionDefinition-事务属性定义"><a href="#TransactionDefinition-事务属性定义" class="headerlink" title="TransactionDefinition - 事务属性定义"></a><code>TransactionDefinition</code> - 事务属性定义</h3><p>事务管理器接口 <code>PlatformTransactionManager</code> 通过 <code>getTransaction(TransactionDefinition definition)</code> 方法来得到一个事务，这个方法里面的参数是 `TransactionDefinition</p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p><p>事务属性包含了 5 个方面：</p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus - 事务状态"></a><code>TransactionStatus</code> - 事务状态</h3><p><code>TransactionStatus</code>接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息。<code>PlatformTransactionManager.getTransaction()</code>方法返回一个 <code>TransactionStatus</code> 对象。<code>TransactionStatus</code> 接口内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h2><p><code>@Transactional</code>中包含的事务属性参数。</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</strong></p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>举例来说，在 A 类的<code>aMethod()</code>中调用了 B 类的<code>bMethod()</code>。这个时候就涉及到业务层方法之间互相调用的事务问题。如果<code>bMethod()</code>发生异常需要回滚，如何配置事务传播行为才能让<code>aMethod()</code>也跟着回滚呢？下面来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便使用，Spring 相应地定义了一个枚举类：<code>Propagation</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则抛出异常。</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务传播行为可能的值如下：</p><p>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></p><p><code>@Transactional</code>注解默认使用的事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p><ul><li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p><p>2.<code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod()</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为<code>bMethod()</code>开启了独立的事务。但是，如果<code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话，<code>aMethod()</code>同样也会回滚，因为这个异常被<code>aMethod()</code>的事务管理机制检测到了。</p><p>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></p><p>如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与<code>TransactionDefinition.PROPAGATION_REQUIRED</code>类似的操作。嵌套事务回滚不影响外部事务。也就是说：</p><ul><li>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。</li><li>如果外部方法无事务，则单独开启一个事务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果 <code>bMethod()</code> 回滚的话，<code>aMethod()</code>不会回滚。如果<code>aMethod()</code>回滚的话，<code>bMethod()</code>会回滚。</p><p>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。这种方式还是能保证全部回滚的，下面的三种则不一定了，需要看情况使用。</p><p>5.<code>TransactionDefinition.PROPAGATION_SUPPORTS</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>6.<code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code><br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>7.<code>TransactionDefinition.PROPAGATION_NEVER</code><br>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和事务传播行为一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 读未提交</span></span><br><span class="line">  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line">  <span class="comment">// 读已提交</span></span><br><span class="line">  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line">  <span class="comment">// 可重复读</span></span><br><span class="line">  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line">  <span class="comment">// 可串行</span></span><br><span class="line">  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次对每一种事务隔离级别进行介绍：</p><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务串行执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以整型的值来表示超时时间，其单位是秒，默认值为<code>-1</code>，这表示事务的超时时间取决于底层事务系统或者没有超时时间。</p><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只有读取数据查询的事务，可以指定事务类型为 <code>readonly</code>，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p><p>为什么数据查询操作还要启用事务支持呢？拿Innodb举例子，根据<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">官网</a>描述：</p><blockquote><p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p></blockquote><p>但是，如果你给方法加上了<code>@Transactional</code>注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p><p>如果不加<code>@Transactional</code>，每条sql会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p><p>分享一下关于事务只读属性，其他人的解答：</p><ul><li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li><li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</li></ul><h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code>也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p><p>可以通过下面的方式回滚特定的异常类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure><h2 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a><code>@Transactional</code> 注解使用详解</h2><h3 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a><code>@Transactional</code> 的作用范围</h3><ol><li>方法：推荐将注解使用于方法上，不过需要注意的是，该注解只能应用到 <code>public</code> 方法上，否则不生效。</li><li>类：如果这个注解使用在类上的话，表明该注解对该类中所有的 <code>public</code> 方法都生效。</li><li>接口：不推荐在接口上使用。</li></ol><h3 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a><code>@Transactional</code> 的常用配置参数</h3><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用配置参数即：propagation、isolation、timeout、readOnly、rollbackFor，具体内容上节已列出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a><br>[2] <a href="https://blog.csdn.net/ITcreater000/article/details/115338657">https://blog.csdn.net/ITcreater000/article/details/115338657</a><br>[3] <a href="https://www.cnblogs.com/rickiyang/p/13652664.html">https://www.cnblogs.com/rickiyang/p/13652664.html</a><br>[4] <a href="https://dl.acm.org/doi/10.1145/289.291">https://dl.acm.org/doi/10.1145/289.291</a><br>[5] <a href="https://juejin.cn/post/6860252224930070536">https://juejin.cn/post/6860252224930070536</a><br>[6] <a href="https://spongecaptain.cool/post/database/logicalandphicallog/">https://spongecaptain.cool/post/database/logicalandphicallog/</a><br>[7] <a href="https://www.jianshu.com/p/646961b93c7e">https://www.jianshu.com/p/646961b93c7e</a><br>[8] <a href="https://zhuanlan.zhihu.com/p/394388285">https://zhuanlan.zhihu.com/p/394388285</a><br>[9] <a href="https://blog.csdn.net/qq_24854607/article/details/114639318">https://blog.csdn.net/qq_24854607/article/details/114639318</a><br>[10] <a href="https://blog.csdn.net/m0_71777195/article/details/130842268">https://blog.csdn.net/m0_71777195/article/details/130842268</a><br>[11] <a href="https://www.cnblogs.com/f66666/articles/10993873.html">https://www.cnblogs.com/f66666/articles/10993873.html</a><br>[12] <a href="http://catkang.github.io/2021/10/30/mysql-undo.html">http://catkang.github.io/2021/10/30/mysql-undo.html</a><br>[13] <a href="http://catkang.github.io/2020/02/27/mysql-redo.html">http://catkang.github.io/2020/02/27/mysql-redo.html</a><br>[14] <a href="http://catkang.github.io/2018/09/19/concurrency-control.html">http://catkang.github.io/2018/09/19/concurrency-control.html</a><br>[15] <a href="https://catkang.github.io/2023/08/08/mysql-buffer-pool.html">https://catkang.github.io/2023/08/08/mysql-buffer-pool.html</a><br>[16] <a href="https://mariadb.com/kb/en/innodb-undo-log">https://mariadb.com/kb/en/innodb-undo-log</a><br>[17] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。&lt;/p&gt;
&lt;p&gt;相关内容：InnoDB事务实现、Spring事务传播机制等。&lt;br&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
    <category term="MySQL" scheme="http://silencezheng.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Optional使用入门</title>
    <link href="http://silencezheng.top/2023/09/14/article122/"/>
    <id>http://silencezheng.top/2023/09/14/article122/</id>
    <published>2023-09-14T15:08:57.000Z</published>
    <updated>2023-09-14T15:11:44.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。</p><span id="more"></span><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional的机制类似于受检异常，强迫API调用者面对没有返回值的现实，因为程序直接返回 null 很可能导致调用端产生错误（空指针异常！）。</p><p>Optional 是用来作为方法返回值的，目的是清晰地表达返回值中没有结果的可能性。</p><h2 id="常用方法及调用方式"><a href="#常用方法及调用方式" class="headerlink" title="常用方法及调用方式"></a>常用方法及调用方式</h2><ul><li><p><code>of(value)</code>：创建一个包含指定非空值的 <code>Optional</code> 对象。</p></li><li><p><code>ofNullable(value)</code>：创建一个可能为空的 <code>Optional</code> 对象。如果传入的值为 <code>null</code>，则返回一个空的 <code>Optional</code>。</p></li><li><p><code>empty()</code>：创建一个空的 <code>Optional</code> 对象。</p></li><li><p><code>isPresent()</code>：检查 <code>Optional</code> 对象是否包含值。</p></li><li><p><code>get()</code>：获取 <code>Optional</code> 对象中的值。在调用之前应先使用 <code>isPresent()</code> 进行判断。</p></li></ul><p><code>Optional</code> 支持方法链式调用，使得我们可以在一系列操作中进行空值检查和转换。</p><p>下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalValue.isPresent()) &#123;</span><br><span class="line">    String value = optionalValue.get();</span><br><span class="line">    System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; nullableValue = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">String result = nullableValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure><p>除了常用方法，还有一些方法可以对<code>Optional</code>对象进行快捷操作，如上面出现的<code>orElse</code>，下面介绍其中一些。</p><ul><li><p><code>orElse(T other)</code>：如果包含的值存在，则返回该值；如果不存在，则返回默认值 <code>other</code>。无论值是否存在，都会进行计算，并返回结果。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String defaultValue = emptyOptional.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(defaultValue); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果包含的值存在，则返回该值；如果不存在，则使用提供的 <code>Supplier</code> 函数来计算并返回值。与 <code>orElse()</code> 类似，但在值不存在时，<code>Supplier</code> 函数才会被调用。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(computedValue); <span class="comment">// 调用 expensiveOperation() 方法，并输出其返回值</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果包含的值存在，则返回该值；如果不存在，则抛出指定的异常。通过提供一个exceptionSupplier来生成异常对象。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>));</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>)); <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure></li><li><p><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>：接受一个 Consumer 函数作为参数，并在包含的值存在时执行该函数。该方法无返回值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">optionalValue.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 输出：Value is present: Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">emptyOptional.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 由于值不存在，所以不执行任何操作</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1、不要使用<code>Optional</code>作为Java Bean实例域的类型<br>即避免以下这种代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; zip;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; telephone = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为 <code>Optional</code> 没有实现Serializable接口（不可序列化）</p><p>2、不要把容器类型包装在<code>Optional</code>中<br>即避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;List&lt;String&gt;&gt; fetchCartItems(<span class="keyword">long</span> id) &#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为容器类都有自己空值设计，如 <code>Collections.emptyList() Collections.emptySet() Collections.emptyMap() Stream.empty()</code> 等：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fetchCartItems</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> items == <span class="keyword">null</span> ? Collections.emptyList() : items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、不要给<code>Optional</code>对象赋值 null<br>避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而应该用 <code>Optional.empty()</code> 表达空值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、尽量使用<code>Optional</code>提供的快捷API避免手写条件语句<br>代码更简洁。</p><p>5、使用 <code>equals</code> 而不是 <code>==</code> 来比较 <code>Optional</code> 的值<br><code>Optional</code> 的 <code>equals</code> 方法已经实现了内部值比较。</p><p>6、对于可能是空值的函数返回使用<code>Optional</code><br>对于读取值类型的函数使用是很好的实践。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/128481434">https://zhuanlan.zhihu.com/p/128481434</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok原理简析</title>
    <link href="http://silencezheng.top/2023/09/11/article121/"/>
    <id>http://silencezheng.top/2023/09/11/article121/</id>
    <published>2023-09-11T13:32:25.000Z</published>
    <updated>2023-09-11T13:36:03.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok实现原理简析。<br><span id="more"></span></p><h2 id="JCP与JSR"><a href="#JCP与JSR" class="headerlink" title="JCP与JSR"></a>JCP与JSR</h2><p>JCP（Java Community Process）是管理 Java 生态（包括 J2SE、J2EE 等等）发展及指导和推动Java平台发展的合作组织，而JSR（Java Specification Request）则是由JCP提出的一种规范请求。</p><blockquote><p>JCP是由Sun Microsystems（现在是Oracle Corporation）创建的一个组织，负责制定和管理Java技术的发展。它包括了一系列专家组和工作组，这些组织和个人共同合作制定和更新Java规范。</p><p>JSR 是 Java 规范请求。这是由一个或多个成员提交给 PMO 的文件，以提议开发新规范或对现有规范进行重大修订。 JCP 计划目前正在开发许多 Java 技术规范，包括 Java™ Micro Edition (Java ME™)、Java™ Platform Enterprise Edition (Java EE™) 和 Java™ Standard Edition (Java SE™) 的下一版本。 JSR 还指由这些提案产生的规范开发工作。</p><p>JSR经历多个阶段，包括草案、提案、公开评论、维护和最终发布等。</p><p>PMO 即 Program Management Office，项目管理办公室是 Oracle 内部负责监督 Java 社区流程并管理项目日常运行的小组。该规范的实际开发是在专家组内进行的。</p></blockquote><p>JCP：<a href="https://jcp.org/en/home/index">https://jcp.org/en/home/index</a></p><h2 id="JSR-000269"><a href="#JSR-000269" class="headerlink" title="JSR-000269"></a>JSR-000269</h2><p>JSR-000269（JSR-269）的目标是定义并实现Java编译时注解处理器的标准API，或称为可插拔注解处理（Pluggable Annotation Processing），该JSR提供了一种机制，使开发人员能够在Java源代码编译过程中访问和处理注解，从而实现更高级的语义效果和自动化任务。</p><p>要完全的了解JSR-269的前因后果及技术细节，不应该在本文中寻找答案，本文仅铺垫一些形象化描述Lombok实现原理所必需的前置知识。总之，通过JSR-269的实现，开发人员可以利用编译时注解处理器的能力，以一种标准化和可扩展的方式对源代码进行自动化处理。这种处理包括生成额外的代码、进行静态分析、验证约束条件等。</p><p>JSR-000269的原始提出第一节如下：</p><blockquote><p>J2SE 1.5引入了一种新的Java语言机制“注解”，允许使用注解类型对类、字段和方法进行注解。这些注解通常由编译时工具或运行时库来处理，以实现新的语义效果。为了支持编译时的注解处理，这个JSR将定义API，允许使用标准可插拔的API创建注解处理器。这将简化创建注解处理器的任务，并且还可以自动发现适用于给定源文件的合适的注解处理器。</p><p>该规范将包括至少两个部分：一个部分是对Java编程语言进行建模的API部分，另一个部分用于声明注解处理器并控制它们的运行方式。由于注解是放置在程序元素上的，注解处理框架需要反映程序结构。注解处理器将能够指定它们处理的注解，并且多个处理器将能够合作运行。</p><p>处理器和程序结构API可以在编译时访问；即此功能补充了核心反射支持读取注解的能力。</p></blockquote><h2 id="Lombok代码注入原理"><a href="#Lombok代码注入原理" class="headerlink" title="Lombok代码注入原理"></a>Lombok代码注入原理</h2><p>Lombok使用了JSR-269的API，即<code>javax.annotation.processing</code>下的一组接口，在编译期时把 Lombok 的注解代码，转换为常规的 Java ⽅法⽽实现注⼊。</p><p>使用 <code>javac</code> 进行编译时，Lombok生成目标方法的流程如下：</p><ol><li>首先 <code>javac</code> 对源代码进行分析生成一棵抽象语法树(AST)</li><li>接着在运行过程中调用实现了 JSR-269 API 的 lombok 程序</li><li>接着编译器会调用 lombok 程序对上面得到的抽象语法树 AST 进行处理，找到其注解所在类对应的语法树(AST)，然后修改该语法树，增加注解对应的方法或代码片段到定义的相应树节点</li><li><code>javac</code> 使用修改后的抽象语法树生成最终的 class 文件</li></ol><h2 id="利用269API实现Setter注解"><a href="#利用269API实现Setter注解" class="headerlink" title="利用269API实现Setter注解"></a>利用269API实现Setter注解</h2><p>1、⾃定义注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MySetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、自定义注解处理器<br>注解处理器是代码生成的核心，对语法树的操作需要使用自己JDK的<code>tools.jar</code>，涉及到的核心库主要为<code>com.sun.tools.javac</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree.Kind;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.api.JavacTrees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Flags;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Type;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.ListBuffer;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Name;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;lombok.setter.MySetter&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetterProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JavacTrees javacTrees; <span class="comment">// 提供了待处理的抽象语法树</span></span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker; <span class="comment">// 封装了创建AST节点的一些方法</span></span><br><span class="line">    <span class="keyword">private</span> Names names; <span class="comment">// 提供了创建标识符的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        <span class="keyword">this</span>.javacTrees = JavacTrees.instance(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">        <span class="keyword">this</span>.names = Names.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MySetter注解的元素</span></span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(MySetter.class);</span><br><span class="line">        elementsAnnotatedWith.forEach(element -&gt; &#123;</span><br><span class="line">            JCTree tree = javacTrees.getTree(element);</span><br><span class="line">            <span class="comment">// 使用 TreeTranslator 遍历抽象语法树</span></span><br><span class="line">            tree.accept(<span class="keyword">new</span> TreeTranslator() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassDef</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span> </span>&#123;</span><br><span class="line">                    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">                    <span class="comment">// 在抽象树中找出所有变量</span></span><br><span class="line">                    <span class="keyword">for</span>(JCTree jcTree:jcClassDecl.defs) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(jcTree.getKind().equals(Kind.VARIABLE)) &#123;</span><br><span class="line">                            JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 对变量生成方法</span></span><br><span class="line">                    jcVariableDeclList.forEach(jcVariableDecl -&gt; &#123;</span><br><span class="line">                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">super</span>.visitClassDef(jcClassDecl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCMethodDecl <span class="title">makeGetterMethodDecl</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span> </span>&#123;</span><br><span class="line">        ListBuffer&lt;JCTree.JCStatement&gt; statements = <span class="keyword">new</span> ListBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生成表达式，例如 this.a = a;</span></span><br><span class="line">        JCTree.JCExpressionStatement aThis = makeAssignment(</span><br><span class="line">            treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)), jcVariableDecl.getName()),</span><br><span class="line">            treeMaker.Ident(jcVariableDecl.getName())</span><br><span class="line">        );</span><br><span class="line">        statements.append(aThis);</span><br><span class="line">        JCTree.JCBlock block = treeMaker.Block(<span class="number">0</span>, statements.toList()); <span class="comment">// 创建代码块抽象语法树节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成入参</span></span><br><span class="line">        JCTree.JCVariableDecl param = treeMaker.VarDef( <span class="comment">// 创建一个变量定义节点</span></span><br><span class="line">            treeMaker.Modifiers(Flags.PARAMETER), <span class="comment">// 指定修饰符为入参</span></span><br><span class="line">            jcVariableDecl.getName(), <span class="comment">// 使用原始变量定义节点的名称作为入参的名称</span></span><br><span class="line">            jcVariableDecl.vartype, <span class="comment">// 使用原始变量定义节点的变量类型作为入参的类型</span></span><br><span class="line">            <span class="keyword">null</span> <span class="comment">// 表示入参没有初始值</span></span><br><span class="line">        );</span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; parameters = List.of(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成返回对象</span></span><br><span class="line">        JCTree.JCExpression methodType = treeMaker.Type(</span><br><span class="line">            <span class="keyword">new</span> Type.JCVoidType()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结合内容生成方法</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">            treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">            getNewMethodName(jcVariableDecl.getName()),</span><br><span class="line">            methodType, List.nil(), parameters, List.nil(), block, <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Name <span class="title">getNewMethodName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        String s = name.toString();</span><br><span class="line">        <span class="comment">// 驼峰命名方法</span></span><br><span class="line">        <span class="keyword">return</span> names.fromString(</span><br><span class="line">            <span class="string">&quot;set&quot;</span> + s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>, name.length())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCExpressionStatement <span class="title">makeAssignment</span><span class="params">(JCTree.JCExpression lhs, JCTree.JCExpression rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成赋值语句的抽象语法树节点</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.Exec(</span><br><span class="line">            treeMaker.Assign(</span><br><span class="line">                lhs, <span class="comment">// left-hand side</span></span><br><span class="line">                rhs  <span class="comment">// right-hand side</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编译注解处理器<br>之后所有操作都在MySetter的目录下进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp /path/to/tools.jar MySetter* -d .</span><br></pre></td></tr></table></figure><p>4、编写和编译目标类<br>目标类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MySetter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用自定义注解处理器编译目标类：<code>javac -processor  lombok.setter.MySetterProcessor TestMySetter.java</code></p><p>编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytee</span><span class="params">(Byte var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytee = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrr</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strr = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntt</span><span class="params">(Integer var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intt = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestMySetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h2><p>前面形象化的讲述了Lombok的代码生成原理，但这些都发生在编译期，代码编辑器如何获取到这些信息并提前应用到代码提示上呢？Lombok给主流集成开发环境编写了Lombok插件，在使用Lombok的过程中不需要编译即可实现代码提示和代码补全，相关源码都公开在GitHub上（见[9]），有兴趣的读者可以自行阅读研究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://developer.aliyun.com/article/1081626">https://developer.aliyun.com/article/1081626</a><br>[2] <a href="https://blog.csdn.net/shouchenchuan5253/article/details/111658356">https://blog.csdn.net/shouchenchuan5253/article/details/111658356</a><br>[3] <a href="https://blog.csdn.net/weixin_43983762/article/details/105867398">https://blog.csdn.net/weixin_43983762/article/details/105867398</a><br>[4] <a href="https://juejin.cn/post/7103011031672176677">https://juejin.cn/post/7103011031672176677</a><br>[5] <a href="https://jcp.org/en/jsr/detail?id=269">https://jcp.org/en/jsr/detail?id=269</a><br>[6] <a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html">https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html</a><br>[7] <a href="https://projectlombok.org/">https://projectlombok.org/</a><br>[8] <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html">https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html</a><br>[9] <a href="https://github.com/projectlombok/lombok">https://github.com/projectlombok/lombok</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok实现原理简析。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Lombok之@Builder碎碎念</title>
    <link href="http://silencezheng.top/2023/09/10/article120/"/>
    <id>http://silencezheng.top/2023/09/10/article120/</id>
    <published>2023-09-10T12:23:30.000Z</published>
    <updated>2023-09-10T12:24:14.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok@Builder实现链式构建的弊病及替代方案。<br><span id="more"></span></p><h2 id="Builder的弊病"><a href="#Builder的弊病" class="headerlink" title="@Builder的弊病"></a>@Builder的弊病</h2><h3 id="存在继承关系时十分复杂"><a href="#存在继承关系时十分复杂" class="headerlink" title="存在继承关系时十分复杂"></a>存在继承关系时十分复杂</h3><p>错误用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：Implicit super constructor Parent() is undefined. Must explicitly invoke another constructor</span></span><br></pre></td></tr></table></figure></p><p>正确用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Child child = Child.builder()</span><br><span class="line">  .parentName(<span class="string">&quot;Andrea&quot;</span>)</span><br><span class="line">  .parentAge(<span class="number">38</span>)</span><br><span class="line">  .childName(<span class="string">&quot;Emma&quot;</span>)</span><br><span class="line">  .childAge(<span class="number">6</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>但如果父类使用了@Builder注解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用原子类会报错：<code>Child中的builder()无法覆盖Parent中的builder()</code>。可以通过修改子类为如下形式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Builder(builderMethodName = &quot;childBuilder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在链式构建子类对象时，就需要调用<code>Child.childBuilder()</code>了。即便如此，在继承层级多时也十分繁琐。</p><p>在Lombok1.18中，提供了@SuperBuilder注解，可以解决上述问题。使用示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不可与-Data同时使用"><a href="#不可与-Data同时使用" class="headerlink" title="不可与@Data同时使用"></a>不可与@Data同时使用</h3><p>很多框架会使用类的无参构造函数创建对象，但是如果同时使⽤@Data和@Builder的话，会导致类的无参构造函数缺失。</p><p>并且，这种情况并不能通过手动添加无参构造函数或添加@NoArgsConstructor解决。</p><p>该问题只能通过引⼊注解@Tolerate来解决。</p><p>Lombok同时使⽤@Data和@Builder的时候，如果要⽣成⽆参构造，需要在代码⾥⾯⼿动引⼊注解@Tolerate，让Lombok在⽣成类的时候，对指定的构造函数不感知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer int1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-Accessors替代-Builder"><a href="#用-Accessors替代-Builder" class="headerlink" title="用@Accessors替代@Builder"></a>用@Accessors替代@Builder</h2><p>在为了链式编程而使用@Builder时，它并非最佳实践。@Builder会额外创建内部类，无法与@Data兼容，且处理继承关系十分复杂。</p><p>使用@Accessors(chain = true)实现链式编程是更好的选择，简单示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.payload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setPayload</span><span class="params">(T payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setStatus</span><span class="params">(Status status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// 假设Status也使用了@Accessors(chain = true)</span></span><br><span class="line">Status status = <span class="keyword">new</span> Status().setResponseCode(<span class="string">&quot;RESPONSE_CODE_IDENTIFIER&quot;</span>).setDescription(<span class="string">&quot;Bla Bla Bla&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> APIResponse().setStatus(status);</span><br></pre></td></tr></table></figure></p><p>实际运用时，如果属性较多，且分为必传属性和选填属性时，可以将必传参数定义在构造方法中，加上 @Accessors 注解，这样就可以实现必传参数的传入，又可以实现选填参数的链式调用。</p><p>假设 Student 类，它的 学生ID和年级和班级是必填的，姓名、性别、住址是选填的，那么示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义必传属性，使用 final 修饰，不提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> studentId; <span class="comment">// 学生ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> grade; <span class="comment">// 年级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> classNum; <span class="comment">// 班级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义选填属性，提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String gender; <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 住址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造方法，接收必传参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> studentId, <span class="keyword">int</span> grade, <span class="keyword">int</span> classNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.classNum = classNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">1001</span>, <span class="number">3</span>, <span class="number">8</span>) <span class="comment">// 创建一个学生对象，传入必传参数</span></span><br><span class="line">        .setName(<span class="string">&quot;张三&quot;</span>) <span class="comment">// 设置姓名</span></span><br><span class="line">        .setGender(<span class="string">&quot;男&quot;</span>) <span class="comment">// 设置性别</span></span><br><span class="line">        .setAddress(<span class="string">&quot;北京市朝阳区&quot;</span>); <span class="comment">// 设置住址</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.baeldung.com/lombok-builder-inheritance">https://www.baeldung.com/lombok-builder-inheritance</a><br>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews">https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok@Builder实现链式构建的弊病及替代方案。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
</feed>
