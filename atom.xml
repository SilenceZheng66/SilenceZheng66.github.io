<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenceZheng66-BLOG</title>
  
  <subtitle>silencezheng.top</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2024-08-07T06:32:46.293Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>SilenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode周记 EP7</title>
    <link href="http://silencezheng.top/2024/08/07/article131/"/>
    <id>http://silencezheng.top/2024/08/07/article131/</id>
    <published>2024-08-07T06:28:14.000Z</published>
    <updated>2024-08-07T06:32:46.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回国了，开始好好准备找工。</p><p>本周主题：快速幂</p><p>题目：</p><ul><li>240730每日一题—<a href="https://leetcode.cn/problems/double-modular-exponentiation/description">Double Modular Exponentiation</a><span id="more"></span></li></ul><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^8 \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}</script><p>的顺序，从 $x$ 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 $x^{64}$ 的值，而不需要对 $x$ 乘 63 次 $x$ 。</p><p>再举一个例子，如果我们要计算 $x^{77}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^9 \rightarrow x^{19} \rightarrow x^{38} \rightarrow x^{77}</script><p>的顺序, 在 $x \rightarrow x^2, x^2 \rightarrow x^4, x^{19} \rightarrow x^{38}$ 这些步骤中, 我们直接把上一次的结果进行平方，而在 $x^4 \rightarrow x^9, x^9 \rightarrow x^{19}, x^{38} \rightarrow x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 $x$ 。</p><p>直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后, 还需不需要额外乘 $x$ 。但如果我们从右往左看, 分治的思想就十分明显了：</p><ul><li>当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y=x^{\lfloor n / 2\rfloor}$ ，其中 $\lfloor a\rfloor$表示对 $a$ 进行下取整；</li><li>根据递归计算的结果, 如果 $n$ 为偶数, 那么 $x^n=y^2$; 如果 $n$ 为奇数,那么 $x^n=y^2 \times x$ ；</li><li>递归的边界为 $n=0$, 任意数的 0 次方均为 1 。</li></ul><p>由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</p><p>下面是快速幂算法的递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步，由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们还是以 $x^{77}$ 作为例子：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow^{+} x^9 \rightarrow^{+} x^{19} \rightarrow x^{38} \rightarrow^{+} x^{77}</script><p>并且把需要额外乘 $x$ 的步骤打上了 + 标记。可以发现：</p><ul><li>$x^{38} \rightarrow^{+} x^{77}$ 中额外乘的 $x$ 在 $x^{77}$ 中贡献了 $x$ ；</li><li>$x^9 \rightarrow^{+} x^{19}$ 中额外乘的 $x$ 在之后被平方了 2 次，因此在 $x^{77}$ 中贡献了 $x^{2^2}=x^4$</li><li>$x^4 \rightarrow^{+} x^9$ 中额外乘的 $x$ 在之后被平方了 3 次，因此在 $x^{77}$ 中贡献了 $x^{2^3}=x^8$</li><li>最初的 $x$ 在之后被平方了 6 次，因此在 $x^{77}$ 中贡献了 $x^{2^6}=x^{64}$ 。</li></ul><p>我们把这些贡献相乘， $x \times x^4 \times x^8 \times x^{64}$ 恰好等于 $x^{77}$ 。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 $x$ 在之后都会被平方若干次。而这些指数 $1 ， 4 ， 8$ 和 $64 ，$ 恰好就对应了 77 的二进制表示 $(1001101)_2$ 中的每个 1 ！</p><p>因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 $n$ 的二进制拆分为</p><script type="math/tex; mode=display">n=2^{i_0}+2^{i_1}+\cdots+2^{i_k}</script><p>那么</p><script type="math/tex; mode=display">x^n=x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}</script><p>这样以来, 我们从 $x$ 开始不断地进行平方, 得到 $x^2, x^4, x^8, x^{16}, \cdots$, 如果 $n$的第 $k$ 个（从右往左，从 0 开始计数）二进制位为 1 ，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。</p><p>下面是快速幂的迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x0</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题：Double-Modular-Exponentiation"><a href="#例题：Double-Modular-Exponentiation" class="headerlink" title="例题：Double Modular Exponentiation"></a>例题：Double Modular Exponentiation</h2><blockquote><p>Double Modular Exponentiation</p><p>You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.</p><p>An index i is good if the following formula holds:</p><ul><li>0 &lt;= i &lt; variables.length</li><li>((ai^bi % 10)^ci) % mi == target</li></ul><p>Return an array consisting of good indices in any order.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getGoodIndices</span><span class="params">(<span class="keyword">int</span>[][] variables, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; variables.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = variables[i];</span><br><span class="line">            <span class="keyword">if</span> (powMod(powMod(v[<span class="number">0</span>], v[<span class="number">1</span>], <span class="number">10</span>), v[<span class="number">2</span>], v[<span class="number">3</span>]) == target) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// (a+b) mod c = (a mod c + b mod c) mod c</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * x % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; <span class="comment">// 相当于y/=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a><br>[2] <a href="https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/">https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回国了，开始好好准备找工。&lt;/p&gt;
&lt;p&gt;本周主题：快速幂&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240730每日一题—&lt;a href=&quot;https://leetcode.cn/problems/double-modular-exponentiation/description&quot;&gt;Double Modular Exponentiation&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（速食版）</title>
    <link href="http://silencezheng.top/2024/06/06/article130/"/>
    <id>http://silencezheng.top/2024/06/06/article130/</id>
    <published>2024-06-05T19:43:00.000Z</published>
    <updated>2024-06-05T19:44:07.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快速计算任意连续子数组元素和的数据结构。</p><p>树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为<br>Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。<br><span id="more"></span></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><blockquote><p>给你一个数组，如何快速地计算任意一段连续子数组的元素和？</p></blockquote><p><img src="/assets/post_img/article130/szsz.png" alt="bit"></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>下标从 $left$ 到 $right$ 的子数组元素和，可以看成是下标从 1 到 $right$ 的子数组元素和，减去下标从 1 到 $left−1$ 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。</p><p>按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 $O(1)$ 地查询（计算任意连续子数组的元素和）了。</p><h2 id="如果更新呢？"><a href="#如果更新呢？" class="headerlink" title="如果更新呢？"></a>如果更新呢？</h2><p>如果修改下标为1的元素，则所有前缀都需要更新（因为所有前缀包含该元素），意味着更新操作时间复杂度为$O(n)$。此时查询与更新的综合时间复杂度还是$O(n)$。</p><p>自然的，想到应该将前缀元素和继续进行拆分，令更新某元素时，仅影响部分“子前缀”，此时只需要更新影响到的部分即可。</p><p>因此，需要找到一种合适的拆分方法，能够把任意前缀拆分成若干<strong>子前缀</strong>，使更新操作的执行范围缩小到部分子前缀中。</p><h2 id="对于想继续探索的同学"><a href="#对于想继续探索的同学" class="headerlink" title="对于想继续探索的同学"></a>对于想继续探索的同学</h2><p>推荐文献[3]，较为全面的阐述了树状数组的来世今生，本文以让读者尽快掌握用法为主，不过多展开深入。</p><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>BIT的重要概念，抛开相关性质不谈，先说计算，lowbit(x)表示取数x的最低位1，常用<code>lowbit(x) = x &amp; -x</code>计算。</p><p>举例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span><span class="punctuation">,</span> lowbit(<span class="keyword">x</span>) <span class="operator">=</span> <span class="keyword">x</span> &amp; -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">计算过程：</span><br><span class="line">   <span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span></span><br><span class="line">  -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0110</span></span><br><span class="line"><span class="keyword">x</span>&amp;-<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><h2 id="树状数组-c-n-的查询与更新"><a href="#树状数组-c-n-的查询与更新" class="headerlink" title="树状数组 c[n] 的查询与更新"></a>树状数组 <code>c[n]</code> 的查询与更新</h2><p>对于原数组<code>a[n]</code>构建对应的树状数组<code>c[n]</code>，可推导得出：<code>c[x] = a[x-lowbit(x)+1] + ... + a[x]</code>，即区间<code>[x-lowbit(x)+1, x]</code>的元素和。</p><p>定义<code>query(x)</code>为查询原数组区间<code>[1, x]</code>上的元素和，则可写出利用<code>c[n]</code>实现$O(logn)$的查询代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 减去所有的lowbit后i为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))</span><br><span class="line">            ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>add(x, v)</code>为修改位置为在索引<code>x</code>的元素，加上<code>v</code>。则可写出利用<code>c[n]</code>实现$O(logn)$的更新代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = 树状数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)&#123;</span><br><span class="line">        c[x] += v;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容很好理解，抓住<code>c[x]</code>的定义就行了。</p><h2 id="树状数组-c-n-的构造"><a href="#树状数组-c-n-的构造" class="headerlink" title="树状数组 c[n] 的构造"></a>树状数组 <code>c[n]</code> 的构造</h2><p>最简单的，遍历原数组，调用<code>n</code>次<code>add</code>方法进行构造，时间复杂度$O(nlogn)$：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更快速的，考虑<code>c[x]</code>表示原数组区间<code>[x-lowbit(x)+1, x]</code>的元素和，可以先对原数组求一个前缀和数组<code>s[n]</code>，利用前缀和来更新树状数组，即<code>c[x] = s[x] - s[x-lowbit(x)]</code>，此时构造的时间复杂度为$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 求a的前缀和</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 用前缀和求出c</span></span><br><span class="line">c[i] = s[i] - s[i - lowbit(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分规则—逆序"><a href="#拆分规则—逆序" class="headerlink" title="拆分规则—逆序"></a>拆分规则—逆序</h2><p>按照逆序处理，每次处理的bit都是当前编号的最后的为1位。将每次处理的bit定义为<strong>lowbit</strong>。</p><p>对于前缀 $[1,i]$：</p><ul><li>如果 $i$ 是 2 的幂，那么 $[1,i]$ 无需拆分。</li><li>如果 $i$ 不是 2 的幂，那么先拆分出一个长为 $lowbit(i)$ 的关键区间 $[i−lowbit(i)+1,i]$，问题转换成剩下的 $[1,i−lowbit(i)]$ 如何拆分，这是一个规模更小的子问题。</li></ul><h1 id="例题一：分数字到两个数组"><a href="#例题一：分数字到两个数组" class="headerlink" title="例题一：分数字到两个数组"></a>例题一：<a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">分数字到两个数组</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; tree.length) &#123;</span><br><span class="line">            tree[i]++;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] resultArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            index.put(sortedNums[i], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Integer&gt; arr2 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">1</span>]));</span><br><span class="line">        BinaryIndexedTree tree1 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        BinaryIndexedTree tree2 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        tree1.add(index.get(nums[<span class="number">0</span>]));</span><br><span class="line">        tree2.add(index.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = arr1.size() - tree1.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">int</span> count2 = arr2.size() - tree2.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr1.size() &lt;= arr2.size())) &#123;</span><br><span class="line">                arr1.add(nums[i]);</span><br><span class="line">                tree1.add(index.get(nums[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.add(nums[i]);</span><br><span class="line">                tree2.add(index.get(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr1) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr2) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/">https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/</a><br>[2] <a href="https://blog.csdn.net/qq_63786973/article/details/127416700">https://blog.csdn.net/qq_63786973/article/details/127416700</a><br>[3] <a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">https://www.cnblogs.com/Last--Whisper/p/13823614.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;快速计算任意连续子数组元素和的数据结构。&lt;/p&gt;
&lt;p&gt;树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为&lt;br&gt;Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排列组合</title>
    <link href="http://silencezheng.top/2024/06/01/article129/"/>
    <id>http://silencezheng.top/2024/06/01/article129/</id>
    <published>2024-06-01T12:59:03.000Z</published>
    <updated>2024-06-01T13:00:10.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排列组合计算公式推导及代码实现。<br><span id="more"></span></p><h1 id="加法原理、乘法原理"><a href="#加法原理、乘法原理" class="headerlink" title="加法原理、乘法原理"></a>加法原理、乘法原理</h1><p><strong>分类计数原理</strong>：完成一件事情，存在$n$类方法，第1类有$m_1$种方式，第2类有$m_2$种方式，…，第$n$类有$m_n$种方式，则完成此事共有$N = m_1 + m_2 + … + m_n$种不同方法。 </p><p><strong>分步计数原理</strong>：若完成某事需经过$n$个步骤，第1步有$m_1$种方法，第2步有$m_2$种方法，…，第$n$步有$m_n$种方法，则总共有$N = m_1 \times m_2 \times \cdots \times m_n$种不同方法。</p><p><strong>区别</strong>：分类计数原理是加法规则，各类方法数相加求和；分步计数原理是乘法规则，各步骤方法数相乘得总数。</p><h1 id="排列（Arrangement）"><a href="#排列（Arrangement）" class="headerlink" title="排列（Arrangement）"></a>排列（Arrangement）</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>从$n$个不同元素中选取$m(m \leq n)$个元素的所有不同排列的个数，叫做从$n$个不同元素中选取$m$个元素的排列数，记作$\mathrm{A}_n^m$。 </p><h2 id="排列数公式"><a href="#排列数公式" class="headerlink" title="排列数公式"></a>排列数公式</h2><script type="math/tex; mode=display">\mathrm{A}_n^m = n(n-1)(n-2)\cdots(n-m+1) = \frac{n!}{(n-m)!}, \quad n, m \in \mathbb{N}^*, m \leq n</script><p>推导：从$n$个不同元素中选取$m$个元素进行排序，按计数原理分布进行，取第一个有$n$种取法，取第二个有$n-1$种取法…取第$m$个有$n-m+1$种取法，根据分步乘法原理推导出上式。</p><h2 id="排列数性质"><a href="#排列数性质" class="headerlink" title="排列数性质"></a>排列数性质</h2><ul><li>$\mathrm{A}_n^m = n\mathrm{A}_{n-1}^{m-1}$：为“某特定位置”先安排，再安排其余位置。</li><li>$\mathrm{A}_n^m = m\mathrm{A}_{n-1}^{m-1} + \mathrm{A}_{n-1}^m$：含特定元素的排列有$m\mathrm{A}_{n-1}^{m-1}$种，不含特定元素的排列有$\mathrm{A}_{n-1}^m$种。</li></ul><h1 id="组合（Combination）"><a href="#组合（Combination）" class="headerlink" title="组合（Combination）"></a>组合（Combination）</h1><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>从$n$个不同元素中选取$m$（$m \leq n$）个元素的所有不同组合的数目，称为从$n$个不同元素中取出$m$个元素的组合数，用符号$\mathrm{C}_n^m$表示。</p><h2 id="组合数公式"><a href="#组合数公式" class="headerlink" title="组合数公式"></a>组合数公式</h2><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!},\quad n,m\in \mathbb{N}^*,m\leq n</script><script type="math/tex; mode=display">\mathrm{C}_n^0=\mathrm{C}_n^n=1</script><p>证明：通过排列与组合的关系以及排列公式推导证明。</p><p>将排列问题$\mathrm{A}_n^m$分为两步：</p><ol><li><p><strong>第一步</strong>：从$n$个球中抽取$m$个，不考虑顺序，即组合问题$\mathrm{C}_n^m$；</p></li><li><p><strong>第二步</strong>：将抽出的$m$个球排序，即全排列$\mathrm{A}_m^m$。</p></li></ol><p>依据乘法原理，$\mathrm{A}_n^m=\mathrm{C}_n^m \mathrm{A}_m^m$，因此</p><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}</script><h2 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h2><ul><li>$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$：反转组合，未选的变选，选了的变未选，组合数相同。</li><li>递推公式$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$：含特定元素组合数为$\mathrm{C}_{n-1}^{m-1}$，不含特定元素组合数为$\mathrm{C}_{n-1}^m$。</li></ul><p><strong>示例</strong><br>令（$n=5$），($m=2$)。</p><p>从1，2，3，4，5中取出2个元素的组合$\mathrm{C}_n^m$：</p><p>12 13 14 15 23 24 25 34 35 45</p><p>这些组合要么含”1”，要么不含。</p><ul><li>含”1”的组合：12 13 14 15 → 挖去”1”得2 3 4 5 → 等价于从2，3，4，5中取出1个元素的组合。（此处m-1为1）</li><li>不含”1”的组合：23 24 25 34 35 45 → 等价于从2，3，4，5中取出2个元素的组合。（此处m为2）</li></ul><p>总方案数是上述两种情况的和，即$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$。</p><h2 id="组合数求和公式"><a href="#组合数求和公式" class="headerlink" title="组合数求和公式"></a>组合数求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><p>直观理解：从$n$个球中抽取0到$n$个球的组合数之和。</p><p>严谨证明可采用数学归纳法：</p><ol><li>当$n=1$，$\mathrm{C}_1^0+\mathrm{C}_1^1=2=2$成立。</li><li>假设$n=k$时公式成立，$\sum_{i=0}^{k} \mathrm{C}_k^i=2^n$，则$n=k+1$时亦成立。</li><li>由1、2归纳得公式对所有$n\in \mathbb{N}^*$成立。</li></ol><p>或用二项式定理简证：</p><script type="math/tex; mode=display">(a+b)^n=\sum_{k=0}^{n}\mathrm{C}_n^k a^{n-k}b^k</script><p>设$a=b=1$，</p><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><p>类似公式（由$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$推导）：</p><script type="math/tex; mode=display">\mathrm{C}_n^0 + \mathrm{C}_n^2 + \mathrm{C}_n^4 + ... = \mathrm{C}_n^1 + \mathrm{C}_n^3 + \mathrm{C}_n^5 + ... =2^{n-1}</script><h1 id="Java：组合求和"><a href="#Java：组合求和" class="headerlink" title="Java：组合求和"></a>Java：组合求和</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">factorialWithRecursion</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorialWithRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">combination</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> numerator = factorialWithRecursion(n);</span><br><span class="line">    <span class="keyword">long</span> denominator1 = factorialWithRecursion(m);</span><br><span class="line">    <span class="keyword">long</span> denominator2 = factorialWithRecursion(n-m);</span><br><span class="line">    <span class="keyword">return</span> numerator/(denominator1*denominator2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/1024th/p/10623541.html">https://www.cnblogs.com/1024th/p/10623541.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;排列组合计算公式推导及代码实现。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之预定义CRUD</title>
    <link href="http://silencezheng.top/2024/03/24/article128/"/>
    <id>http://silencezheng.top/2024/03/24/article128/</id>
    <published>2024-03-24T08:54:43.000Z</published>
    <updated>2024-03-24T08:55:36.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>探究MyBatis Plus提供的预定义CRUD接口的实现方式。<br><span id="more"></span></p><h1 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h1><p>MBP提供两种包含预定义CRUD的接口：</p><ol><li><code>com.baomidou.mybatisplus.extension.service.IService</code></li><li><code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code></li></ol><p>其中<code>IService</code>接口是针对业务逻辑层的封装，并提供了批处理操作。<code>BaseMapper</code>则是对DAO层CRUD的封装。</p><h1 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h1><p><code>BaseMapper</code>的接口规范很简单，看代码就能明白，重点是了解MBP如何实现的<code>BaseMapper</code>。</p><p>在使用MyBatis的情况下，我们定义了Mapper接口，然后会在对应的XML文件中提供动态SQL及映射关系，或者直接在Mapper接口方法上添加注解，MyBatis将XML中的配置或者注解作为元数据进行解析，然后将解析后的SQL语句存至<code>org.apache.ibatis.session.Configuration</code>。MBP在MyBatis的基础上只做增强不做改变，则只要能够实现原pipeline将元数据解析成动态SQL存至<code>org.apache.ibatis.session.Configuration</code>即可。</p><p>MyBatis Plus的整体思路是使用自己的组件替换MyBatis中的组件，以实现自定义的逻辑。其中<code>MybatisPlusAutoConfiguration</code>类替代了MyBatis的自动配置类，这个类中包含<code>MybatisPlusProperties</code>属性。<code>MybatisPlusProperties</code>包含<code>mapperLocations</code>字段用于解析Mapper XML文件的位置，并汇总为<code>Resource</code>数组。</p><p>在<code>MybatisPlusAutoConfiguration#sqlSessionFactory</code>函数中，包含XML位置的<code>Resource</code>数组被设置到<code>MybatisSqlSessionFactoryBean.mapperLocations</code>下（<code>MybatisSqlSessionFactoryBean</code>也是MBP替换组件）。而后在<code>MybatisSqlSessionFactoryBean#buildSqlSessionFactory</code>函数中，XML文件被逐个读取并解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>XMLMapperBuilder</code>在解析过程中会调用<code>XMLMapperBuilder#bindMapperForNamespace</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">            <span class="keyword">this</span>.configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>configuration</code>为<code>MybatisSqlSessionFactoryBean</code>传入的<code>targetConfiguration</code>，即<code>MybatisConfiguration</code>（MBP替换组件）。此时<code>MybatisMapperRegistry#addMapper</code>调用<code>MybatisMapperRegistry#addMapper</code>方法。</p><p><code>MybatisMapperRegistry</code>也是一个MBP替换组件，继承并替换掉原本的<code>MapperRegistry</code>，其<code>addMapper</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MybatisMapperProxyFactory(type));</span><br><span class="line">            MybatisMapperAnnotationBuilder parser = <span class="keyword">new</span> MybatisMapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用MBP自定义的<code>MybatisMapperAnnotationBuilder#parse</code>方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入 CURD 动态 SQL</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过全局缓存工具<code>GlobalConfigUtils</code>获取<code>ISqlInjector</code>实例，调用<code>ISqlInjector#inspectInject</code>方法进行CRUD方法注入。在实现上，实际上是由<code>AbstractSqlInjector</code>实现了<code>ISqlInjector</code>接口，然后又由<code>DefaultSqlInjector</code>继承<code>AbstractSqlInjector</code>实现最终注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; modelClass = ReflectionKit.getSuperClassGenericType(mapperClass, Mapper.class, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 注入的方法</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperClass 当前mapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入的方法集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.1.2 add  mapperClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass,TableInfo tableInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> DeleteById(),</span><br><span class="line">                <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> UpdateById(),</span><br><span class="line">                <span class="keyword">new</span> SelectById(),</span><br><span class="line">                <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(String.format(<span class="string">&quot;%s ,Not found @TableId annotation, Cannot use Mybatis-Plus &#x27;xxById&#x27; Method.&quot;</span>,</span><br><span class="line">                tableInfo.getEntityType()));</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每一个函数都是继承了<code>com.baomidou.mybatisplus.core.injector.AbstractMethod</code>的类，包含一个<code>inject</code>注入方法。</p><h1 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h1><p><code>IService</code>的实现在<code>com.baomidou.mybatisplus.extension.service.impl.ServiceImpl</code>。</p><p><code>IService</code>依赖于Spring容器，而<code>BaseMapper</code>不依赖，原因是<code>IService</code>实例中会注入一个<code>BaseMapper</code>实例用于做CRUD操作，也就是上面的那一套。</p><p><code>IService</code>还支持批量操作，这部分源码比较好看，调用链路是：<code>com.baomidou.mybatisplus.extension.toolkit.SqlHelper#executeBatch -&gt; org.apache.ibatis.session#flushStatements</code></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/wjw465150/article/details/126896276">https://blog.csdn.net/wjw465150/article/details/126896276</a><br>[2] <a href="https://blog.csdn.net/zzuhkp/article/details/120174101">https://blog.csdn.net/zzuhkp/article/details/120174101</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;探究MyBatis Plus提供的预定义CRUD接口的实现方式。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>回归问题指标计算</title>
    <link href="http://silencezheng.top/2024/03/10/article127/"/>
    <id>http://silencezheng.top/2024/03/10/article127/</id>
    <published>2024-03-10T10:56:26.000Z</published>
    <updated>2024-05-01T17:34:10.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回归问题指标计算入门。<br><span id="more"></span></p><h1 id="RSE-Relative-Squared-Error"><a href="#RSE-Relative-Squared-Error" class="headerlink" title="RSE (Relative Squared Error)"></a><strong>RSE (Relative Squared Error)</strong></h1><p>相对平方误差是预测值与实际值之间的平方差与实际值的平方差的比率。计算公式如下：</p><script type="math/tex; mode=display">RSE = \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}</script><p>其中，$ y_i $ 是第 $ i $ 个观测值，$ \hat{y}_i $ 是对应的预测值，$ \bar{y} $ 是观测值的均值，$ n $ 是样本数量。</p><h1 id="RAE-Relative-Absolute-Error"><a href="#RAE-Relative-Absolute-Error" class="headerlink" title="RAE (Relative Absolute Error)"></a><strong>RAE (Relative Absolute Error)</strong></h1><p>相对绝对误差是预测值与实际值之间的绝对差与实际值的绝对差的比率。计算公式如下：</p><script type="math/tex; mode=display">RAE = \frac{\sum_{i=1}^{n} |y_i - \hat{y}_i|}{\sum_{i=1}^{n} |y_i - \bar{y}|}</script><h1 id="MSE-Mean-Squared-Error"><a href="#MSE-Mean-Squared-Error" class="headerlink" title="MSE (Mean Squared Error)"></a><strong>MSE (Mean Squared Error)</strong></h1><p>均方误差是预测值与实际值之间的平方差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2</script><h1 id="RMSE-Root-Mean-Squared-Error"><a href="#RMSE-Root-Mean-Squared-Error" class="headerlink" title="RMSE (Root Mean Squared Error)"></a><strong>RMSE (Root Mean Squared Error)</strong></h1><p>均方根误差是均方误差的平方根，它提供了预测误差的标准化度量。计算公式如下：</p><script type="math/tex; mode=display">RMSE = \sqrt{MSE}</script><h1 id="MAE-Mean-Absolute-Error"><a href="#MAE-Mean-Absolute-Error" class="headerlink" title="MAE (Mean Absolute Error)"></a><strong>MAE (Mean Absolute Error)</strong></h1><p>平均绝对误差是一种常用的回归问题评价指标，用于衡量预测值与真实值之间的偏差程度。它的计算基于所有预测值与对应真实值之间绝对误差的平均值，因此对所有个体错误给予相同权重，不考虑误差的方向，只关注其大小。MAE的计算公式如下：</p><script type="math/tex; mode=display">\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|</script><p>其中：</p><ul><li>$n$ 表示样本的数量。</li><li>$y_i$ 表示第 $ i $ 个样本的真实值。</li><li>$ \hat{y}_i $ 表示第 $ i $ 个样本的预测值。</li><li>$ | \cdot | $ 表示绝对值函数，确保误差值为非负。</li></ul><h1 id="MAPE-Mean-Absolute-Percentage-Error"><a href="#MAPE-Mean-Absolute-Percentage-Error" class="headerlink" title="MAPE (Mean Absolute Percentage Error)"></a><strong>MAPE (Mean Absolute Percentage Error)</strong></h1><p>平均绝对百分比误差是预测值与实际值之间的绝对百分比误差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MAPE = \frac{100}{n} \sum_{i=1}^{n} \left| \frac{y_i - \hat{y}_i}{y_i} \right|</script><h1 id="Correlation-Pearson-Correlation-Coefficient"><a href="#Correlation-Pearson-Correlation-Coefficient" class="headerlink" title="Correlation (Pearson Correlation Coefficient)"></a><strong>Correlation (Pearson Correlation Coefficient)</strong></h1><p>相关系数衡量了预测值与实际值之间的线性关系强度和方向。计算公式如下：</p><script type="math/tex; mode=display">\text{Correlation} = \frac{\sum_{i=1}^{n} (y_i - \bar{y})(\hat{y}_i - \bar{\hat{y}})}{\sqrt{\sum_{i=1}^{n} (y_i - \bar{y})^2 \sum_{i=1}^{n} (\hat{y}_i - \bar{\hat{y}})^2}}</script><p>其中，$ \bar{y} $ 和 $ \bar{\hat{y}} $ 分别是观测值和预测值的均值。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回归问题指标计算入门。&lt;br&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://silencezheng.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发体验</title>
    <link href="http://silencezheng.top/2024/02/08/article126/"/>
    <id>http://silencezheng.top/2024/02/08/article126/</id>
    <published>2024-02-07T18:40:36.000Z</published>
    <updated>2024-02-07T18:44:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。</p><p>但在做课题调研时我习惯使用<code>[n]</code>作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫<code>Reference Extension</code>吧。<br><span id="more"></span></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>0、更新npm、cnpm：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cnpm</span></span><br><span class="line">npm install -g cnpm -registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>1、安装 Yeoman 和 VS Code Extension Generator：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g yo generator-code</span><br></pre></td></tr></table></figure></p><p>2、创建一个新的插件项目<code>Reference Extension</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Reference Extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? reference-extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? Literature Citation Extension</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? Yes</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? npm</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> reference-extension</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>主要实现两个功能：</p><ol><li><code>[n]</code>格式索引增加项时自动递增（实际只实现了一部分）。</li><li><code>[n]</code>格式索引重新索引，包含删除项与增加项（实际只实现了一部分）。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 VSCode 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活插件的入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令：自动递增索引</span></span><br><span class="line">    <span class="keyword">let</span> disposableAutoIncrement = vscode.commands.registerTextEditorCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前光标位置</span></span><br><span class="line">            <span class="keyword">const</span> currentPosition = editor.selection.active;</span><br><span class="line">            <span class="keyword">const</span> currentLine = currentPosition.line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前行的文本内容，并匹配是否以 [n] 格式结尾</span></span><br><span class="line">            <span class="keyword">const</span> currentLineText = editor.document.lineAt(currentLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = currentLineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="comment">// 获取匹配到的数字，并计算下一个数字</span></span><br><span class="line">                <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> nextNumber = currentNumber + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自增逻辑</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// TODO： 这段有问题，要修改，而且还是没有做到回车前触发。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = currentLine + <span class="number">1</span>; line &lt; editor.document.lineCount; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> matchBelow = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (matchBelow) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentNumberBelow = <span class="built_in">parseInt</span>(matchBelow[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndexBelow = currentNumberBelow + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 替换下方方括号中的数字</span></span><br><span class="line">                            <span class="keyword">const</span> startPosBelow = <span class="keyword">new</span> vscode.Position(line, <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">const</span> endPosBelow = <span class="keyword">new</span> vscode.Position(line, matchBelow[<span class="number">0</span>].length);</span><br><span class="line">                            editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPosBelow, endPosBelow), <span class="string">`[<span class="subst">$&#123;newIndexBelow&#125;</span>] <span class="subst">$&#123;matchBelow[<span class="number">2</span>]&#125;</span>`</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果下方没有符合 [n] 格式索引的项，结束循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> newPosition = <span class="keyword">new</span> vscode.Position(currentLine + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    editBuilder.insert(newPosition, <span class="string">`[<span class="subst">$&#123;nextNumber&#125;</span>] `</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册命令：重新索引所有行的方括号</span></span><br><span class="line">    <span class="comment">// TODO：实际上只实现了删除一个索引时将下方索引都自动减1</span></span><br><span class="line">    <span class="keyword">let</span> disposableReindex = vscode.commands.registerCommand(<span class="string">&#x27;rext.reindex&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前行的行号</span></span><br><span class="line">            <span class="keyword">const</span> currentLine = editor.selection.active.line;</span><br><span class="line">            <span class="keyword">const</span> startLine = currentLine;</span><br><span class="line">            <span class="keyword">const</span> endLine = editor.document.lineCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义当前列表的索引</span></span><br><span class="line">            <span class="keyword">let</span> currentListIndex: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：匹配一下</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 查找当前列表的索引</span></span><br><span class="line">            <span class="keyword">const</span> lineText = editor.document.lineAt(startLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                currentListIndex = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：自动减1</span></span><br><span class="line">            <span class="keyword">if</span> (currentListIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// TODO：重新索引列表中的方括号数字</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = startLine; line &lt; endLine; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                            <span class="comment">// 获取当前方括号中的数字和新索引</span></span><br><span class="line">                            <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndex = currentNumber - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果当前数字不等于新索引，替换方括号中的数字</span></span><br><span class="line">                            <span class="keyword">if</span> (currentNumber !== newIndex) &#123;</span><br><span class="line">                                <span class="keyword">const</span> startPos = <span class="keyword">new</span> vscode.Position(line, match.index!);</span><br><span class="line">                                <span class="keyword">const</span> endPos = <span class="keyword">new</span> vscode.Position(line, match.index! + match[<span class="number">0</span>].length);</span><br><span class="line">                                editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPos, endPos), <span class="string">`[<span class="subst">$&#123;newIndex&#125;</span>] `</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听文档内容变化事件</span></span><br><span class="line">    vscode.workspace.onDidChangeTextDocument(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.document.languageId === <span class="string">&#x27;markdown&#x27;</span> &amp;&amp; event.document.fileName.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> range = event.contentChanges[<span class="number">0</span>].range;</span><br><span class="line">            <span class="comment">// 检查是否按下了回车键</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否删除了某一行</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;&#x27;</span> &amp;&amp; range.start.line !== range.end.line) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.reindex&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令注册到上下文订阅中，确保插件在激活期间有效</span></span><br><span class="line">    context.subscriptions.push(disposableAutoIncrement, disposableReindex);</span><br><span class="line"></span><br><span class="line">    process.stdout.write(<span class="string">&#x27;Debugging message\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件被停用时调用的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这代码写的很糙，只实现了部分功能，但是也确实没时间去学<code>markdown-it</code>的插件实现了，以后再去实现吧（正常来说我要实现的东西通过<code>markdown-it</code>自定义插件插入的形式实现更方便…在插件上写插件😂）。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>项目F5进行调试，创建一个Markdown文件，写入对应情景内容，别忘了在<code>package.json</code>中设置触发条件。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>要想发布插件到市场，需要创建在Azure DevOps上创建个人访问令牌，如果没有组织则需要先创建组织。可以用GitHub账户登陆Azure DevOps创建组织，比如<code>dev.azure.com/SilenceZheng66</code>。</p><p>然后创建项目，在项目中创建PAT（Personal Access Tokens）并记住它。下面需要在<a href="https://marketplace.visualstudio.com/manage/createpublisher">Visual Studio Marketplace</a>创建一个publisher，这里需要注意的是这里必须使用刚才创建个人访问令牌的微软账号，这里的publisher需要和package.json里的publisher字段一致。</p><p>准备就绪后，下载<code>vsce</code>，用来打包/发布/管理插件的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g vsce</span><br></pre></td></tr></table></figure><p>执行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">vsce login SilenceZheng66</span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">vsce publish --no-dependencies</span><br></pre></td></tr></table></figure><p>使用webpack打包插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnpm i --save-dev webpack webpack-cli ts-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># package.json 脚本如下：</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;vscode:prepublish&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>,</span><br><span class="line"><span class="string">&quot;compile&quot;</span>: <span class="string">&quot;webpack --mode none&quot;</span>,</span><br><span class="line"><span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --mode none --watch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html">https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html</a><br>[2] <a href="https://github.com/yzhang-gh/vscode-markdown">https://github.com/yzhang-gh/vscode-markdown</a><br>[3] <a href="https://juejin.cn/post/7327570230775201826">https://juejin.cn/post/7327570230775201826</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/459554765">https://zhuanlan.zhihu.com/p/459554765</a><br>[5] <a href="https://juejin.cn/post/6844903921555603470">https://juejin.cn/post/6844903921555603470</a><br>[6] <a href="https://markdown-it.github.io">https://markdown-it.github.io</a><br>[7] <a href="https://juejin.cn/post/7076649162653040647">https://juejin.cn/post/7076649162653040647</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。&lt;/p&gt;
&lt;p&gt;但在做课题调研时我习惯使用&lt;code&gt;[n]&lt;/code&gt;作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫&lt;code&gt;Reference Extension&lt;/code&gt;吧。&lt;br&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://silencezheng.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>SpEL使用入门</title>
    <link href="http://silencezheng.top/2023/12/30/article125/"/>
    <id>http://silencezheng.top/2023/12/30/article125/</id>
    <published>2023-12-29T17:00:25.000Z</published>
    <updated>2023-12-29T17:02:59.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。</p><p>SpEL是单独模块（<code>org.springframework.expression</code>），只依赖于core模块，不依赖于其他模块，可以单独使用。<br><span id="more"></span></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先从一个简单的“literal string expression”例子引入，所谓“literal string”就是指代码中直接使用双引号括起来的字符串（起码在Java下是这样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先创建了解析器<code>ExpressionParser</code>，负责解析表达式字符串，表达式字符串是由周围的单引号表示的字符串字面量。而后解析表达式，<code>Expression</code>接口负责评估所定义的表达式字符串。最后对表达式进行求值，获取信息。</p><p>通过这一流程可以总结SpEL在求表达式值时的一般步骤：</p><ol><li>创建解析器</li><li>解析表达式</li><li>构造上下文</li><li>表达式求值</li></ol><p>其中第三步构造上下文是一个可选步骤，当需要准备上下文变量时会使用。</p><p>PS：在调用 <code>parser.parseExpression</code> 和 <code>exp.getValue</code> 时，可能分别抛出两个异常：<code>ParseException</code> 和 <code>EvaluationException</code>。<br>PPS：Evaluate可以理解为“求值”或“计算”。</p><h2 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h2><p>SpEL支持多种功能，如调用方法、访问属性和调用构造函数，这里用一个例子快速过一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用concat方法</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();  <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性，invokes &#x27;getBytes()&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套属性，invokes &#x27;getBytes().length&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes.length&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> length = (Integer) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;new String(&#x27;hello world&#x27;).toUpperCase()&quot;</span>);</span><br><span class="line">String message = exp.getValue(String.class); <span class="comment">// HELLO WORLD</span></span><br></pre></td></tr></table></figure><h2 id="更常见的用法"><a href="#更常见的用法" class="headerlink" title="更常见的用法"></a>更常见的用法</h2><p>SpEL更常见的用法是提供一个表达式字符串，针对特定对象实例（称为根对象）进行求值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并设置一个日历对象</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数分别为name, birthday, nationality</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">// 将&quot;name&quot;解析为表达式</span></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br></pre></td></tr></table></figure><h2 id="全部语法"><a href="#全部语法" class="headerlink" title="全部语法"></a>全部语法</h2><p>关于如何编写正确的表达式，可以参见 <a href="https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html">https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html</a></p><h1 id="EvaluationContext（求值上下文）"><a href="#EvaluationContext（求值上下文）" class="headerlink" title="EvaluationContext（求值上下文）"></a>EvaluationContext（求值上下文）</h1><p><code>EvaluationContext</code>接口用于计算表达式，以解析属性、方法或字段，并帮助执行类型转换。Spring 提供了两种实现：</p><ul><li><p><code>SimpleEvaluationContext</code>：该接口公开了基本 SpEL 功能和配置选项的子集，适用于不需要完整 SpEL 语言语法且应受到有意义限制的表达式类别，包括但不限于数据绑定表达式和基于属性的过滤器。</p></li><li><p><code>StandardEvaluationContext</code>：提供全套 SpEL 功能和配置选项，可以用它来指定默认根对象，并配置所有可用的求值相关策略。</p></li></ul><p><code>SimpleEvaluationContext</code> 只支持 SpEL 语法的一个子集。它不包括 Java 类型引用、构造函数和 Bean 引用。它还要求使用者明确选择对表达式中属性和方法的支持级别，默认情况下，<code>create()</code>静态工厂方法只能对属性进行读取访问。用户还可以获取一个构建器来配置所需的特定支持级别，针对以下一种或几种组合：</p><ul><li>Custom PropertyAccessor only (no reflection)</li><li>Data binding properties for read-only access</li><li>Data binding properties for read and write</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>默认情况下，SpEL 使用 Spring core 中的转换服务（org.springframework.core.convert.ConversionService）。该转换服务为常见转换提供了许多内置转换器，但也具有完全可扩展性，因此您可以在类型间添加自定义转换。此外，它还具有泛型感知功能。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换，以保持遇到的任何对象的类型正确性。</p><p>举个例子，假设使用 <code>setValue()</code> 进行赋值是为了设置 List 属性。该属性的类型实际上是 <code>List&lt;Boolean&gt;</code>。SpEL会识别到在将列表元素放入其中之前，需要将其转换为布尔值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Boolean&gt; booleanList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">simple.booleanList.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;false&quot; is passed in here as a String. SpEL and the conversion service</span></span><br><span class="line"><span class="comment">// will recognize that it needs to be a Boolean and convert it accordingly.</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;booleanList[0]&quot;</span>).setValue(context, simple, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b is false</span></span><br><span class="line">Boolean b = simple.booleanList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h1><p>可以使用解析器配置对象（org.springframework.expression.spel.SpelParserConfiguration）来配置 SpEL 表达式解析器，该配置对象可控制某些表达式组件的行为。例如，在对数组或集合进行索引时，指定索引处的元素为空，SpEL 会自动创建该元素。这在使用由一连串属性引用组成的表达式时非常有用。如果用户对数组或列表进行索引，并指定一个超出数组或列表当前大小的索引，SpEL 可以自动增长数组或列表以容纳该索引。为了在指定的索引处添加元素，SpEL 将尝试使用元素类型的默认构造函数创建元素，然后再设置指定的值。如果元素类型没有默认构造函数，则会将空值添加到数组或列表中。如果没有转换器（内置或自定义的）知道如何设置值，空值将保留在数组或列表的指定索引处。</p><p>下面的示例演示了如何自动增长列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn on:</span></span><br><span class="line"><span class="comment">// - auto null reference initialization</span></span><br><span class="line"><span class="comment">// - auto collection growing</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">&quot;list[3]&quot;</span>);</span><br><span class="line"></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">Object o = expression.getValue(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.list will now be a real collection of 4 entries</span></span><br><span class="line"><span class="comment">// Each entry is a new empty String</span></span><br></pre></td></tr></table></figure><h1 id="表达式编译（提升求值速度）"><a href="#表达式编译（提升求值速度）" class="headerlink" title="表达式编译（提升求值速度）"></a>表达式编译（提升求值速度）</h1><p>Spring Framework 4.1 包含一个基本的表达式编译器。表达式通常是<strong>解释型</strong>的，这在求值过程中提供了很大的动态灵活性，但无法提供最佳性能。对于偶尔使用表达式的情况，这并无大碍，但当其他组件（如 Spring Integration）使用表达式时，性能可能会变得非常重要，而且对动态性也没有真正的需求。</p><p>SpEL 编译器旨在满足这一需求。在评估过程中，编译器会生成一个 Java 类，在运行时体现表达式的行为，并使用该类实现更快的表达式求值。由于缺乏围绕表达式的类型，编译器在执行编译时会使用在表达式的解释求值过程中收集到的信息。例如，编译器并不能纯粹从表达式中知道属性引用的类型，但在第一次解释求值时，编译器就能知道它是什么类型。当然，如果各种表达式元素的类型随着时间的推移而发生变化，那么根据这些派生信息进行编译就会带来麻烦。因此，编译最适合类型信息不会在重复求值时发生变化的表达式。</p><p>例如对于基本表达式<code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code>来说，由于涉及数组访问、一些属性去引用和数值操作，因此性能提升非常明显。在一个迭代 50000 次的微型基准运行示例中，使用解释器求值需要 75 毫秒，而使用该表达式的编译版本仅需 3 毫秒。</p><h2 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h2><p>编译器默认情况下是不开启的，可以通过两种不同的方式开启它。</p><ol><li>通过使用解析器配置过程打开</li><li>在将SpEL嵌入到其他组件中时，还可以使用Spring属性来打开</li></ol><p>编译器可以在三种模式下运行，这些模式在 org.springframework.expression.spel.SpelCompilerMode 枚举中：</p><ul><li><code>OFF</code> (默认)：编译器关闭。</li><li><code>IMMEDIATE</code>：在立即模式下，表达式会尽快编译。通常是在第一次解释求值之后。如果编译表达式失败（通常是由于类型改变），表达式求值的调用者将收到异常。</li><li><code>MIXED</code>：在混合模式下，表达式会随着时间的推移在解释模式和编译模式之间默默切换。经过一定次数的解释运行后，它们会切换到编译形式，如果编译形式出了问题（如前面所述的类型改变），表达式会自动再次切换回解释形式。之后，它可能会生成另一个编译形式并切换到它。基本上，用户在 <code>IMMEDIATE</code> 模式下获得的异常会在内部处理。</li></ul><p><code>IMMEDIATE</code> 模式之所以存在，是因为 <code>MIXED</code> 模式可能会给有副作用的表达式造成问题。如果一个编译表达式在部分成功后崩溃，那么它可能已经执行了影响系统状态的操作。如果发生了这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能会运行两次。</p><p>选择模式后，使用 <code>SpelParserConfiguration</code> 配置解析器。下面的示例演示了如何进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,</span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expr = parser.parseExpression(<span class="string">&quot;payload&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyMessage message = <span class="keyword">new</span> MyMessage();</span><br><span class="line"></span><br><span class="line">Object payload = expr.getValue(message);</span><br></pre></td></tr></table></figure><p>在指定编译器模式时，还可以指定一个类加载器（允许传递空值）。编译后的表达式将定义在一个子类加载器中，该类加载器将根据所提供的任何类型创建。重要的是，如果指定了类加载器，要确保它能看到表达式求值过程中涉及的所有类型。如果未指定类加载器，则会使用默认类加载器（通常是表达式求值过程中运行线程的上下文类加载器）。</p><p>配置编译器的第二种方法适用于 SpEL 嵌入其他组件的情况，这种情况下可能无法通过配置对象进行配置。在这种情况下，可以通过 JVM 系统属性（或 SpringProperties 机制）将 <code>spring.expression.compiler.mode</code> 属性设置为<code>SpelCompilerMode</code>枚举值。</p><h2 id="编译器的局限性"><a href="#编译器的局限性" class="headerlink" title="编译器的局限性"></a>编译器的局限性</h2><p>自 Spring Framework 4.1 以来，基本的编译框架已经到位。不过，该框架还不支持编译所有类型的表达式。最初的重点是可能在性能关键型上下文中使用的常见表达式。以下几种表达式暂时无法编译：</p><ul><li>涉及赋值的表达式</li><li>依赖转换服务的表达式</li><li>使用自定义解析器或访问器的表达式</li><li>使用选择或投影的表达式</li></ul><h1 id="使用SpEL定义Bean"><a href="#使用SpEL定义Bean" class="headerlink" title="使用SpEL定义Bean"></a>使用SpEL定义Bean</h1><p>用户可以在基于XML或注解的配置元数据中使用SpEL表达式来定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法形式为<code>#&#123; &lt;expression string&gt; &#125;</code>。这里忽略XML配置方式，用的不多了。</p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>要指定默认值，可在字段、方法、方法或构造函数参数上添加<code>@Value</code>注解。</p><p>1、设置一个字段的默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> <span class="comment">// 读取的是服务部署机器的region</span></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、注入属性set方法默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方式，当Spring容器创建 <code>PropertyValueTestBean</code> 对象时，它将调用 <code>setDefaultLocale</code> 方法并传入系统属性中 ‘user.region’ 对应的值，从而设置 <code>defaultLocale</code> 成员变量的值。</p><p>3、<code>@Autowired</code>和构造函数也可以使用 <code>@Value</code> 注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.country&#x27;]&#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>一些值得关注的功能…</p><h2 id="ClassType表达式"><a href="#ClassType表达式" class="headerlink" title="ClassType表达式"></a>ClassType表达式</h2><p>使用<code>T(Type)</code>来表示<code>java.lang.Class</code>实例，<code>Type</code>必须是类全限定名（<code>java.lang</code>包下的类除外）。使用ClassType表达式还可以访问类静态方法及类静态字段。</p><p>下面的例子展示了如何使用ClassType表达式和如何进行条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang包内的不需要使用全限定名</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(String)&quot;</span>).getValue(Class.class);</span><br><span class="line"><span class="comment">// 类静态字段访问</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(Integer).MAX_VALUE&quot;</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 类静态方法调用</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;</span>, ParserContext.TEMPLATE_EXPRESSION).getValue(Double.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：</span></span><br><span class="line"><span class="comment">// 算数运算表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;1 + 1&quot;</span>).getValue(Integer.class);</span><br><span class="line"><span class="comment">// 关系表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2==2&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 逻辑表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2&gt;1 and (NOT true or NOT false)&quot;</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="comment">// instanceof表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(Integer)&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="函数、对象、变量的定义及引用"><a href="#函数、对象、变量的定义及引用" class="headerlink" title="函数、对象、变量的定义及引用"></a>函数、对象、变量的定义及引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;路人甲java&quot;</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;lesson&quot;</span>, <span class="string">&quot;Spring系列&quot;</span>);</span><br><span class="line">        <span class="comment">//获取name变量，lesson变量</span></span><br><span class="line">        String name = parser.parseExpression(<span class="string">&quot;#name&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(name);</span><br><span class="line">        String lesson = parser.parseExpression(<span class="string">&quot;#lesson&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(lesson);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象</span></span><br><span class="line">        <span class="comment">// StandardEvaluationContext构造器传入root对象，可以通过#root来访问root对象</span></span><br><span class="line">        context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">&quot;我是root对象&quot;</span>);</span><br><span class="line">        String rootObj = parser.parseExpression(<span class="string">&quot;#root&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(rootObj);</span><br><span class="line">        <span class="comment">// #this用来访问当前上下文中的对象</span></span><br><span class="line">        String thisObj = parser.parseExpression(<span class="string">&quot;#this&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(thisObj);</span><br><span class="line">        <span class="comment">// 定义List对象，过滤List并做投影运算</span></span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>));</span><br><span class="line">        context.setVariable(<span class="string">&quot;primes&quot;</span>, primes);  <span class="comment">// 注册对象变量</span></span><br><span class="line">        List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(<span class="string">&quot;#primes.?[#this&gt;10]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(primesGreaterThanTen.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义方法</span></span><br><span class="line">        context.registerFunction(<span class="string">&quot;reverseString&quot;</span>, SpELTest.class.getDeclaredMethod(<span class="string">&quot;reverseString&quot;</span>, String.class));</span><br><span class="line">        log.info(parser.parseExpression(<span class="string">&quot;#reverseString(&#x27;hello&#x27;)&quot;</span>).getValue(context, String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><p>SpEL引入了Groovy语言中的安全导航运算符<code>(对象|属性)?.属性</code>，用来避免<code>?.</code>前边的表达式为null时抛出空指针异常，转而返回null。还可以使用<code>?:</code>选择在表达式为null时返回默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">tesla.setName(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// null时取默认值</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?:&#x27;Unknown&#x27;&quot;</span>).getValue(context, String.class));</span><br><span class="line"><span class="comment">// null时安全调用</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?.length()&quot;</span>).getValue(context, Integer.class).toString());</span><br></pre></td></tr></table></figure><h2 id="List运算"><a href="#List运算" class="headerlink" title="List运算"></a>List运算</h2><p>在 SpEL 中，<code>?[]</code> 和 <code>![]</code> 分别表示集合选择（collection selection）和集合投影（collection projection）。<code>?[]</code> 表达式用于选择满足指定条件的集合元素，<code>![]</code> 表达式用于对集合进行投影操作。</p><blockquote><p>集合投影或集合映射的基本思想是：通过对集合中的每个元素应用一个表达式，生成一个新的集合，该集合包含了原始集合中的元素经过某种转换后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELCollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inventor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Bei Jin&quot;</span>);</span><br><span class="line">        Inventor tesla1 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla1&quot;</span>, <span class="string">&quot;Shang Hai&quot;</span>);</span><br><span class="line">        Inventor tesla2 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla2&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Inventor tesla3 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla3&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        Inventor tesla4 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla4&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        List&lt;Inventor&gt; inventors = Arrays.asList(tesla, tesla1, tesla2, tesla3, tesla4);</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">&quot;inventors&quot;</span>, inventors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对List做各类运算：</span></span><br><span class="line">        <span class="comment">// 过滤，选择所有 nationality 字段为 &#x27;Serbian&#x27; 的 Inventor 对象</span></span><br><span class="line">        List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.?[nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 nationality 字段，并返回一个新的 List</span></span><br><span class="line">        List&lt;Inventor&gt; list1 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list1.toString());</span><br><span class="line">        <span class="comment">// 投影，对所有对象的 nationality 字段是否为 &#x27;Serbian&#x27; 进行判断，并返回一个新的布尔类型List</span></span><br><span class="line">        List&lt;Inventor&gt; list2 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list2.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 serbian 字段，并返回一个新的 List，与list1等同。</span></span><br><span class="line">        List&lt;Inventor&gt; list3 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![#this.getNationality()]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问Map"><a href="#访问Map" class="headerlink" title="访问Map"></a>访问Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问map</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">params.put(<span class="string">&quot;backOrderCode&quot;</span>, <span class="string">&quot;H12345764564&quot;</span>);</span><br><span class="line">context.setVariable(<span class="string">&quot;params&quot;</span>, params);</span><br><span class="line">Object object = parser.parseExpression(<span class="string">&quot;#params[backOrderCode]&quot;</span>).getValue(context);</span><br><span class="line">log.info(object.toString());</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/174786047">https://zhuanlan.zhihu.com/p/174786047</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/149920813">https://zhuanlan.zhihu.com/p/149920813</a><br>[3] <a href="https://docs.spring.io/spring-framework/reference/core/expressions.html">https://docs.spring.io/spring-framework/reference/core/expressions.html</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。&lt;/p&gt;
&lt;p&gt;SpEL是单独模块（&lt;code&gt;org.springframework.expression&lt;/code&gt;），只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>空洞卷积</title>
    <link href="http://silencezheng.top/2023/12/25/article124/"/>
    <id>http://silencezheng.top/2023/12/25/article124/</id>
    <published>2023-12-24T18:01:57.000Z</published>
    <updated>2023-12-24T18:07:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。<br><span id="more"></span></p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>空洞卷积最初的提出是为了解决图像分割的问题，常见的图像分割算法通常使用池化层和卷积层来增加感受域，同时也缩小了特征图尺寸(resolution)，然后再利用上采样还原图像尺寸，特征图缩小再放大的过程造成了精度上的损失，因此需要一种操作可以在增加感受域的同时保持特征图的尺寸不变，从而代替下采样和上采样操作，在这种需求下，空洞卷积就诞生了。当然，跳跃连接（skip connection）也是另一种弥补信息损失的方法。</p><p>空洞卷积自2016在ICLR上被提出后，本身是用在图像分割领域，但立马被Deepmind拿来应用到语音(WaveNet)和NLP领域，它在物体检测也发挥了重要的作用。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在常规卷积运算中，固定大小的滤波器在输入特征图上滑动，滤波器中的值与输入特征图中的相应值相乘以产生单个输出值。输出特征图中神经元的感受域被定义为滤波器可以“看到”的输入特征图中的区域。感受域的大小由滤波器的大小和卷积的步长决定。</p><p>相反，在膨胀卷积运算中，通过在滤波器值之间插入间隙来“扩张”滤波器。<strong>膨胀率</strong>(dilation rate) 决定了间隙的大小，它是一个可以调整的超参数。当膨胀率为 1 时，膨胀卷积简化为常规卷积。</p><p>膨胀率在不增加参数数量的情况下有效地增加了滤波器的感受域，因为滤波器的大小仍然相同，但值之间有间隙。这在需要更大感受域的情况下很有用，但增加滤波器的大小会导致参数数量和计算复杂性的增加。</p><p>下图描述了正常卷积与扩张卷积之间的差异，附加参数$l$（膨胀因子）表示输入扩张了多少。换句话说，根据该参数的值，滤波器中会跳过$(l-1)$个像素。</p><p><img src="/assets/post_img/article124/normalvsdilatedconv.png" alt="dc"></p><p>膨胀卷积的公式可表示如下：</p><script type="math/tex; mode=display">\left(F_{* l} k\right)(p)=\sum_{(s+l t=p)} F(s) k(t)</script><p>其中，$F(s)$为输入特征，$s$为各采样位置，$k(t)$表示卷积核$k$在$t$处的权重，${*l}$表示膨胀因子为$l$的膨胀卷积。</p><p>$(F_{* l} k)(p)$为在位置$p$处的输出。求和条件还需要再看下…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在Pytorch中实现空洞卷积十分简单，只需要指定dilation参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DilatedCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(DilatedCNN,self).__init__()</span><br><span class="line">    self.convlayers = nn.Sequential(</span><br><span class="line">      nn.Conv2d(in_channels = <span class="number">3</span>, out_channels = <span class="number">6</span>, kernel_size = <span class="number">9</span>, stride = <span class="number">1</span>, padding = <span class="number">0</span>, dilation=<span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding= <span class="number">0</span>, dilation = <span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">    )</span><br><span class="line">    self.fclayers = nn.Sequential(</span><br><span class="line">      nn.Linear(<span class="number">2304</span>,<span class="number">120</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">120</span>,<span class="number">84</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line">    )</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    x = self.convlayers(x)</span><br><span class="line">    x = x.view(-<span class="number">1</span>,<span class="number">2304</span>)</span><br><span class="line">    x = self.fclayers(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>网格效应（The Gridding Effect）</li><li>Long-ranged information might be not relevant.</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/113285797">https://zhuanlan.zhihu.com/p/113285797</a><br>[2] <a href="https://www.geeksforgeeks.org/dilated-convolution/">https://www.geeksforgeeks.org/dilated-convolution/</a><br>[3] <a href="https://developer.orbbec.com.cn/v/blog_detail/892">https://developer.orbbec.com.cn/v/blog_detail/892</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在Spring项目中使用数据库事务</title>
    <link href="http://silencezheng.top/2023/11/24/article123/"/>
    <id>http://silencezheng.top/2023/11/24/article123/</id>
    <published>2023-11-24T15:48:44.000Z</published>
    <updated>2023-11-24T15:57:36.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。</p><p>相关内容：InnoDB事务实现、Spring事务传播机制等。<br><span id="more"></span></p><h1 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong>。事务是一种用于维护数据一致性的机制，它确保了数据库在多个并发操作下仍然保持一致性。</p><p>事务（最小操作单元）存在的主要意图：</p><ul><li>在最小操作单元中保持稳定的操作，即使在故障时也能恢复到操作之前的状态保持数据一致性。</li><li>保持各个最小操作单元之间互相隔离，以防止互相交互产生的覆盖性错误。</li></ul><p>事务结束的两种可能方式：</p><ul><li><code>commit</code>：提交最小操作单元中的所有操作。</li><li><code>terminate</code>：操作终止，最小操作单元中所有修改无效。</li></ul><p>数据库操作的环境：</p><ul><li>共享-多用户并发访问</li><li>不稳定-潜在的硬件/软件故障</li></ul><p>事务所需环境：</p><ul><li>不共享 - 一个事务内的操作不受其他事务影响</li><li>稳定 - 即使面对系统故障，当前事务的操作也能保留现场</li></ul><p>一个事务一旦开始，则必须确保：</p><ul><li>所有操作必须可回溯</li><li>所有操作对后续操作的影响必须是可见的</li></ul><p>一个事务开始的过程中必须确保：在该事务结束之前其他事务看不到它的结果。如果事务中止，必须确保当前事务所有可能影响数据一致性的操作都会被清理。如果系统出现故障，必须确保重新启动时所有未提交的事务都会被清理。</p><p>关系型数据库大多遵循事务的四大特性：</p><ol><li>原子性（Atomicity）：事务是最小的执行单位，事务中的所有操作要么全部成功执行，要么全部失败回滚。如果其中任何一个操作失败，那么整个事务都会被回滚到初始状态。</li><li>一致性（Consistency）：事务在执行前后，数据库必须保持一致性状态。这意味着事务执行后，数据库的完整性约束仍然得以维护，以转账业务为例，双方存款总额应不变。</li><li>隔离性（Isolation）：事务的执行应该与其他事务相互隔离，即一个事务的执行不应该影响其他事务的执行。这确保了并发事务之间的数据不会互相干扰。</li><li>持久性（Durability）：一旦事务提交成功，对数据库的修改应该永久保存，即使数据库发生故障也不应该对其有影响。</li></ol><p>关于四大特性的一些理解：</p><blockquote><p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。只有保证了事务的持久性、原子性、隔离性之后，一致性才可能得到保障。</p></blockquote><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久性是为了能应对数据库崩溃的情况。</li></ul><h1 id="InnoDB事务实现"><a href="#InnoDB事务实现" class="headerlink" title="InnoDB事务实现"></a>InnoDB事务实现</h1><p>MySQL提供插件式存储引擎，这些存储引擎是基于表的，而不是数据库。</p><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。它的特点是行锁设计，支持外键，并支持非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是MySQL默认的存储引擎。</p><p>在InnoDB引擎中实现事务最重要的东西就是日志系统，保证事务的四大特性主要依靠这两大日志：</p><ul><li><strong>redo log</strong>：保证事务持久性</li><li><strong>undo log</strong>：回滚日志，保证事务原子性</li></ul><p>两大日志系统分别保证了持久性和原子性，隔离性则是通过<strong>MVCC机制</strong>和<strong>锁机制</strong>来控制实现。</p><h2 id="Logical-logs-amp-Physical-logs"><a href="#Logical-logs-amp-Physical-logs" class="headerlink" title="Logical logs &amp; Physical logs"></a>Logical logs &amp; Physical logs</h2><p><strong>逻辑日志（Logical Logs）：</strong></p><ol><li><strong>记录内容</strong>：逻辑日志记录的是数据库操作的逻辑信息，例如SQL语句、表和列的名称、数据的逻辑结构等。它不关心底层数据的物理存储方式。</li><li><strong>用途</strong>：逻辑日志主要用于数据导入、导出、备份和恢复等高层次的数据操作。它允许将数据从一个数据库复制到另一个数据库，而不必考虑底层数据的物理结构。</li><li><strong>示例</strong>：MySQL的二进制日志（binlog）是一种逻辑日志，记录了SQL语句的执行顺序，以便在复制数据或进行数据备份时使用。</li></ol><p><strong>物理日志（Physical Logs）：</strong></p><ol><li><strong>记录内容</strong>：物理日志记录的是数据库操作对底层物理数据的实际修改，包括数据页的读写、磁盘块的分配和释放等。它关注数据的物理存储细节。</li><li><strong>用途</strong>：物理日志主要用于确保事务的持久性和恢复能力。它允许在系统崩溃或故障后恢复未提交的事务，以及将事务的修改应用到数据库中。</li><li><strong>示例</strong>：MySQL的重做日志（redo log）是一种物理日志，记录了事务对数据页的修改，以便在事务提交后将这些修改应用到数据文件中，或者在系统故障时恢复数据一致性。</li></ol><p>以上只是简要的概念解释，更多信息可以参见[6]。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>在介绍InnoDB的两大核心日志前，先简单聊一下MySQL的二进制日志，对理解Redo log的作用有帮助。</p><p>binlog = binary log，二进制日志，它记录了除了 select 之外所有的 DDL 和 DML 语句。以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL都会记录binlog日志。</p><p>binlog日志有两个最重要的使用场景：</p><ul><li>主从复制：mysql replication 在 master 端开启 binlog，master 把它的二进制日志传递给 slaves 来达到 master-slave 数据一致的目的。</li><li>数据恢复：通过 mysqlbinlog 工具来恢复数据。</li></ul><p>binlog 日志包括两类文件：</p><ol><li>二进制日志索引文件（文件名后缀为 .index）用于记录所有的二进制文件。</li><li>二进制日志文件（文件名后缀为 .00000*）记录数据库所有的 DDL 和 DML 语句事件。</li></ol><p>binlog文件是通过追加的方式写入的，可通过配置参数<code>max_binlog_size</code>设置每个 binlog 文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。</p><p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。在 MySQL 5.7.7之前，默认的格式是STATEMENT，MySQL 5.7.7之后，默认值是ROW。日志格式通过<code>binlog-format</code>指定。</p><p>我们假设数据库只有 binlog，那么数据文件的更新和写入 binlog 只有两种情况：</p><ol><li>先更新数据文件，再写入 binlog。</li><li>先写入 binlog，再更新数据文件。</li></ol><p>如果先更新数据文件，接着服务器宕机，则导致 binlog 中缺少最后的更新信息；如果先写 binlog 再更新数据则可能导致数据文件未被更新。所以在只有 binlog 的环境中的 MySQL 是不具备 crash-safe 的能力。</p><p>PS：这里关于binlog的写入机制不做过多展开，但也是分write和fsync两个步骤，时机由参数<code>sync_binlog</code>控制。</p><h2 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h2><p>Write-Ahead Logging策略是一种用于确保数据一致性和恢复能力的重要技术，为了保证恢复时可以从日志中看到最新的数据库状态，要求日志先于数据内容落盘。其核心思想是在修改数据之前，首先将这些修改操作记录到一个持久性的日志文件中，然后再将这些操作应用到实际的数据文件。注意这里的日志是比binlog更细粒度的日志。</p><p>除此之外，事务完成提交前还需要在日志中记录对应的Commit标记，以供恢复时了解当前的事务状态，因此还需要关注Commit标记和事务中数据内容的落盘顺序。根据日志中记录的内容可以分为三类：<strong>Undo-Only</strong>，<strong>Redo-Only</strong>，<strong>Redo-Undo</strong>。</p><h3 id="Undo-Only-Logging"><a href="#Undo-Only-Logging" class="headerlink" title="Undo-Only Logging"></a>Undo-Only Logging</h3><p>Undo-Only Logging的Log记录可以表示为<code>&lt;T, X, v&gt;</code>，事务$T$修改了$X$的值，$X$的旧值是v。事务提交时，需要通过强制Flush保证Commit标记落盘前，对应事务的所有数据落盘，即落盘顺序为Log记录-&gt;Data-&gt;Commit标记。恢复时可以根据Commit标记判断事务的状态，并通过Undo Log中记录的旧值将未提交事务的修改回滚。我们来审视一下Undo-Only对Durability及Atomic的保证：</p><ul><li>Durability of Updates：Data强制刷盘保证，已经Commit的事务由于其所有Data都已经在Commit标记之前落盘，因此会一直存在；</li><li>Failure Atomic：Undo Log内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>然而Undo-Only依然有不能Page内并发的问题，如果两个事务的修改落到一个Page中，一个事务提交前需要的强制Flush操作，会导致同Page所有事务的Data落盘，可能会早于对应的Log项从而损害WAL。同时，也会导致关键路径上过于频繁的磁盘随机访问。</li></ul><h3 id="Redo-Only-Logging"><a href="#Redo-Only-Logging" class="headerlink" title="Redo-Only Logging"></a>Redo-Only Logging</h3><p>不同于Undo-Only，采用Redo-Only的Log中记录的是修改后的新值。对应地，Commit时需要保证，Log中的Commit标记在事务的任何数据之前落盘，即落盘顺序为Log记录-&gt;Commit标记-&gt;Data。恢复时同样根据Commit标记判断事务状态，并通过Redo Log中记录的新值将已经Commit，但数据没有落盘的事务修改重放。</p><ul><li>Durability of Updates：Redo Log内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：阻止Commit前Data落盘保证，失败事务的修改不会出现在磁盘上，自然不可见。<br>Redo-Only同样有不能Page内并发的问题，Page中的多个不同事务，<strong>只要有一个未提交就不能刷盘，这些数据全部都需要维护在内存中，造成较大的内存压力</strong>。</li></ul><h3 id="Redo-Undo-Logging"><a href="#Redo-Undo-Logging" class="headerlink" title="Redo-Undo Logging"></a>Redo-Undo Logging</h3><p>可以看出的只有Undo或Redo的问题，主要来自于对Commit标记及Data落盘顺序的限制，而这种限制归根结底来源于Log信息中对新值或旧值的缺失。因此Redo-Undo采用同时记录新值和旧值的方式，来消除Commit和Data之间刷盘顺序的限制。</p><ul><li>Durability of Updates：Redo 内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：Undo内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>如此一来，同Page的不同事务提交就变得非常简单。同时可以将连续的数据攒着进行批量的刷盘已利用磁盘较高的顺序写性能。</li></ul><h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入磁盘后，内存和磁盘上的数据页内容就一致了，称为“干净页”。刷脏页，即把脏页（内存中的修改过的数据页）刷新（flush）到磁盘上。</p><p>对于 InnoDB 存储引擎，缓冲池（buffer pool）是内存中的一个重要组成部分。当查询需要读取数据时，数据库首先查看缓冲池中是否已经有相应的数据页。如果数据页在缓冲池中，查询可以立即从内存中获取数据，而不必进行磁盘读取，这大大提高了性能。如果数据页不在缓冲池中（缓冲池未命中），数据库系统将从磁盘读取该数据页，并将其放入缓冲池中，以便将来的查询可以更快地访问。缓冲池的大小通常是可以配置的，数据库管理员可以根据系统的内存和性能需求来调整缓冲池的大小。</p><p>对于事务处理，数据的修改通常首先在内存中进行，然后等待事务提交。在事务提交之前，数据在内存中被认为是脏的，因为它们还未被写入到磁盘。下面有一段文字可以也可以帮助引出Redo log的作用。</p><blockquote><p>InnoDB 有 缓冲池（buffer pool）。缓冲池是物理页的缓存，对 InnoDB 的任何修改操作都会首先在缓冲池的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的 flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO操作，同时异步写入也降低了访问的时延。</p><p>然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了缓冲池页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。</p></blockquote><h2 id="Redo-log-Durability"><a href="#Redo-log-Durability" class="headerlink" title="Redo log (Durability)"></a>Redo log (Durability)</h2><p>Redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p><p>在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer写入redo log file实际上是先写入文件系统page cache，然后再通过系统调用fsync将其刷到redo log file中。由此可以得到redo log的三种状态：</p><ol><li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中。</li><li>写到磁盘 (write)，但是没有持久化，物理上是在文件系统的 page cache 里面。</li><li>调用fsync，持久化到磁盘。</li></ol><p>事务在执行过程中，对内存中数据页进行修改将生成redo log，生成的 redo log 是先写到 redo log buffer 中，然后通过某些方式刷入磁盘。这里所指的方式，个人理解主要有五种：</p><ol><li>后台线程每秒一次执行刷盘，并行轮询。</li><li>每个事务提交时依据策略刷盘。</li><li>当redo log buffer缓存可用空间小于一半的时候刷盘，整体空间受<code>innodb_log_buffer_size</code>控制。这个情况的刷盘仅指write，然后可能被后台线程刷盘，这也是未提交redo log刷盘的可能情况之一。</li><li>数据库服务器正常关闭时。</li><li>检查点，<strong>checkpoints</strong>。</li></ol><p>PS：另外两种情况是：1、事务执行过程中的 redo log 也是直接写在 redo log buffer 中的，即将事务的修改暂时保存于内存中，这些 redo log 也会被后台线程一起持久化到磁盘。即一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。2、事务并行，先提交的事务把其他事务的redo log buffer刷盘。</p><p>Redo log的在事务提交时的写入策略由参数<code>innodb_flush_log_at_trx_commit</code>控制，有以下三种取值选项：</p><ol><li>设置为<code>0</code>的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为<code>1</code>的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘（默认）；</li><li>设置为<code>2</code>的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>（TODO：这一部分应该有问题，内存中的数据也会写入，不过这时候落盘的脏数据就靠undo了）那么了解了redo log的写入机制后，它到底是如何实现保证数据库持久性的呢？下面我尝试从一个事务的开始进行分析。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Chain1:</span> 事务开始 -&gt; 数据页读取 -&gt; 事务执行（数据页修改 &amp; <span class="keyword">redo</span> log生成）-&gt; 事务提交 -&gt; 事务结束</span><br><span class="line"><span class="symbol">Chain2:</span>                           执行过程中会发生<span class="keyword">redo</span> log刷盘  依据策略决定是否直接刷盘    </span><br></pre></td></tr></table></figure><p>我把执行流程分为了两个链条，chain1是事务执行的流程，chain2是redo log部分InnoDB在对应位置可能采取的操作。下面我们在chain1的每个部分模拟掉电关机，看会发生什么事情。由于这一块内容实际上是崩溃恢复相关内容，我们先定义<strong>正常状态</strong>，<strong>正常状态</strong>指的是 MySQL 崩溃之前，数据页最后一次正确的刷新到磁盘的状态。</p><p>1、数据页读取：对数据库完整性无影响。<br>2、事务执行（redo log生成未落盘）：无影响，事务未提交。<br>3、事务执行（redo log生成已落盘）：无影响，事务未提交。<br>4、事务提交（redo log写入策略=1）：任意时间崩溃，都可以通过redo log执行恢复，损坏的数据页可以通过<strong>double write</strong>修复后再执行恢复。<br>5、事务提交（redo log写入策略=2）：如果在redo log刚写入未刷盘时断电，则会丢失上一秒的数据，仅mysqld崩溃不会丢失数据。<br>6、事务提交（redo log写入策略=0）：与上一情况相同，但如果崩溃情况降级，例如mysqld崩溃，也会丢失数据。</p><p>注意以上分析仅是简化版，更多细节如Checkpoints、Double write、LSN、Mini-Transaction等…需要多读书实践才能通透了，需要时再学习吧。</p><h2 id="Undo-log-Atomicity"><a href="#Undo-log-Atomicity" class="headerlink" title="Undo log (Atomicity)"></a>Undo log (Atomicity)</h2><p>Undo Log是InnoDB十分重要的组成部分，它的作用横贯InnoDB中两个最主要的部分，并发控制（Concurrency Control）和故障恢复（Crash Recovery），InnoDB中undo log的实现亦日志亦数据。</p><p>为保证原子性，InnoDB会在正常事务进行中，就不断的连续写入undo log，来记录本次修改之前的历史值。当故障真正发生时，可以在recovery过程中通过回放undo log将未提交事务的修改抹掉。此外，undo log也可以用来支持死锁处理或用户请求的事务回滚。</p><p>在并发控制中，主流数据库采用多版本并发控制，为每条记录保存多份历史数据供读事务访问，新的写入只需要添加新的版本即可，InnoDB利用undo log提供此功能。</p><p>在设计方面，undo log需要的是事务之间的并发，以及方便的多版本数据维护，其重放逻辑不希望因数据库物理存储变化而变化，因此InnoDB中的undo log采用<strong>逻辑日志</strong>。同时，InnoDB是把undo log当做一种数据来维护和使用的，其本身也像其他的数据库数据一样，会写自己对应的redo log，以此保证自己不出错。</p><h3 id="Undo-Record的内容"><a href="#Undo-Record的内容" class="headerlink" title="Undo Record的内容"></a>Undo Record的内容</h3><p>每当InnoDB中需要修改某条记录时，都会将其历史版本写入一个undo log中，对应的undo record是Update类型。当插入新的记录时，还没有一个历史版本，但为了方便事务回滚时做逆向（Delete）操作，还是会写入一个Insert类型的undo record。</p><p>对于Insert类型的undo record，它仅仅是为了可能的事务回滚准备的，并不在MVCC功能中承担作用，因此只需要用<strong>Key Fields</strong>记录对应数据库记录的主键，供回滚时查找记录位置即可。</p><p><img src="/assets/post_img/article123/insert_undo_record.png" alt=""></p><p>其中Undo Number是Undo的一个递增编号，Table ID用来表示是哪张表的修改。下面一组Key Fields的长度不定，因为对应表的主键可能由多个field组成，这里需要存储数据库记录完整的主键信息，回滚的时候可以通过这个信息在索引中定位到对应的记录。除此之外，在Undo Record的头尾还各留了两个字节用户记录其前序和后继Undo Record的位置。</p><p>对于Update类型的undo record，情况稍微复杂一些，由于MVCC需要保留记录的多个历史版本，当某个记录的历史版本还在被使用时，这个记录是不能被真正的删除的。因此，当需要删除时，其实只是修改对应记录的Delete Mark标记。对应的，如果这时这个记录又重新插入，其实也只是修改一下Delete Mark标记，也就是将这两种情况的删除和插入转变成了更新操作。再加上常规的更新记录，这种类型的undo record存在三种类型：<code>TRX_UNDO_UPD_EXIST_REC, TRX_UNDO_DEL_MARK_REC, TRX_UNDO_UPD_DEL_REC</code>。</p><p><img src="/assets/post_img/article123/update_undo_record.png" alt=""></p><p>除了<strong>Key Fields</strong>外，Update类型的undo record增加了以下内容：</p><ol><li>Transaction Id，记录了产生这个历史版本事务ID，用作后续MVCC中的版本可见性判断。</li><li>RollPtr，指向的是该记录的上一个版本的位置，沿着RollPtr可以找到一个记录的所有历史版本。</li><li>Update Fields，其中记录的就是当前这个记录版本相对于其之后的一次修改的Delta信息，包括所有被修改的Field的编号，长度和历史值。</li></ol><h3 id="Undo-Record的组织方式"><a href="#Undo-Record的组织方式" class="headerlink" title="Undo Record的组织方式"></a>Undo Record的组织方式</h3><p>每一次的修改都会产生至少一个Undo Record，现在考虑大量Undo Record如何组织起来支持高效访问与管理。首先是在不考虑物理存储的情况下的逻辑组织方式；之后，物理组织方式介绍如何将其存储到到实际16KB物理块中；然后文件组织方式介绍整体的文件结构；最后再介绍其在内存中的组织方式。</p><h4 id="逻辑组织方式-Undo-Log"><a href="#逻辑组织方式-Undo-Log" class="headerlink" title="逻辑组织方式 - Undo Log"></a>逻辑组织方式 - Undo Log</h4><p>每个事务会修改一组数据库记录，对应的会产生一组Undo Record，这些Undo Record首尾相连组成了这个事务的Undo Log。除了一个个的Undo Record之外，还在开头增加了一个Undo Log Header来记录一些必要的控制信息，因此，一个Undo Log的结构如下所示：</p><p><img src="/assets/post_img/article123/undo_log.png" alt=""></p><p><strong>Undo Log Header</strong>中记录了产生这个Undo Log的事务的Trx ID；Trx No是事务的提交顺序，也会用这个来判断是否能Purge，这个在后面会详细介绍；Delete Mark标明该Undo Log中有没有<code>TRX_UNDO_DEL_MARK_REC</code>类型的Undo Record，避免Purge时不必要的扫描；Log Start Offset中记录Undo Log Header的结束位置，方便之后Header中增加内容时的兼容；之后是一些Flag信息；Next Undo Log及Prev Undo Log标记前后两个Undo Log，这个会在接下来介绍；最后通过History List Node将自己挂载到为Purge准备的History List中。</p><p>索引中的同一个数据库记录被不同事务修改，会产生不同的历史版本，这些历史版本又通过<strong>Rollptr</strong>穿成一个链表，供MVCC使用。如下图所示：</p><p><img src="/assets/post_img/article123/undo_logical.png" alt=""></p><p>示例中有三个事务操作了表$t$上，主键id是1的记录，首先事务$I$插入了这条记录并且设置字段$a$的值为A，之后事务$J$和事务$K$分别将这条id为1的记录中的字段$a$的值修改为了B和C。$I$，$J$，$K$三个事务分别有自己的逻辑上连续的三条Undo Log，每条Undo Log有自己的Undo Log Header。从索引中的这条数据库记录沿着<strong>Rollptr</strong>可以依次找到这三个事务Undo Log中关于这条记录的历史版本。同时可以看出，Insert类型Undo Record中只记录了对应的主键值：<code>id=1</code>，而Update类型的Undo Record中还记录了对应的历史版本的生成事务Trx_id，以及被修改的字段$a$的历史值。</p><h4 id="物理组织格式-Undo-Segment"><a href="#物理组织格式-Undo-Segment" class="headerlink" title="物理组织格式 - Undo Segment"></a>物理组织格式 - Undo Segment</h4><p>一个事务会产生多大的Undo Log本身是不可控的，而最终写入磁盘却是按照固定的块大小为单位的，InnoDB中默认是16KB，因此需要考虑如何用固定的块大小承载不定长的Undo Log，以实现高效的空间分配、复用，避免空间浪费。InnoDB的基本思路是让多个较小的Undo Log紧凑存在一个Undo Page中，而对较大的Undo Log则随着不断的写入，按需分配足够多的Undo Page分散承载。下面来看这部分的物理存储方式：</p><p><img src="/assets/post_img/article123/undo_physical.png" alt=""></p><p>每个写事务开始写操作之前都需要持有一个Undo Segment，一个Undo Segment中的所有磁盘空间的分配和释放，也就是16KB Page的申请和释放，都是由一个FSP Segment管理的。</p><blockquote><p>FSP（File Space Page）是InnoDB存储引擎中的一个概念，表示文件空间段（Segment）。每个FSP Segment对应于一个表空间（tablespace），用于存储数据和索引。</p><p>在InnoDB中，数据和索引被组织为一个个页面（Page），而这些页面又按照一定的方式来组织并保存在FSP Segment中。FSP Segment是InnoDB存储引擎管理存储空间的基本单位。</p><p>FSP Segment包含多个连续的文件空间页（File Space Pages），这些页面可以是数据页、索引页或其他类型的页，以满足不同的存储需求。每个FSP Segment都有自己的FSP ID（File Space Page ID），用于唯一标识它。</p></blockquote><p>Undo Segment会持有至少一个Undo Page，每个Undo Page会在开头38字节到56字节记录Undo Page Header，其中记录Undo Page的类型、最后一条Undo Record的位置，当前Page还空闲部分的开头，也就是下一条Undo Record要写入的位置。Undo Segment中的第一个Undo Page还会在56字节到86字节记录<strong>Undo Segment Header</strong>，这就是这个Undo Segment中磁盘空间管理的Handle，其中记录的是这个Undo Segment的状态（State），包括TRX_UNDO_CACHED、TRX_UNDO_TO_PURGE等，还记录了这个Undo Segment中最后一条Undo Record的位置、这个FSP Segment的Header以及当前分配出来的所有Undo Page的链表。</p><p>Undo Page剩余的空间都是用来存放Undo Log的，对于像上图Undo Log 1，Undo Log 2这种较短的Undo Log，为了避免Page内的空间浪费，InnoDB会复用Undo Page来存放多个Undo Log，而对于像Undo Log 3这种比较长的Undo Log可能会分配多个Undo Page来存放。需要注意的是Undo Page的复用只会发生在第一个Page。</p><h4 id="文件组织方式-Undo-Tablespace"><a href="#文件组织方式-Undo-Tablespace" class="headerlink" title="文件组织方式 - Undo Tablespace"></a>文件组织方式 - Undo Tablespace</h4><p>每一时刻一个Undo Segment都是被一个事务独占的。每个写事务都会持有至少一个Undo Segment，当有大量写事务并发运行时，就需要存在多个Undo Segment。InnoDB中的Undo文件中准备了大量的Undo Segment的槽位，按照1024一组划分为<strong>Rollback Segment</strong>。每个<strong>Undo Tablespace</strong>最多会包含128个Rollback Segment，Undo Tablespace文件中的第三个Page会固定作为这128个Rollback Segment的目录，也就是<strong>Rollback Segment Arrary Header</strong>，其中最多会有128个指针指向各个Rollback Segment Header所在的Page。Rollback Segment Header是按需分配的，其中包含1024个Slot，每个<strong>Slot</strong>占四个字节，指向一个Undo Segment的First Page。除此之前还会记录该Rollback Segment中已提交事务的History List，后续的Purge过程会顺序从这里开始回收工作。</p><p>可以看出Rollback Segment的个数会直接影响InnoDB支持的最大事务并发数。MySQL 8.0由于支持了最多127个独立的Undo Tablespace，一方面避免了ibdata1的膨胀，方便undo空间回收，另一方面也大大增加了最大的Rollback Segment的个数，增加了可支持的最大并发写事务数。如下图所示：</p><p><img src="/assets/post_img/article123/undo_tablespace.png" alt=""></p><h4 id="内存组织结构"><a href="#内存组织结构" class="headerlink" title="内存组织结构"></a>内存组织结构</h4><p>上面介绍的都是Undo数据在磁盘上的组织结构，除此之外，在内存中也会维护对应的数据结构来管理Undo Log，如下图所示：</p><p><img src="/assets/post_img/article123/undo_memory.png" alt=""></p><p>对应每个磁盘Undo Tablespace会有一个<strong>undo::Tablespace</strong>的内存结构，其中最主要的就是一组<strong>trx_rseg_t</strong>的集合，trx_rseg_t对应的就是上面介绍过的一个Rollback Segment Header（目录），除了一些基本的元信息之外，trx_rseg_t中维护了四个trx_undo_t的链表，Update List中是正在被使用的用于写入Update类型Undo的Undo Segment；Update Cache List中是空闲空间比较多，可以被后续事务复用的Update类型Undo Segment;对应的，Insert List和Insert Cache List分别是正在使用中的Insert类型Undo Segment，和空间空间较多，可以被后续复用的Insert类型Undo Segment。因此<strong>trx_undo_t对应的就是上面介绍过的Undo Segment</strong>。接下来，我们就从Undo的写入、Undo用于Rollback、MVCC、Crash Recovery以及如何清理Undo等方面来介绍InnoDB中Undo的角色和功能。</p><h3 id="Undo-Log的写入"><a href="#Undo-Log的写入" class="headerlink" title="Undo Log的写入"></a>Undo Log的写入</h3><p>当写事务开始时，会先通过<strong>trx_assign_rseg_durable</strong>操作分配一个Rollback Segment，该事务的内存结构<strong>trx_t</strong>也会通过rsegs指针指向对应的trx_rseg_t内存结构，这里的分配策略很简单，就是依次尝试下一个Active的Rollback Segment。之后当第一次真正产生修改需要写Undo Record的时，会调用<strong>trx_undo_assign_undo</strong>操作来获得一个Undo Segment。这里会优先复用trx_rseg_t上<strong>Cached List</strong>中的trx_undo_t，也就是已经分配出来但没有被正在使用的Undo Segment，如果没有才调用<strong>trx_undo_create</strong>操作创建新的Undo Segment，trx_undo_create中会轮询选择当前Rollback Segment中可用的Slot，也是就值FIL_NUL的Slot，申请新的Undo Page，初始化Undo Page Header，Undo Segment Header等信息，创建新的trx_undo_t内存结构并挂到trx_rseg_t的对应List中。</p><p>获得了可用的Undo Segment之后，该事务会在合适的位置初始化自己的Undo Log Header，之后，其所有修改产生的Undo Record都会顺序的通过<strong>trx_undo_report_row_operation</strong>操作顺序的写入当前的Undo Log，其中会根据是insert还是update类型，分别调用trx_undo_page_report_insert或者trx_undo_page_report_modify。本文开始已经介绍过了具体的Undo Record内容。简单的讲，insert类型会记录插入Record的主键，update类型除了记录主键以外还会有一个update fileds记录这个历史值跟索引值的diff。之后指向当前Undo Record位置的Rollptr会返回写入索引的Record上。</p><p>当一个Page写满后，会调用<strong>trx_undo_add_page</strong>来在当前的Undo Segment上添加新的Page，新Page写入Undo Page Header之后继续供事务写入Undo Record，为了方便维护，这里有一个限制就是单条Undo Record不跨page，如果当前Page放不下，会将整个Undo Record写入下一个Page。</p><p>当事务结束（commit或者rollback）之后，如果只占用了一个Undo Page，且当前Undo Page使用空间小于page的3/4，这个Undo Segment会保留并加入到对应的insert/update cached list中。否则，insert类型的Undo Segment会直接回收，而update类型的Undo Segment会等待后台的Purge做完后回收。根据不同的情况，Undo Segment Header中的State会被从<code>TRX_UNDO_ACTIVE</code>改成<code>TRX_UNDO_TO_FREE</code>，<code>TRX_UNDO_TO_PURGE</code>或<code>TRX_UNDO_CACHED</code>，这个修改其实就是InnoDB的事务结束的标志，无论是Rollback还是Commit，在这个修改对应的Redo落盘之后，就可以返回用户结果，并且Crash Recovery之后也不会再做回滚处理。</p><h3 id="Undo-Log之回滚"><a href="#Undo-Log之回滚" class="headerlink" title="Undo Log之回滚"></a>Undo Log之回滚</h3><p>InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或者发生Crash，重启后对未提交的事务回滚。在Undo层面来看，这些回滚的操作是一致的，基本的过程就是从该事务的Undo Log中，从后向前依次读取Undo Record，并根据其中内容做逆向操作，恢复索引记录。</p><p>回滚的入口是函数<strong>row_undo</strong>，其中会先调用trx_roll_pop_top_rec_of_trx获取并删除该事务的最后一条Undo Record。如下图例子中的Undo Log包括三条Undo Records，其中Record 1在Undo Page 1中，Record 2，3在Undo Page 2中，先通过从Undo Segment Header中记录的Page List找到当前事务的最后一个Undo Page的Header，并根据Undo Page 2的Header上记录的Free Space Offset定位最后一条Undo Record结束的位置，当然实际运行时，这两个值是缓存在trx_undo_t的top_page_no和top_offset中的。利用Prev Record Offset可以找到Undo Record 3，做完对应的回滚操作之后，再通过前序指针Prev Record Offset找到前一个Undo Record，依次进行处理。处理完当前Page中的所有Undo Records后，再沿着Undo Page Header中的List找到前一个Undo Page，重复前面的过程，完成一个事务所有Page上的所有Undo Records的回滚。</p><p><img src="/assets/post_img/article123/undo_rollback.png" alt=""></p><p>拿到一个Undo Record之后，自然地，就是对其中内容的解析，这里会调用row_undo_ins_parse_undo_rec，从Undo Record中获取修改行的table，解析出其中记录的主键信息，如果是update类型，还会拿到一个update vector记录其相对于更新的一个版本的变化。</p><p><code>TRX_UNDO_INSERT_REC</code>类型的Undo回滚在row_undo_ins中进行，insert的逆向操作当然就是delete，根据从Undo Record中解析出来的主键，用row_undo_search_clust_to_pcur定位到对应的ROW， 分别调用row_undo_ins_remove_sec_rec和row_undo_ins_remove_clust_rec在二级索引和主索引上将当前行删除。</p><p>update类型的undo包括<code>TRX_UNDO_UPD_EXIST_REC</code>，<code>TRX_UNDO_DEL_MARK_REC</code>和<code>TRX_UNDO_UPD_DEL_REC</code>三种情况，他们的Undo回滚都是在row_undo_mod中进行，首先会调用row_undo_mod_del_unmark_sec_and_undo_update，其中根据从Undo Record中解析出的update vector来回退这次操作在所有二级索引上的影响，可能包括重新插入被删除的二级索引记录、去除其中的Delete Mark标记，或者用update vector中的diff信息将二级索引记录修改之前的值。之后调用row_undo_mod_clust同样利用update vector中记录的diff信息将主索引记录修改回之前的值。</p><p>完成回滚的Undo Log部分，会调用trx_roll_try_truncate进行回收，对不再使用的page调用trx_undo_free_last_page将磁盘空间交还给Undo Segment，这个是写入过程中trx_undo_add_page的逆操作。</p><h3 id="Undo-Log之故障恢复"><a href="#Undo-Log之故障恢复" class="headerlink" title="Undo Log之故障恢复"></a>Undo Log之故障恢复</h3><p>Crash Recovery时，需要利用Undo中的信息将未提交的事务的所有影响回滚，以保证数据库的Failure Atomic。前面提到过，InnoDB中的Undo其实是像数据一样处理的，也从上面的组织结构中可以看出来，Undo本身有着比Redo Log复杂得多、按事务分配而不是顺序写入的组织结构，其本身的Durability像InnoDB中其他的数据一样，需要靠Redo来保证。除了通用的一些MLOG_2BYTES、MLOG_4BYTES类型之外，Undo本身也有自己对应的Redo Log类型：<strong>MLOG_UNDO_INIT</strong>类型在Undo Page舒适化的时候记录初始化；在分配Undo Log的时候，需要重用Undo Log Header或需要创建新的Undo Log Header的时候，会分别记录<strong>MLOG_UNDO_HDR_REUSE</strong>和<strong>MLOG_UNDO_HDR_CREATE</strong>类型的Redo Record；<strong>MLOG_UNDO_INSERT</strong>是最常见的，在Undo Log里写入新的Undo Record都对应的写这个日志记录写入Undo中的所有内容；最后，<strong>MLOG_UNDO_ERASE_END</strong>对应Undo Log跨Undo Page时抹除最后一个不完整的Undo</p><blockquote><p>ARIES（Algorithms for Recovery and Isolation Exploiting Semantics）是一种事务恢复协议，用于数据库系统中的崩溃恢复和并发控制。它是一个经典的恢复算法，并被广泛应用于许多关系型数据库管理系统（RDBMS）。</p><p>ARIES本质是一种Redo-Undo的WAL实现。其正常运行过程为：修改数据之前先追加Log记录，Log内容同时包括Redo和Undo信息，每个日志记录产生一个标记其在日志中位置的递增LSN（Log Sequence Number）；数据页中记录最后修改的日志项LSN，以此来判断Page中的内容的新旧程度，实现幂等。故障恢复阶段需要通过Log中的内容恢复数据库状态，为了减少恢复时需要处理的日志量，ARIES会在正常运行期间周期性的生成Checkpoint，Checkpoint中除了当前的日志LSN之外，还需要记录当前活跃事务的最新LSN，以及所有脏页，供恢复时决定重放Redo的开始位置。需要注意的是，由于生成Checkpoint时数据库还在正常提供服务（Fuzzy Checkpoint），其中记录的活跃事务及脏页信息并不一定准确，因此需要Recovery阶段通过Log内容进行修正。</p><p>Recover过程：故障恢复包含三个阶段：Analysis，Redo和Undo。Analysis阶段的任务主要是利用Checkpoint及Log中的信息确认后续Redo和Undo阶段的操作范围，通过Log修正Checkpoint中记录的脏页集合信息，并用其中涉及最小的LSN位置作为下一步Redo的开始位置RedoLSN。同时修正Checkpoint中记录的活跃事务集合（未提交事务），作为Undo过程的回滚对象；Redo阶段从Analysis获得的RedoLSN出发，重放所有的Log中的Redo内容，注意这里也包含了未Commit事务；最后Undo阶段对所有未提交事务利用Undo信息进行回滚，通过Log的PrevLSN可以顺序找到事务所有需要回滚的修改。</p></blockquote><p>以ARIES过程为例，Crash Recovery的过程中会先重放所有的Redo Log，整个Undo的磁盘组织结构，也会作为一种数据类型也会通过上面讲到的这些Redo类型的重放恢复出来。之后在trx_sys_init_at_db_start操作中会扫描Undo的磁盘结构，遍历所有的Rollback Segment和其中所有的Undo Segment，通过读取Undo Segment Header中的State，可以知道在Crash前，最后持有这个Undo Segment的事务状态。如果是<code>TRX_UNDO_ACTIVE</code>，说明当时事务需要回滚，否则说明事务已经结束，可以继续清理Undo Segment的逻辑。之后，就可以恢复出Undo Log的内存组织模式，包括活跃事务的内存结构trx_t，Rollback Segment的内存结构trx_rseg_t，以及其中的trx_undo_t的四个链表。</p><p>Crash Recovery完成之前，会启动在srv_dict_recover_on_restart中启动异步回滚线程trx_recovery_rollback_thread，其中对Crash前还活跃的事务，通过trx_rollback_active进行回滚，这个过程与上面提到的Undo回滚是一致的。</p><h3 id="Undo-Log的清理"><a href="#Undo-Log的清理" class="headerlink" title="Undo Log的清理"></a>Undo Log的清理</h3><p>InnoDB在Undo Log中保存了多份历史版本来实现MVCC，当某个历史版本已经确认不会被任何现有的和未来的事务看到的时候，就应该被清理掉。因此就需要有办法判断哪些Undo Log不会再被看到。InnoDB中每个写事务结束时都会拿一个递增的编号trx_no作为事务的提交序号，而每个读事务会在自己的ReadView中记录自己开始的时候看到的最大的trx_no为m_low_limit_no。那么，如果一个事务的trx_no小于当前所有活跃的读事务Readview中的这个m_low_limit_no，说明这个事务在所有的读开始之前已经提交了，其修改的新版本是可见的， 因此不再需要通过undo构建之前的版本，这个事务的Undo Log也就可以被清理了。</p><p>这里不多深入，暂时用处不大，相关内容：Undo Purge、Undo Truncate、Undo Tablespace Truncate。</p><h2 id="MVCC和锁-Isolation"><a href="#MVCC和锁-Isolation" class="headerlink" title="MVCC和锁 (Isolation)"></a>MVCC和锁 (Isolation)</h2><p>多版本的目的是为了避免写事务和读事务的互相等待，那么每个读事务都需要在不对数据库记录加锁的情况下，找到对应的应该看到的历史版本。所谓历史版本就是假设在该只读事务开始的时候对整个DB打一个快照，之后该事务的所有读请求都从这个快照上获取。当然实现上不能真正去为每个事务打一个快照，这个时间空间都太高了。InnoDB的做法，是在读事务第一次读取的时候获取一份ReadView，并一直持有，其中记录所有当前活跃的写事务ID，由于写事务的ID是自增分配的，通过这个ReadView我们可以知道在这一瞬间，哪些事务已经提交哪些还在运行，根据Read Committed的要求，未提交的事务的修改就是不应该被看见的，对应地，已经提交的事务的修改应该被看到。</p><p>作为存储历史版本的Undo Record，其中记录的trx_id就是做这个可见性判断的，对应的数据库主索引的记录上也有这个值。当一个读事务拿着自己的ReadView访问某个表索引上的记录时，会通过比较记录上的trx_id确定是否是可见的版本，如果不可见就沿着Record或Undo Record中记录的rollptr一路找更老的历史版本。如下图所示，事务$R$开始需要查询表$t$上的id为1的记录，$R$开始时事务$I$已经提交，事务$J$还在运行，事务$K$还没开始，这些信息都被记录在了事务$R$的ReadView中。事务$R$从索引中找到对应的这条$Record_{1,C}$，对应的trx_id是$K$，不可见。沿着rollptr找到Undo中的前一版本$Record_{1,B}$，对应的trx_id是$J$，不可见。继续沿着rollptr找到$Record_{1,A}$，trx_id是$I$可见，返回结果。</p><p><img src="/assets/post_img/article123/undo_mvcc.png" alt=""></p><p>前面提到过，作为逻辑日志，Undo中记录的其实是前后两个版本的diff信息，而读操作最终是要获得完整的Record内容的，也就是说这个沿着rollptr指针一路查找的过程中需要用Undo Record中的diff内容依次构造出对应的历史版本，这个过程在函数row_search_mvcc中，其中trx_undo_prev_version_build会根据当前的rollptr找到对应的Undo Record位置，这里如果是rollptr指向的是insert类型，或者找到了已经Purge了的位置，说明到头了，会直接返回失败。否则，就会解析对应的Undo Record，恢复出trx_id、指向下一条Undo Record的rollptr、主键信息和diff信息update vector等信息。之后通过row_upd_rec_in_place，用update vector修改当前持有的Record拷贝中的信息，获得Record的这个历史版本。之后调用自己ReadView的changes_visible判断可见性，如果可见则返回用户。完成这个历史版本的读取。</p><p>TODO：补充关于锁的内容和MVCC的相关内容，并发事务问题-&gt;事务隔离级别-&gt;（隔离级别设置）-&gt;隔离级别的实现-&gt;锁（表、行、页）-&gt;MVCC（隐藏字段、undo、read view）。[3]</p><h1 id="Spring事务使用"><a href="#Spring事务使用" class="headerlink" title="Spring事务使用"></a>Spring事务使用</h1><p>先介绍Spring支持的两种事务管理方式，然后介绍Spring提供的主要事务管理接口。在实际开发中，我们通常使用<code>@Transactional</code>注解来开启事务，于是我们介绍这个注解中包含的事务属性参数（包括隔离级别、传播行为等等重要内容），并介绍如何使用该注解。</p><h2 id="两种事务管理方式"><a href="#两种事务管理方式" class="headerlink" title="两种事务管理方式"></a>两种事务管理方式</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过 <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用。使用 <code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务管理（常用）"><a href="#声明式事务管理（常用）" class="headerlink" title="声明式事务管理（常用）"></a>声明式事务管理（常用）</h3><p>代码侵入性最小，实际是通过 AOP 实现（基于<code>@Transactional</code>的全注解方式使用最多）。</p><p>使用<code>@Transactional</code>注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-事务管理接口"><a href="#Spring-事务管理接口" class="headerlink" title="Spring 事务管理接口"></a>Spring 事务管理接口</h2><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：<code>PlatformTransactionManager</code>，（平台）事务管理器，Spring 事务策略的核心；<code>TransactionDefinition</code>，事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)；<code>TransactionStatus</code>，事务运行状态。我们可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。<code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="PlatformTransactionManager-事务管理器接口"><a href="#PlatformTransactionManager-事务管理器接口" class="headerlink" title="PlatformTransactionManager - 事务管理器接口"></a><code>PlatformTransactionManager</code> - 事务管理器接口</h3><p>Spring 并不直接管理事务，而是提供了多种事务管理器，通过这个接口，Spring 为各个平台如：JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。将事务管理行为抽象出来方便程序扩展。</p><p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionDefinition-事务属性定义"><a href="#TransactionDefinition-事务属性定义" class="headerlink" title="TransactionDefinition - 事务属性定义"></a><code>TransactionDefinition</code> - 事务属性定义</h3><p>事务管理器接口 <code>PlatformTransactionManager</code> 通过 <code>getTransaction(TransactionDefinition definition)</code> 方法来得到一个事务，这个方法里面的参数是 `TransactionDefinition</p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p><p>事务属性包含了 5 个方面：</p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus - 事务状态"></a><code>TransactionStatus</code> - 事务状态</h3><p><code>TransactionStatus</code>接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息。<code>PlatformTransactionManager.getTransaction()</code>方法返回一个 <code>TransactionStatus</code> 对象。<code>TransactionStatus</code> 接口内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h2><p><code>@Transactional</code>中包含的事务属性参数。</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</strong></p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>举例来说，在 A 类的<code>aMethod()</code>中调用了 B 类的<code>bMethod()</code>。这个时候就涉及到业务层方法之间互相调用的事务问题。如果<code>bMethod()</code>发生异常需要回滚，如何配置事务传播行为才能让<code>aMethod()</code>也跟着回滚呢？下面来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便使用，Spring 相应地定义了一个枚举类：<code>Propagation</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则抛出异常。</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务传播行为可能的值如下：</p><p>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></p><p><code>@Transactional</code>注解默认使用的事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p><ul><li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p><p>2.<code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod()</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为<code>bMethod()</code>开启了独立的事务。但是，如果<code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话，<code>aMethod()</code>同样也会回滚，因为这个异常被<code>aMethod()</code>的事务管理机制检测到了。</p><p>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></p><p>如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与<code>TransactionDefinition.PROPAGATION_REQUIRED</code>类似的操作。嵌套事务回滚不影响外部事务。也就是说：</p><ul><li>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。</li><li>如果外部方法无事务，则单独开启一个事务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果 <code>bMethod()</code> 回滚的话，<code>aMethod()</code>不会回滚。如果<code>aMethod()</code>回滚的话，<code>bMethod()</code>会回滚。</p><p>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。这种方式还是能保证全部回滚的，下面的三种则不一定了，需要看情况使用。</p><p>5.<code>TransactionDefinition.PROPAGATION_SUPPORTS</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>6.<code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code><br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>7.<code>TransactionDefinition.PROPAGATION_NEVER</code><br>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和事务传播行为一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 读未提交</span></span><br><span class="line">  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line">  <span class="comment">// 读已提交</span></span><br><span class="line">  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line">  <span class="comment">// 可重复读</span></span><br><span class="line">  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line">  <span class="comment">// 可串行</span></span><br><span class="line">  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次对每一种事务隔离级别进行介绍：</p><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务串行执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以整型的值来表示超时时间，其单位是秒，默认值为<code>-1</code>，这表示事务的超时时间取决于底层事务系统或者没有超时时间。</p><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只有读取数据查询的事务，可以指定事务类型为 <code>readonly</code>，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p><p>为什么数据查询操作还要启用事务支持呢？拿Innodb举例子，根据<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">官网</a>描述：</p><blockquote><p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p></blockquote><p>但是，如果你给方法加上了<code>@Transactional</code>注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p><p>如果不加<code>@Transactional</code>，每条sql会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p><p>分享一下关于事务只读属性，其他人的解答：</p><ul><li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li><li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</li></ul><h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code>也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p><p>可以通过下面的方式回滚特定的异常类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure><h2 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a><code>@Transactional</code> 注解使用详解</h2><h3 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a><code>@Transactional</code> 的作用范围</h3><ol><li>方法：推荐将注解使用于方法上，不过需要注意的是，该注解只能应用到 <code>public</code> 方法上，否则不生效。</li><li>类：如果这个注解使用在类上的话，表明该注解对该类中所有的 <code>public</code> 方法都生效。</li><li>接口：不推荐在接口上使用。</li></ol><h3 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a><code>@Transactional</code> 的常用配置参数</h3><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用配置参数即：propagation、isolation、timeout、readOnly、rollbackFor，具体内容上节已列出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a><br>[2] <a href="https://blog.csdn.net/ITcreater000/article/details/115338657">https://blog.csdn.net/ITcreater000/article/details/115338657</a><br>[3] <a href="https://www.cnblogs.com/rickiyang/p/13652664.html">https://www.cnblogs.com/rickiyang/p/13652664.html</a><br>[4] <a href="https://dl.acm.org/doi/10.1145/289.291">https://dl.acm.org/doi/10.1145/289.291</a><br>[5] <a href="https://juejin.cn/post/6860252224930070536">https://juejin.cn/post/6860252224930070536</a><br>[6] <a href="https://spongecaptain.cool/post/database/logicalandphicallog/">https://spongecaptain.cool/post/database/logicalandphicallog/</a><br>[7] <a href="https://www.jianshu.com/p/646961b93c7e">https://www.jianshu.com/p/646961b93c7e</a><br>[8] <a href="https://zhuanlan.zhihu.com/p/394388285">https://zhuanlan.zhihu.com/p/394388285</a><br>[9] <a href="https://blog.csdn.net/qq_24854607/article/details/114639318">https://blog.csdn.net/qq_24854607/article/details/114639318</a><br>[10] <a href="https://blog.csdn.net/m0_71777195/article/details/130842268">https://blog.csdn.net/m0_71777195/article/details/130842268</a><br>[11] <a href="https://www.cnblogs.com/f66666/articles/10993873.html">https://www.cnblogs.com/f66666/articles/10993873.html</a><br>[12] <a href="http://catkang.github.io/2021/10/30/mysql-undo.html">http://catkang.github.io/2021/10/30/mysql-undo.html</a><br>[13] <a href="http://catkang.github.io/2020/02/27/mysql-redo.html">http://catkang.github.io/2020/02/27/mysql-redo.html</a><br>[14] <a href="http://catkang.github.io/2018/09/19/concurrency-control.html">http://catkang.github.io/2018/09/19/concurrency-control.html</a><br>[15] <a href="https://catkang.github.io/2023/08/08/mysql-buffer-pool.html">https://catkang.github.io/2023/08/08/mysql-buffer-pool.html</a><br>[16] <a href="https://mariadb.com/kb/en/innodb-undo-log">https://mariadb.com/kb/en/innodb-undo-log</a><br>[17] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。&lt;/p&gt;
&lt;p&gt;相关内容：InnoDB事务实现、Spring事务传播机制等。&lt;br&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
    <category term="MySQL" scheme="http://silencezheng.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Optional使用入门</title>
    <link href="http://silencezheng.top/2023/09/14/article122/"/>
    <id>http://silencezheng.top/2023/09/14/article122/</id>
    <published>2023-09-14T15:08:57.000Z</published>
    <updated>2023-09-14T15:11:44.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。</p><span id="more"></span><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional的机制类似于受检异常，强迫API调用者面对没有返回值的现实，因为程序直接返回 null 很可能导致调用端产生错误（空指针异常！）。</p><p>Optional 是用来作为方法返回值的，目的是清晰地表达返回值中没有结果的可能性。</p><h2 id="常用方法及调用方式"><a href="#常用方法及调用方式" class="headerlink" title="常用方法及调用方式"></a>常用方法及调用方式</h2><ul><li><p><code>of(value)</code>：创建一个包含指定非空值的 <code>Optional</code> 对象。</p></li><li><p><code>ofNullable(value)</code>：创建一个可能为空的 <code>Optional</code> 对象。如果传入的值为 <code>null</code>，则返回一个空的 <code>Optional</code>。</p></li><li><p><code>empty()</code>：创建一个空的 <code>Optional</code> 对象。</p></li><li><p><code>isPresent()</code>：检查 <code>Optional</code> 对象是否包含值。</p></li><li><p><code>get()</code>：获取 <code>Optional</code> 对象中的值。在调用之前应先使用 <code>isPresent()</code> 进行判断。</p></li></ul><p><code>Optional</code> 支持方法链式调用，使得我们可以在一系列操作中进行空值检查和转换。</p><p>下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalValue.isPresent()) &#123;</span><br><span class="line">    String value = optionalValue.get();</span><br><span class="line">    System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; nullableValue = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">String result = nullableValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure><p>除了常用方法，还有一些方法可以对<code>Optional</code>对象进行快捷操作，如上面出现的<code>orElse</code>，下面介绍其中一些。</p><ul><li><p><code>orElse(T other)</code>：如果包含的值存在，则返回该值；如果不存在，则返回默认值 <code>other</code>。无论值是否存在，都会进行计算，并返回结果。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String defaultValue = emptyOptional.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(defaultValue); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果包含的值存在，则返回该值；如果不存在，则使用提供的 <code>Supplier</code> 函数来计算并返回值。与 <code>orElse()</code> 类似，但在值不存在时，<code>Supplier</code> 函数才会被调用。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(computedValue); <span class="comment">// 调用 expensiveOperation() 方法，并输出其返回值</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果包含的值存在，则返回该值；如果不存在，则抛出指定的异常。通过提供一个exceptionSupplier来生成异常对象。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>));</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>)); <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure></li><li><p><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>：接受一个 Consumer 函数作为参数，并在包含的值存在时执行该函数。该方法无返回值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">optionalValue.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 输出：Value is present: Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">emptyOptional.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 由于值不存在，所以不执行任何操作</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1、不要使用<code>Optional</code>作为Java Bean实例域的类型<br>即避免以下这种代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; zip;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; telephone = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为 <code>Optional</code> 没有实现Serializable接口（不可序列化）</p><p>2、不要把容器类型包装在<code>Optional</code>中<br>即避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;List&lt;String&gt;&gt; fetchCartItems(<span class="keyword">long</span> id) &#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为容器类都有自己空值设计，如 <code>Collections.emptyList() Collections.emptySet() Collections.emptyMap() Stream.empty()</code> 等：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fetchCartItems</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> items == <span class="keyword">null</span> ? Collections.emptyList() : items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、不要给<code>Optional</code>对象赋值 null<br>避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而应该用 <code>Optional.empty()</code> 表达空值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、尽量使用<code>Optional</code>提供的快捷API避免手写条件语句<br>代码更简洁。</p><p>5、使用 <code>equals</code> 而不是 <code>==</code> 来比较 <code>Optional</code> 的值<br><code>Optional</code> 的 <code>equals</code> 方法已经实现了内部值比较。</p><p>6、对于可能是空值的函数返回使用<code>Optional</code><br>对于读取值类型的函数使用是很好的实践。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/128481434">https://zhuanlan.zhihu.com/p/128481434</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok原理简析</title>
    <link href="http://silencezheng.top/2023/09/11/article121/"/>
    <id>http://silencezheng.top/2023/09/11/article121/</id>
    <published>2023-09-11T13:32:25.000Z</published>
    <updated>2023-09-11T13:36:03.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok实现原理简析。<br><span id="more"></span></p><h2 id="JCP与JSR"><a href="#JCP与JSR" class="headerlink" title="JCP与JSR"></a>JCP与JSR</h2><p>JCP（Java Community Process）是管理 Java 生态（包括 J2SE、J2EE 等等）发展及指导和推动Java平台发展的合作组织，而JSR（Java Specification Request）则是由JCP提出的一种规范请求。</p><blockquote><p>JCP是由Sun Microsystems（现在是Oracle Corporation）创建的一个组织，负责制定和管理Java技术的发展。它包括了一系列专家组和工作组，这些组织和个人共同合作制定和更新Java规范。</p><p>JSR 是 Java 规范请求。这是由一个或多个成员提交给 PMO 的文件，以提议开发新规范或对现有规范进行重大修订。 JCP 计划目前正在开发许多 Java 技术规范，包括 Java™ Micro Edition (Java ME™)、Java™ Platform Enterprise Edition (Java EE™) 和 Java™ Standard Edition (Java SE™) 的下一版本。 JSR 还指由这些提案产生的规范开发工作。</p><p>JSR经历多个阶段，包括草案、提案、公开评论、维护和最终发布等。</p><p>PMO 即 Program Management Office，项目管理办公室是 Oracle 内部负责监督 Java 社区流程并管理项目日常运行的小组。该规范的实际开发是在专家组内进行的。</p></blockquote><p>JCP：<a href="https://jcp.org/en/home/index">https://jcp.org/en/home/index</a></p><h2 id="JSR-000269"><a href="#JSR-000269" class="headerlink" title="JSR-000269"></a>JSR-000269</h2><p>JSR-000269（JSR-269）的目标是定义并实现Java编译时注解处理器的标准API，或称为可插拔注解处理（Pluggable Annotation Processing），该JSR提供了一种机制，使开发人员能够在Java源代码编译过程中访问和处理注解，从而实现更高级的语义效果和自动化任务。</p><p>要完全的了解JSR-269的前因后果及技术细节，不应该在本文中寻找答案，本文仅铺垫一些形象化描述Lombok实现原理所必需的前置知识。总之，通过JSR-269的实现，开发人员可以利用编译时注解处理器的能力，以一种标准化和可扩展的方式对源代码进行自动化处理。这种处理包括生成额外的代码、进行静态分析、验证约束条件等。</p><p>JSR-000269的原始提出第一节如下：</p><blockquote><p>J2SE 1.5引入了一种新的Java语言机制“注解”，允许使用注解类型对类、字段和方法进行注解。这些注解通常由编译时工具或运行时库来处理，以实现新的语义效果。为了支持编译时的注解处理，这个JSR将定义API，允许使用标准可插拔的API创建注解处理器。这将简化创建注解处理器的任务，并且还可以自动发现适用于给定源文件的合适的注解处理器。</p><p>该规范将包括至少两个部分：一个部分是对Java编程语言进行建模的API部分，另一个部分用于声明注解处理器并控制它们的运行方式。由于注解是放置在程序元素上的，注解处理框架需要反映程序结构。注解处理器将能够指定它们处理的注解，并且多个处理器将能够合作运行。</p><p>处理器和程序结构API可以在编译时访问；即此功能补充了核心反射支持读取注解的能力。</p></blockquote><h2 id="Lombok代码注入原理"><a href="#Lombok代码注入原理" class="headerlink" title="Lombok代码注入原理"></a>Lombok代码注入原理</h2><p>Lombok使用了JSR-269的API，即<code>javax.annotation.processing</code>下的一组接口，在编译期时把 Lombok 的注解代码，转换为常规的 Java ⽅法⽽实现注⼊。</p><p>使用 <code>javac</code> 进行编译时，Lombok生成目标方法的流程如下：</p><ol><li>首先 <code>javac</code> 对源代码进行分析生成一棵抽象语法树(AST)</li><li>接着在运行过程中调用实现了 JSR-269 API 的 lombok 程序</li><li>接着编译器会调用 lombok 程序对上面得到的抽象语法树 AST 进行处理，找到其注解所在类对应的语法树(AST)，然后修改该语法树，增加注解对应的方法或代码片段到定义的相应树节点</li><li><code>javac</code> 使用修改后的抽象语法树生成最终的 class 文件</li></ol><h2 id="利用269API实现Setter注解"><a href="#利用269API实现Setter注解" class="headerlink" title="利用269API实现Setter注解"></a>利用269API实现Setter注解</h2><p>1、⾃定义注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MySetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、自定义注解处理器<br>注解处理器是代码生成的核心，对语法树的操作需要使用自己JDK的<code>tools.jar</code>，涉及到的核心库主要为<code>com.sun.tools.javac</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree.Kind;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.api.JavacTrees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Flags;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Type;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.ListBuffer;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Name;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;lombok.setter.MySetter&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetterProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JavacTrees javacTrees; <span class="comment">// 提供了待处理的抽象语法树</span></span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker; <span class="comment">// 封装了创建AST节点的一些方法</span></span><br><span class="line">    <span class="keyword">private</span> Names names; <span class="comment">// 提供了创建标识符的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        <span class="keyword">this</span>.javacTrees = JavacTrees.instance(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">        <span class="keyword">this</span>.names = Names.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MySetter注解的元素</span></span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(MySetter.class);</span><br><span class="line">        elementsAnnotatedWith.forEach(element -&gt; &#123;</span><br><span class="line">            JCTree tree = javacTrees.getTree(element);</span><br><span class="line">            <span class="comment">// 使用 TreeTranslator 遍历抽象语法树</span></span><br><span class="line">            tree.accept(<span class="keyword">new</span> TreeTranslator() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassDef</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span> </span>&#123;</span><br><span class="line">                    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">                    <span class="comment">// 在抽象树中找出所有变量</span></span><br><span class="line">                    <span class="keyword">for</span>(JCTree jcTree:jcClassDecl.defs) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(jcTree.getKind().equals(Kind.VARIABLE)) &#123;</span><br><span class="line">                            JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 对变量生成方法</span></span><br><span class="line">                    jcVariableDeclList.forEach(jcVariableDecl -&gt; &#123;</span><br><span class="line">                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">super</span>.visitClassDef(jcClassDecl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCMethodDecl <span class="title">makeGetterMethodDecl</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span> </span>&#123;</span><br><span class="line">        ListBuffer&lt;JCTree.JCStatement&gt; statements = <span class="keyword">new</span> ListBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生成表达式，例如 this.a = a;</span></span><br><span class="line">        JCTree.JCExpressionStatement aThis = makeAssignment(</span><br><span class="line">            treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)), jcVariableDecl.getName()),</span><br><span class="line">            treeMaker.Ident(jcVariableDecl.getName())</span><br><span class="line">        );</span><br><span class="line">        statements.append(aThis);</span><br><span class="line">        JCTree.JCBlock block = treeMaker.Block(<span class="number">0</span>, statements.toList()); <span class="comment">// 创建代码块抽象语法树节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成入参</span></span><br><span class="line">        JCTree.JCVariableDecl param = treeMaker.VarDef( <span class="comment">// 创建一个变量定义节点</span></span><br><span class="line">            treeMaker.Modifiers(Flags.PARAMETER), <span class="comment">// 指定修饰符为入参</span></span><br><span class="line">            jcVariableDecl.getName(), <span class="comment">// 使用原始变量定义节点的名称作为入参的名称</span></span><br><span class="line">            jcVariableDecl.vartype, <span class="comment">// 使用原始变量定义节点的变量类型作为入参的类型</span></span><br><span class="line">            <span class="keyword">null</span> <span class="comment">// 表示入参没有初始值</span></span><br><span class="line">        );</span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; parameters = List.of(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成返回对象</span></span><br><span class="line">        JCTree.JCExpression methodType = treeMaker.Type(</span><br><span class="line">            <span class="keyword">new</span> Type.JCVoidType()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结合内容生成方法</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">            treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">            getNewMethodName(jcVariableDecl.getName()),</span><br><span class="line">            methodType, List.nil(), parameters, List.nil(), block, <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Name <span class="title">getNewMethodName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        String s = name.toString();</span><br><span class="line">        <span class="comment">// 驼峰命名方法</span></span><br><span class="line">        <span class="keyword">return</span> names.fromString(</span><br><span class="line">            <span class="string">&quot;set&quot;</span> + s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>, name.length())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCExpressionStatement <span class="title">makeAssignment</span><span class="params">(JCTree.JCExpression lhs, JCTree.JCExpression rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成赋值语句的抽象语法树节点</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.Exec(</span><br><span class="line">            treeMaker.Assign(</span><br><span class="line">                lhs, <span class="comment">// left-hand side</span></span><br><span class="line">                rhs  <span class="comment">// right-hand side</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编译注解处理器<br>之后所有操作都在MySetter的目录下进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp /path/to/tools.jar MySetter* -d .</span><br></pre></td></tr></table></figure><p>4、编写和编译目标类<br>目标类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MySetter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用自定义注解处理器编译目标类：<code>javac -processor  lombok.setter.MySetterProcessor TestMySetter.java</code></p><p>编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytee</span><span class="params">(Byte var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytee = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrr</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strr = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntt</span><span class="params">(Integer var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intt = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestMySetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h2><p>前面形象化的讲述了Lombok的代码生成原理，但这些都发生在编译期，代码编辑器如何获取到这些信息并提前应用到代码提示上呢？Lombok给主流集成开发环境编写了Lombok插件，在使用Lombok的过程中不需要编译即可实现代码提示和代码补全，相关源码都公开在GitHub上（见[9]），有兴趣的读者可以自行阅读研究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://developer.aliyun.com/article/1081626">https://developer.aliyun.com/article/1081626</a><br>[2] <a href="https://blog.csdn.net/shouchenchuan5253/article/details/111658356">https://blog.csdn.net/shouchenchuan5253/article/details/111658356</a><br>[3] <a href="https://blog.csdn.net/weixin_43983762/article/details/105867398">https://blog.csdn.net/weixin_43983762/article/details/105867398</a><br>[4] <a href="https://juejin.cn/post/7103011031672176677">https://juejin.cn/post/7103011031672176677</a><br>[5] <a href="https://jcp.org/en/jsr/detail?id=269">https://jcp.org/en/jsr/detail?id=269</a><br>[6] <a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html">https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html</a><br>[7] <a href="https://projectlombok.org/">https://projectlombok.org/</a><br>[8] <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html">https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html</a><br>[9] <a href="https://github.com/projectlombok/lombok">https://github.com/projectlombok/lombok</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok实现原理简析。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Lombok之@Builder碎碎念</title>
    <link href="http://silencezheng.top/2023/09/10/article120/"/>
    <id>http://silencezheng.top/2023/09/10/article120/</id>
    <published>2023-09-10T12:23:30.000Z</published>
    <updated>2023-09-10T12:24:14.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok@Builder实现链式构建的弊病及替代方案。<br><span id="more"></span></p><h2 id="Builder的弊病"><a href="#Builder的弊病" class="headerlink" title="@Builder的弊病"></a>@Builder的弊病</h2><h3 id="存在继承关系时十分复杂"><a href="#存在继承关系时十分复杂" class="headerlink" title="存在继承关系时十分复杂"></a>存在继承关系时十分复杂</h3><p>错误用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：Implicit super constructor Parent() is undefined. Must explicitly invoke another constructor</span></span><br></pre></td></tr></table></figure></p><p>正确用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Child child = Child.builder()</span><br><span class="line">  .parentName(<span class="string">&quot;Andrea&quot;</span>)</span><br><span class="line">  .parentAge(<span class="number">38</span>)</span><br><span class="line">  .childName(<span class="string">&quot;Emma&quot;</span>)</span><br><span class="line">  .childAge(<span class="number">6</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>但如果父类使用了@Builder注解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用原子类会报错：<code>Child中的builder()无法覆盖Parent中的builder()</code>。可以通过修改子类为如下形式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Builder(builderMethodName = &quot;childBuilder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在链式构建子类对象时，就需要调用<code>Child.childBuilder()</code>了。即便如此，在继承层级多时也十分繁琐。</p><p>在Lombok1.18中，提供了@SuperBuilder注解，可以解决上述问题。使用示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不可与-Data同时使用"><a href="#不可与-Data同时使用" class="headerlink" title="不可与@Data同时使用"></a>不可与@Data同时使用</h3><p>很多框架会使用类的无参构造函数创建对象，但是如果同时使⽤@Data和@Builder的话，会导致类的无参构造函数缺失。</p><p>并且，这种情况并不能通过手动添加无参构造函数或添加@NoArgsConstructor解决。</p><p>该问题只能通过引⼊注解@Tolerate来解决。</p><p>Lombok同时使⽤@Data和@Builder的时候，如果要⽣成⽆参构造，需要在代码⾥⾯⼿动引⼊注解@Tolerate，让Lombok在⽣成类的时候，对指定的构造函数不感知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer int1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-Accessors替代-Builder"><a href="#用-Accessors替代-Builder" class="headerlink" title="用@Accessors替代@Builder"></a>用@Accessors替代@Builder</h2><p>在为了链式编程而使用@Builder时，它并非最佳实践。@Builder会额外创建内部类，无法与@Data兼容，且处理继承关系十分复杂。</p><p>使用@Accessors(chain = true)实现链式编程是更好的选择，简单示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.payload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setPayload</span><span class="params">(T payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setStatus</span><span class="params">(Status status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// 假设Status也使用了@Accessors(chain = true)</span></span><br><span class="line">Status status = <span class="keyword">new</span> Status().setResponseCode(<span class="string">&quot;RESPONSE_CODE_IDENTIFIER&quot;</span>).setDescription(<span class="string">&quot;Bla Bla Bla&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> APIResponse().setStatus(status);</span><br></pre></td></tr></table></figure></p><p>实际运用时，如果属性较多，且分为必传属性和选填属性时，可以将必传参数定义在构造方法中，加上 @Accessors 注解，这样就可以实现必传参数的传入，又可以实现选填参数的链式调用。</p><p>假设 Student 类，它的 学生ID和年级和班级是必填的，姓名、性别、住址是选填的，那么示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义必传属性，使用 final 修饰，不提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> studentId; <span class="comment">// 学生ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> grade; <span class="comment">// 年级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> classNum; <span class="comment">// 班级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义选填属性，提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String gender; <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 住址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造方法，接收必传参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> studentId, <span class="keyword">int</span> grade, <span class="keyword">int</span> classNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.classNum = classNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">1001</span>, <span class="number">3</span>, <span class="number">8</span>) <span class="comment">// 创建一个学生对象，传入必传参数</span></span><br><span class="line">        .setName(<span class="string">&quot;张三&quot;</span>) <span class="comment">// 设置姓名</span></span><br><span class="line">        .setGender(<span class="string">&quot;男&quot;</span>) <span class="comment">// 设置性别</span></span><br><span class="line">        .setAddress(<span class="string">&quot;北京市朝阳区&quot;</span>); <span class="comment">// 设置住址</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.baeldung.com/lombok-builder-inheritance">https://www.baeldung.com/lombok-builder-inheritance</a><br>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews">https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok@Builder实现链式构建的弊病及替代方案。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>匿名内部类</title>
    <link href="http://silencezheng.top/2023/09/02/article119/"/>
    <id>http://silencezheng.top/2023/09/02/article119/</id>
    <published>2023-09-02T10:10:40.000Z</published>
    <updated>2023-09-02T10:11:20.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中的匿名类，Java8及以后。</p><p>涉及概念包括：<strong>等效<code>final</code></strong>，成员，变量，作用域。<br><span id="more"></span></p><h2 id="匿名内部类-Anonymous-Classes"><a href="#匿名内部类-Anonymous-Classes" class="headerlink" title="匿名内部类(Anonymous Classes)"></a>匿名内部类(Anonymous Classes)</h2><p>匿名内部类（匿名类）是一种在Java中用于创建临时性、一次性使用的类的特殊语法结构。它可以用来实现接口、继承类或创建临时对象等操作，通常在需要一个类的实例，但又不希望单独为之创建一个独立的类文件时使用。</p><p>匿名类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，就可以使用匿名类来表达。</p><p>匿名类通常用于以下场景：</p><ol><li><p><strong>实现接口：</strong> 通过匿名类实现一个接口，从而创建一个接口的实例。</p></li><li><p><strong>继承类：</strong> 通过匿名类继承一个类，从而创建一个子类的实例。</p></li><li><p><strong>创建临时对象：</strong> 在一些临时需要的情况下，可以使用匿名类来创建对象。</p></li></ol><h2 id="匿名类与局部类对比"><a href="#匿名类与局部类对比" class="headerlink" title="匿名类与局部类对比"></a>匿名类与局部类对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAnonymousClasses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含两个方法的HelloWorld接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、局部类EnglishGreeting实现了HelloWorld接口</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EnglishGreeting</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">            String name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HelloWorld englishGreeting = <span class="keyword">new</span> EnglishGreeting();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、匿名类实现HelloWorld接口</span></span><br><span class="line">        HelloWorld frenchGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">            String name = <span class="string">&quot;tout le monde&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;tout le monde&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Salut &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、匿名类实现HelloWorld接口</span></span><br><span class="line">        HelloWorld spanishGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">            String name = <span class="string">&quot;mundo&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;mundo&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hola, &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        englishGreeting.greet();</span><br><span class="line">        frenchGreeting.greetSomeone(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">        spanishGreeting.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        HelloWorldAnonymousClasses myApp = <span class="keyword">new</span> HelloWorldAnonymousClasses();</span><br><span class="line">        myApp.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Hello world</span></span><br><span class="line">        <span class="comment">// Salut Fred</span></span><br><span class="line">        <span class="comment">// Hola, mundo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例中用局部类来初始化变量<code>englishGreeting</code>，用匿类来初始化变量<code>frenchGreeting</code>和<code>spanishGreeting</code>，两种实现之间有明显的区别：</p><p>1）局部类<code>EnglishGreeting</code>继承<code>HelloWorld</code>接口，有自己的类名，定义完成之后需要再用new关键字实例化才可以使用；</p><p>2）<code>frenchGreeting、spanishGreeting</code>在定义的时候就实例化了，定义完了就可以直接使用；</p><p>3）<strong>匿名类是一个表达式</strong>，因此在定义的最后用分号”;”结束。</p><h2 id="匿名类的语法"><a href="#匿名类的语法" class="headerlink" title="匿名类的语法"></a>匿名类的语法</h2><p>匿名类表达式的通用语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建匿名类实例</span></span><br><span class="line">SuperClassOrInterface obj = <span class="keyword">new</span> SuperClassOrInterface() &#123;</span><br><span class="line">    <span class="comment">// 成员变量（如果需要）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化块（如果需要）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">returnType <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的关键点包括：</p><ul><li><p><code>SuperClassOrInterface</code>：匿名类可以继承一个类或实现一个接口，这个部分就是你要继承或实现的类或接口的类型。</p></li><li><p>成员变量：如果需要，在匿名类内部可以定义成员变量，可以在构造器、初始化块以及方法中使用。</p></li><li><p>初始化块：如果需要，在匿名类内部可以定义初始化块，用来初始化成员变量。</p></li><li><p>方法重写：匿名类可以重写父类或接口中的方法。</p></li><li><p><code>returnType</code>：重写方法的返回类型。</p></li><li><p><code>methodName()</code>：要重写的方法名。</p></li></ul><h2 id="匿名类对局部变量的访问规则，及对成员的声明及访问规则"><a href="#匿名类对局部变量的访问规则，及对成员的声明及访问规则" class="headerlink" title="匿名类对局部变量的访问规则，及对成员的声明及访问规则"></a>匿名类对局部变量的访问规则，及对成员的声明及访问规则</h2><p>与局部类一样，匿名类可以捕获变量，它们对外部域的局部变量具有相同的访问权限：</p><ol><li>匿名类可以访问其外部类的成员。</li><li>匿名类无法访问其外部域内未声明为<code>final</code>或实际上未声明为<code>final</code>的<strong>局部变量</strong>。</li><li>与嵌套类一样，匿名类中的类型（例如变量）声明会隐藏（<strong>shadow</strong>）外部域中具有相同名称的任何其他声明。</li></ol><p>匿名类对于其成员也有与局部类相同的限制：</p><ol><li>不能在匿名类中声明<strong>静态初始化块</strong>或<strong>成员接口</strong>。</li><li>匿名类可以具有静态成员，前提是它们是<strong>常量变量</strong>。</li></ol><p>匿名类中可以声明以下内容：</p><ul><li>字段</li><li>额外的方法（即使它们不实现父类的任何方法）</li><li>实例初始化块（Instance initializers）</li><li>局部类（Local classes）</li></ul><p>但是，<strong>在匿名类中不能声明构造函数</strong>（constructors）。</p><h2 id="匿名类访问外部类成员"><a href="#匿名类访问外部类成员" class="headerlink" title="匿名类访问外部类成员"></a>匿名类访问外部类成员</h2><p>一个有继承父类的匿名类示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String ANIMAL = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名类访问其外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnimalName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(bird.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鸟类，匿名子类，继承自Animal类，可以覆写父类方法</span></span><br><span class="line">    Animal bird = <span class="keyword">new</span> Animal(<span class="string">&quot;布谷鸟&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnimalName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            accessTest();   <span class="comment">// 访问外部类成员方法</span></span><br><span class="line">            System.out.println(ANIMAL);  <span class="comment">// 访问外部类成员变量</span></span><br><span class="line">            <span class="keyword">super</span>.printAnimalName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bird.printAnimalName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalTest animalTest = <span class="keyword">new</span> AnimalTest();</span><br><span class="line">        animalTest.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 匿名类访问其外部类方法</span></span><br><span class="line">        <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">// 布谷鸟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，匿名类可以访问外部类的所有成员。事实上，他们甚至可以修改这些成员。</p><h2 id="匿名类访问局部变量"><a href="#匿名类访问局部变量" class="headerlink" title="匿名类访问局部变量"></a>匿名类访问局部变量</h2><p>匿名类与局部类对外部域<strong>局部变量</strong>的访问权限是相同的，先看下面局部类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outerValue = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 尝试修改局部变量 localValue，会发生什么？</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localValue = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 输出Value</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类访问外部变量Int: &quot;</span> + outerValue);</span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类访问局部变量Int: &quot;</span> + localValue);</span><br><span class="line">                outerValue = <span class="number">20</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类修改外部变量Int: &quot;</span> + outerValue);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 尝试修改局部变量 localValue，会发生什么？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalInner localInner = <span class="keyword">new</span> LocalInner();</span><br><span class="line">        localInner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outer.outerMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 内部类方法访问外部类成员变量Int: 10</span></span><br><span class="line">        <span class="comment">// 内部类方法访问局部变量Int: 20</span></span><br><span class="line">        <span class="comment">// 内部类方法修改外部类成员变量Int: 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出说明局部类可以访问外部类成员，也可以访问局部变量。但修改局部变量会发生什么？我们添加<code>localValue = 10;</code>在对应注释下并执行，会报错：<code>java: 从内部类引用的本地变量必须是最终变量或实际上的最终变量</code>。</p><p>这是因为局部类访问局部变量的先决条件是局部变量满足<code>final</code>或<strong>等效<code>final</code></strong>。简单来说，该局部变量必须在初始化后不被修改，无论是否声明为<code>final</code>。</p><p>匿名类对于局部变量的访问规则与局部类相同，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EffectivelyFinalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// Effectively Final，虽然没有声明为final，但不会再次修改</span></span><br><span class="line">        <span class="comment">// x = 20; // 如果尝试修改x的值，编译器将产生错误</span></span><br><span class="line"></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Value of x: &quot;</span> + x); <span class="comment">// 在匿名内部类中访问Effectively Final变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类隐藏外部域声明"><a href="#匿名类隐藏外部域声明" class="headerlink" title="匿名类隐藏外部域声明"></a>匿名类隐藏外部域声明</h2><p>当在匿名类中声明具有与外部类相同名称的类型（例如变量）时，会发生隐藏（shadowing）现象。这意味着匿名类中的类型声明会覆盖外部类中具有相同名称的任何其他声明，从而隐藏外部类中的相应内容。</p><p>下面是一个示例，用于说明这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowingExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 外部类中的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">20</span>; <span class="comment">// 外部类中的局部变量</span></span><br><span class="line"></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> value = <span class="number">30</span>; <span class="comment">// 匿名类中的局部变量，会隐藏外部类的局部变量</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Value in anonymous class: &quot;</span> + value); <span class="comment">// 访问匿名类中的局部变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Value in outer class method: &quot;</span> + ShadowingExample.<span class="keyword">this</span>.value); <span class="comment">// 访问外部类成员变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShadowingExample example = <span class="keyword">new</span> ShadowingExample();</span><br><span class="line">        example.performAction();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Value in anonymous class: 30</span></span><br><span class="line">        <span class="comment">// Value in outer class method: 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名类中，我们可以通过 <code>ShadowingExample.this.value</code> 访问外部类的成员变量，因为匿名类中的局部变量 <code>value</code> 隐藏了外部类的局部变量 <code>value</code>，但没有隐藏外部类的成员变量 <code>value</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html</a><br>[2] <a href="https://www.cnblogs.com/wuhenzhidu/p/anonymous.html">https://www.cnblogs.com/wuhenzhidu/p/anonymous.html</a><br>[3] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing</a><br>[4] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java中的匿名类，Java8及以后。&lt;/p&gt;
&lt;p&gt;涉及概念包括：&lt;strong&gt;等效&lt;code&gt;final&lt;/code&gt;&lt;/strong&gt;，成员，变量，作用域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之配置自动填充</title>
    <link href="http://silencezheng.top/2023/08/26/article118/"/>
    <id>http://silencezheng.top/2023/08/26/article118/</id>
    <published>2023-08-26T05:12:19.000Z</published>
    <updated>2023-08-26T05:13:41.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过<code>MetaObjectHandler</code>接口，配置MyBatis-Plus的自动填充。</p><p>MyBatis-Plus版本：<code>3.4.3.4</code><br><span id="more"></span></p><h2 id="什么是自动填充"><a href="#什么是自动填充" class="headerlink" title="什么是自动填充"></a>什么是自动填充</h2><p>通常在建表时，会设置一些公共字段，例如创建人（creator）、更新人（uptater）、创建时间（create_time）、更新时间（update_time）等等。</p><p>每次将实体对象新增入库时，都要设置创建人和创建时间；每次更新实体对象时，都要设置更新人和更新时间；如果这些都放在业务代码中，很是繁琐，于是就需要配置自动填充来简化工作。</p><h2 id="MetaObjectHandler"><a href="#MetaObjectHandler" class="headerlink" title="MetaObjectHandler"></a>MetaObjectHandler</h2><p><code>MetaObjectHandler</code> 是 MyBatis-Plus 提供的一个接口类，通过实现该接口并重写其中的方法，可以在执行数据库操作（插入和更新）时自动填充某些字段的值。</p><p><code>MetaObjectHandler</code> 中有若干默认方法（已实现）和两个接口方法（需实现），接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MetaObject 是 MyBatis 的一个反射工具类，用于操作 Java 对象的属性。它提供了一系列方法来获取、设置、判断和操作 Java 对象的属性，使得在不直接调用 JavaBean 的 getter 和 setter 方法的情况下进行属性操作变得更加方便和灵活。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个基础的自动填充配置示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新增时填充</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now()); <span class="comment">// 起始版本 3.3.0(推荐使用)</span></span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, () -&gt; LocalDateTime.now(), LocalDateTime.class); <span class="comment">// 起始版本 3.3.3(推荐)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改时填充</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now()); <span class="comment">// 起始版本 3.3.0(推荐)</span></span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, () -&gt; LocalDateTime.now(), LocalDateTime.class); <span class="comment">// 起始版本 3.3.3(推荐)</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想使用 <code>MetaObjectHandler</code>，需要在其实现类上添加 <code>@Component</code> 注解，然后将其注册为 Spring 的一个 Bean，这样 MyBatis Plus 就会自动调用其中定义的方法来进行字段值的填充。</p><p>然后，在实体类上添加注解，告知Mybatis-Plus需要预留注入SQL字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(value = &quot;create_time&quot;,fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure><p>填充策略包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FieldFill</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认不处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DEFAULT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UPDATE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入和更新填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT_UPDATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果属性有值则不覆盖，如果sql中赋值了，自动填充又设置为其他值，则以sql中的值为准。</p><p>2、如果填充值为null则不填充，比如<code>this.setFieldValByName(“update_time”, null, metaObject);</code>实际是不会更新为null的。</p><p>3、填充处理器（如<code>MyMetaObjectHandler</code>）在 Spring Boot 中需要声明<code>@Component</code>或<code>@Bean</code>注入</p><p>4、最好不要在自定义mapper方法中使用填充，非要使用的话需要使用特定参数注解，如<code>@Param(&quot;et&quot;)</code>等。</p><p>5、<code>update(T t,Wrapper updateWrapper)</code>时<code>t</code>不能为空,否则自动填充失效，如<code>this.update(new User(), new UpdateWrapper&lt;User&gt;().set(&quot;name&quot;, &quot;张三&quot;)));</code>不能省略<code>new User()</code>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;MetaObjectHandler&lt;/code&gt;接口，配置MyBatis-Plus的自动填充。&lt;/p&gt;
&lt;p&gt;MyBatis-Plus版本：&lt;code&gt;3.4.3.4&lt;/code&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>图卷积(GCN)学习</title>
    <link href="http://silencezheng.top/2023/08/15/article117/"/>
    <id>http://silencezheng.top/2023/08/15/article117/</id>
    <published>2023-08-15T15:11:28.000Z</published>
    <updated>2023-08-15T15:16:44.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图卷积学习记录，同时也涉及离散拉普拉斯算子内容，可能对视觉方向有帮助。</p><p>相关内容：卷积、傅立叶变换、拉普拉斯算子、狄利克雷能量、图卷积<br><span id="more"></span></p><h2 id="传统卷积"><a href="#传统卷积" class="headerlink" title="传统卷积"></a>传统卷积</h2><p>传统的卷积主要应用于Euclidean Structure的数据上（排列很整齐、Grid形式的），如图像、语句等，主要是因为欧式结构数据能够保证卷积的性质，即平移不变性，而Non-Euclidean无法保证平移不变性，通俗理解就是在拓扑图中每个顶点的相邻顶点数目都可能不同，那么当然无法用一个同样尺寸的卷积核来进行卷积运算。</p><h2 id="推广卷积到图"><a href="#推广卷积到图" class="headerlink" title="推广卷积到图"></a>推广卷积到图</h2><p>卷积定理指出，<strong>函数卷积的傅里叶变换是函数傅里叶变换的乘积</strong>。即一个域中的卷积对应于另一个域中的乘积, 例如时域中的卷积对应于频域中的乘积。</p><script type="math/tex; mode=display">\mathcal{F}\{f * g\}=\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}</script><p>其中 $\mathcal{F}(f)$ 表示 $f$ 的傅里叶变换。下面这种形式也成立：</p><script type="math/tex; mode=display">\mathcal{F}\{f \cdot g\}=\mathcal{F}\{f\} * \mathcal{F}\{g\}</script><p>借由傅里叶逆变换 $\mathcal{F}^{-1}$, 也可以写成：</p><script type="math/tex; mode=display">f * g=\mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\}</script><p>注意以上的写法只对特定形式定义的变换正确，变换可能由其它方式正规化，使得上面的关系式中出现其它的常数因子。</p><p>这一定理对拉普拉斯变换、双边拉普拉斯变换、Z变换、梅林变换和Hartley变换等各种傅里叶变换的变体同样成立。</p><p>利用卷积定理可以简化卷积的运算量。对于长度为 $n$ 的序列，按照卷积的定义进行计算，需要做 $2 n-1$ 组对位乘法，其计算复杂度为 $\mathcal{O}\left(n^2\right)$；而利用傅里叶变换将序列变换到频域上后，只需要一组对位乘法，利用傅里叶变换的快速算法之后，总的计算复杂度为 $\mathcal{O}(n \log n)$ 。这一结果可以在快速乘法计算中得到应用。</p><p>傅里叶变换又可以通过<strong>谱图理论</strong>推广到图上进行变换。</p><blockquote><p>谱图理论是图论与线性代数相结合的产物，它通过分析图的某些矩阵的特征值与特征向量而研究图的性质。拉普拉斯矩阵是谱图理论中的核心与基本概念，在机器学习与深度学习中有重要的应用。包括但不仅限于：流形学习数据降维算法中的拉普拉斯特征映射、局部保持投影，无监督学习中的谱聚类算法，半监督学习中基于图的算法，以及目前炙手可热的图神经网络等。还有在图像处理、计算机图形学以及其他工程领域应用广泛的图切割问题。理解拉普拉斯矩阵的定义与性质是掌握这些算法的基础。</p></blockquote><p>所以，Convolution —— Fourier —— Spectral Graph，卷积通过傅里叶变换和图（频谱域）发生了联系。</p><p>从整个的研究进程来看，首先是研究GSP（Graph Signal Processing）的学者提出了Graph上的Fourier Transformation，进而定义了Graph的Convolution，最后与深度学习结合起来，发展出来GCN。</p><h2 id="图傅立叶变换的实施"><a href="#图傅立叶变换的实施" class="headerlink" title="图傅立叶变换的实施"></a>图傅立叶变换的实施</h2><p>关于时域和频域，我在<a href="https://silencezheng.top/2022/10/05/article67/">高斯滤波和双边滤波</a>一文中已有一些介绍。</p><p>此处需要强调的一点是<strong>傅里叶级数是向量</strong>，一般描述向量的时候，都有对应的基，即在某组基下的坐标表示构成了向量。默认是单位基时，则不显式提到。频域下，某个曲线是表示成了关于正弦函数正交基下的傅里叶级数向量。而在时域下，某个曲线是表示成了关于时间的周期函数。不管时域还是频域，其实反映的都是同一个曲线，只是一个是用函数的观点，一个是用向量的观点。</p><p>图上的傅里叶变换是通过下述联系实施的：</p><ol><li>图拉普拉斯算子， Laplacian Operator —- Graph Laplacian Matrix。</li><li>图拉普拉斯的谱分解，Graph Laplacian Matrix —- Spectral Decomposition。</li><li>图上狄利克雷能量最小的基， Dirichlet Energy —- Orthonormal Basis —- Spectral Decomposition —- Eigenvectors</li><li>傅里叶变换，Fourier —- Fourier Basis —- Laplacian eigenfunctions</li></ol><p>根据4，可以证明，Fourier basis = Laplacian eigenfunctions，即傅立叶级数的基(和频率一一对应)是拉普拉斯算子的特征函数 (满足特征方程)。根据1，在图上，拉普拉斯算子为拉普拉斯矩阵。根据2，拉普拉斯矩阵的谱分解得到的特征向量(和特征值一一对应)类比特征函数。因此，<strong>传统傅里叶变换在图的拓展就是将正弦函数基替换换成图拉普拉斯矩阵的特征向量</strong>，正弦函数与频率一一对应，特征向量与特征值一一对应。而根据3，这一替换的根源意义在于，图拉普拉斯矩阵的特征向量作为一组基的话，这组基是图上狄利克雷能量最小的基。</p><blockquote><p>Laplacian Operator（拉普拉斯算子）和Laplacian eigenfunctions（拉普拉斯特征函数）是在图论和图信号处理中密切相关的概念。</p><ol><li><p>Laplacian Operator:<br>在图论中，Laplacian Operator是用来描述图的拓扑结构和节点之间连接关系的算子。对于一个无向图G，Laplacian Operator通常定义为度矩阵（Degree Matrix）D和邻接矩阵（Adjacency Matrix）A之间的差，即L = D - A。其中，度矩阵D是一个对角矩阵，其对角线元素是每个节点的度数（与该节点相连接的边的数量），邻接矩阵A描述了节点之间的连接关系。<br>Laplacian Operator有多种形式，常见的有度标准化Laplacian、随机游走标准化Laplacian等，不同的形式在不同的图信号处理任务中有不同的应用。</p></li><li><p>Laplacian eigenfunctions:<br>Laplacian eigenfunctions是指Laplacian Operator对应的特征函数，也称为拉普拉斯特征向量。Laplacian Operator的特征函数是在图上定义的一组正交函数，它们描述了图的振动模式和频率。</p></li></ol><p>对于图的Laplacian Operator L，它可以进行谱分解，得到一组特征向量（Laplacian eigenfunctions）和对应的特征值（Laplacian eigenvalues）。这些特征向量在图信号处理中具有重要的意义，它们构成了一个基，可以用于将图信号从原始的节点空间转换到频域空间，类似于傅里叶变换中的基函数。</p><p>Laplacian eigenfunctions对应的特征值可以用来表示图的结构和节点之间的连接关系，不同的特征值对应不同的频率，反映了图的振动特性。在图信号处理任务中，Laplacian eigenfunctions常常被用作图嵌入、图卷积神经网络（GCN）等方法的基础，以便有效地学习图的特征和结构。</p></blockquote><h2 id="图拉普拉斯算子"><a href="#图拉普拉斯算子" class="headerlink" title="图拉普拉斯算子"></a>图拉普拉斯算子</h2><p>先讨论常规连续拉普拉斯算子，然后通过<strong>有限差分法</strong>在离散网格上近似计算拉普拉斯算子，对其进行离散化。</p><blockquote><p>有限差分法是将导数或微分算子替换为差分的形式，从而将微分方程转化为差分方程。</p><p>差分方程是一种数学方程，用于描述离散点之间的关系，通常在数值计算和离散模型中使用。与微分方程类似，差分方程是在离散时间或空间上建立函数之间的关系，而不是连续变量的关系。</p></blockquote><p>最后，我们推广到图结构上。</p><h3 id="拉普拉斯算子（Laplacian-Operator）"><a href="#拉普拉斯算子（Laplacian-Operator）" class="headerlink" title="拉普拉斯算子（Laplacian Operator）"></a>拉普拉斯算子（Laplacian Operator）</h3><p>拉普拉斯算子的严格数学定义：多元函数$f(x_1,…,x_n)$的拉普拉斯算子是<strong>所有自变量的非混合二阶偏导数之和</strong>。</p><script type="math/tex; mode=display">\Delta f=\sum_{i=1}^n \frac{\partial^2 f}{\partial x_i^2}</script><p>基于定义，所有的__拉普拉斯算子都是其一个特例，或是某种情况下(比如离散情况下)的一种近似。很多时候我们之只能近似计算导数值，称为<strong>数值微分</strong>。</p><blockquote><p>数值微分是一种通过数值计算来近似计算函数的导数的方法。它在数值分析和科学计算中经常用于解决无法通过解析方法求得导数的问题，或者用于验证解析导数的结果。</p><p>数值微分的基本思想是利用函数在某一点附近的函数值来近似计算该点的导数。常见的数值微分方法包括：</p><ol><li><p><strong>中心差分法：</strong> 中心差分法使用函数在当前点的前后两个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}</script><p>这里，$h$ 是一个小的正数，代表点的间隔。</p></li><li><p><strong>前向差分法：</strong> 前向差分法使用函数在当前点和该点之后的一个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x+h) - f(x)}{h}</script></li><li><p><strong>后向差分法：</strong> 后向差分法使用函数在当前点和该点之前的一个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x) - f(x-h)}{h}</script></li></ol><p>数值微分方法的精度取决于间隔$h$的大小，过大的$h$可能引入较大的近似误差，而过小的$h$可能引入舍入误差。选择合适的$h$值是确保数值微分结果精度的关键。</p></blockquote><p>对于二阶导数，则有：</p><script type="math/tex; mode=display">\begin{aligned}f^{\prime \prime}(x) & \approx \frac{f^{\prime}(x)-f^{\prime}(x-\Delta x)}{\Delta x} \approx \frac{\frac{f(x+\Delta x)-f(x)}{\Delta x}-\frac{f(x)-f(x-\Delta x)}{\Delta x}}{\Delta x} \\& =\frac{f(x+\Delta x)+f(x-\Delta x)-2 f(x)}{(\Delta x)^2}\end{aligned}</script><p>下面考虑多元函数的偏导数。对于二元函数$f(x,y)$，其拉普拉斯算子可以用下面的公式近似计算：</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2} \\& \approx \frac{f(x+\Delta x, y)+f(x-\Delta x, y)-2 f(x, y)}{(\Delta x)^2}+\frac{f(x, y+\Delta y)+f(x, y-\Delta y)-2 f(x, y)}{(\Delta y)^2}\end{aligned}</script><h3 id="离散拉普拉斯算子"><a href="#离散拉普拉斯算子" class="headerlink" title="离散拉普拉斯算子"></a>离散拉普拉斯算子</h3><p>图像和图结构都是离散数据，其拉普拉斯算子必然要进行离散化。如果上面的二元函数进行离散化，对自变量的一系列点处的函数值进行采样，得到下面一系列点处的函数值，构成一个矩阵。</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}f\left(x_1, y_1\right) & f\left(x_2, y_1\right) & \ldots & f\left(x_n, y_1\right) \\f\left(x_1, y_2\right) & f\left(x_2, y_2\right) & \ldots & f\left(x_n, y_2\right) \\\ldots & \ldots & \ldots & \ldots \\f\left(x_1, y_n\right) & f\left(x_2, y_n\right) & \ldots & f\left(x_n, y_n\right)\end{array}\right]</script><p>在这里 $x$ 为水平方向， $y$ 为垂直方向。为了简化， 假设 $x$ 和 $y$ 的增量（步长）全为 $1$ ， 即：</p><script type="math/tex; mode=display">\Delta x=x_{i+1}-x_i=1, \Delta y=y_{i+1}-y_i=1</script><p>则点 $\left(x_i, y_j\right)$ 处的拉普拉斯算子可以用下面的公式近似计算：</p><script type="math/tex; mode=display">\begin{aligned}& \frac{f\left(x_i+\Delta x, y_j\right)+f\left(x_i-\Delta x, y_j\right)-2 f\left(x_i, y_j\right)}{(\Delta x)^2}+\frac{f\left(x_i, y_j+\Delta y\right)+f\left(x_i, y_j-\Delta y\right)-2 f\left(x_i, y_j\right)}{(\Delta y)^2} \\& \quad=\frac{f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)-2 f\left(x_i, y_j\right)}{1^2}+\frac{f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-2 f\left(x_i, y_j\right)}{1^2} \\& \quad=f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)+f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-4 f\left(x_i, y_j\right)\end{aligned}</script><p>这是一个非常优美的结果， 它就是 $\left(x_i, y_j\right)$ 的 4 个相邻点处的函数值之和与 $\left(x_i, y_j\right)$ 点处的函数值乘以 4 后的差值。如下图所示：</p><p><img src="/assets/post_img/article117/lisan-lapo.png" alt="lisan"></p><p>基于这种离散表示，拉普拉斯算子的计算公式可以写成如下形式：</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)+f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-4 f\left(x_i, y_j\right) \\& =f\left(x_{i+1}, y_j\right)-f\left(x_i, y_j\right)+f\left(x_{i-1}, y_j\right)-f\left(x_i, y_j\right) \\& +f\left(x_i, y_{j+1}\right)-f\left(x_i, y_j\right)+f\left(x_i, y_{j-1}\right)-f\left(x_i, y_j\right) \\& =\sum_{(k, l) \in N(i, j)}\left(f\left(x_k, y_l\right)-f\left(x_i, y_j\right)\right)\end{aligned}</script><p>其中 $N(i, j)$ 是 $\left(x_i, y_j\right)$ 邻居节点的集合。</p><p>这也给我们一种形象的结论：二维网格（离散二元函数）上计算某点的拉普拉斯算子就是计算上下左右四个自由度上的“变化和”。</p><p>PS：变化和是笔者的个人理解，也有人说是“微小变化后获得的增益”。另外，对于二维网格，也可以拓展出八个自由度的拉普拉斯算子。</p><h3 id="图上的拉普拉斯算子"><a href="#图上的拉普拉斯算子" class="headerlink" title="图上的拉普拉斯算子"></a>图上的拉普拉斯算子</h3><p>在图中，顶点的连接关系是任意的，这意味着顶点的邻居节点数量不固定。将拉普拉斯算子推广到图上，如果将图的顶点处的值看作是函数值，则在顶点$i$处的拉普拉斯算子为：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in N_i}\left(f_i-f_j\right)</script><p>其中 $N_i$ 是顶点 $i$ 的所有邻居顶点的集合。这里我们调换了 $f_i$ 和 $f_j$ 的位置， 和之前的拉普拉斯算子相比， 相当于多了一个负号。由于图的边可以带有权重， 我们可以在上面的计算公式中加上权重：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in N_i} w_{i j}\left(f_i-f_j\right)</script><p>如果 $j$ 不是 $i$ 的邻居, 则 $w_{i j}=0$ 。因此上面的式子也可以写成如下形式：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in V} w_{i j}\left(f_i-f_j\right)=\sum_{j \in V} w_{i j} f_i-\sum_{j \in V} w_{i j} f_j=d_i f_i-\mathbf{w}_i \mathbf{f}</script><p>这里的 $d_i$ 是顶点 $i$ 的加权度，$w_i$ 是邻接矩阵的第 $i$ 行, $f$ 是所有顶点的值构成的列向量, $w_i f$ 是二者的内积。对于图的所有顶点, 有</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =\left[\begin{array}{c}\Delta f_1 \\\ldots \\\Delta f_n\end{array}\right]=\left[\begin{array}{c}d_1 f_1-\mathbf{w}_1 \mathbf{f} \\\ldots \\d_n f_n-\mathbf{w}_n \mathbf{f}\end{array}\right]=\left[\begin{array}{ccc}d_1 & \ldots & \ldots \\\ldots & \ldots & \ldots \\\ldots & \ldots & d_n\end{array}\right]\left[\begin{array}{c}f_1 \\\ldots \\f_n\end{array}\right]-\left[\begin{array}{c}\mathbf{w}_1 \\\ldots \\\mathbf{w}_n\end{array}\right]\left[\begin{array}{c}f_1 \\\ldots \\f_n\end{array}\right] \\& =(\mathbf{D}-\mathbf{A}) \mathbf{f}\end{aligned}</script><p>上式的全称是：图拉普拉斯算子作用在由图节点信息构成的向量$f$上得到的结果等于<strong>图拉普拉斯矩阵</strong>和向量$f$的点积。</p><p>这也说明，<strong>在图上，拉普拉斯算子等于拉普拉斯矩阵</strong>。</p><h3 id="图拉普拉斯矩阵（Laplacian-Matrix）"><a href="#图拉普拉斯矩阵（Laplacian-Matrix）" class="headerlink" title="图拉普拉斯矩阵（Laplacian Matrix）"></a>图拉普拉斯矩阵（Laplacian Matrix）</h3><p>由此，我们推出了无向图上定义拉普拉斯矩阵的一种方式：</p><script type="math/tex; mode=display">L = D - A</script><p>其中，$L$是图拉普拉斯矩阵，$D$是加权度矩阵（Weighted Degree Matrix），$A$是邻接矩阵（Adjacency Matrix）。</p><p>由于$D$ 和 $A$都是对称矩阵，则无向图的拉普拉斯矩阵也是对称矩阵，它实际上代表了图的二阶导数。</p><p>显然无向图拉普拉斯矩阵每一行元素之和都为 0 。下面介绍拉普拉斯矩阵的若干重要性质（省略证明）：</p><p>1、对任意向量 $\mathbf{f} \in \mathbb{R}^n$ 有：</p><script type="math/tex; mode=display">\mathbf{f}^{\mathrm{T}} \mathbf{L} \mathbf{f}=\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n w_{i j}\left(f_i-f_j\right)^2</script><p>2、拉普拉斯矩阵是对称半正定矩阵;</p><p>3、拉普拉斯矩阵的最小特征值为 0 ，其对应的特征向量为常向量 1 ，即所有分量为 1 ;</p><p>4、拉普拉斯矩阵有 $n$ 个非负实数特征值，并且满足：</p><script type="math/tex; mode=display">0=\lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n</script><p>5（结论）、假设 $G$ 是一个有非负权重的无向图，其拉普拉斯矩阵 $L$ 的特征值0的重数 $k$ 等于图的联通分量的个数$A_1， \ldots, A_k$。特征值0的特征空间由这些联通分量所对应的特征向量$\mathbf{1}_{A_1}， \ldots, \mathbf{1}_{A_k}$所张成。</p><p>对于结论5，举一个例子进行说明：</p><p><img src="/assets/post_img/article117/jl5.png" alt="jl5"></p><p>上图有两个联通子图，其邻接矩阵为：</p><script type="math/tex; mode=display">\mathbf{A}=\left[\begin{array}{ccccc}0 & 0.37 & 0.37 & 0 & 0 \\0.37 & 0 & 0.14 & 0 & 0 \\0.37 & 0.14 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0.37 \\0 & 0 & 0 & 0.37 & 0\end{array}\right]</script><p>其加权度矩阵为：</p><script type="math/tex; mode=display">\mathbf{D}=\left[\begin{array}{ccccc}0.74 & 0 & 0 & 0 & 0 \\0 & 0.51 & 0 & 0 & 0 \\0 & 0 & 0.51 & 0 & 0 \\0 & 0 & 0 & 0.37 & 0 \\0 & 0 & 0 & 0 & 0.37\end{array}\right]</script><p>拉普拉斯矩阵为：</p><script type="math/tex; mode=display">\mathbf{L}=\mathbf{D}-\mathbf{A}=\left[\begin{array}{ccccc}0.74 & -0.37 & -0.37 & 0 & 0 \\-0.37 & 0.51 & -0.14 & 0 & 0 \\-0.37 & -0.14 & 0.51 & 0 & 0 \\0 & 0 & 0 & 0.37 & -0.37 \\0 & 0 & 0 & -0.37 & 0.37\end{array}\right]</script><p>它由如下两个子矩阵构成：</p><script type="math/tex; mode=display">\begin{aligned}& \mathbf{L}_1=\left[\begin{array}{ccc}0.74 & -0.37 & -0.37 \\-0.37 & 0.51 & -0.14 \\-0.37 & -0.14 & 0.51\end{array}\right] \\& \mathbf{L}_2=\left[\begin{array}{cc}0.37 & -0.37 \\-0.37 & 0.37\end{array}\right]\end{aligned}</script><p>每个子矩阵对应于图的一个联通分量。0 是每个子矩阵的 1 重特征值，由于有两个联通分量，因此 0 是整个图的拉普拉斯矩阵的 2 重特征值。两个线性无关的特征向量为：</p><script type="math/tex; mode=display">\begin{aligned}& \mathbf{1}_{A_1}=\left[\begin{array}{lllll}1 & 1 & 1 & 0 & 0\end{array}\right]^{\mathrm{T}} \\& \mathbf{1}_{A_2}=\left[\begin{array}{lllll}0 & 0 & 0 & 1 & 1\end{array}\right]^{\mathrm{T}}\end{aligned}</script><h3 id="归一化拉普拉斯矩阵（Normalized-Laplacian-Matrix）"><a href="#归一化拉普拉斯矩阵（Normalized-Laplacian-Matrix）" class="headerlink" title="归一化拉普拉斯矩阵（Normalized Laplacian Matrix）"></a>归一化拉普拉斯矩阵（Normalized Laplacian Matrix）</h3><p>图拉普拉斯矩阵有两种形式的归一化。</p><p>第一种称为<strong>对称归一化</strong>，定义为：</p><script type="math/tex; mode=display">\mathbf{L}_{\text {sym }}=\mathbf{D}^{-1 / 2} \mathbf{L D}^{-1 / 2}=\mathbf{I}-\mathbf{D}^{-1 / 2} \mathbf{A} \mathbf{D}^{-1 / 2}</script><p>这里 $D^{1 / 2}$ 是 $D$ 的所有元素计算正平方根得到的矩阵。位置为 $(i . j), i \neq j$ 的元素为将未归一化拉普拉斯矩阵对应位置处的元素 $l_{i j}$ 除以 $\sqrt{d_{i i} d_{j j}}$ 后形成的，主对角线上的元素为 1 ：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{L}_{\mathrm{sym}} & =\left[\begin{array}{cccc}1 / \sqrt{d_{11}} & 0 & \ldots & 0 \\0 & 1 / \sqrt{d_{22}} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / \sqrt{d_{n n}}\end{array}\right]\left[\begin{array}{cccc}l_{11} & l_{12} & \ldots & l_{1 n} \\l_{21} & l_{22} & \ldots & l_{2 n} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} & l_{n 2} & \ldots & l_{n n}\end{array}\right]\left[\begin{array}{cccc}1 / \sqrt{d_{11}} & 0 & \ldots & 0 \\0 & 1 / \sqrt{d_{22}} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / \sqrt{d_{n n}}\end{array}\right] \\& =\left[\begin{array}{cccc}1 & l_{12} / \sqrt{d_{11} d_{22}} & \ldots & l_{1 n} / \sqrt{d_{11} d_{n n}} \\l_{21} / \sqrt{d_{22} d_{11}} & 1 & \ldots & l_{2 n} / \sqrt{d_{22} d_{n n}} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} / \sqrt{d_{n n} d_{11}} & l_{n 2} / \sqrt{d_{n n} d_{22}} & \ldots & 1\end{array}\right]\end{aligned}</script><p>由于 $D^{1 / 2}$ 和 $L$ 都是对称矩阵, 因此 $L_{sym}$ 也是对称矩阵。如果图是联通的，则 $D$ 和 $D^{1 / 2}$ 都是可逆的对角矩阵，其逆矩阵分别为其主对角线元素的逆。</p><p>第二种称为<strong>随机漫步归一化</strong>，定义为：</p><script type="math/tex; mode=display">\mathbf{L}_{\mathrm{rw}}=\mathbf{D}^{-1} \mathbf{L}=\mathbf{I}-\mathbf{D}^{-1} \mathbf{A}</script><p>其位置为 $(i, j), i \neq j$ 的元素为将未归一化拉普拉斯矩阵对应位置处的元素 $l_{i j}$ 除以 $d_{i i}$ 后形成的，主对角线元素也为 1：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{L}_{\mathrm{rw}} & =\left[\begin{array}{cccc}1 / d_{11} & 0 & \ldots & 0 \\0 & 1 / d_{22} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / d_{n n}\end{array}\right]\left[\begin{array}{cccc}l_{11} & l_{12} & \ldots & l_{1 n} \\l_{21} & l_{22} & \ldots & l_{2 n} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} & l_{n 2} & \ldots & l_{n n}\end{array}\right] \\& =\left[\begin{array}{cccc}1 & l_{12} / d_{11} & \ldots & l_{1 n} / d_{11} \\l_{21} / d_{22} & 1 & \ldots & l_{2 n} / d_{22} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} / d_{n n} & l_{n 2} / d_{n n} & \ldots & 1\end{array}\right]\end{aligned}</script><p>下面介绍这两种归一化矩阵的若干重要性质：</p><p>1、对任意向量 $\mathbf{f} \in \mathbb{R}^n$ 有：</p><script type="math/tex; mode=display">\mathbf{f}^{\mathrm{T}} \mathbf{L}_{\mathrm{sym}} \mathbf{f}=\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n w_{i j}\left(\frac{f_i}{\sqrt{d_i}}-\frac{f_j}{\sqrt{d_j}}\right)^2</script><p>2、$\lambda$ 是矩阵 $L_{rw}$ 的特征值，$\mu$ 是特征向量, 当且仅当 $\lambda$ 是 $L_{sym}$ 的特征值且其特征向量为 $w=D^{1 / 2} \mu$。</p><p>3、$\mu$ 是矩阵 $L_{rw}$ 的特征值，$\mu$ 是对应的特征向量，当且仅当 $\lambda$ 和 $\mu$ 是广义特征值问题 $L u=\lambda D u$ 的解。</p><p>4、0 是矩阵 $L_{rw}$ 的特征值，其对应的特征向量为常向量 1 ，即所有分量为 1。 0 是矩阵 $L_{sym}$ 的特征值，其对应的特征向量为 $D^{1 / 2} 1$ 。</p><p>5、矩阵 $L_{sym}$ 和 $L_{rw}$ 是半正定矩阵，有 $n$ 个非负实数特征值, 并且满足：</p><script type="math/tex; mode=display">0=\lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n</script><p>6（结论）、和未归一化的拉普拉斯矩阵类似，假设 $G$ 是一个有非负权重的无向图，其归一化拉普拉斯矩阵 $L_{rw}$ 和 $L_{sym}$ 的特征值0的重数 $k$ 等于图的联通分量的个数 $A_1, \ldots, A_k$ 。</p><p>对于矩阵 $L_{rw}$，特征值0的特征空间由这些联通分量所对应的向量 $1_{A_1}, \ldots, 1_{A_k}$ 所张成。 $1_{A_i}$ 的定义与未归一化拉普拉斯矩阵0特征值的特征向量相同。</p><p>对于矩阵 $L_{sym}$, 特征值O的特征空间由这些联通分量所对应的向量 $\mathbf{D}^{1 / 2} \mathbf{1}_{A_1}, \ldots, \mathbf{D}^{1 / 2} \mathbf{1}_{A_k}$ 所张成。</p><h2 id="拉普拉斯矩阵的谱分解（Spectral-Decomposition）"><a href="#拉普拉斯矩阵的谱分解（Spectral-Decomposition）" class="headerlink" title="拉普拉斯矩阵的谱分解（Spectral Decomposition）"></a>拉普拉斯矩阵的谱分解（Spectral Decomposition）</h2><p>在矩阵范围内，不考虑过于复杂的数学概念，谱分解又称为特征值分解，只有方阵才能进行谱分解。</p><blockquote><p><strong>特征向量（Eigenvectors）</strong>：一个矩阵的特征向量是指一个非零向量，其在经过矩阵变换后只发生了伸缩而没有改变方向，只相差了一个常数倍数。换句话说，矩阵乘以特征向量后，相当于对该向量进行了一个比例的拉伸。</p><p><strong>特征值（Eigenvalues）</strong>：特征值是对应于特征向量的标量，它表示了在特征向量进行矩阵变换后的伸缩倍数。一个矩阵可以有多个特征向量和对应的特征值。</p></blockquote><p>对于一个方阵 $A$，谱分解的基本思想是将它表示为特征向量矩阵 $P$ 与对角特征值矩阵 $Λ$ 相乘的形式，即 $A = P <em> Λ </em> P^{-1} $。如果 $A$ 是对称矩阵，则 $P$ 是正交矩阵，则原式也可写作 $A = P <em> Λ </em> P^T$。</p><p>由于拉普拉斯矩阵是<strong>对称半正定</strong>的，我们可以得到以下性质：<br>1、一定有$n$个线性无关的特征向量（对称）。<br>2、矩阵的特征值一定非负（半正定）。<br>3、矩阵的特征向量相互正交，即所有特征向量构成的矩阵为正交矩阵（对称）。</p><p>所以，拉普拉斯矩阵 $L$ 的谱分解也可以写成 $P <em> Λ </em> P^T$ 的形式，如下所示：</p><script type="math/tex; mode=display">\boldsymbol{L}=\boldsymbol{\Phi} \boldsymbol{\Lambda} \boldsymbol{\Phi}^{\top}</script><p>$\Phi=\left(\phi_1, \phi_2, \ldots, \phi_n\right) \in \mathbb{R}^{\mathrm{n} \times n}$ 是正交矩阵，其列向量为单位特征向量。<br>$\Lambda=\operatorname{diag}\left(\lambda_1, \ldots, \lambda_n\right)$ 是由对应特征值构成的对角矩阵。</p><h2 id="狄利克雷能量（Dirichlet-Energy）"><a href="#狄利克雷能量（Dirichlet-Energy）" class="headerlink" title="狄利克雷能量（Dirichlet Energy）"></a>狄利克雷能量（Dirichlet Energy）</h2><p>狄利克雷能量衡量了函数的平滑性（Smoothness），越小说明函数越平滑。狄利克雷能量定义为:</p><script type="math/tex; mode=display">\mathrm{E}_{\mathrm{Dir}}(\boldsymbol{f})=\boldsymbol{f}^{\top} \boldsymbol{\Delta} \boldsymbol{f}</script><p>其中$f$ 是函数，$\Delta$ 是拉普拉斯算子。整个公式在图结构上的含义是，计算函数$\boldsymbol{f}$在图的节点上的变化程度，其中变化程度通过将函数$\boldsymbol{f}$映射到拉普拉斯矩阵的空间（$\boldsymbol{\Delta} \boldsymbol{f}$），并计算映射后的向量与原向量的内积来衡量。</p><p>在图论中，狄利克雷能量越小表示图中节点的函数在空间中变化越平滑，节点之间的连接或关系越紧密。这可以用于量化图中的平滑性和连通性。</p><p>那么，<strong>狄利克雷能量最小化问题对推广图傅立叶变换有什么帮助呢</strong>？</p><p>图傅立叶变换是将一个定义在图的节点上的函数映射到频谱域，类似于信号处理中的傅立叶变换。在连续信号的情况下，傅立叶变换将信号分解为不同频率的正弦和余弦函数。类似地，在图上，图傅立叶变换将一个函数分解为图中的基函数，<strong>这些基函数由狄利克雷能量最小化问题得到</strong>。</p><p>我们的目标是寻找图上狄利克雷能量最小的一组单位正交基（每个基都可以看成函数）。 巧合的是，这样的正交基正好就是对拉普拉斯矩阵 $L$ 进行谱分解得到的单位特征向量 $\phi_1, \ldots, \phi_n$ 。 这对我们从传统傅里叶变换推广到图上傅里叶变换时进行的类比和替换提供了理论解释。</p><h2 id="图傅立叶变换（Graph-Fourier-Transformation）"><a href="#图傅立叶变换（Graph-Fourier-Transformation）" class="headerlink" title="图傅立叶变换（Graph Fourier Transformation）"></a>图傅立叶变换（Graph Fourier Transformation）</h2><p>简单回顾傅立叶变换，然后推广到图。</p><h3 id="傅立叶变换（Fourier-Transformation）"><a href="#傅立叶变换（Fourier-Transformation）" class="headerlink" title="傅立叶变换（Fourier Transformation）"></a>傅立叶变换（Fourier Transformation）</h3><p>傅里叶变换于将一个函数从时间（或空间）域转换到频率域，以便分析其频率特性。傅里叶变换可以将一个信号分解成不同频率的成分，从而揭示出信号的频谱信息。</p><p>傅里叶变换的公式如下：</p><p>对于连续信号：</p><script type="math/tex; mode=display">F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j\omega t} dt</script><p>对于离散信号：</p><script type="math/tex; mode=display">F(k) = \sum_{n=0}^{N-1} f(n) e^{-j\frac{2\pi}{N}kn}</script><p>其中，$ F(\omega) $ 或 $ F(k)$ 是信号在频率域的表示，$ f(t) $ 或 $ f(n) $ 是信号在时间（或空间）域的表示，$ \omega $ 是角频率，$ j $ 是虚数单位， $ t $ 或 $ n $ 是时间（或空间）的变量。</p><p>$F(\omega)$ 就是傅里叶变换，得到的就是频域图，它在 $\omega_0$ 的值 $F(\omega_0)$ 表示 $f(x)$ 在 $\omega_0$ 频率对应的正交基上的系数。</p><p>下面两者称为傅里叶变换对, 可以相互转换:</p><script type="math/tex; mode=display">f(x) \Leftrightarrow F(\omega)</script><p>另外，$e^{-j\omega t}$ 是傅立叶基函数之一，也被称为<strong>复指数函数</strong>。傅立叶变换可以将一个函数从时域转换到频域，它将一个函数表示为不同频率的正弦和余弦函数的叠加。$e^{-j\omega t}$ 就是这些正弦和余弦函数的复数形式，参照$e^{jx} = \cos(x) + j \sin(x)$。</p><h3 id="傅立叶基函数（Fourier-Basis-Functions）"><a href="#傅立叶基函数（Fourier-Basis-Functions）" class="headerlink" title="傅立叶基函数（Fourier Basis Functions）"></a>傅立叶基函数（Fourier Basis Functions）</h3><p>傅立叶基函数（Fourier Basis Functions）是一组正交函数，用于展开和表示信号在频率域的成分。在傅立叶变换中，原始信号可以被分解为各种频率的正弦和余弦函数的线性组合，而这些正弦和余弦函数就构成了傅立叶基函数。</p><p>傅立叶基函数的具体形式取决于是连续信号还是离散信号。对于连续信号，傅立叶基函数是正弦和余弦函数，表达式如下：</p><script type="math/tex; mode=display">\phi_k(t) = \frac{1}{\sqrt{T}} \cdot \begin{cases} \cos(2\pi kft), & \text{for even}\ k \\ \sin(2\pi kft), & \text{for odd}\ k \end{cases}</script><p>其中，$k$ 为频率索引，$f$ 为信号的基本频率，$T$ 为信号的周期。</p><p>对于离散信号，傅立叶基函数是复指数函数，表达式如下：</p><script type="math/tex; mode=display">\phi_k[n] = \frac{1}{\sqrt{N}} \cdot e^{j2\pi kn/N}</script><p>其中，$k$ 为频率索引，$N$ 为信号的样本点数。</p><p>傅立叶基函数构成了频率域的正交基，意味着不同频率的基函数之间彼此正交。通过将信号在傅立叶基函数上的投影，我们可以得到信号在不同频率上的分量，从而实现频域分析。</p><p>傅立叶基函数是傅立叶变换的核心概念，它们的线性组合可以用来表示任何信号。</p><h3 id="图傅立叶变换"><a href="#图傅立叶变换" class="headerlink" title="图傅立叶变换"></a>图傅立叶变换</h3><p>首先，在图上，拉普拉斯算子等于拉普拉斯矩阵。复指数函数$e^{-j\omega t}$，即傅立叶变换的基函数，可以被证明是图上拉普拉斯算子的一个特征函数。</p><script type="math/tex; mode=display">\Delta e^{-j\omega t}=\frac{\partial^2 e^{-j\omega t}}{\partial t^2}=-\omega^2 e^{-j\omega t}</script><p>在图上作类比，令变量为 $x$，令频率为 $\mathrm{k}$ （注意与角频率的区别）， $\phi_{\mathrm{k}}$ 为图拉普拉斯算子 $L$ 的特征向量（满足 $L \phi_k=\lambda_k \phi_k$ ）。即在图中 $\Delta=\boldsymbol{L}, \mathrm{e}^{-\mathrm{jkx}}=\phi_k$ ，而 $\mathrm{k}$ 和特征值 $\lambda_{\mathrm{k}}$ 有关。</p><p>因此，为了在图上进行傅里叶变换，可以把传统傅里叶变换中的 $\mathrm{e}^{-\mathrm{jk} x}$ 换成 $\phi_k$ ，把频率 $\mathrm{k}$ 换为 特征值 $\lambda_{\mathrm{k}}$。</p><p>则图傅里叶变换写作:</p><script type="math/tex; mode=display">F\left(\lambda_k\right)=\hat{f_k}=\left\langle f, \phi_k\right\rangle</script><p>$f=\left(f_1, \ldots, f_n\right)$ 是由节点信息构成的n维向量。做个类似的解释，即特征值 $\lambda_k$ 下，$f$ 的 图傅里叶变换（振幅）等于 $f$ 与 $\lambda_k$ 对应的特征向量 $\phi_k$ 的内积。</p><p>推广到矩阵形式，图傅里叶变换:</p><script type="math/tex; mode=display">\hat{f} = \boldsymbol{\Phi}^{\top} f</script><p>其中, $\hat{f}=\left(\hat{f_1} , \hat{f_2}, \ldots, \hat{f_n}\right)$，即图傅里叶变换，即不同特征值(频率)下对应的振幅构成的向量。 $f=\left(f_1, \ldots, f_n\right)$ 是由节点信息构成的n维向量。</p><p>类似的，传统逆傅里叶变换（n个正弦波的叠加）：</p><script type="math/tex; mode=display">{ }^{-1}[F(k)]=f(x)=\sum_k F(k) e^{i k x}=\sum_k \frac{1}{2 \pi} \int_{-\infty}^{\infty} f\left(x^{\prime}\right) e^{-i k x^{\prime}} d x^{\prime} e^{i k x}</script><p>迁移到图上，$\mathrm{e}^{ikx} \mathrm{e}^{-ikx}=1$，两个基正交，类比于 $\left(\phi_{\mathrm{k}}^{\top} \phi_{\mathrm{k}}\right)_{\mathrm{i}}=1$，则图逆傅里叶变换：</p><script type="math/tex; mode=display">\mathrm{f}_{\mathrm{i}}=\sum_{\mathrm{k}=1}^{\mathrm{n}} \hat{\mathrm{f}_{\mathrm{k}}}\left(\boldsymbol{\phi}_k^{\top}\right)_{\mathrm{i}}</script><p>推广到矩阵形式，图逆傅立叶变换：</p><script type="math/tex; mode=display">f = \boldsymbol{\Phi} \hat{f}</script><h2 id="图卷积（Graph-Convolution）"><a href="#图卷积（Graph-Convolution）" class="headerlink" title="图卷积（Graph Convolution）"></a>图卷积（Graph Convolution）</h2><p>结合图傅立叶变换和卷积定理的结论，我们可以推导出图卷积，首先有：</p><script type="math/tex; mode=display">\begin{align}    f * g=\mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\} \\    \\    \hat{f} = \boldsymbol{\Phi}^{\top} f \\    \\    f = \boldsymbol{\Phi} \hat{f}\end{align}</script><p>下面令图为 $f$，卷积核为 $h$，则图卷积为 $f * h$，有：</p><script type="math/tex; mode=display">\begin{align}f * h = \mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{h\}\} \\= \mathcal{F}^{-1}\{\boldsymbol{\Phi}^{\top} f \odot \boldsymbol{\Phi}^{\top} h\} \\ = \boldsymbol{\Phi}\boldsymbol{\Phi}^{\top} f \odot \boldsymbol{\Phi}^{\top} h \\= \boldsymbol{\Phi}\boldsymbol{\Phi}^{\top} h \odot \boldsymbol{\Phi}^{\top} f \\= \boldsymbol{\Phi}\hat{h} \odot \boldsymbol{\Phi}^{\top} f \\= \boldsymbol{\Phi} \operatorname{diag}\left[\hat{h}\left(\lambda_1\right), \ldots, \hat{h}\left(\lambda_n\right)\right] \boldsymbol{\Phi}^T \boldsymbol{f}\end{align}</script><p>上式是我按自己的理解推导得来，如有错误，请联系我的邮箱赐教🙏，感谢。</p><p>对于卷积核的图傅里叶变换: $\hat{h}=\left(\hat{h}_1, \ldots, \hat{h}_n\right)$, 其中 $\hat{h}_k=\left\langle h, \phi_k\right\rangle, k=1,2 \ldots, n$。</p><p>对于把 $\hat{h}$ 组织成对角矩阵 $\operatorname{diag}\left[\hat{h}\left(\lambda_k\right)\right] \in \mathbb{R}^{N \times N}$，个人理解，并不是在改变向量的形状，而是在改变操作方式（转变成矩阵乘法），以更好地表达图卷积的运算。</p><p>深度学习中的卷积就是要设计可学习的卷积核，从公式可以看出，就是要设计 $\operatorname{diag}\left[\hat{h}\left(\lambda_1\right), \ldots, \hat{h}\left(\lambda_n\right)\right]$, 由此, 可以直接将其变为卷积核 $\operatorname{diag}\left[\theta_1, \ldots, \theta_n\right]$，而不需要再将卷积核进行傅里叶变换，相当于直接对变换后的参量进行学习，可以把它理解成可训练权重向量。</p><p>PS：本人还有一个问题没搞懂，是否图和卷积核要分别计算 $\boldsymbol{\Phi}$ ？</p><h3 id="一代GCN"><a href="#一代GCN" class="headerlink" title="一代GCN"></a>一代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1312.6203">Spectral Networks and Locally Connected Networks on Graphs</a></p><p>由上述图卷积可以得到第一代GCN：</p><script type="math/tex; mode=display">\boldsymbol{y}_{\text {output }}=\sigma\left(\boldsymbol{\Phi} \boldsymbol{g}_\theta \boldsymbol{\Phi}^T \boldsymbol{x}\right)=\sigma\left(\boldsymbol{\Phi} \operatorname{diag}\left[\theta_1, \ldots, \theta_n\right] \boldsymbol{\Phi}^T \boldsymbol{x}\right)</script><p>其中，$\boldsymbol{g}_{\boldsymbol{\theta}}=\text{diag}[\theta_1,…,\theta_n]$ 为卷积核，$\sigma$ 是激活函数，$\boldsymbol{x}$ 就是图上对应每个节点的特征构成的向量，$x=\left(x_1, x_2, \ldots, x_n\right)$，这里暂时对每个节点都使用标量，相当于通道数为 1 ，然后经过激活之后，得到输出 $\boldsymbol{y}_{\text {output, }}$ 之后传入下一层。</p><p>缺点：</p><ul><li>需要对拉普拉斯矩阵进行谱分解来求 $\boldsymbol{\Phi}$，在图很大的时候复杂度很高。 另外，还需要计算矩阵乘积，复杂度为 $O\left(n^2\right)$ 。</li><li>卷积核参数为 $n$，当图很大的时候，$n$ 会很大。</li><li>卷积核的spatial localization不好。</li></ul><blockquote><p>卷积核的空间定位（spatial localization）是指卷积核在输入数据的空间维度上的操作范围和影响范围。在卷积操作中，卷积核会在输入数据的不同位置上滑动，通过与输入数据的局部区域进行逐元素相乘并求和来生成输出。</p><p>在图像处理领域，卷积核的空间定位决定了卷积操作在图像中提取特征的方式。不同大小的卷积核和不同的卷积操作方式可以捕捉到图像中不同尺度和结构的特征。例如，小尺寸的卷积核可以捕捉到图像中的细节特征，而较大尺寸的卷积核则可以捕捉到图像中的整体结构特征。</p><p>在图卷积网络中，卷积核的空间定位也很重要。由于图数据不像图像一样具有规则的网格结构，卷积核的设计需要考虑图的拓扑结构。卷积核在图上的空间定位可以用来控制卷积操作在图节点之间传播信息的方式，从而捕捉到图的局部和全局特征。</p><p>因此，卷积核的空间定位在卷积操作中起到了至关重要的作用，它决定了卷积操作如何在输入数据的不同位置上进行特征提取。</p></blockquote><h3 id="二代GCN"><a href="#二代GCN" class="headerlink" title="二代GCN"></a>二代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1606.09375">Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering</a></p><p>图傅里叶变换是关于特征值(相当于普通傅里叶变换的频率)的函数，也就是 $F\left(\lambda_1\right), \ldots, F\left(\lambda_n\right)$，即 $F(\boldsymbol{\Lambda})$, 因此，将卷积核 $\boldsymbol{g}_\theta$ 写成 $\boldsymbol{g}_\theta(\Lambda)$，然后将 $\boldsymbol{g}_\theta(\Lambda)$ 定义为如下k阶多项式</p><script type="math/tex; mode=display">g_{\theta^{\prime}}(\mathbf{\Lambda}) \approx \sum_{k=0}^K \theta_k^{\prime} \mathbf{\Lambda}^k</script><p>这里的 $\Lambda$ 为以特征值为对角元素的对角矩阵，所以 $\Lambda^k$ 也是对角矩阵，通过求和之后，还是对角矩阵，就这一点来说，和 $g_\theta$ 本身是对角矩阵是非常吻合的。</p><p>将卷积公式带入，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}g_{\theta^{\prime}} * x & \approx \Phi \sum_{k=0}^K \theta_k^{\prime} \boldsymbol{\Lambda}^k \boldsymbol{\Phi}^T \boldsymbol{x} \\& =\sum_{k=0}^K \theta_k^{\prime}\left(\boldsymbol{\Phi} \boldsymbol{\Lambda}^k \boldsymbol{\Phi}^T\right) x \\& =\sum_{k=0}^K \theta_k^{\prime}\left(\mathbf{\Phi} \boldsymbol{\Lambda} \boldsymbol{\Phi}^T\right)^k x \\& =\sum_{k=0}^K \theta_k^{\prime} \boldsymbol{L}^k x\end{aligned}</script><p>可以看出，这一代的GCN不需要做特征分解了，可以直接对Laplacian矩阵做变换，通过事先将Laplacian矩阵求出来，以及 $\boldsymbol{L}^k$ 求出来，前向传播的时候，就可以直接使用，复杂度为 $O\left(K n^2\right)$ 。</p><p>那么上式是如何体现localization呢？我们知道，矩阵的$k$次方可以用于求连通性，即1个节点经过$k$步能否到达另一个顶点，矩阵$k$次方结果中对应元素非0的话可达，为0不可达。那么 $\boldsymbol{L}^k$ 所表达的就是 k-hop 内的节点。又可以通过拉普拉斯算子的性质证明，如果两个节点的最短路径大于 $k$ 的话，$\boldsymbol{L}^k$ 在相应位置的元素值为0。</p><p>综上，相当于只有n节点的k-hop之内的邻居节点能够传递信息，实际上只利用了节点的K-Localized信息。</p><p>另外，作者提出可以使用切比雪夫展开式来近似 $\boldsymbol{L}^k$，因为任何 $\mathbf{k}$ 次多项式都可以使用切比雪夫展开式来近似，由此，引入切比雪夫多项式的 $K$ 阶截断获得 $\boldsymbol{L}^k$ 近似，从而获得对 $g_\theta(\boldsymbol{\Lambda})$ 的近似</p><script type="math/tex; mode=display">g_{\theta^{\prime}}(\mathbf{\Lambda}) \approx \sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\mathbf{\Lambda}})</script><p>其中，$\tilde{\boldsymbol{\Lambda}}=\frac{2}{\lambda_{\max }} \boldsymbol{\Lambda}-\boldsymbol{I}_n $ 为经图拉普拉斯矩阵 $L$ 的最大特征值（即谱半径）缩放后的特征向量矩阵（防止连乘爆炸），$ \boldsymbol{\theta}^{\prime} \in \mathbb{R}^K$ 为一个切比雪夫向量，$\theta_k^{\prime}$ 为第 $k$ 维分量，切比雪夫多项式 $T_k(x)$ 使用递归的方式进行定义：</p><script type="math/tex; mode=display">T_k(x)=2 x T_{k-1}(x)-T_{k-2}(x)</script><p>其中, $T_0(x)=1, T_1(x)=x$ 。</p><p>此时，用近似的卷积核带入到原公式，可得：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{g}_{\boldsymbol{\theta}^{\prime}} * \boldsymbol{x} & \approx \boldsymbol{\Phi} \sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{\Lambda}}) \boldsymbol{\Phi}^T \boldsymbol{x} \\& \approx \sum_{k=0}^K \theta_k^{\prime}\left(\boldsymbol{\Phi} T_k(\tilde{\boldsymbol{\Lambda}}) \boldsymbol{\Phi}^T\right) x \\& =\sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{L}}) \boldsymbol{x}\end{aligned}</script><p>其中，$\tilde{\boldsymbol{L}}=\frac{2}{\lambda_{\max }} \boldsymbol{L}-\boldsymbol{I}_n$ 。</p><p>因此，可以得到输出为：</p><script type="math/tex; mode=display">\boldsymbol{y}_{\text {output }}=\sigma\left(\sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{L}}) \boldsymbol{x}\right)</script><p>其中参数向量 $\boldsymbol{\theta}^{\prime} \in \mathbb{R}^{k}$ 需要学习。</p><h3 id="三代GCN"><a href="#三代GCN" class="headerlink" title="三代GCN"></a>三代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1609.02907">Semi-supervised Classification with Graph Convolutional Networks</a></p><p>这一代GCN直接取切比雪夫多项式中 $K=1$，此时模型是 1 阶近似，即每层卷积层只考虑了直接邻域，类似CNN中 $3 \times 3$ 的卷积核。并且，这一代GCN加深了深度而减小了宽度，若要建立多阶 proximity，只需要使用多个卷积层。同时，加入了一些参数约束，如 $\lambda_{\max }=2$ 和引入renormalization trick，大大简化了模型。</p><p>下面开始推导，将 $K=1, \quad \lambda_{\max }=2$ 带入可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{g}_{\theta^{\prime}} * \boldsymbol{x} & \approx \boldsymbol{\theta}_0^{\prime} \boldsymbol{x}+\theta_1^{\prime}\left(\boldsymbol{L}-\boldsymbol{I}_n\right) \boldsymbol{x} \\& =\boldsymbol{\theta}_0^{\prime} \boldsymbol{x}+\theta_1^{\prime}\left(\boldsymbol{L}-\boldsymbol{I}_n\right) \boldsymbol{x} \\& =\theta_0^{\prime} \boldsymbol{x}-\theta_1^{\prime}\left(\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}\right) \boldsymbol{x}\end{aligned}</script><p>最终转换步骤的解释如下：</p><script type="math/tex; mode=display">\boldsymbol{L}=\boldsymbol{D}^{-1 / 2}(\boldsymbol{D}-\boldsymbol{W}) \boldsymbol{D}^{-1 / 2}=\boldsymbol{I}_n-\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}</script><p>现在每个卷积核只有2个参数，为了进一步简化，令 $\theta_0^{\prime}=-\theta_1^{\prime}$，此时只含有一个参数 $\theta$：</p><script type="math/tex; mode=display">g_{\theta^{\prime}} * x=\theta\left(I_n+D^{-1 / 2} W D^{-1 / 2}\right) x</script><p>由于 $\boldsymbol{I}_n+\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}$ 的谱半径 $[0,2]$ 太大，使用renormalization trick：</p><script type="math/tex; mode=display">\boldsymbol{I}_n+\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2} \rightarrow \tilde{\boldsymbol{D}}^{-1 / 2} \tilde{\boldsymbol{W}} \tilde{\boldsymbol{D}}^{-1 / 2}</script><p>其中，$\tilde{\boldsymbol{W}}=\boldsymbol{W}+\boldsymbol{I}_n$ (相当于加了self-connection，本来$\boldsymbol{W}$对角元素为0)，$\tilde{D}_{i j}=\Sigma_j \tilde{W}_{i j}$ 。</p><p>带入卷积公式：</p><script type="math/tex; mode=display">\underbrace{g_{\theta^{\prime}} * x}_{\mathbb{R}^{n \times 1}}=\theta(\underbrace{\tilde{D}^{-1 / 2} \tilde{W} \tilde{D}^{-1 / 2}}_{\mathbb{R}^{n \times n}}) \underbrace{x}_{\mathbb{R}^{n \times 1}}</script><p>如果推广到多通道，相当于每一个节点的信息是向量，且有多卷积核：</p><script type="math/tex; mode=display">x \in \mathbb{R}^{N \times 1} \rightarrow X \in \mathbb{R}^{N \times C}</script><p>其中，$N$ 是节点数量，$C$ 是通道数，或者称作表示节点的信息维度数。 $\mathrm{X}$ 是 节点的特征矩阵。</p><p>相应的卷积核参数变化：</p><script type="math/tex; mode=display">\theta \in \mathbb{R} \rightarrow \Theta \in \mathbb{R}^{C \times F}</script><p>其中，$F$ 为卷积核数量。</p><p>那么卷积结果写成矩阵形式为：</p><script type="math/tex; mode=display">\underbrace{Z}_{\mathbb{R}^{N \times F}}=\underbrace{\tilde{D}^{-1 / 2} \tilde{W} \tilde{D}^{-1 / 2}}_{\mathbb{R}^{N \times N}} \underbrace{X}_{\mathbb{R}^{N \times C}}  \underbrace{\Theta}_{\mathbb{R}^{C \times F}}</script><p>上述操作可以叠加多层，对输出$Z$激活一下，就可以作为下一层节点的特征矩阵。</p><p>这一代GCN特点：</p><ul><li>取 $K=1$，相当于直接取邻域信息，类似于 $3 \times 3$ 的卷积核。</li><li>由于卷积核宽度减小，可以通过增加卷积层数来扩大感受域，从而增强网络的表达能力。</li><li>增加了参数约束，比如 $\lambda_{\max } \approx 2$，引入重归一化trick。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/76296353">https://zhuanlan.zhihu.com/p/76296353</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/54505069">https://zhuanlan.zhihu.com/p/54505069</a><br>[3] <a href="http://xtf615.com/2019/02/24/gcn/">http://xtf615.com/2019/02/24/gcn/</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/362416124">https://zhuanlan.zhihu.com/p/362416124</a><br>[5] <a href="https://qddmj.cn/gcn-laplacian.htm">https://qddmj.cn/gcn-laplacian.htm</a><br>[6] <a href="https://zhuanlan.zhihu.com/p/170091053">https://zhuanlan.zhihu.com/p/170091053</a><br>[7] <a href="https://qddmj.cn/gcn-laplacian2.htm">https://qddmj.cn/gcn-laplacian2.htm</a><br>[8] <a href="https://zhuanlan.zhihu.com/p/41609577">https://zhuanlan.zhihu.com/p/41609577</a><br>[9] <a href="https://zhuanlan.zhihu.com/p/464121739">https://zhuanlan.zhihu.com/p/464121739</a><br>[10] <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#convolutional-layers">https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#convolutional-layers</a><br>[11] <a href="https://zhuanlan.zhihu.com/p/60014316">https://zhuanlan.zhihu.com/p/60014316</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图卷积学习记录，同时也涉及离散拉普拉斯算子内容，可能对视觉方向有帮助。&lt;/p&gt;
&lt;p&gt;相关内容：卷积、傅立叶变换、拉普拉斯算子、狄利克雷能量、图卷积&lt;br&gt;</summary>
    
    
    
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图论" scheme="http://silencezheng.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Yilia图片居中</title>
    <link href="http://silencezheng.top/2023/08/13/article116/"/>
    <id>http://silencezheng.top/2023/08/13/article116/</id>
    <published>2023-08-13T07:48:59.000Z</published>
    <updated>2023-08-13T07:50:37.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo博客，Yilia主题设置图片居中。</p><span id="more"></span><p>Yilia用了很久了，终于想起来动一下图片居中的毛病，原版是无法实现图片居中的，在<code>article-main.scss</code>中加个样式可以解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  // 要添加的</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但添加完需要重新编译主题项目，进入项目根目录执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 编译、压缩。</span></span><br><span class="line">npm run dist</span><br></pre></td></tr></table></figure></p><p>Yilia这个项目2017年后就没有维护了，注意在安装依赖时用Python2环境。</p><p>参考<a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia源码目录结构及构建须知">官方文档</a>。</p><p>在外部编译压缩完，替换source目录下的<code>main.XXX.css</code>文件就行了。</p><p>但如果项目编译环境有问题的话，这样替换还是容易造成其他bug，最稳妥的方式还是直接在已发布的<code>main.XXX.css</code>中搜索<code>.article img</code>然后进行修改。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo博客，Yilia主题设置图片居中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Yilia" scheme="http://silencezheng.top/tags/Yilia/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装使用入门</title>
    <link href="http://silencezheng.top/2023/08/12/article115/"/>
    <id>http://silencezheng.top/2023/08/12/article115/</id>
    <published>2023-08-12T12:32:55.000Z</published>
    <updated>2023-08-12T12:34:10.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis安装使用入门，包含基本知识和命令行客户端使用。</p><span id="more"></span><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。Redis的全称是<code>REmote DIctionary Server</code>。</p><p>Redis 提供数据结构，例如字符串、哈希、列表、集合、带有范围查询的排序集、位图、HyperLogLog、地理空间索引和流。 Redis 具有内置复制、Lua 脚本、LRU 逐出、事务和不同级别的磁盘持久性，并通过 Redis Sentinel 和 Redis 集群的自动分区提供高可用性。</p><p>另外，膜拜一下<a href="http://antirez.com/latest/0">作者大佬的博客</a>，风格太简约了😄。</p><h2 id="Redis快速安装"><a href="#Redis快速安装" class="headerlink" title="Redis快速安装"></a>Redis快速安装</h2><p>Docker安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># author: SilenceZheng66 2023.8.11</span></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">docker search redis</span><br><span class="line"></span><br><span class="line">docker pull redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件目录</span></span><br><span class="line">mkdir myredis</span><br><span class="line">mkdir myredis/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建持久化目录</span></span><br><span class="line">mkdir myredis/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件下载</span></span><br><span class="line">wget -O myredis/config/redis.conf http://download.redis.io/redis-stable/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个名为&quot;myredis&quot;的Redis容器，并根据指定的配置文件和参数进行配置</span></span><br><span class="line">docker run --restart=always --log-opt max-size=50m --log-opt max-file=1 -p 6379:6379 --name myredis -v /path/to/myredis/redis.conf:/etc/redis/redis.conf -v /path/to/myredis/data:/data -d redis redis-server /etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是各个参数的解释：</span></span><br><span class="line"><span class="comment"># `--restart=always`: 设置容器在退出时总是自动重启。</span></span><br><span class="line"><span class="comment"># `--log-opt max-size=100m`: 设置容器日志文件的最大大小为100MB。当日志文件达到该大小时，将进行轮转。</span></span><br><span class="line"><span class="comment"># `--log-opt max-file=2`: 设置容器日志文件的最大数量为2个。当日志文件数量超过该值时，最旧的日志文件将被删除。</span></span><br><span class="line"><span class="comment"># `-p 6379:6379`: 将宿主机的6379端口映射到容器的6379端口，允许从宿主机访问Redis服务。</span></span><br><span class="line"><span class="comment"># `--name myredis`: 为容器指定一个名称，即&quot;myredis&quot;。</span></span><br><span class="line"><span class="comment"># `-v /path/to/myredis/redis.conf:/etc/redis/redis.conf`: 将主机上的 `/path/to/myredis/redis.conf` 文件挂载到容器内的 `/etc/redis/redis.conf` 路径，用作Redis配置文件。</span></span><br><span class="line"><span class="comment"># `-v /path/to/myredis/data:/data`: 将主机上的 `/path/to/myredis/data` 目录挂载到容器内的 `/data` 路径，用作Redis数据目录。</span></span><br><span class="line"><span class="comment"># `-d redis`: 在后台运行一个Redis容器。</span></span><br><span class="line"><span class="comment"># `redis-server /etc/redis/redis.conf`: 指定要运行的Redis服务器，并指定使用 `/etc/redis/redis.conf` 作为配置文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器运行日志</span></span><br><span class="line">docker logs --since 30m myredis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找所有与端口号相关的网络连接和监听端口</span></span><br><span class="line">netstat -an | grep 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器redis命令行客户端</span></span><br><span class="line">docker <span class="built_in">exec</span> -it myredis redis-cli</span><br></pre></td></tr></table></figure></p><h2 id="Redis基础介绍"><a href="#Redis基础介绍" class="headerlink" title="Redis基础介绍"></a>Redis基础介绍</h2><h3 id="查看Redis信息"><a href="#查看Redis信息" class="headerlink" title="查看Redis信息"></a>查看Redis信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看全部信息</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:<span class="number">7.0</span>.11</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某板块信息</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; info CPU</span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:<span class="number">1.023336</span></span><br><span class="line">used_cpu_user:<span class="number">0.675062</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Redis默认有16个数据库，这个可以在配置文件redis.conf中做出修改:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure><p>这16个数据库以编号0-15命名，不支持修改名字，而且各个数据库之间的数据并不具备完全的隔离性，比如我们切换到任意一个数据库，执行命令<code>flushall</code>就可以清空所有数据库的数据，所以并不建议通过数据库来隔离不同的业务系统数据，但是我们可以针对同一个业务系统中的不同模块将其设置到不同的数据库中。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis的基本数据类型如下图：<br><img src="/assets/post_img/article115/redis-data-struct.png" alt="bdt"></p><p>但还有其他一些数据类型可扩展，截至目前，官网包含如下数据类型：<br><img src="/assets/post_img/article115/all-psb-dt.png" alt="alldt"></p><p>以下是常用数据结构的简要介绍：</p><ol><li><p><strong>Strings（字符串）</strong>：</p><ul><li>存储文本、二进制数据等。</li><li>可用于缓存、计数器等。</li></ul></li><li><p><strong>Lists（列表）</strong>：</p><ul><li>有序、可重复的元素集合。</li><li>支持在列表头部和尾部添加、删除元素，以及获取子列表。</li><li>适用于实现消息队列、最新动态等。</li></ul></li><li><p><strong>Sets（集合）</strong>：</p><ul><li>无序、不重复的元素集合。</li><li>支持添加、删除、判断元素是否存在等操作。</li><li>适用于存储不重复的标签、好友关系等。</li></ul></li><li><p><strong>Sorted Sets（有序集合）</strong>：</p><ul><li>与集合类似，但每个元素都有一个分数（score）用于排序。</li><li>支持按照分数范围获取元素。</li><li>适用于排行榜、优先级队列等。</li></ul></li><li><p><strong>Hashs（哈希）</strong>：</p><ul><li>存储对象，每个字段存储一个属性。</li><li>支持单个字段的读写、删除，以及获取所有字段。</li><li>适用于存储用户信息、商品属性等。</li></ul></li><li><p><strong>Bitmaps（位图）</strong>：</p><ul><li>位存储结构，适合表示某些状态或事件。</li><li>支持位的设置、清除、查询等操作。</li><li>适用于用户在线状态、签到等。</li></ul></li><li><p><strong>HyperLogLog（基数估算）</strong>：</p><ul><li>用于估算集合中不重复元素的数量，占用很少的内存。</li><li>支持添加元素，以及计算估算的基数数量。</li><li>适用于统计不重复 IP 数量、UV 数量等。</li></ul></li><li><p><strong>Geospatials（地理位置）</strong>：</p><ul><li>存储地理位置信息。</li><li>支持添加地点、计算两个地点之间的距离等操作。</li><li>适用于附近商店查找、位置服务等。</li></ul></li></ol><p>这些数据结构的特点在于快速的读写操作，以及许多方便的命令和功能。</p><h3 id="Key命名规范"><a href="#Key命名规范" class="headerlink" title="Key命名规范"></a>Key命名规范</h3><p>在 Redis 中，Key 的命名是非常重要的，它不仅影响到数据存储的性能，还会影响到代码的可读性和维护性。以下是一些 Redis Key 命名的规范和建议：</p><ol><li><p><strong>清晰而有意义的命名</strong>：Key 应该能够清楚地表达出它所对应的数据含义，不要使用过于简单的名称，可以使用类似于命名空间的方式来分隔不同业务领域的数据。</p></li><li><p><strong>避免特殊字符</strong>：Key 不应该包含特殊字符，特别是空格、换行符等。建议使用字母、数字、下划线、英文冒号等字符组成。</p></li><li><p><strong>长度适中</strong>：Key 的长度应该适中，不要过长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率。</p></li><li><p><strong>小写字母</strong>：建议使用小写字母来命名 Key，这样可以避免在大小写不敏感的 Redis 配置中引起问题。</p></li><li><p><strong>使用分隔符</strong>：在 Key 中使用分隔符，以提高可读性，比如使用冒号（:）或下划线（_）来分隔不同的层级。注意虽然可以使用分隔符方式划分 Key，但不要过度嵌套，以免增加查找和维护的复杂性。</p></li><li><p><strong>避免重复</strong>：确保不同业务使用不同的 Key，以免冲突和混淆。</p></li><li><p><strong>避免敏感信息</strong>：避免在 Key 中包含敏感信息，比如密码、安全令牌等。</p></li></ol><p>合理的命名规范可以提高代码的可读性和维护性，同时也能更好地利用 Redis 的性能优势。根据业务需求和团队的约定，可以制定适合自己的 Key 命名规范。</p><p>下面列举一些键命名示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命名规范：user:&#123;user_id&#125;:name</span><br><span class="line">示例：user:123:name</span><br><span class="line"></span><br><span class="line">命名规范：post:&#123;post_id&#125;</span><br><span class="line">示例：post:456</span><br><span class="line"></span><br><span class="line">命名规范：online:&#123;date&#125;</span><br><span class="line">示例：online:2023-06-01</span><br></pre></td></tr></table></figure></p><h2 id="Redis使用入门（CLI）"><a href="#Redis使用入门（CLI）" class="headerlink" title="Redis使用入门（CLI）"></a>Redis使用入门（CLI）</h2><p>下面使用Redis命令行客户端进行一些操作，加深对上述知识的理解😄。</p><h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; select <span class="number">1</span>    <span class="comment"># 数据库选择</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; set a a</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; select <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">2</span>]&gt; get a</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">2</span>]&gt; keys *   <span class="comment"># 显示当前数据库的所有键</span></span><br><span class="line">(empty array)</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; select <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; flushdb <span class="comment"># 清空当前数据库</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>[<span class="number">1</span>]&gt; flushdb <span class="comment"># 清空所有数据库</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="字符串（Strings）"><a href="#字符串（Strings）" class="headerlink" title="字符串（Strings）"></a>字符串（Strings）</h3><p>在 Redis 中，字符串是最简单的数据类型，但也是最通用和常用的，它不仅可以存储文本、整数、浮点数，甚至包括任何二进制数据，例如图像和序列化的对象。</p><p>这是因为在 Redis 中，字符串是二进制安全的（Binary-safe）。这意味着 Redis 的字符串值可以包含任何类型的数据，包括文本、图像、序列化的对象等，而不会对其中的二进制数据做任何处理或解释。</p><p>如果需要对存储的二进制数据进行解码，比如将其转换为特定的对象或文件格式，需要在应用程序中处理解码操作。</p><h4 id="设-取值"><a href="#设-取值" class="headerlink" title="设/取值"></a>设/取值</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个设置</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; set test:<span class="number">1</span>:string <span class="string">&quot;Silence&quot;</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; get test:<span class="number">1</span>:string</span><br><span class="line"><span class="string">&quot;Silence&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量设置</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; mset name:<span class="number">1</span> Silence name:<span class="number">2</span> Zheng</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; mget name:<span class="number">1</span> name:<span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Silence&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;Zheng&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不存在则设值，存在则设置失败</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; setnx name:<span class="number">1</span> <span class="string">&quot;Eminem&quot;</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; get name:<span class="number">1</span></span><br><span class="line"><span class="string">&quot;Silence&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; set name:<span class="number">3</span> <span class="string">&quot;Eminem&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><code>SET</code> 命令支持设置过期时间，一般分布式锁就是基于带过期时间的这个命令来实现的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> key value EX|PX 18 <span class="comment"># EX表示秒，PX表示毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置3秒后自动过期</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> tmp:1 5 EX 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get tmp:1</span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get tmp:1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h4 id="增减"><a href="#增减" class="headerlink" title="增减"></a>增减</h4><p>字符串类型包含整数和浮点数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; SET counter <span class="number">10</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; INCR counter</span><br><span class="line">(integer) <span class="number">11</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; DECR counter</span><br><span class="line">(integer) <span class="number">10</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; INCRBY counter <span class="number">5</span></span><br><span class="line">(integer) <span class="number">15</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; DECRBY counter <span class="number">100</span></span><br><span class="line">(integer) -<span class="number">85</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; DECRBYFLOAT counter <span class="number">5.2465</span></span><br><span class="line">(error) ERR unknown command <span class="string">&#x27;DECRBYFLOAT&#x27;</span>, with args beginning with: <span class="string">&#x27;counter&#x27;</span> <span class="string">&#x27;5.2465&#x27;</span> </span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; INCRBYFLOAT counter -<span class="number">5.2465</span></span><br><span class="line"><span class="string">&quot;-90.2465&quot;</span></span><br></pre></td></tr></table></figure><p>对于浮点运算，不存在<code>DECRBYFLOAT</code>，而是通过<code>INCRBYFLOAT</code>负值来进行减少。</p><p>最重要的是，<code>INCR</code>等指令本身就具有原子操作的特性，所以我们完全可以利用redis的<code>INCR、INCRBY、DECR、DECRBY</code>等指令来实现多客户端原子计数的效果，不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p><h4 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h4><p>在值后新增内容&amp;获取值的子串：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append <span class="built_in">test</span>:1:string <span class="string">&quot;Zheng66&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">test</span>:1:string</span><br><span class="line"><span class="string">&quot;SilenceZheng66&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; GETRANGE <span class="built_in">test</span>:1:string 2 10</span><br><span class="line"><span class="string">&quot;lenceZhen&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h3><p>在 Redis 中，List 是一个有序的字符串集合，它允许存储多个字符串值，并且保持它们的插入顺序。每个值都被称为元素（element）。Redis 中的 List 是一个<strong>双向链表</strong>（double-ended list），这使得在两端进行插入和删除操作非常快速。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p>下面称列表的左侧为头部，右侧为尾部。</p><ol><li><code>lpush</code>：将一个或者多个<code>value</code>插入到列表key的头部，不存在则创建列表key。</li><li><code>lpushx</code>：将<code>value</code>插入到列表key的头部，不存在则不做任何处理。</li><li><code>lpop</code>：移除并返回列表key指定数量的头元素，默认1。</li><li><code>rpush</code>、<code>rpushx</code>：尾部插入，对应关系同上。</li><li><code>rpop</code>：尾部推出，同上。</li><li><code>llen</code>：返回列表key的长度。</li><li><code>lindex</code>：获取列表key指定索引位置上的元素，头部从0开始，尾部从-1开始。</li><li><code>lrange</code>：返回列表key中下标start到stop之间的元素，包含边界。</li><li><code>lset</code>：将value设置到列表key中指定index位置。key不存在或者index超出范围报错。</li><li><code>lrem</code>：从列表key中删除指定数量的匹配值。</li><li><code>ltrim</code>：修剪原列表，只保留指定范围内的元素，包含边界。</li><li><code>linsert</code>：在列表中指定元素前或后插入新元素。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; LPUSH mylist item1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; LPUSHX mylist item2 item3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; RPUSH mylist item4 item5</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; RPUSHX mylist item6</span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;item3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; rpop mylist</span><br><span class="line"><span class="string">&quot;item6&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; llen mylist</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lindex mylist <span class="number">0</span></span><br><span class="line"><span class="string">&quot;item2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lindex mylist -<span class="number">1</span></span><br><span class="line"><span class="string">&quot;item5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lindex mylist -<span class="number">2</span></span><br><span class="line"><span class="string">&quot;item4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;item2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;item1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;item4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;item5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lset mylist <span class="number">0</span> item2:new</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;item2:new&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; ltrim mylist <span class="number">2</span> <span class="number">2</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; llen mylist</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; LINSERT mylist BEFORE item5 item100</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; LINSERT mylist after item5 item100</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;item100&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;item5&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;item100&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lrem mylist <span class="number">2</span> item100</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;item5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; lpush mylist item1 item2 item3</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; rpop mylist <span class="number">4</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;item5&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;item1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;item2&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;item3&quot;</span></span><br></pre></td></tr></table></figure><h4 id="更多操作-1"><a href="#更多操作-1" class="headerlink" title="更多操作"></a>更多操作</h4><p><strong>BLPOP / BRPOP</strong></p><ul><li><code>BLPOP key [key ...] timeout</code>: 阻塞式左弹出操作，等待并弹出第一个非空列表的元素。</li><li><code>BRPOP key [key ...] timeout</code>: 阻塞式右弹出操作，等待并弹出第一个非空列表的元素。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从多个列表中弹出元素，等待时间为10秒</span></span><br><span class="line">BLPOP mylist1 mylist2 10 </span><br></pre></td></tr></table></figure><h3 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h3><p>Redis中的集合是一个String类型的无序集合，集合中元素唯一不可重复。</p><p>Sets在Redis中的常用函数有：</p><ol><li><code>SADD key member [member ...]</code>：将一个或多个成员添加到集合key中。</li><li><code>SCARD key</code>：返回集合key的基数（集合中元素的数量）。</li><li><code>SISMEMBER key member</code>：判断member元素是否是集合key的成员。</li><li><code>SREM key member [member ...]</code>：移除集合key中的一个或多个member元素。</li><li><code>SMEMBERS key</code>：返回集合key中的所有成员。</li><li><code>SPOP key [count]</code>：移除并返回集合key中的count个随机元素。</li><li><code>SRANDMEMBER key [count]</code>：从集合key中随机获取count个元素。</li><li><code>SDIFF key [key ...]</code>：返回所有给定集合之间的差集。</li><li><code>SINTER key [key ...]</code>：返回所有给定集合的交集。</li><li><code>SUNION key [key ...]</code>：返回所有给定集合的并集。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; SADD myset value1 value2 value3</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; SCARD myset</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; SISMEMBER myset value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sadd aset value2 value3 value4</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; SISMEMBER aset value1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; srem myset value2 value3</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; smove myset aset value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; smembers myset</span><br><span class="line">(empty array)</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sadd myset value1 value3 value5</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; spop aset <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; smembers aset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; srandmember myset <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sdiff myset aset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sdiff aset myset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sinter myset aset</span><br><span class="line">(empty array)</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; sunion myset aset</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="有序集合（Sorted-sets）"><a href="#有序集合（Sorted-sets）" class="headerlink" title="有序集合（Sorted sets）"></a>有序集合（Sorted sets）</h3><p>在Redis中，Sorted Set（有序集合）是一种可以排序的集合数据结构，它的每个成员都有一个相关的分数（score），根据分数的排列顺序对成员进行排序。<br>Sorted Set主要用于处理需要排序和去重的数据。</p><h4 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h4><p>因为添加操作的参数较多，单独拿出来说一下。<code>ZADD</code>命令用于将一个或多个成员添加到有序集合（Sorted Set）中，或者更新已存在成员的分数。</p><p>下面是<code>ZADD</code>命令的各种用法示例：</p><ol><li>添加单个成员到有序集合：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset 3 <span class="string">&quot;member1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ol><li>添加多个成员到有序集合：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset 2 <span class="string">&quot;member2&quot;</span> 4 <span class="string">&quot;member3&quot;</span> 1 <span class="string">&quot;member4&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><ol><li>使用<code>NX</code>选项，仅在成员不存在时才添加：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset NX 3 <span class="string">&quot;member1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><ol><li>使用<code>XX</code>选项，仅在成员已存在时才更新分数：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset XX 5 <span class="string">&quot;member1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ol><li>使用<code>CH</code>选项，返回更新或添加的成员数量，包括分数未变动的成员：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset CH 5 <span class="string">&quot;member1&quot;</span> 2 <span class="string">&quot;member2&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><ol><li>使用<code>INCR</code>选项，将分数作为增量进行更新：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset INCR 2 <span class="string">&quot;member1&quot;</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure><ol><li>结合<code>NX</code>、<code>CH</code>和<code>INCR</code>选项的多功能用法：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myzset NX CH INCR 3 <span class="string">&quot;member1&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><h4 id="基础操作-1"><a href="#基础操作-1" class="headerlink" title="基础操作"></a>基础操作</h4><p>Sorted Sets在Redis中的常用函数有：</p><ol><li><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code>：将一个或多个成员添加到有序集合key中，或者更新已存在成员的分数。</li><li><code>ZCARD key</code>：返回有序集合key的基数（有序集合中元素的数量）。</li><li><code>ZSCORE key member</code>：返回成员member的分数。</li><li><code>ZCOUNT key min max</code>：返回有序集合key中分数介于min和max之间的成员数量。</li><li><code>ZINCRBY key increment member</code>：将成员member的分数增加increment。</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：返回有序集合key中索引从start到stop之间的成员。</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>：返回有序集合key中索引从start到stop之间的成员，按分数从大到小排列。</li><li><code>ZRANK key member</code>：返回成员member在有序集合key中的排名，从0开始计数。</li><li><code>ZREVRANK key member</code>：返回成员member在有序集合key中的排名，从高到低排列。</li><li><code>ZREM key member [member ...]</code>：移除有序集合key中的一个或多个成员。</li><li><code>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</code>：返回有序集合key中分数介于min和max之间的成员。</li><li><code>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code>：返回有序集合key中分数介于max和min之间的成员，按分数从大到小排列。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; ZADD mysset <span class="number">1</span> member1 <span class="number">2</span> member2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zadd mysset NX <span class="number">3</span> member3</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zcard mysset</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zscore mysset member2</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zcount mysset <span class="number">2</span> <span class="number">3</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zincrby mysset <span class="number">2</span> member1</span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrange mysset <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;member2&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;member1&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;member3&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrevrange mysset <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;member3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;member1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;member2&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrank mysset member2</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrevrank mysset member2</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrem mysset member3</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrangebyscore mysset <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;member1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; zrevrangebyscore mysset <span class="number">3</span> <span class="number">1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;member1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;member2&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="哈希表（Hashs）"><a href="#哈希表（Hashs）" class="headerlink" title="哈希表（Hashs）"></a>哈希表（Hashs）</h3><p>在Redis中，Hashs是一种用于存储字段和值的数据结构，每个字段都与一个值相关联，类似于Python中的字典。<br>Hashs主要用于存储对象，以及需要多个字段来表示的数据。</p><p>Redis中Hashs的常用函数有：</p><ol><li><code>HSET key field value</code>：将哈希表key中的字段field的值设置为value。</li><li><code>HSETNX key field value</code>：将哈希表key中的字段field的值设置为value，如果field已存在，则不执行任何操作。</li><li><code>HGET key field</code>：返回哈希表key中给定字段field的值。</li><li><code>HMSET key field1 value1 [field2 value2 ...]</code>：同时将多个field-value对设置到哈希表key中。</li><li><code>HMGET key field1 [field2 ...]</code>：返回哈希表key中给定字段的值。</li><li><code>HDEL key field1 [field2 ...]</code>：删除哈希表key中的一个或多个指定字段。</li><li><code>HGETALL key</code>：返回哈希表key中所有字段和值。</li><li><code>HKEYS key</code>：返回哈希表key中的所有字段。</li><li><code>HVALS key</code>：返回哈希表key中的所有值。</li><li><code>HLEN key</code>：返回哈希表key中字段的数量。</li><li><code>HEXISTS key field</code>：查看哈希表key中是否存在指定字段。</li><li><code>HINCRBY key field increment</code>：为哈希表key中的字段field的值增加increment。</li><li><code>HINCRBYFLOAT key field increment</code>：为哈希表key中的字段field的值增加浮点数increment。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; HSET myhash field1 value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HSET myhash field2 value2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HGET myhash field1</span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HMSET myhash field3 value3 field4 value4</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HMGET myhash field1 field2 field3</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HDEL myhash field2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HGETALL myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;field1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;field3&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HKEYS myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;field1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;field3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HVALS myhash</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HLEN myhash</span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HEXISTS myhash field1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HINCRBY myhash field3 <span class="number">2</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; HINCRBYFLOAT myhash field3 <span class="number">1.5</span></span><br><span class="line"><span class="string">&quot;3.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="位图（Bitmaps）"><a href="#位图（Bitmaps）" class="headerlink" title="位图（Bitmaps）"></a>位图（Bitmaps）</h3><p>在Redis中，Bitmaps是一种特殊的数据结构，它可以表示一系列位的集合，每个位的值要么是0，要么是1。<br>比如存储数据格式一般为：100110000111，这里的0和1就是bit值，设置的时候可以设置指定位置(偏移量)的bit值。<br>Bitmaps通常用于存储布尔值的信息，如用户的在线状态、用户活跃情况等。</p><p>Redis中Bitmaps的常用函数有：</p><ol><li><code>SETBIT key offset value</code>：将key对应的Bitmap中的offset位设置为value（0或1）。</li><li><code>GETBIT key offset</code>：返回key对应的Bitmap中offset位的值。</li><li><code>BITCOUNT key [start end]</code>：统计key对应的Bitmap中[start, end]范围内值为1的位的数量。</li><li><code>BITOP operation destkey key [key ...]</code>：对多个Bitmap执行位运算，并将结果保存到destkey中，operation可以是AND、OR、XOR、NOT。</li><li><code>BITPOS key bit [start] [end]</code>：返回key对应的Bitmap中值为bit的第一个位的位置，[start, end]范围内。</li><li><code>BITFIELD key [GET type offset] [SET type offset value]</code>：执行多种位域操作，可以进行位取反、位截取、位增加等操作。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; SETBIT online_users <span class="number">1000</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GETBIT online_users <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; SETBIT online_users <span class="number">2000</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; SETBIT online_users <span class="number">3000</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITCOUNT online_users</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITCOUNT online_users <span class="number">0</span> <span class="number">2000</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITOP OR all_online online_users1 online_users2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GETBIT all_online <span class="number">1000</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GETBIT all_online <span class="number">2000</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITPOS all_online <span class="number">1</span></span><br><span class="line">(integer) <span class="number">2000</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITPOS all_online <span class="number">1</span> <span class="number">2000</span> <span class="number">3000</span></span><br><span class="line">(integer) <span class="number">3000</span></span><br><span class="line"><span class="comment"># 在名为online_users的Bitmap中，执行位域操作，使用GET命令从偏移量为1000的位开始，获取一个有符号的4位整数（u4类型，无符号4位整数）。</span></span><br><span class="line"><span class="comment"># 结果为字符串&quot;6&quot;，表示在偏移量1000的4位中，值为6。</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITFIELD online_users GET u4 <span class="number">1000</span></span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="comment"># 在名为online_users的Bitmap中，执行位域操作，使用SET命令将偏移量为1000的4位设置为2。命令执行成功，返回整数0。</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITFIELD online_users SET u4 <span class="number">1000</span> <span class="number">2</span></span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="comment"># 再次使用GET命令从偏移量为1000的位开始，获取一个有符号的4位整数（u4类型）。结果为字符串&quot;2&quot;，表示在偏移量1000的4位中，值已经被设置为2。</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; BITFIELD online_users GET u4 <span class="number">1000</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure><h3 id="基数估算（HyperLogLog）"><a href="#基数估算（HyperLogLog）" class="headerlink" title="基数估算（HyperLogLog）"></a>基数估算（HyperLogLog）</h3><p>HyperLogLog本身是一种算法，其来源于论文《HyperLogLog the analysis of a near-optimal cardinality estimation algorithm》。</p><p>在Redis中，HyperLogLog是一种用于统计基数（集合中不重复元素的数量）的数据结构，它通过使用固定的空间来估计集合的基数，占用的空间相对较小。<br>HyperLogLog主要用于对大型数据集合的去重统计，适用于对数据的<strong>近似计数</strong>，而不需要实际存储所有元素。</p><p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64 个不同元素的基数，但是也可能有0.81%的错误率。</p><p>HyperLogLog在Redis中的常用函数有：</p><ol><li><code>PFADD key element [element ...]</code>：将一个或多个元素添加到指定的HyperLogLog中。</li><li><code>PFCOUNT key [key ...]</code>：返回指定HyperLogLog的基数估算值。</li><li><code>PFMERGE destkey sourcekey [sourcekey ...]</code>：合并多个HyperLogLog为一个HyperLogLog。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; PFADD myhll element1 element2 element3</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; PFADD myhll element4 element5</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; PFCOUNT myhll</span><br><span class="line">(integer) <span class="number">5</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; PFMERGE merged-hll myhll myhll2</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; PFCOUNT merged-hll</span><br><span class="line">(integer) <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="地理空间（Geospatials）"><a href="#地理空间（Geospatials）" class="headerlink" title="地理空间（Geospatials）"></a>地理空间（Geospatials）</h3><p>在Redis中，Geospatials数据结构用于存储地理位置信息（经纬度）和相关的数据，然后可以通过位置信息进行距离计算和范围查询。<br>Redis提供了一种叫做Geohash的算法来将地理位置映射到字符串，从而可以在Redis中高效地进行位置查询和计算。</p><p>Geospatial数据在Redis中的常用函数有：</p><ol><li><code>GEOADD key longitude latitude member [longitude latitude member ...]</code>：将一个或多个地理位置成员添加到指定的key中。</li><li><code>GEODIST key member1 member2 [unit]</code>：返回两个地理位置成员之间的距离。</li><li><code>GEOHASH key member [member ...]</code>：返回指定地理位置成员的Geohash字符串。</li><li><code>GEOPOS key member [member ...]</code>：返回指定地理位置成员的经纬度坐标。</li><li><code>GEORADIUS key longitude latitude radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]</code>：在指定的经纬度范围内查找地理位置成员。</li><li><code>GEORADIUSBYMEMBER key member radius unit [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC]</code>：在指定地理位置成员附近查找其他地理位置成员。</li><li><code>GEODEL key member [member ...]</code>：从指定key中删除一个或多个地理位置成员。</li></ol><p>以下是一些配合cli示例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:<span class="number">6379</span>&gt; GEOADD mygeo <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">&quot;Palermo&quot;</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">&quot;Catania&quot;</span></span><br><span class="line">(integer) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEODIST mygeo Palermo Catania km</span><br><span class="line"><span class="string">&quot;166.2740&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEOHASH mygeo Palermo Catania</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;sqc8b49rny0&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;sqdtr74hyu0&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEOPOS mygeo Palermo Catania</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;13.36138933897018433&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">&quot;38.11555639549629859&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;15.08726745843887329&quot;</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">&quot;37.50266842333162032&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEORADIUS mygeo <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Catania&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEORADIUSBYMEMBER mygeo Palermo <span class="number">200</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line"><span class="number">127.0</span>.0.1:<span class="number">6379</span>&gt; GEODEL mygeo Catania</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h2><p>Redis是基于内存操作，具备高可用、高性能等特点，同时也提供了丰富的数据类型。一般可用于如下场景：</p><p>1、数据缓存。项目早期一般都是将数据存储到<code>MySQL、oracle</code>等关系型数据库中，所有的数据读写都是基于磁盘操作。随着业务的不断扩大，通过传统的方式进行数据的读取，系统在读写方面都会遇到瓶颈。针对这一情况，将数据存放在内存中，所有的读操作都通过内存进行查询，提高了系统的数据查询能力。对于数据的读，在高并发的业务场景下，也可以将数据先写入内存中，在通过异步的方式持久化到磁盘中，提高了系统的并发能力。</p><p>2、存储用户登录<code>token</code>。针对用户登录鉴权，一般可以基于<code>cookie</code>、jwt来实现。<code>cookie</code>是基于文件存储，并且<code>cookie</code>会涉及到跨域、分布式架构问题，jwt由于是基于客户端断存储方案，服务端无法直接控制登录<code>token</code>的状态。由于Redis是具备分布式部署架构，很好的解决了分布式架构<code>token</code>鉴权、用户登录状态等问题的控制。同时将登录<code>token</code>存放在Redis中，每次读取都采用内存读取，也提高了整个系统的性能。</p><p>3、秒杀场景。对于秒杀业务场景，对于系统的并发能力都是非常高的。在该场景下，将商品数据存储到Redis中，提高了系统的查询能力，减少了MySQL的压力。将商品库存都存储到Redis中，因Redis采用的是单线程架构，也可以实现商品超卖问题。</p><p>4、用户签到。可以使用 <code>bitmap</code> 数据类型，将用户签到存储在Redis中，然后通过异步线程将数据存储到MySQL中。既节约了内存，也提供了系统的读写能力。</p><p>5、消息队列。Redis提供 <code>list</code> 数据类型，技能用来做消息队列，也能用来做栈等场景。在 Redis5.0 开始，也提供了一种 <code>stream</code> 数据类型，提高了消息队列的可靠性。</p><p>6、社交场景。Redis提供了两种集合数据类型(set sortset)，可以用在积分排行、好友推荐等场景。</p><p>7、就近推荐。Redis中提供了一种 <code>Geospatials</code> 的数据类型来进行位运算。可以根据用户当前的经纬度，来计算附近的酒店、商场等场所的搜索与推荐功能。</p><p>8、分布式锁。当分布式架构中，需要对共享数据的读写操作(例如商品秒杀)。为了保证数据的一致性，一般是采用分布式锁实现，Redis能够非常简单的实现分布式锁功能。可以直接使用 <code>setnx key value + expire time</code> 操作，为了实现原子性操作，也可以直接使用 <code>lua</code> 实现。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/411888708">https://zhuanlan.zhihu.com/p/411888708</a><br>[2] <a href="https://redis.io/docs/getting-started/">https://redis.io/docs/getting-started/</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/609596571">https://zhuanlan.zhihu.com/p/609596571</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/270168739">https://zhuanlan.zhihu.com/p/270168739</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Redis安装使用入门，包含基本知识和命令行客户端使用。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://silencezheng.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Pyinstaller逆向初体验</title>
    <link href="http://silencezheng.top/2023/08/08/article114/"/>
    <id>http://silencezheng.top/2023/08/08/article114/</id>
    <published>2023-08-08T15:28:09.000Z</published>
    <updated>2023-08-08T15:28:55.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写了个Python小工具，突然想到防逆向的问题，写篇小文实践一下。</p><span id="more"></span><h2 id="用PyInstaller打包程序"><a href="#用PyInstaller打包程序" class="headerlink" title="用PyInstaller打包程序"></a>用PyInstaller打包程序</h2><p>对有图形界面的程序，最简单的打包就是<code>pyinstaller -F --noconsole xxx.py</code>。</p><h2 id="反编译该程序"><a href="#反编译该程序" class="headerlink" title="反编译该程序"></a>反编译该程序</h2><p>一个比较经典的工具是<a href="https://github.com/WithSecureLabs/python-exe-unpacker">pyinstxtractor</a>。</p><p>对于Windows中打包的Python应用（python3.9，pyinstaller5.x+），可以直接提取。但对于同配置下MacOS中打包的应用不能提取。下面简单演示如何使用。</p><p>首先下载项目代码，将待提取可执行文件置于项目根目录下，以我反编译的项目<code>replacer.exe</code>为例，运行<code>python python_exe_unpack.py -i replacer.exe</code>。</p><p>运行后根目录下会出现<code>unpacked</code>目录，其中为抽取出的<code>pyc</code>文件。找到其中的程序入口文件，通常与可执行文件名字相同，或为<code>main</code>等，但也很可能不符合这一规律，所以需要自行确定，这里我的程序入口就是<code>replace</code>。修改抽取出的入口文件名，增加后缀为 <code>replace.pyc</code>。</p><p>然后执行<code>uncompyle6 replacer.pyc&gt;replacer.py</code>，反编译<code>pyc</code>文件为源代码。这一步你很可能在反编译出的文件中发现类似<code>Unknown magic number 227 in replacer.pyc</code>的错误，这是因为不同Python版本的<code>pyc</code>文件前缀<code>Magic Number</code>不同，我们需要找到对应版本的<code>Magic Number</code>。一种简单的办法是把抽取出的<code>struct</code>文件，也修改为<code>struct.pyc</code>并对其进行反编译，如果能反编译成功，则将其文件前缀应用到<code>replace.pyc</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">od -c struct.pyc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">0000000    3  \r  \r  \n   p   y   i   0 001 001  \0  \0 343  \0  \0  \0</span><br><span class="line">0000020   \0  \0  \0  \0  \0  \0  \0  \0  \0  \b  \0  \0  \0   @  \0  \0</span><br><span class="line">0000040   \0   s   8  \0  \0  \0   d  \0   d 001   d 002   d 003   d 004</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再反观<code>replacer.pyc</code>，明显缺少前缀。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">od -c replacer.pyc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">0000000  343  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</span><br><span class="line">0000020   \0 004  \0  \0  \0   @  \0  \0  \0   s 350  \0  \0  \0   d  \0</span><br><span class="line">0000040    d 001   l  \0   Z  \0   d  \0   d 001   l 001   Z 001   d  \0</span><br></pre></td></tr></table></figure><p>于是我们给<code>replacer.pyc</code>加上合适的<code>Magic Number</code>文件前缀，在这里是<code>3  \r  \r  \n   p   y   i   0 001 001  \0  \0</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vim -b replacer.pyc</span><br><span class="line"><span class="comment"># 命令模式输入</span></span><br><span class="line">:%!xxd</span><br><span class="line"><span class="comment"># 显示左侧是16进制，右侧是原文件</span></span><br><span class="line"><span class="comment"># VIM把这些当做普通的字符串对待，所以，修改了左侧的16进制的字符后右侧的字符并不会跟着改变，反之亦然。</span></span><br><span class="line"><span class="comment"># 注意修改完成后,不要保存,要再用 </span></span><br><span class="line">:%!xxd -r</span><br><span class="line"><span class="comment"># 切换成文本状态格式再保存.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改方式：</span></span><br><span class="line"><span class="comment"># 找到起始位置，例如这里是e300</span></span><br><span class="line"><span class="comment"># 然后同样方式打开 xxx.pyc，把起始位置之前的内容复制到replacer.pyc中左侧。</span></span><br><span class="line"><span class="comment"># 然后 :%!xxd -r 后wq保存。</span></span><br></pre></td></tr></table></figure><p>但笔者的MacOS13进行如上操作后依然无法解析，报错<code>struct.error: unpack requires a buffer of 2 bytes</code>，换用Windows后解决，成功反编译出了<code>replacer</code>的源码。</p><p>PS：添加前缀后报错：<code>Ill-formed bytecode file replacer.pyc &lt;class &#39;ValueError&#39;&gt;; bad marshal data (unknown type code)</code>通常也是由于<code>Magic Number</code>不对，对于python3.8及以上版本打包的可执行文件反编译似乎需要使用pycdc，还没验证。笔者测试了3.6、3.8和3.9打包的可执行文件，3.8和3.9均无法通过上述方法反编译，猜测是3.8后续更新导致。</p><p>PPS：上述<code>.pyc</code>反编译工具的作者也有点难顶啊<a href="https://github.com/rocky/python-uncompyle6/issues/316">😆</a>，另外Pyinstaller的<a href="https://pyinstaller.org/en/stable/advanced-topics.html#inspecting-executables">官方文档</a>有时间也应该读一下。</p><h2 id="在打包时加密程序"><a href="#在打包时加密程序" class="headerlink" title="在打包时加密程序"></a>在打包时加密程序</h2><p>在<code>pyinstaller</code>打包时进行加密，只需要添加参数<code>--key</code>即可，例如<code>pyinstaller -F --noconsole --key 12345 xxx.py</code>。</p><p>Windows上使用这个参数需要安装<code>tinyaes</code>（或<code>pycrypto</code>），这个库需要<code>Microsoft Visual C++</code>，还要去安装<code>Microsoft Visual C++ Build Tools</code>。</p><h2 id="反编译加密的程序（未实践）"><a href="#反编译加密的程序（未实践）" class="headerlink" title="反编译加密的程序（未实践）"></a>反编译加密的程序（未实践）</h2><p>用上面的方法加密后，<code>PYZ-00.pyz_extracted</code>中的文件就被加密了，也就是说仅能反编译出程序入口的源码。</p><h2 id="用Cython加密程序"><a href="#用Cython加密程序" class="headerlink" title="用Cython加密程序"></a>用Cython加密程序</h2><p>待补充，用Mac磕磕绊绊，丧失兴趣了～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/109266820">https://zhuanlan.zhihu.com/p/109266820</a><br>[2] <a href="https://blog.csdn.net/as604049322/article/details/119834495">https://blog.csdn.net/as604049322/article/details/119834495</a><br>[3] <a href="https://pyinstaller.org/en/stable/advanced-topics.html#inspecting-archives">https://pyinstaller.org/en/stable/advanced-topics.html#inspecting-archives</a><br>[4] <a href="https://pyinstaller.org/en/stable/advanced-topics.html#inspecting-executables">https://pyinstaller.org/en/stable/advanced-topics.html#inspecting-executables</a><br>[5] <a href="https://github.com/WithSecureLabs/python-exe-unpacker">https://github.com/WithSecureLabs/python-exe-unpacker</a><br>[6] <a href="https://blog.csdn.net/qq_15969343/article/details/120001351">https://blog.csdn.net/qq_15969343/article/details/120001351</a><br>[7] <a href="https://github.com/rocky/python-decompile3">https://github.com/rocky/python-decompile3</a><br>[8] <a href="https://github.com/rocky/python-uncompyle6/">https://github.com/rocky/python-uncompyle6/</a><br>[9] <a href="https://blog.csdn.net/Zheng__Huang/article/details/112380221">https://blog.csdn.net/Zheng__Huang/article/details/112380221</a><br>[10] <a href="https://blog.csdn.net/weixin_44222568/article/details/111672799">https://blog.csdn.net/weixin_44222568/article/details/111672799</a><br>[11] <a href="https://www.cnblogs.com/Here-is-SG/p/15885799.html">https://www.cnblogs.com/Here-is-SG/p/15885799.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写了个Python小工具，突然想到防逆向的问题，写篇小文实践一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
    <category term="逆向" scheme="http://silencezheng.top/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>EqualsAndHashCode注解使用注意</title>
    <link href="http://silencezheng.top/2023/08/06/article113/"/>
    <id>http://silencezheng.top/2023/08/06/article113/</id>
    <published>2023-08-06T11:16:30.000Z</published>
    <updated>2023-08-06T11:18:43.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>派生类中@EqualsAndHashCode注解使用的注意事项。</p><p>其实就是派生类什么时候需要显示指定<code>@EqualsAndHashCode(callSuper = true)</code>的问题。<br><span id="more"></span></p><h2 id="重写equals要重写hashCode"><a href="#重写equals要重写hashCode" class="headerlink" title="重写equals要重写hashCode"></a>重写equals要重写hashCode</h2><p>在 Java 中，<code>hashCode()</code> 方法用于计算对象的哈希码，而哈希码在散列数据结构中用于确定对象的存储位置。当使用散列数据结构存储对象时，首先会根据对象的哈希码来确定存储位置，然后使用 <code>equals()</code> 方法来检查是否有碰撞（即两个不同的对象有相同的哈希码）。如果 <code>hashCode()</code> 和 <code>equals()</code> 方法不一致，可能会导致以下问题：</p><ol><li><p>在散列数据结构中查找对象时，可能无法找到预期的对象，因为 <code>hashCode()</code> 不同导致对象存储在不同的位置。</p></li><li><p>当使用对象作为键（key）存储在 <code>HashMap</code> 或 <code>Hashtable</code> 中时，由于哈希码不一致，可能无法正确地查找或删除对应的值（value）。</p></li><li><p>在使用 <code>HashSet</code> 存储对象时，可能会允许重复的对象进入集合，因为 <code>HashSet</code> 使用哈希码来检查对象是否已经存在，而哈希码不同意味着对象不同，即使它们的 <code>equals()</code> 方法返回 <code>true</code>。</p></li></ol><p>为了避免这些问题，在重写 <code>equals()</code> 方法时同时重写 <code>hashCode()</code> 方法，并且要确保两个方法在比较对象是否相等时一致。在重写 <code>hashCode()</code> 方法时，应该确保相等的对象返回相同的哈希码，这样可以保证对象在散列数据结构中能够正确存储和检索。</p><h2 id="EqualsAndHashCode注解的callSuper属性"><a href="#EqualsAndHashCode注解的callSuper属性" class="headerlink" title="@EqualsAndHashCode注解的callSuper属性"></a>@EqualsAndHashCode注解的callSuper属性</h2><p><code>@EqualsAndHashCode</code> 是 Lombok 注解中的一个，用于自动生成 <code>equals()</code> 和 <code>hashCode()</code> 方法。其中，<code>callSuper</code> 属性是一个布尔值，用于指定是否在生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法中调用父类的对应方法。</p><p>默认情况下，<code>callSuper</code> 属性的值为 <code>false</code>，即不调用父类的 <code>equals()</code> 和 <code>hashCode()</code> 方法。这意味着如果一个类继承自另一个类并使用 <code>@EqualsAndHashCode</code> 注解来生成方法，它只会考虑自己的成员变量，不考虑从父类继承的成员变量。</p><p>当 <code>callSuper</code> 属性的值为 <code>true</code> 时，Lombok 会在生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法中调用父类的对应方法。这样做可以确保在比较两个对象是否相等时，除了考虑子类自己的成员变量外，还会考虑父类的成员变量。这对于包含继承关系的类结构是很有用的，因为它保证了在比较对象时考虑了所有继承链上的成员变量。</p><h2 id="派生类需要显示指定-EqualsAndHashCode-callSuper-true"><a href="#派生类需要显示指定-EqualsAndHashCode-callSuper-true" class="headerlink" title="派生类需要显示指定@EqualsAndHashCode(callSuper = true)"></a>派生类需要显示指定@EqualsAndHashCode(callSuper = true)</h2><p>现在来解释为什么在派生类上已经有 <code>@Data</code> 注解时，仍然需要加入 <code>@EqualsAndHashCode(callSuper = true)</code> 注解：</p><ol><li><p>如果在派生类上仅使用 <code>@Data</code> 注解而没有 <code>@EqualsAndHashCode</code> 注解，那么生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法只会考虑派生类自己的成员变量，而不会考虑从父类继承的成员变量。这可能会导致在比较对象时忽略了所包含的父类属性，从而出现错误的结果。</p></li><li><p>如果在派生类上同时使用 <code>@Data</code> 和 <code>@EqualsAndHashCode(callSuper = true)</code> 注解，那么生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法会考虑派生类自己的成员变量，同时也会调用父类的对应方法，确保了继承链上所有成员变量都会被考虑在内。</p></li></ol><p>综上，当派生类需要考虑继承自父类的成员变量时，应该在派生类上使用 <code>@EqualsAndHashCode(callSuper = true)</code> 注解。而如果派生类只需要考虑自己的成员变量，不涉及继承关系，那么可以仅使用 <code>@Data</code> 注解而不添加 <code>@EqualsAndHashCode</code> 注解。</p><h2 id="Lombok全局配置callSuper"><a href="#Lombok全局配置callSuper" class="headerlink" title="Lombok全局配置callSuper"></a>Lombok全局配置callSuper</h2><p>在 Lombok 中，全局配置 <code>callSuper</code> 属性可以通过使用配置文件或在注解处理器的命令行参数中设置。这样可以为整个项目中的所有类统一配置 <code>callSuper</code> 属性的默认值。</p><p>在项目中配置 Lombok 的全局属性有以下两种方法：</p><ol><li>使用 <code>lombok.config</code> 文件：</li></ol><p>在项目的根目录（通常可以放在<code>src/main/java</code>下）下创建一个名为 <code>lombok.config</code> 的文件，并在该文件中添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明该配置文件是一个根配置文件，从该配置文件所在的目录开始扫描</span></span><br><span class="line"><span class="attr">config.stopBubbling</span>=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 全局配置 equalsAndHashCode 的 callSuper 属性为true</span></span><br><span class="line"><span class="attr">lombok.equalsAndHashCode.callSuper</span>=call</span><br></pre></td></tr></table></figure><p>这样，所有使用 <code>@EqualsAndHashCode</code> 注解的类都会自动设置 <code>callSuper</code> 属性为 <code>true</code>，即在生成的 <code>equals()</code> 和 <code>hashCode()</code> 方法中调用父类的对应方法。</p><ol><li>使用注解处理器的命令行参数：</li></ol><p>在构建工具中配置注解处理器的命令行参数，将 <code>lombok.equalsAndHashCode.callSuper</code> 设置为 <code>true</code>。具体方法根据使用的构建工具有所不同：</p><ul><li>对于 Maven，可以在 <code>pom.xml</code> 文件中添加以下配置：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArg</span>&gt;</span>-Alombok.equalsAndHashCode.callSuper=true<span class="tag">&lt;/<span class="name">compilerArg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意替换 <code>$&#123;lombok.version&#125;</code> 为你使用的 Lombok 版本。</p><ul><li>对于 Gradle，可以在 <code>build.gradle</code> 文件中添加以下配置（不一定对）：</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    annotationProcessor <span class="string">&quot;org.projectlombok:lombok:$&#123;lombokVersion&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    <span class="keyword">options</span>.compilerArgs &lt;&lt; <span class="string">&quot;-Alombok.equalsAndHashCode.callSuper=true&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意替换 <code>lombokVersion</code> 为你使用的 Lombok 版本。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/460297314">https://zhuanlan.zhihu.com/p/460297314</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;派生类中@EqualsAndHashCode注解使用的注意事项。&lt;/p&gt;
&lt;p&gt;其实就是派生类什么时候需要显示指定&lt;code&gt;@EqualsAndHashCode(callSuper = true)&lt;/code&gt;的问题。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate--SpringBoot接口调用整合</title>
    <link href="http://silencezheng.top/2023/08/06/article112/"/>
    <id>http://silencezheng.top/2023/08/06/article112/</id>
    <published>2023-08-06T10:48:12.000Z</published>
    <updated>2023-08-06T10:56:05.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring Boot整合RestTemplate实现接口调用入门。</p><span id="more"></span><h2 id="什么是RestTemplate"><a href="#什么是RestTemplate" class="headerlink" title="什么是RestTemplate"></a>什么是RestTemplate</h2><p><code>RestTemplate</code>是Spring框架中提供的用于以同步方式发送HTTP请求和处理HTTP响应的类。它是一个用于访问RESTful服务的模板类，简化了在Java应用程序中进行HTTP通信的过程。</p><p><code>RestTemplate</code>提供了一系列方法来执行HTTP请求，例如GET、POST、PUT、DELETE等，并能够自动将HTTP响应转换为Java对象（如JSON转换为POJO）。它支持各种HTTP协议，如HTTP、HTTPS，并且可以与其他Spring框架组件（如Spring MVC和Spring Boot）无缝集成。</p><p>底层实现上，<code>RestTemplate</code>默认构造函数使用<code>java.net.HttpURLConnection</code>执行请求。用户可以通过实现<code>ClientHttpRequestFactory</code>接口来切换到不同的HTTP库。内置支持以下库：</p><ul><li>Apache HttpComponents</li><li>Netty</li><li>OkHttp</li></ul><h2 id="RestTemplate提供的方法"><a href="#RestTemplate提供的方法" class="headerlink" title="RestTemplate提供的方法"></a>RestTemplate提供的方法</h2><p>RestTemplate 提供高度封装的接口。</p><div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>getForObject</td><td>通过GET请求获取资源的表示。</td></tr><tr><td>getForEntity</td><td>通过GET请求获取资源的<code>ResponseEntity</code>（包含状态、响应头和响应体）。</td></tr><tr><td>headForHeaders</td><td>通过HEAD请求获取资源的所有头信息。</td></tr><tr><td>postForLocation</td><td>通过POST请求创建新资源，并从响应中返回Location头信息。</td></tr><tr><td>postForObject</td><td>通过POST请求创建新资源，并从响应中返回资源的表示。</td></tr><tr><td>postForEntity</td><td>通过POST请求创建新资源，并从响应中返回资源的<code>ResponseEntity</code>（包含状态、响应头和响应体）。</td></tr><tr><td>put</td><td>通过PUT请求创建或更新资源。</td></tr><tr><td>patchForObject</td><td>通过PATCH请求更新资源，并从响应中返回资源的表示。请注意，JDK HttpURLConnection不支持PATCH，但Apache HttpComponents和其他库支持。</td></tr><tr><td>delete</td><td>通过DELETE请求删除指定URI的资源。</td></tr><tr><td>optionsForAllow</td><td>通过OPTIONS请求获取资源允许的HTTP方法。</td></tr><tr><td>exchange</td><td>通用的（灵活但不局限于特定用途）请求方法，提供额外的灵活性。它接受<code>RequestEntity</code>作为输入，其中包含HTTP方法、URL、头信息和请求体，并返回<code>ResponseEntity</code>。</td></tr><tr><td>execute</td><td>最通用的执行请求的方式，完全控制请求准备和响应提取，通过回调接口实现。</td></tr></tbody></table></div><h2 id="Springboot整合RestTemplate"><a href="#Springboot整合RestTemplate" class="headerlink" title="Springboot整合RestTemplate"></a>Springboot整合RestTemplate</h2><p>分别采用默认方式和Apache HttpComponents进行实践。</p><h3 id="默认方式"><a href="#默认方式" class="headerlink" title="默认方式"></a>默认方式</h3><p>仅需要：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- author: SilenceZheng66 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加配置类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在控制器中加入<code>restTemplate</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br></pre></td></tr></table></figure></p><p>当然也可以在Service中加入：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceImpl</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.restTemplate = restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写简单的接口访问代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeHttpGetRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;https://api.example.com/data&quot;</span>;</span><br><span class="line">    ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(url, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">        String responseBody = response.getBody();</span><br><span class="line">        <span class="comment">// 处理响应数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误响应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Apache-HttpComponents发送请求"><a href="#Apache-HttpComponents发送请求" class="headerlink" title="Apache HttpComponents发送请求"></a>Apache HttpComponents发送请求</h3><p>Apache HttpComponents是一个开源的Java HTTP库，用于处理HTTP请求和响应。它是Apache软件基金会下的一个项目，提供了一组可重用的组件，可以轻松地在Java应用程序中进行HTTP通信。</p><p>Apache HttpComponents由两个子项目组成：</p><ol><li><p>HttpClient：这是一个完整的HTTP客户端库，用于发送HTTP请求和处理HTTP响应。它提供了一组简单而强大的API，可以执行各种HTTP方法（GET、POST、PUT、DELETE等），设置请求头，处理响应，处理Cookies等。</p></li><li><p>HttpCore：这是一个核心HTTP处理库，为HTTP客户端和服务器提供了低级别的HTTP支持。它定义了HTTP协议的基本元素，如请求、响应、头部、实体等，为客户端和服务器实现提供了基础功能。</p></li></ol><p>添加HttpClient依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- author: SilenceZheng66 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在配置文件中写入参数：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http_pool:</span></span><br><span class="line">  <span class="attr">max_total:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">default_max_per_route:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">connect_timeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">connection_request_timeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">socket_timeout:</span> <span class="number">65000</span></span><br><span class="line">  <span class="attr">validate_after_inactivity:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure></p><p>创建HTTP参数类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpValues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.max_total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.default_max_per_route&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPerRoute;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.connect_timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.connection_request_timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connReqTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.socket_timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> socketTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;http_pool.validate_after_inactivity&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> inactivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建配置类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> HttpValues appValues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate(httpRequestFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个自定义的 ClientHttpRequestFactory Bean。</span></span><br><span class="line"><span class="comment">     * ClientHttpRequestFactory 是 Spring 提供的用于创建 ClientHttpRequest 的工厂接口。</span></span><br><span class="line"><span class="comment">     * 这里使用了基于 Apache HttpComponents 的 HttpComponentsClientHttpRequestFactory 实现。</span></span><br><span class="line"><span class="comment">     * HttpComponentsClientHttpRequestFactory 使用了自定义的 HttpClient 对象来发送 HTTP 请求。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 ClientHttpRequestFactory 对象，用于创建 ClientHttpRequest。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">httpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 HttpComponentsClientHttpRequestFactory 对象，并传入自定义的 HttpClient。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个自定义的 HttpClient Bean。</span></span><br><span class="line"><span class="comment">     * 这个方法使用了连接池来管理 HTTP 连接，提高了性能和效率。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 HttpClient 对象，可以用于发送 HTTP 请求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpClient <span class="title">httpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Registry，用于管理不同协议的连接工厂。</span></span><br><span class="line">        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span><br><span class="line">                <span class="comment">// 注册 HTTP 协议的连接工厂，使用默认的 PlainConnectionSocketFactory。</span></span><br><span class="line">                .register(<span class="string">&quot;http&quot;</span>, PlainConnectionSocketFactory.getSocketFactory())</span><br><span class="line">                <span class="comment">// 注册 HTTPS 协议的连接工厂，使用默认的 SSLConnectionSocketFactory。</span></span><br><span class="line">                .register(<span class="string">&quot;https&quot;</span>, SSLConnectionSocketFactory.getSocketFactory())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个连接池管理器，用于管理连接的复用和回收。</span></span><br><span class="line">        PoolingHttpClientConnectionManager connectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager(registry);</span><br><span class="line">        <span class="comment">// 设置连接池的最大连接数。</span></span><br><span class="line">        connectionManager.setMaxTotal(appValues.getMaxTotal());</span><br><span class="line">        <span class="comment">// 设置每个路由的最大连接数。</span></span><br><span class="line">        connectionManager.setDefaultMaxPerRoute(appValues.getMaxPerRoute());</span><br><span class="line">        <span class="comment">// 设置连接空闲多长时间后进行验证，避免空闲连接过多占用资源。</span></span><br><span class="line">        connectionManager.setValidateAfterInactivity(appValues.getInactivity());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个请求配置对象，用于设置连接超时和读写超时等参数。</span></span><br><span class="line">        RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">                <span class="comment">// 服务器返回数据的时间，超过该时间将抛出 read timeout 异常。</span></span><br><span class="line">                .setSocketTimeout(appValues.getSocketTimeout())</span><br><span class="line">                <span class="comment">// 连接上服务器的时间，超过该时间将抛出 connect timeout 异常。</span></span><br><span class="line">                .setConnectTimeout(appValues.getConnTimeOut())</span><br><span class="line">                <span class="comment">// 从连接池中获取连接的超时时间，超过该时间将抛出 ConnectionPoolTimeoutException 异常。</span></span><br><span class="line">                .setConnectionRequestTimeout(appValues.getConnReqTimeOut())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 HttpClientBuilder 创建一个 HttpClient 对象，并设置连接池管理器和请求配置。</span></span><br><span class="line">        <span class="keyword">return</span> HttpClientBuilder.create()</span><br><span class="line">                .setDefaultRequestConfig(requestConfig)</span><br><span class="line">                .setConnectionManager(connectionManager)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/students/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Students&gt; <span class="title">getStudentById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">    Students student = studentsService.getById(id);</span><br><span class="line">    <span class="keyword">if</span> (student != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果找到学生，返回状态码200 OK和学生对象</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(student);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未找到学生，返回状态码404 NOT FOUND</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/rest/get/students+1/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">restGetTest</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;http://localhost:48081/students/&quot;</span> + String.valueOf(id+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里应该加入异常处理</span></span><br><span class="line">    ResponseEntity&lt;Students&gt; response = restTemplate.getForEntity(url, Students.class);</span><br><span class="line">    <span class="comment">// 获取响应</span></span><br><span class="line">    <span class="keyword">if</span> (response.getStatusCode().is2xxSuccessful()) &#123;</span><br><span class="line">        Students responseBody = response.getBody();</span><br><span class="line">        <span class="keyword">if</span> (responseBody!=<span class="keyword">null</span>) <span class="keyword">return</span> ResponseEntity.ok(responseBody.toString());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(<span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">        <span class="comment">// 处理响应数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误响应</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(<span class="string">&quot;Bad Request&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于带路径参数的URL，可以用这种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line">String url = <span class="string">&quot;http://localhost:48081/students/&#123;1&#125;&quot;</span>;</span><br><span class="line">ResponseEntity&lt;Students&gt; response = restTemplate.getForEntity(url, Students.class, id+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>对于添加请求头、Cookie、文件上传等等更多用法，在使用时查阅、积累即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/spring-framework-reference/integration.html#rest-resttemplate">https://docs.spring.io/spring-framework/docs/5.1.9.RELEASE/spring-framework-reference/integration.html#rest-resttemplate</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/258121569">https://zhuanlan.zhihu.com/p/258121569</a><br>[3] <a href="https://www.cnblogs.com/javazhiyin/p/9851775.html">https://www.cnblogs.com/javazhiyin/p/9851775.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring Boot整合RestTemplate实现接口调用入门。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
</feed>
