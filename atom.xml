<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenceZheng66-BLOG</title>
  
  <subtitle>silencezheng.top</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2024-08-19T15:25:11.209Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>SilenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>xxl-job源码阅读（一）：定时任务执行链路分析</title>
    <link href="http://silencezheng.top/2024/08/19/article135/"/>
    <id>http://silencezheng.top/2024/08/19/article135/</id>
    <published>2024-08-19T15:15:50.000Z</published>
    <updated>2024-08-19T15:25:11.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>xxl-job源码阅读第一章：定时任务执行链路分析</p><p>一时兴起，花一下午看了一遍这部分源码，写的不错。</p><p>PS：写完才发现有官方文档讲解…尴尬😅<br><span id="more"></span></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="部署xxl-job-admin"><a href="#部署xxl-job-admin" class="headerlink" title="部署xxl-job-admin"></a>部署xxl-job-admin</h2><p>官网文档秒了。</p><p>地址：<a href="https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8</a></p><h2 id="装载配置类"><a href="#装载配置类" class="headerlink" title="装载配置类"></a>装载配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandlerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses:http://ip:8008/xxl-job-admin-1.8.2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname:appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath:./xxlLogs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        XxlJobExecutor xxlJobExecutor = <span class="keyword">new</span> XxlJobExecutor();</span><br><span class="line">        xxlJobExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobExecutor.setAppName(appName);</span><br><span class="line">        xxlJobExecutor.setLogPath(logPath);</span><br><span class="line">        <span class="keyword">return</span> xxlJobExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现任务接口"><a href="#实现任务接口" class="headerlink" title="实现任务接口"></a>实现任务接口</h2><p>注意两点：</p><ol><li><code>@JobHandler</code>注解用于唯一识别任务</li><li>实现了<code>IJobHandler</code>接口才会被加载到任务列表中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@JobHandler(value = &quot;AutoSendEmailScheduler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoSendEmailScheduler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdenAutoUpdateAndSendEmail uniqueIdenAutoUpdateAndSendEmail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String startDate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler start, startDate:&#123;&#125;&quot;</span>, startDate);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ReturnT&lt;String&gt; result = <span class="keyword">new</span> ReturnT&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uniqueIdenAutoUpdateAndSendEmail.autoSendEmail(startDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;AutoSendEmailScheduler fail, startDate:&#123;&#125;&quot;</span>, startDate, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setCode(SUCCESS_CODE);</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler end, cost &#123;&#125;ms&quot;</span>, System.currentTimeMillis() - start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Xxl-job-Server端源码分析"><a href="#Xxl-job-Server端源码分析" class="headerlink" title="Xxl-job Server端源码分析"></a>Xxl-job Server端源码分析</h1><p>版本：xxl-job-core1.9.1</p><h2 id="统一入口-—-执行器"><a href="#统一入口-—-执行器" class="headerlink" title="统一入口 — 执行器"></a>统一入口 — 执行器</h2><p>执行器即<code>XxlJobExecutor</code>，被注册为上下文，主要是为了能用<code>ApplicationContext</code>获取各种信息，例如Bean信息等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="加载任务处理器"><a href="#加载任务处理器" class="headerlink" title="加载任务处理器"></a>加载任务处理器</h3><p>把刚才自己定义的定时任务处理器和其他所有加入了<code>@JobHandler</code>注解的类加载进来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, IJobHandler&gt; jobHandlerRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IJobHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IJobHandler <span class="title">registJobHandler</span><span class="params">(String name, IJobHandler jobHandler)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobHandlerRepository.put(name, jobHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initJobHandlerRepository</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init job handler action</span></span><br><span class="line">    Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceBeanMap!=<span class="keyword">null</span> &amp;&amp; serviceBeanMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (serviceBean <span class="keyword">instanceof</span> IJobHandler)&#123;</span><br><span class="line">                String name = serviceBean.getClass().getAnnotation(JobHandler.class).value();</span><br><span class="line">                IJobHandler handler = (IJobHandler) serviceBean;</span><br><span class="line">                <span class="keyword">if</span> (loadJobHandler(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;xxl-job jobhandler naming conflicts.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                registJobHandler(name, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化客户端（调度中心）"><a href="#初始化客户端（调度中心）" class="headerlink" title="初始化客户端（调度中心）"></a>初始化客户端（调度中心）</h3><p>xxl-job是C/S架构的，客户端是RPC服务的调用者，即<code>xxl-job-admin</code>，带有一个前端。这里可以有多个调度中心，是因为支持集群部署。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adminAddresses!=<span class="keyword">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (address!=<span class="keyword">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// http://ip:port/xxl-job-admin-1.8.2 + /api</span></span><br><span class="line">                String addressUrl = address.concat(AdminBiz.MAPPING);</span><br><span class="line">                AdminBiz adminBiz = (AdminBiz) <span class="keyword">new</span> NetComClientProxy(AdminBiz.class, addressUrl, accessToken).getObject();</span><br><span class="line">                <span class="keyword">if</span> (adminBizList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    adminBizList = <span class="keyword">new</span> ArrayList&lt;AdminBiz&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                adminBizList.add(adminBiz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; <span class="title">getAdminBizList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminBizList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化RPC服务器工厂"><a href="#初始化RPC服务器工厂" class="headerlink" title="初始化RPC服务器工厂"></a>初始化RPC服务器工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetComServerFactory serverFactory = <span class="keyword">new</span> NetComServerFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExecutorServer</span><span class="params">(<span class="keyword">int</span> port, String ip, String appName, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// valid param</span></span><br><span class="line">    port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start server</span></span><br><span class="line">    NetComServerFactory.putService(ExecutorBiz.class, <span class="keyword">new</span> ExecutorBizImpl());   <span class="comment">// rpc-service, base on jetty</span></span><br><span class="line">    NetComServerFactory.setAccessToken(accessToken);</span><br><span class="line">    serverFactory.start(port, ip, appName); <span class="comment">// jetty + registry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务执行线程池"><a href="#任务执行线程池" class="headerlink" title="任务执行线程池"></a>任务执行线程池</h3><p>并没有用线程池，而是一个并发哈希表。这里有个疑问，如果并发线程量过大是不是有安全问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, JobThread&gt; JobThreadRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">registJobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread newJobThread = <span class="keyword">new</span> JobThread(jobId, handler);</span><br><span class="line">    newJobThread.start();</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job regist JobThread success, jobId:&#123;&#125;, handler:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;jobId, handler&#125;);</span><br><span class="line"></span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.put(jobId, newJobThread);  <span class="comment">// putIfAbsent | oh my god, map&#x27;s put method return the old value!!!</span></span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newJobThread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeJobThread</span><span class="params">(<span class="keyword">int</span> jobId, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.remove(jobId);</span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">loadJobThread</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>&#123;</span><br><span class="line">    JobThread jobThread = JobThreadRepository.get(jobId);</span><br><span class="line">    <span class="keyword">return</span> jobThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>该服务器用于获取请求、执行任务，是核心的执行逻辑。</p><p>主体是封装了一个jetty服务器（servlet容器，HTTP协议），利用反射实现服务调用。</p><p>相关类如下：</p><ul><li>NetComServerFactory：RPC服务器工厂类，同时负责维护RPC服务。</li><li>JettyServer：核心类，真正运行的服务器。</li><li>JettyServerHandler：jetty的handler，负责执行任务。</li><li>ExecutorBiz：包含RPC方法的接口，被工厂类加载并执行请求调用的RPC方法。</li><li>ExecutorBizImpl：真正提供服务的类，实现了ExecutorBiz接口。</li><li>JobThread：真正执行任务（完成Job）的线程，维护一个阻塞队列用于执行任务。</li><li>ExecutorRegistryThread：用于将服务器注册到客户端上，或取消注册。</li><li>TriggerCallbackThread：维护一个阻塞队列，用于对任务执行结果实施callback。</li></ul><h3 id="NetComServerFactory"><a href="#NetComServerFactory" class="headerlink" title="NetComServerFactory"></a>NetComServerFactory</h3><p>入口中初始化的就是这个Server工厂，工厂里面内容很简单，简化后如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器，核心类</span></span><br><span class="line">JettyServer server = <span class="keyword">new</span> JettyServer(); <span class="comment">//有start(), destroy()两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC服务存储，通过反射加载进来</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 认证token，携带正确token的请求才能被执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中放入ExecutorBiz的方法，Key是接口名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putService</span><span class="params">(Class&lt;?&gt; iface, Object serviceBean)</span></span>&#123;</span><br><span class="line">    serviceMap.put(iface.getName(), serviceBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化中设置token的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAccessToken</span><span class="params">(String accessToken)</span> </span>&#123;</span><br><span class="line">    NetComServerFactory.accessToken = accessToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正实现RPC服务调用的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcResponse <span class="title">invokeService</span><span class="params">(RpcRequest request, Object serviceBean)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">        String methodName = request.getMethodName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] parameters = request.getParameters();</span><br><span class="line"></span><br><span class="line">        FastClass serviceFastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">        Object result = serviceFastMethod.invoke(serviceBean, parameters);</span><br><span class="line"></span><br><span class="line">        response.setResult(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        response.setError(t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JettyServer"><a href="#JettyServer" class="headerlink" title="JettyServer"></a>JettyServer</h3><p><code>JettyServer</code>包含服务器（非阻塞线程池）、注册线程、回调线程三部分。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> String ip, <span class="keyword">final</span> String appName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The Server</span></span><br><span class="line">                server = <span class="keyword">new</span> Server(<span class="keyword">new</span> ExecutorThreadPool());  <span class="comment">// 非阻塞</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// HTTP connector</span></span><br><span class="line">                ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);</span><br><span class="line">                connector.setHost(ip);</span><br><span class="line">                connector.setPort(port);</span><br><span class="line">                server.setConnectors(<span class="keyword">new</span> Connector[]&#123;connector&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set a handler</span></span><br><span class="line">                HandlerCollection handlerc =<span class="keyword">new</span> HandlerCollection();</span><br><span class="line">                handlerc.setHandlers(<span class="keyword">new</span> Handler[]&#123;<span class="keyword">new</span> JettyServerHandler()&#125;);</span><br><span class="line">                server.setHandler(handlerc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start server</span></span><br><span class="line">                server.start();</span><br><span class="line">                <span class="comment">// Start Registry-Server</span></span><br><span class="line">                ExecutorRegistryThread.getInstance().start(port, ip, appName);</span><br><span class="line">                <span class="comment">// Start Callback-Server</span></span><br><span class="line">                TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">                server.join();  <span class="comment">// block until thread stopped</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// daemon, service jvm, user thread leave &gt;&gt;&gt; daemon leave &gt;&gt;&gt; jvm leave</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destroy Registry-Server</span></span><br><span class="line">        ExecutorRegistryThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// destroy Callback-Server</span></span><br><span class="line">        TriggerCallbackThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// 关闭服务器</span></span><br><span class="line">        server.stop();</span><br><span class="line">        server.destroy();</span><br><span class="line">        <span class="comment">// 关闭总线程</span></span><br><span class="line">        <span class="keyword">if</span> (thread.isAlive()) &#123;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是这里的<code>ExecutorThreadPool</code>是jetty自己封装的<code>ThreadPoolExecutor</code>，最大线程池大小为256, 线程timeout为1分钟，并使用了<code>Unbounded LinkedBlockingQueue</code>作为任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using an unbounded queue makes the maxThreads parameter useless</span></span><br><span class="line">    <span class="comment">// Refer to ThreadPoolExecutor javadocs for details</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">256</span>, <span class="number">256</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JettyServerHandler"><a href="#JettyServerHandler" class="headerlink" title="JettyServerHandler"></a>JettyServerHandler</h3><p>这个类就是用来衔接jetty接到的请求和实际处理方法<code>NetComServerFactory#invokeService</code>的，对入参出参和异常进行一些处理。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServerHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// invoke</span></span><br><span class="line">        RpcResponse rpcResponse = doInvoke(request);</span><br><span class="line">        <span class="comment">// serialize response</span></span><br><span class="line">        <span class="keyword">byte</span>[] responseBytes = HessianSerializer.serialize(rpcResponse);</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        baseRequest.setHandled(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        out.write(responseBytes);</span><br><span class="line">        out.flush();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RpcResponse <span class="title">doInvoke</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// deserialize request</span></span><br><span class="line">            <span class="keyword">byte</span>[] requestBytes = HttpClientUtil.readBytes(request);</span><br><span class="line">            <span class="keyword">if</span> (requestBytes == <span class="keyword">null</span> || requestBytes.length==<span class="number">0</span>) &#123;</span><br><span class="line">                RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                rpcResponse.setError(<span class="string">&quot;RpcRequest byte[] is null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> rpcResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) HessianSerializer.deserialize(requestBytes, RpcRequest.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// invoke</span></span><br><span class="line">            RpcResponse rpcResponse = NetComServerFactory.invokeService(rpcRequest, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            rpcResponse.setError(<span class="string">&quot;Server-error:&quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ExecutorBizImpl"><a href="#ExecutorBizImpl" class="headerlink" title="ExecutorBizImpl"></a>ExecutorBizImpl</h3><p>真正执行任务的类，实现了<code>ExecutorBiz</code>接口。</p><p><code>ExecutorBiz</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorBiz</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 心跳，用于确认服务器状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">beat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 判断任务是否在执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">idleBeat</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 终止任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">kill</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 读日志，返回日志内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;LogResult&gt; <span class="title">log</span><span class="params">(<span class="keyword">long</span> logDateTim, <span class="keyword">int</span> logId, <span class="keyword">int</span> fromLineNum)</span></span>;</span><br><span class="line">    <span class="comment">// 根据参数执行任务，TriggerParam里携带jobId</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ExecutorBizImpl</code>通过上下文<code>XxlJobExecutor</code>获取资源（例如<code>JobThread</code>）实现各个功能，这里我们只关注<code>run</code>方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加载已有线程，没有则都置为空</span></span><br><span class="line">    <span class="comment">// load old：jobHandler + jobThread</span></span><br><span class="line">    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());</span><br><span class="line">    IJobHandler jobHandler = jobThread!=<span class="keyword">null</span>?jobThread.getHandler():<span class="keyword">null</span>;</span><br><span class="line">    String removeOldReason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有几种执行模式，bean、glue和script，通常自己实现的是用bean模式，需要验证一下</span></span><br><span class="line">    <span class="comment">// 验证如果原来的jobHandler不对，那么也要置空</span></span><br><span class="line">    <span class="comment">// valid：jobHandler + jobThread</span></span><br><span class="line">    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());</span><br><span class="line">    <span class="keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// new jobhandler</span></span><br><span class="line">        IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        <span class="keyword">if</span> (jobThread!=<span class="keyword">null</span> &amp;&amp; jobHandler != newJobHandler) &#123;</span><br><span class="line">            <span class="comment">// change handler, need kill old thread</span></span><br><span class="line">            removeOldReason = <span class="string">&quot;更换JobHandler或更换任务模式,终止旧任务线程&quot;</span>;</span><br><span class="line">            jobThread = <span class="keyword">null</span>;</span><br><span class="line">            jobHandler = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = newJobHandler;</span><br><span class="line">            <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job handler [&quot;</span> + triggerParam.getExecutorHandler() + <span class="string">&quot;] not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());</span><br><span class="line">                jobHandler = <span class="keyword">new</span> GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (glueTypeEnum!=<span class="keyword">null</span> &amp;&amp; glueTypeEnum.isScript()) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = <span class="keyword">new</span> ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;glueType[&quot;</span> + triggerParam.getGlueType() + <span class="string">&quot;] is not valid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据设置的阻塞策略，选择是否丢弃已有线程</span></span><br><span class="line">    <span class="comment">// executor block strategy</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// discard when running</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;阻塞处理策略-生效：&quot;</span>+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// kill running jobThread</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                removeOldReason = <span class="string">&quot;阻塞处理策略-生效：&quot;</span> + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();</span><br><span class="line">                jobThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just queue trigger</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册新的任务线程并添加任务</span></span><br><span class="line">    <span class="comment">// replace thread (new or exists invalid)</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push data to queue</span></span><br><span class="line">    ReturnT&lt;String&gt; pushResult = jobThread.pushTriggerQueue(triggerParam);</span><br><span class="line">    <span class="keyword">return</span> pushResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JobThread"><a href="#JobThread" class="headerlink" title="JobThread"></a>JobThread</h3><p>这是最终执行任务的线程，通过前面的分析可以看到，一项任务被最终交付给了TriggerQueue，并等待完成执行回调实现异步执行。</p><p>那么什么是TriggerQueue？它是一个存放Trigger参数的<code>LinkedBlockingQueue</code>阻塞队列，用于存放待执行的任务。</p><p><code>JobThread</code>会按指定的时间间隔轮询该队列，尝试取出任务执行。任务执行结束后，将结果交给Callback线程执行回调。</p><p>还有一些其他细节，例如唯一日志ID的维护（通过Set），终止任务的实现（多种情况），可以参考代码分析。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(JobThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> jobId;</span><br><span class="line">    <span class="keyword">private</span> IJobHandler handler;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;TriggerParam&gt; triggerQueue;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashSet&lt;Integer&gt; triggerLogIdSet;     <span class="comment">// avoid repeat trigger for the same TRIGGER_LOG_ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String stopReason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;    <span class="comment">// if running job</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleTimes = <span class="number">0</span>;          <span class="comment">// idel times</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobId = jobId;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.triggerQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;TriggerParam&gt;();</span><br><span class="line">        <span class="keyword">this</span>.triggerLogIdSet = <span class="keyword">new</span> ConcurrentHashSet&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IJobHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new trigger to queue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> triggerParam</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">pushTriggerQueue</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// avoid repeat</span></span><br><span class="line">        <span class="keyword">if</span> (triggerLogIdSet.contains(triggerParam.getLogId())) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; repeate trigger job, logId:&#123;&#125;&quot;</span>, triggerParam.getLogId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;repeate trigger job, logId:&quot;</span> + triggerParam.getLogId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        triggerLogIdSet.add(triggerParam.getLogId());</span><br><span class="line">        triggerQueue.add(triggerParam);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kill job thread</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stopReason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">(String stopReason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread.interrupt只支持终止线程的阻塞状态(wait、join、sleep)，</span></span><br><span class="line"><span class="comment">         * 在阻塞出抛出InterruptedException异常,但是并不会终止运行的线程本身；</span></span><br><span class="line"><span class="comment">         * 所以需要注意，此处彻底销毁本线程，需要通过共享变量方式；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.stopReason = stopReason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is running job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunningOrHasQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> running || triggerQueue.size()&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute</span></span><br><span class="line">        <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">            idleTimes++;</span><br><span class="line"></span><br><span class="line">            TriggerParam triggerParam = <span class="keyword">null</span>;</span><br><span class="line">            ReturnT&lt;String&gt; executeResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// to check toStop signal, we need cycle, so wo cannot use queue.take(), instand of poll(timeout)</span></span><br><span class="line">                triggerParam = triggerQueue.poll(<span class="number">3L</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    running = <span class="keyword">true</span>;</span><br><span class="line">                    idleTimes = <span class="number">0</span>;</span><br><span class="line">                    triggerLogIdSet.remove(triggerParam.getLogId());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// log filename, like &quot;logPath/yyyy-MM-dd/9999.log&quot;</span></span><br><span class="line">                    String logFileName = XxlJobFileAppender.makeLogFileName(<span class="keyword">new</span> Date(triggerParam.getLogDateTim()), triggerParam.getLogId());</span><br><span class="line">                    XxlJobFileAppender.contextHolder.set(logFileName);</span><br><span class="line">                    ShardingUtil.setShardingVo(<span class="keyword">new</span> ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// execute</span></span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute start -----------&lt;br&gt;----------- Param:&quot;</span> + triggerParam.getExecutorParams());</span><br><span class="line">                    executeResult = handler.execute(triggerParam.getExecutorParams());</span><br><span class="line">                    <span class="keyword">if</span> (executeResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        executeResult = IJobHandler.FAIL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(finish) -----------&lt;br&gt;----------- ReturnT:&quot;</span> + executeResult);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (idleTimes &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                        XxlJobExecutor.removeJobThread(jobId, <span class="string">&quot;excutor idel times over limit.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (toStop) &#123;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread toStop, stopReason:&quot;</span> + stopReason);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">                e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));</span><br><span class="line">                String errorMsg = stringWriter.toString();</span><br><span class="line">                executeResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, errorMsg);</span><br><span class="line"></span><br><span class="line">                XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread Exception:&quot;</span> + errorMsg + <span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(error) -----------&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(triggerParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// callback handler info</span></span><br><span class="line">                    <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                        <span class="comment">// commonm</span></span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), executeResult));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// is killed</span></span><br><span class="line">                        ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [业务运行中，被强制终止]&quot;</span>);</span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback trigger request in queue</span></span><br><span class="line">        <span class="keyword">while</span>(triggerQueue !=<span class="keyword">null</span> &amp;&amp; triggerQueue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TriggerParam triggerParam = triggerQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// is killed</span></span><br><span class="line">                ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [任务尚未执行，在调度队列中被终止]&quot;</span>);</span><br><span class="line">                TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// destroy</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job JobThread stoped, hashCode:&#123;&#125;&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TriggerCallbackThread"><a href="#TriggerCallbackThread" class="headerlink" title="TriggerCallbackThread"></a>TriggerCallbackThread</h3><p>回调线程，用于处理执行完的任务结果，通知调度中心执行完毕。</p><p>同样的，使用一个阻塞队列存放待回调的执行结果。</p><p>代码简化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriggerCallbackThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TriggerCallbackThread instance = <span class="keyword">new</span> TriggerCallbackThread();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TriggerCallbackThread <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// job results callback queue</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt; callBackQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pushCallBack</span><span class="params">(HandleCallbackParam callback)</span></span>&#123;</span><br><span class="line">        getInstance().callBackQueue.add(callback);</span><br><span class="line">        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, push callback request, logId:&#123;&#125;&quot;</span>, callback.getLogId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callback thread</span></span><br><span class="line">    <span class="keyword">private</span> Thread triggerCallbackThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        triggerCallbackThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// normal callback</span></span><br><span class="line">                <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        HandleCallbackParam callback = getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// callback list param</span></span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line">                            <span class="comment">// callback, will retry if error</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// last callback</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                    <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                    <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        doCallback(callbackParamList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        triggerCallbackThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        triggerCallbackThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// interrupt and wait</span></span><br><span class="line">        triggerCallbackThread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerCallbackThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do callback, will retry if error</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span></span>&#123;</span><br><span class="line">        <span class="comment">// callback, will retry if error</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="keyword">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackResult = ReturnT.SUCCESS;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback success, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback fail, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback error, callbackParamList：&#123;&#125;&quot;</span>, callbackParamList, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>总结一下，一个定时任务（run请求）从调度中心出发到执行完毕的链路为：<br><code>JettyServer</code>-&gt;<br>    <code>JettyServerHandler</code>-&gt;<br>        <code>NetComServerFactory#invokeService</code>-&gt;<br>            <code>ExecutorBizImpl#run</code>-&gt;<br>                    <code>JobThread</code>-&gt;<br>                        <code>TriggerCallbackThread</code>-&gt;<br>                            <code>AdminBiz#callback</code></p><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;xxl-job源码阅读第一章：定时任务执行链路分析&lt;/p&gt;
&lt;p&gt;一时兴起，花一下午看了一遍这部分源码，写的不错。&lt;/p&gt;
&lt;p&gt;PS：写完才发现有官方文档讲解…尴尬😅&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="xxl-job" scheme="http://silencezheng.top/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP3</title>
    <link href="http://silencezheng.top/2024/08/18/article134/"/>
    <id>http://silencezheng.top/2024/08/18/article134/</id>
    <published>2024-08-18T15:32:17.000Z</published>
    <updated>2024-08-18T15:33:52.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。</p><p>本周主题：动态规划、贪心</p><p>题目：</p><ul><li>240619每日一题—<a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description">Maximum Strictly Increasing Cells in a Matrix</a></li><li>240622每日一题—<a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">Lexicographically Smallest Beautiful String</a><span id="more"></span>这两道Hard题稍微看看理解一下就行了，暂时没太多可归纳的，可记忆的点就是二维排序和回文判别（只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串）。</li></ul><h1 id="动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix"><a href="#动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix" class="headerlink" title="动态规划 — Maximum Strictly Increasing Cells in a Matrix"></a>动态规划 — Maximum Strictly Increasing Cells in a Matrix</h1><blockquote><p>Maximum Strictly Increasing Cells in a Matrix</p><p>Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell.</p><p>From the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p><p>Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.</p><p>Return an integer denoting the maximum number of cells that can be visited.</p></blockquote><p>设 <strong>$d[i][j]$ 为移动到单元格 $(i, j)$ 的最大步数</strong>, 其中 $(i, j)$ 可以作为起始单元格, 也可以是从其他单元格移动而来。那么我们会考虑从第 $i$ 行以及第 $j$ 列上矩阵数值小于 $\operatorname{mat}[i][j]$ 的位置进行转移, 即取以下数值中的最大值:</p><ul><li>第 $i$ 行： $\max \left(d[i]\left[j^{\prime}\right]+1\right)$ ，其中 $\operatorname{mat}[i]\left[j^{\prime}\right]&lt;\operatorname{mat}[i][j]$ ；</li><li>第 $j$ 列： $\max \left(d\left[l^{\prime}\right][j]+1\right)$ ，其中 $\operatorname{mat}\left[i^{\prime}\right][j]&lt;\operatorname{mat}[[][j]$ 。</li></ul><p>因此, 整个状态空间在进行转移时是有序的, 我们可以对 mat 进行排序, 从小到大进行转移。但在转移时, 每个状态都要扫描一遍对应的行和列, 时间复杂度为 $O(n+m)$, 而整体求解的时间复杂度为 $O(n m(n+m))$, 可能会超时, 因此需要进行优化。</p><p>考虑到所有的 $d[i][j]$ 在更新时, 值只会越来越大, 而转移过程中我们只考虑对应行和对应列上 $d$ 的最大值（由于大于 mat $[i][j]$ 的位置还末遍历到, 它们的状态还末更新, 可设置为 0 )。因此, 设置长度为 $m$ 的数组 row 来维护每一行 $d$ 的最大值, 设置长度为 $n$ 的数组 $c o l$ 来维护每一列的最大值，这样一来:</p><script type="math/tex; mode=display">d[i][j]=\max (\operatorname{row}[i], \operatorname{col}[j])+1</script><p>在每次更新了 $d[i][j]$ 后, 需要更新 $r o w[i]$ 和 $col[j]$ 。另外需要注意的是, 由于 mat 中可能包含相同数字, 我们需要同时更新它们的 $d$ 值, 然后再同时更新它们对应的 row 和 col。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIncreasingCells</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                mp.putIfAbsent(mat[i][j], <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">                mp.get(mat[i][j]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(mp.keySet());</span><br><span class="line">        Collections.sort(keys);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keys) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; pos = mp.get(key);</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 存放相同数值的答案，便于后续更新 row 和 col</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : pos) &#123;</span><br><span class="line">                res.add(Math.max(row[arr[<span class="number">0</span>]], col[arr[<span class="number">1</span>]]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pos.get(i);</span><br><span class="line">                <span class="keyword">int</span> d = res.get(i);</span><br><span class="line">                row[arr[<span class="number">0</span>]] = Math.max(row[arr[<span class="number">0</span>]], d);</span><br><span class="line">                col[arr[<span class="number">1</span>]] = Math.max(col[arr[<span class="number">1</span>]], d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(row).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心-—-Lexicographically-Smallest-Beautiful-String"><a href="#贪心-—-Lexicographically-Smallest-Beautiful-String" class="headerlink" title="贪心 — Lexicographically Smallest Beautiful String"></a>贪心 — Lexicographically Smallest Beautiful String</h1><blockquote><p>Lexicographically Smallest Beautiful String</p><p>A string is beautiful if:</p><ul><li>It consists of the first k letters of the English lowercase alphabet.</li><li>It does not contain any substring of length 2 or more which is a palindrome.</li></ul><p>You are given a beautiful string s of length n and a positive integer k.</p><p>Return the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.</p><p>A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.</p><ul><li>For example, “abcd” is lexicographically larger than “abcc” because the first position they differ is at the fourth character, and d is greater than c.</li></ul></blockquote><p>首先分析一下美丽字符串的第二个条件：不包含任何长度为 2 或者更长的回文字符串。长度为 2 的回文字符串是两个相同字符构成的字符串。长度为 3 的回文字符串中也有两个相同字符，但下标之差为 2。而任何长度为 2 或者更长的回文字符串，都包含一个长度为 2 或者 3 的回文字符串。因此，<strong>只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串</strong>。</p><p>接下来看其他要求，返回的美丽字符串需要字典序大于 s 并且字典序最小。贪心的思路是修改 s 的末尾字符，一点点将字符变大，如果在变大的同时能够满足美丽字符串的两个条件，那么我们就找到了要求的美丽字符串。修改后的字符不能与前两个字符相同，因此我们在将字符变大的时候只需要将字符逐步变大三次，就能判断出修改当前字符能否满足美丽字符串的条件。如果修改末尾字符达不到美丽字符串的条件，则我们需要将被修改的字符改为倒数第二个字符，仍然按照之前的思路一点点增大，并判断是否满足美丽字符串的两个条件。我们从末尾字符开始，往前一点点判断是否可以修改当前字符来找到目标美丽字符串。一旦我们第一次找到了合适的下标，我们就可以来修改字符来达到目标条件。</p><p>首先我们需要修改寻找到的下标的字符，将其修改为最小的满足美丽字符串条件的字符。接下来需要修改它右边的字符。因为之前修改的字符已经能保证返回的字符串在字典序上大于 s，我们只需要将后续的字符修改得尽可能小即可，因为每个字符需要与前两个字符不同，因此每个字符只需要遍历 <code>‘a’∼‘c’</code> 即可。因为 $k≥ 4$，所以接下来修改的字符一定都能满足美丽字符串的条件。</p><p>在代码实现上，我们先用一个循环从 $n−1$ 开始，往前遍历来寻找第一个被修改的字符，找到之后，再用另一个函数 $generate(s,idx,offset)$ 来生成修改后的字符，其中 $idx$ 是我们找到的下标，$offset$ 是将这个下标的字符增大的偏移量。最后返回修改后的字符，如果我们未能找到目标下标，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestBeautifulString</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(s.charAt(i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// s.charAt(i) - &#x27;a&#x27; + j 需要+1才能与k比较，因为k从1计数</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) - <span class="string">&#x27;a&#x27;</span> + j + <span class="number">1</span> &lt;= k &amp;&amp; !blockedCharacters.contains((<span class="keyword">char</span>) (s.charAt(i) + j))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> generate(s, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        res[idx] += offset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(res[i - j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// abc里面一定有一个可用的，因为blockedCharacters只有两个字符</span></span><br><span class="line">                <span class="keyword">if</span> (!blockedCharacters.contains((<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j))) &#123;</span><br><span class="line">                    res[i] = (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/">https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/</a><br>[2] <a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/">https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、贪心&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240619每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description&quot;&gt;Maximum Strictly Increasing Cells in a Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240622每日一题—&lt;a href=&quot;https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/&quot;&gt;Lexicographically Smallest Beautiful String&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP2</title>
    <link href="http://silencezheng.top/2024/08/18/article133/"/>
    <id>http://silencezheng.top/2024/08/18/article133/</id>
    <published>2024-08-18T10:44:02.000Z</published>
    <updated>2024-08-18T10:52:27.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周周赛菜了…赶紧记一下。</p><p>本周主题：差分数组、动态规划</p><p>题目：</p><ul><li>240615每日一题—<a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">Maximum Beauty of an Array After Applying Operation</a></li><li>240616周赛第三题—<a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/">Maximum Total Damage With Spell Casting</a></li><li>LC198打家劫舍—<a href="https://leetcode.cn/problems/house-robber/description/">House Robber</a><span id="more"></span></li></ul><h1 id="差分数组（Difference-Array）"><a href="#差分数组（Difference-Array）" class="headerlink" title="差分数组（Difference Array）"></a>差分数组（Difference Array）</h1><p>作用：开辟一块空间用于压缩对原数组上连续子数组的操作。</p><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>考虑数组 $a=[1,3,3,5,8]$，对其中的相邻元素两两作差（右边减左边），得到数组 $[2,0,2,3]$。然后在开头补上 $a[0]$，得到差分数组：$d=[1,2,0,2,3]$</p><p>这有什么用呢？如果从左到右累加 ddd 中的元素，我们就「还原」回了 $a$ 数组 $[1,3,3,5,8]$。这类似求导与积分的概念。</p><p>这又有什么用呢？现在把连续子数组 $a[1],a[2],a[3]$ 都加上 $10$，得到 $a’=[1,13,13,15,8]$。再次两两作差，并在开头补上 $a’[0]$，得到差分数组：$d’=[1,12,0,2,−7]$</p><p>对比 $d$ 和 $d’$，可以发现只有 $d[1]$ 和 $d[4]$ 变化了，这意味着<strong>对 $a$ 中连续子数组的操作，可以转变成对差分数组 $d$ 中两个数的操作</strong>。</p><h2 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h2><p>对于数组 $a$，定义其差分数组（difference array）为</p><script type="math/tex; mode=display">d[i] = \begin{cases} a[0],&i=0\\ a[i]-a[i-1],&i\ge 1 \end{cases}​</script><p>性质 1：从左到右累加 $d$ 中的元素，可以得到数组 $a$。</p><p>性质 2：如下两个操作是等价的。</p><ul><li>把 $a$ 的子数组 $a[i],a[i+1],\cdots,a[j]$ 都加上 $x$。</li><li>把 $d[i]$ 增加 $x$，把 $d[j+1]$ 减少 $x$。</li></ul><p>利用性质 2，我们只需要 $O(1)$ 的时间就可以完成对 $a$ 的子数组的操作。最后利用性质 1 从差分数组复原出数组 $a$。</p><p>注：也可以这样理解，$d[i]$ 表示把下标 $≥i$ 的数都加上 $d[i]$。</p><h2 id="例题：Maximum-Beauty-of-an-Array-After-Applying-Operation"><a href="#例题：Maximum-Beauty-of-an-Array-After-Applying-Operation" class="headerlink" title="例题：Maximum Beauty of an Array After Applying Operation"></a>例题：Maximum Beauty of an Array After Applying Operation</h2><blockquote><p><strong>Maximum Beauty of an Array After Applying Operation</strong></p><p>You are given a 0-indexed array nums and a non-negative integer k.</p><p>In one operation, you can do the following:</p><p>Choose an index i that hasn’t been chosen before from the range [0, nums.length - 1].<br>Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].<br>The beauty of the array is the length of the longest subsequence consisting of equal elements.</p><p>Return the maximum possible beauty of the array nums after applying the operation any number of times.</p><p>Note that you can apply the operation to each index only once.</p><p>A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p><p>Constraints:</p><ul><li>1 &lt;= nums.length &lt;= 1e5</li><li>0 &lt;= nums[i], k &lt;= 1e5</li></ul></blockquote><p>自然想到的思路是把每个元素看作是一个可换空间，将所有可换空间在一个足够大的空间中进行叠加，被最多可换空间覆盖到的地方即为所求结果。或者，把每个元素考虑为对其对应可换空间中的每一个位置投一票，最终票数最多的位置为所求结果。</p><p>从数据范围上分析，区间大小应该为[-1e5, 2e5]。将区间为负数的部分用<code>offset</code>来表示，则可以写出以下解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumBeauty</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="comment">// 多开3个空间，为了存0、存差分数组上限和匹配下标</span></span><br><span class="line">        <span class="keyword">int</span>[] diffArr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> ofst = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">1</span>; <span class="comment">// diffArr[ofst]为0所在位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            diffArr[x-k+ofst]++;</span><br><span class="line">            diffArr[x+k+ofst+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;diffArr.length;i++)&#123;</span><br><span class="line">            diffArr[i] += diffArr[i-<span class="number">1</span>];</span><br><span class="line">            res = Math.max(res, diffArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>周赛第三题属于值域上的打家劫舍，因此先来了解一下打家劫舍类型题目，其特点是<strong>对某一元素的选择会对其相邻区域造成影响</strong>。此类问题通常可以通过动态规划求解。</p><blockquote><p>House Robber</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p></blockquote><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 $k(k&gt;2)$ 间房屋，有两个选项:</p><ol><li>偷窃第 $k$ 间房屋，那么就不能偷窃第 $k-1$ 间房屋，偷窃总金额为前 $k-2$ 间房屋的最高总金额与第 $k$ 间房屋的金额之和。</li><li>不偷窃第 $k$ 间房屋，偷窃总金额为前 $k-1$ 间房屋的最高总金额。</li></ol><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 $k$ 间房屋能偷窃到的最高总金额。</p><p>用 $d p[i]$ 表示前 $i$ 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><script type="math/tex; mode=display">d p[i]=\max (d p[i-2]+\operatorname{nums}[i], d p[i-1])</script><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=\operatorname{nums}[0] & \text { 只有一间房屋，则偷窃该房屋 } \\ d p[1]=\max (n u m s[0], n u m s[1]) & \text { 只有两间房屋，选择其中金额较高的房屋进行偷窃 }\end{cases}</script><p>最终的答案即为 $d p[n-1]$, 其中 $n$ 是数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，可以考虑使用滚动数组优化空间使用。上述方法使用了数组存储结果，考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。得到优化解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：Maximum-Total-Damage-With-Spell-Casting"><a href="#例题：Maximum-Total-Damage-With-Spell-Casting" class="headerlink" title="例题：Maximum Total Damage With Spell Casting"></a>例题：Maximum Total Damage With Spell Casting</h2><blockquote><p>Maximum Total Damage With Spell Casting</p><p>A magician has various spells.</p><p>You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p><p>It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.</p><p>Each spell can be cast only once.</p><p>Return the maximum possible total damage that a magician can cast.</p></blockquote><p>这道题不是从空间上限制选取，而是从值域上限制，因此我们可以考虑对原数组进行排序，使元素选取与空域产生一定相关性，方便状态记录。排序后，考虑聚合相等值的元素，每一步选取实际上都是选取了一组元素。</p><p>用$nums$表示聚合后的排序数组，$total(nums[k])$表示元素$nums[k]$的值总和，用 $dp[i]$ 表示前 $i$ 个元素能造成的最高总伤害，那么对于$nums[k]$选或不选：</p><ul><li>不选，$dp[i] = dp[i-1]$;</li><li>选，则值在$[nums[k]-2, nums[k]-1]$的元素不能选，令$j$为最小满足$nums[j]&gt;=nums[k]-2$的元素，则$dp[i] = dp[j-1] + total(nums[k])$。</li></ul><p>对两种情况取最大值，有如下的状态转移方程：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1], dp[j-1] + total(nums[i]))</script><p>假设一种最坏的情况，$nums$中所有的元素都是连续的，那么在遇到元素$nums[i]$时，我们至少要保存三个状态才能够完成状态转移，即$dp[i-1], dp[i-2], dp[i-3]$，此时他们的末尾值分别对应$nums[i]-1,nums[i]-2,nums[i]-3$，则$j = i-2$，状态可能从$dp[i-3]$转移。也就是说，$dp[j-1]$的取值范围是$dp[i-1], dp[i-2], dp[i-3]$。</p><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=total(\operatorname{nums}[0]) \\ d p[1]=\begin{cases} \max (total(\operatorname{nums}[0]), total(\operatorname{nums}[1])),&nums[0]-2<=nums[1]<nums[0] \\ dp[0]+total(\operatorname{nums}[1]), &nums[0]<nums[1]-2 \end{cases}\end{cases}</script><p>此时发现问题：面对下标为$2$的元素，并不存在状态$dp[-1]$供其转移（$dp[j-1]$的下界）。于是如果从$nums[2]$开始遍历则应该添加此状态（置0），或从$nums[3]$开始遍历。</p><p>注意到当前状态仅与前三个状态有关，则可以用长度为$3$的滚动数组进行优化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maximumTotalDamage</span><span class="params">(<span class="keyword">int</span>[] power)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : power) &#123;</span><br><span class="line">            map.merge(x, (<span class="keyword">long</span>) x, Long::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer[] nums = map.keySet().toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 三个状态</span></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = map.get(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">2</span>] = nums[<span class="number">0</span>]&lt;nums[<span class="number">1</span>]-<span class="number">2</span>?dp[<span class="number">1</span>]+map.get(nums[<span class="number">1</span>]):Math.max(dp[<span class="number">1</span>], map.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j放到外面，可以避免每次都从0开始查</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 定位j</span></span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt; nums[i]-<span class="number">2</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = j==i?<span class="number">2</span>:(j==i-<span class="number">1</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> tmp = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[pos]+map.get(nums[i]));</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果把2换为k呢？一样的，多增加几个状态就行了，滚动数组法只需要k+1个状态。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/">https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/">https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周周赛菜了…赶紧记一下。&lt;/p&gt;
&lt;p&gt;本周主题：差分数组、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240615每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/&quot;&gt;Maximum Beauty of an Array After Applying Operation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240616周赛第三题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/&quot;&gt;Maximum Total Damage With Spell Casting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LC198打家劫舍—&lt;a href=&quot;https://leetcode.cn/problems/house-robber/description/&quot;&gt;House Robber&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP1</title>
    <link href="http://silencezheng.top/2024/08/18/article132/"/>
    <id>http://silencezheng.top/2024/08/18/article132/</id>
    <published>2024-08-17T16:14:09.000Z</published>
    <updated>2024-08-17T16:15:40.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。</p><p>本周主题：记忆化搜索、动态规划、01背包</p><p>题目：</p><ul><li>240609每日一题—<a href="https://leetcode.cn/problems/burst-balloons/description/">Burst Balloons</a></li><li>240608双周赛最后两题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/">Find the Maximum Length of a Good Subsequence</a></li><li>240609周赛最后两题—<a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/">Maximum Total Reward Using Operations</a><span id="more"></span><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><blockquote><p><strong>Burst Balloons</strong><br>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.</p><p>If you burst the ith balloon, you will get nums[i - 1] <em> nums[i] </em> nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</p><p>Return the maximum coins you can collect by bursting the balloons wisely.</p></blockquote></li></ul><p>这道题的第一个关键思路是逆向思维，戳气球的操作会导致两个气球从不相邻变成相邻，使后续操作处理困难，将戳气球的过程反过来看成每次添加一个气球，直到形成原数组。定义方法 $solve$，令 $solve(i,j)$ 表示将开区间 $(i,j)$ 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 $i$ 和 $j$，对应着 $val[i]$ 和 $val[j]$。</p><p>第二个思路比较简单，在原数组左右各增加一个$1$，即左右边界时的得分。</p><p>下面，对于$solve(i,j)$：</p><ul><li>当 $i≥j−1$ 时，开区间中没有气球，$solve(i,j)$ 的值为 0；</li><li>当 $i&lt;j−1$ 时，我们枚举开区间内的全部位置 $mid$，令 $mid$ 为当前区间第一个添加的气球，该操作能得到的硬币数为 $val[i]×val[mid]×val[j]$。同时我们递归地计算分割出的两区间对 $solve(i,j)$ 的贡献，这三项之和的最大值，即为 $solve(i,j)$ 的值。这样问题就转化为求 $solve(i,mid)$ 和 $solve(mid,j)$ ，可以写出方程：<script type="math/tex; mode=display">{solve}(i,j)= \begin{cases}{} \displaystyle \max_{\textit{mid} = i + 1}^{j - 1}val[i] \times \textit{val}[\textit{mid}] \times \textit{val}[j] + \textit{solve}(i, \textit{mid}) + \textit{solve}(\textit{mid}, j) ,&i < j - 1 \\ 0, & i \geq j - 1 \end{cases}</script></li></ul><p>由于在枚举mid的过程中，一定会产生相同子区间，即存在重复计算，此时可以采用记忆化的方式存储计算结果，优化时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>]; <span class="comment">// 增加边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>]; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right]; <span class="comment">// 已计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/burst-balloons/solutions/336390/chuo-qi-qiu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h1><blockquote><p>有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>在上述例题中，若每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。</p><p>例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。</p><p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的容量会增大 $w_{i}$，即前一个状态的背包容量必须是 $j-w_{i}$，通过本轮加上 $w_{i}$ 达到 $j$，同时背包中物品的总价值会增大 $v_{i}$，故这种情况下的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。</p><p>由此可以得出状态转移方程：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})</script><p>依据该状态转移方程可以写出解法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = w.length;</span><br><span class="line"><span class="comment">// 容量维度多开辟一个位置，因为要用索引表示容量，需要匹配到 W</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][W+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 对于dp[0][j]，所有j&lt;w[0]的位置初始化为0，其余位置初始化为 v[0]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;w[<span class="number">0</span>])&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于dp[i][0]，背包容量为0时无法装物，价值为0，对于其余位置，是由其上层的状态计算出的，也一并初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Arrays.fills(dp[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[n-1][W]即为结果</span></span><br></pre></td></tr></table></figure><p>如果直接采用二维数组对状态进行记录，可能会出现 MLE（Memory Limit Exceeded）。可以考虑改用<strong>滚动数组</strong>的形式来优化。</p><blockquote><p>滚动数组</p><p>在动态规划问题中，通常需要存储一系列状态值，每个状态值可能依赖于前几个状态。随着计算的进行，较早的状态值可能不再需要。例如，在求解斐波那契数列时，只需要保留最近两个值即可计算下一个值，之前的值则可以被覆盖重用。</p><p>思想：通过观察dp方程来判断需要使用哪些数据，可以抛弃哪些数据，一旦找到关系，就可以用新的数据不断覆盖旧的数据量来减少空间的使用。</p></blockquote><p>由于在二维解法中，对于当前层（当前物品）状态有影响的只有上一层（前一物品），即对 $f_i$ 有影响的只有 $f_{i-1}$，则可以去掉第一维，用一个重复更新的一维数组记录状态，直接用 $f_{j}$ 来表示处理到当前物品时背包容量为 $j$ 的最大价值，得出以下方程：</p><script type="math/tex; mode=display">f_j=\max \left(f_j,f_{j-w_i}+v_i\right)</script><p>这里，$f_{j-w_i} + v_i$代表如果选择放入第$i$个物品，则在背包容量为$j-w_i$时的价值加上这个物品的价值。而$max$操作保证了在是否选择放入第$i$个物品之间取最优解。</p><p>大部分背包问题的转移方程都是在此基础上推导出来的。</p><p>对于代码实现方面，<strong>滚动数组的实现要注意内层循环应从后向前逆序遍历</strong>，这可以避免在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 被 $f_{i,j-w_{i}}$ 所影响，即避免小背包容量下取物对后续大背包容量下状态计算的影响。</p><p>举例来说，假设<em>物品4</em>的重量为$1$，在二维解法中<code>dp[4][5]</code>应该由<code>dp[3][5]</code>和<code>dp[3][4]</code>得出，<code>dp[4][6]</code>应该由<code>dp[3][6]</code>和<code>dp[3][5]</code>得出，而在正序遍历的一维解法中，<code>f[5]</code>会先被计算，可能存在<code>f[5]</code>存储<code>dp[3][4]</code>状态的情况，此时<code>f[6]</code>的计算就无法获取<code>dp[3][5]</code>，造成计算错误。这个计算错误事实上是对<strong>同一物品的多次装包</strong>，因为<code>dp[3][4]</code>表示取<em>物品4</em>(下标为3)，若下一步<code>f[6]</code>再选择<code>f[5]+v[3]</code>则表示又取了一次<em>物品4</em>，这在01背包中是不允许的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">13010</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];  <span class="comment">// 读入数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = W; l &gt;= w[i]; l--) <span class="comment">// l &gt;= w[i]保证背包能装下，防止越界</span></span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的：</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//   for (int l = 0; l &lt;= W - w[i]; l++)</span></span><br><span class="line"><span class="comment">//     f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);</span></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。</p><p>可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)</script><p>考虑进行优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)</script><p>理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。</p><p>实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxW = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxW];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; W &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = w[i]; l &lt;= W; l++)</span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 核心状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题1-Maximum-Total-Reward-Using-Operations"><a href="#例题1-Maximum-Total-Reward-Using-Operations" class="headerlink" title="例题1: Maximum Total Reward Using Operations"></a>例题1: Maximum Total Reward Using Operations</h2><blockquote><p><strong>Maximum Total Reward Using Operations I &amp; II</strong></p><p>You are given an integer array rewardValues of length n, representing the values of rewards.</p><p>Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:</p><ul><li>Choose an unmarked index i from the range [0, n - 1].</li><li>If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.</li></ul><p>Return an integer denoting the maximum total reward you can collect by performing the operations optimally.</p></blockquote><p>首先，<code>rewardValues</code>中的数应该从小到大选，于是可以对其进行排序。排序后，可以看作01背包问题处理，背包的重量限制转化成了<code>rewardValues[i]</code>与reward<code>x</code>的制约关系。因此定义 <code>f[i][j]</code> 表示选取前<code>i</code>个<code>rewardValues</code>下<code>x</code>能达到的最大值<code>j</code>。由于<code>x</code>所能达到的最大值不确定，在实现中应选取一个尽可能大的值。</p><p>考虑转移，对于<code>f[i][j]</code>，是否选择<code>rewardValues[i]</code>：</p><ul><li>不选，<code>f[i][j] = f[i-1][j]</code>，即分数与上轮相同。</li><li>选择，<code>f[i][j] = f[i-1][j-rewardValues[i]]</code>，即上一轮的分数 <code>j-rewardValues[i]</code> 必须满足 <code>j-rewardValues[i]&lt;rewardValues[i]</code>, 同时为防止越界，<code>j-rewardValues[i]</code>需要大于等于0。综上，需满足 <code>rewardValues[i] &lt;= j &lt; 2*rewardValues[i]</code>。</li></ul><p>这里由于<code>f[i][j]</code>不需要存储“价值”，<code>j</code>自然表示了可以达到的最大值，因此<code>f[i][j]</code>通过布尔值表示是否可达即可，则有<code>f[i][j] = f[i-1][j] || f[i-1][j-rewardValues[i]]</code>。</p><p>写出二维解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rewardValues.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// int m = Integer.MAX_VALUE;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对物品从小到大排序</span></span><br><span class="line">        Arrays.sort(rewardValues);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 全部初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 不选</span></span><br><span class="line">        dp[<span class="number">0</span>][rewardValues[<span class="number">0</span>]] = <span class="keyword">true</span>; <span class="comment">// 选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化第一列，即一直不选。</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 对于[1, rewardValues[i]]区间，复制上一层表示可以不选。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于可选取区间，计算新得分。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=rewardValues[i];j&lt;<span class="number">2</span>*rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-rewardValues[i]]);</span><br><span class="line">                <span class="comment">// if(dp[i][j]) System.out.println(i+&quot;, &quot;+j);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后一行的最大真值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n-<span class="number">1</span>][i]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维解法对于数据范围大的情况会存在MLE，因此参照01背包问题，考虑使用滚动数组进行优化。原计算可以简化为：<code>f[j] = f[j] || f[j-rewardValues[i]]</code>，同时注意逆序遍历。另外，由于最终结果可以由<code>j</code>的值表示，故可以进一步优化数组为位运算，采用一个<code>BigInteger</code>表示布尔数组。</p><p>下面考虑如何用位运算表示布尔运算，假设之前已经遍历过的元素为<code>1, 2, 3</code>，则此时状态应为：<code>0000 0011 1111</code>，即可达分数区间为<code>[0, 5]</code>，此时假设下一个元素为<code>5</code>，则需要对区间<code>[5, 10)</code>进行布尔计算，计算的本质是将当前状态的区间<code>[0, 5)</code>与区间<code>[5, 10)</code>进行<code>or</code>运算。因此可以通过构造一个“<em>把区间<code>[0, 5)</code>移动到区间<code>[5, 10)</code>位置上且其余部分为<code>0</code></em>”的mask来与原状态进行<code>or</code>运算，既计算了目标区间，又不影响其他状态。构造的方法是先构造区间<code>[0, 5)</code>上全为<code>1</code>的mask，而后与原状态进行<code>and</code>操作提取目标区间，再将目标区间左移到<code>[5, 10)</code>的位置上得到最终的mask。</p><p>对于上面的例子来说，我们首先构造一个初始mask<code>0000 0000 0001</code>，而后对其左移<code>rewardValues[i]</code>位，这里即$5$位，得到<code>0000 0001 0000</code>，减$1$得到目标区间全真值mask<code>0000 0000 1111</code>，再左移<code>rewardValues[i]</code>位到目标区间，得到<code>0001 1110 0000</code>，与原状态进行<code>or</code>运算，得到：<code>0001 1111 1111</code>，即可取的分数范围为<code>[0, 8]</code>，符合题意。参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        BigInteger f = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : Arrays.stream(rewardValues).distinct().sorted().toArray()) &#123;</span><br><span class="line">            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);</span><br><span class="line">            f = f.or(f.and(mask).shiftLeft(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.bitLength() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2-Find-the-Maximum-Length-of-a-Good-Subsequence"><a href="#例题2-Find-the-Maximum-Length-of-a-Good-Subsequence" class="headerlink" title="例题2: Find the Maximum Length of a Good Subsequence"></a>例题2: Find the Maximum Length of a Good Subsequence</h2><blockquote><p>Find the Maximum Length of a Good Subsequence I &amp; II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p><p>A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p></blockquote><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>这道01背包没想清楚，先来特殊思路：<strong>处理相邻元素不同的DP问题</strong></p><p>把有$k$个相邻下标元素不同的子序列称为k序列。用 $c n t[k]$ 记录以 $x$ 结尾的 $k$ 序列的最大长度。考虑以 $nums[i]$ 结尾的 $k$ 序列, $nums [i]$ 要么接在以 $nums[i]$ 结尾的 $k$ 序列后，要么接在某个以 $n u m s<a href="j&lt;i">j</a>$ 结尾的 $k-1$ 序列后。所以状态转移方程即为</p><script type="math/tex; mode=display">\operatorname{cnt}[k][\operatorname{nums}[i]]=\max \left(\operatorname{cnt}[k][\operatorname{nums}[i]], \max _{j<i}\{\operatorname{cnt}[k-1][\operatorname{nums}[j]]\}\right)+1</script><p>这里我们不需要关心是否 $n u m s[j] \neq n u m s[i]$ ，即 $k-1$ 序列是否已经以 $nums[i]$ 结尾，因为在同样以 $nums[i]$ 结尾的情况下， $k-1$ 序列的长度一定小于 $k$ 序列的长度。</p><p>$c n t[k-1]$ 的最大值可以在哈希表基础上维护值有序来实现。但实际上，我们不需要维护 $c n t[k-1]$ 的所有值, 由于 $k-1$ 序列的最大长度单调不减, 所以只需要维护 $c n t[k-1]$ 的最大值就可以了。</p><p>在一些要求相邻状态不同的DP问题中，在处理当前状态时，不一定非要与所有前置状态比较, 只需要记录 $d p$ 最大和次大值对应的前置状态即可。这样的思路同样适用于本题。</p><p>注意由于$nums[i]$的范围比较大，Java实现的时候要用Map来存防止OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] mx = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            cnt.put(i, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> kk = k; kk &gt;= <span class="number">0</span>; kk--) &#123;</span><br><span class="line">                <span class="comment">// 考虑到更新顺序，需要倒序枚举</span></span><br><span class="line">                <span class="keyword">int</span> currentValue = kk&gt;<span class="number">0</span>?mx[kk - <span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">                currentValue = Math.max(currentValue, cnt.get(kk).getOrDefault(x, <span class="number">0</span>))+<span class="number">1</span>;</span><br><span class="line">                cnt.get(kk).put(x, currentValue);</span><br><span class="line">                mx[kk] = Math.max(mx[kk], cnt.get(kk).getOrDefault(x, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMax(mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : mx) &#123;</span><br><span class="line">            max = Math.max(max, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/dp">https://oi-wiki.org/dp</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/">https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/</a><br>[3] <a href="https://blog.csdn.net/txyyt_wst/article/details/130206572">https://blog.csdn.net/txyyt_wst/article/details/130206572</a><br>[4] <a href="https://blog.csdn.net/m0_46427179/article/details/107419492">https://blog.csdn.net/m0_46427179/article/details/107419492</a><br>[5] <a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/">https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p><p><strong>关于最后一个例题我自己的思考如下（不知道为什么是错的），没时间浪费了先存档以后再思考，先理解正确解法：</strong></p><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>由于 k 是非负整数，因此长度等于 1 的子序列一定是好子序列。对于任意一个子序列，在后面添加一个元素之后，子序列的长度增加 1，相邻不同元素对的数量不变或增加 1，因此可以使用动态规划计算最长好子序列的长度。</p><p>由于是”子序列“问题，其实也还是从全集中选择若干元素的问题，由于元素不能重复选，则还是0-1背包问题。这里背包的重量限制转化为<strong>前后不相同元素对</strong>数量的限制，对于元素<code>x = nums[i]</code>，定义<code>dp[i][j]</code>为遍历前<code>i</code>个元素时<strong>前后不相同元素对</strong>数量不超过<code>j</code>时的子序列最大长度。</p><p><strong>TODO:如果定义为前<code>i</code>个元素，则实现时遇到相等长度情况应该如何处理？即dp[a][j]==dp[b][j]，如果只取最后一个，那么后面和dp[?][j-1]比的时候也是相同亦可？</strong></p><p>这里需要注意一下如何定义，参考01背包问题，“前i个元素”一致，“背包容量”与“前后不相同元素对数量”一致，且此约束条件应转换为不超过<code>j</code>而不是等于<code>j</code>。</p><p>则对于<code>x</code>的选取分为三种情况：</p><ol><li>不选，<code>dp[i][j] = dp[i-1][j]</code>；</li><li>选择，且<code>x</code>与子序列的前一个数相同，则<code>dp[i][j] = dp[?][j]+1</code>；</li><li>选择，且<code>x</code>与子序列的前一个数不同，则<code>dp[i][j] = dp[?][j-1]+1</code>。</li></ol><p>这里使用了<code>?</code>来表示前一个数<code>y</code>的下标，<code>y</code>需要通过遍历得到。</p><p>由此可以得到状态转移方程为：</p><ul><li>情况A（不选）：<code>dp[i][j] = dp[i-1][j]+1</code></li><li>情况B（选）：<code>dp[i][j] = max(dp[?][j], dp[?][j-1])+1</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。&lt;/p&gt;
&lt;p&gt;本周主题：记忆化搜索、动态规划、01背包&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240609每日一题—&lt;a href=&quot;https://leetcode.cn/problems/burst-balloons/description/&quot;&gt;Burst Balloons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240608双周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/&quot;&gt;Find the Maximum Length of a Good Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240609周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/&quot;&gt;Maximum Total Reward Using Operations&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP7</title>
    <link href="http://silencezheng.top/2024/08/07/article131/"/>
    <id>http://silencezheng.top/2024/08/07/article131/</id>
    <published>2024-08-07T06:28:14.000Z</published>
    <updated>2024-08-19T16:23:04.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回国了，开始好好准备找工。</p><p>本周主题：快速幂</p><p>题目：</p><ul><li>240730每日一题—<a href="https://leetcode.cn/problems/double-modular-exponentiation/description">Double Modular Exponentiation</a><span id="more"></span></li></ul><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^8 \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}</script><p>的顺序，从 $x$ 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 $x^{64}$ 的值，而不需要对 $x$ 乘 63 次 $x$ 。</p><p>再举一个例子，如果我们要计算 $x^{77}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^9 \rightarrow x^{19} \rightarrow x^{38} \rightarrow x^{77}</script><p>的顺序, 在 $x \rightarrow x^2, x^2 \rightarrow x^4, x^{19} \rightarrow x^{38}$ 这些步骤中, 我们直接把上一次的结果进行平方，而在 $x^4 \rightarrow x^9, x^9 \rightarrow x^{19}, x^{38} \rightarrow x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 $x$ 。</p><p>直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后, 还需不需要额外乘 $x$ 。但如果我们从右往左看, 分治的思想就十分明显了：</p><ul><li>当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y=x^{\lfloor n / 2\rfloor}$ ，其中 $\lfloor a\rfloor$表示对 $a$ 进行下取整；</li><li>根据递归计算的结果, 如果 $n$ 为偶数, 那么 $x^n=y^2$; 如果 $n$ 为奇数,那么 $x^n=y^2 \times x$ ；</li><li>递归的边界为 $n=0$, 任意数的 0 次方均为 1 。</li></ul><p>由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</p><p>下面是快速幂算法的递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步，由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们还是以 $x^{77}$ 作为例子：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow^{+} x^9 \rightarrow^{+} x^{19} \rightarrow x^{38} \rightarrow^{+} x^{77}</script><p>并且把需要额外乘 $x$ 的步骤打上了 + 标记。可以发现：</p><ul><li>$x^{38} \rightarrow^{+} x^{77}$ 中额外乘的 $x$ 在 $x^{77}$ 中贡献了 $x$ ；</li><li>$x^9 \rightarrow^{+} x^{19}$ 中额外乘的 $x$ 在之后被平方了 2 次，因此在 $x^{77}$ 中贡献了 $x^{2^2}=x^4$</li><li>$x^4 \rightarrow^{+} x^9$ 中额外乘的 $x$ 在之后被平方了 3 次，因此在 $x^{77}$ 中贡献了 $x^{2^3}=x^8$</li><li>最初的 $x$ 在之后被平方了 6 次，因此在 $x^{77}$ 中贡献了 $x^{2^6}=x^{64}$ 。</li></ul><p>我们把这些贡献相乘， $x \times x^4 \times x^8 \times x^{64}$ 恰好等于 $x^{77}$ 。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 $x$ 在之后都会被平方若干次。而这些指数 $1 ， 4 ， 8$ 和 $64 ，$ 恰好就对应了 77 的二进制表示 $(1001101)_2$ 中的每个 1 ！</p><p>因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 $n$ 的二进制拆分为</p><script type="math/tex; mode=display">n=2^{i_0}+2^{i_1}+\cdots+2^{i_k}</script><p>那么</p><script type="math/tex; mode=display">x^n=x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}</script><p>这样以来, 我们从 $x$ 开始不断地进行平方, 得到 $x^2, x^4, x^8, x^{16}, \cdots$, 如果 $n$的第 $k$ 个（从右往左，从 0 开始计数）二进制位为 1 ，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。</p><p>下面是快速幂的迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x0</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题：Double-Modular-Exponentiation"><a href="#例题：Double-Modular-Exponentiation" class="headerlink" title="例题：Double Modular Exponentiation"></a>例题：Double Modular Exponentiation</h2><blockquote><p>Double Modular Exponentiation</p><p>You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.</p><p>An index i is good if the following formula holds:</p><ul><li>0 &lt;= i &lt; variables.length</li><li>((ai^bi % 10)^ci) % mi == target</li></ul><p>Return an array consisting of good indices in any order.</p></blockquote><p>计算式中重复出现的模式是“幂+取模”，于是可以把快速幂和取模融合在一起。</p><p>另一个知识点是“加法和乘法”的取模，有如下公式：<br>$(a+b) \bmod m=((a \bmod m)+(b \bmod m)) \bmod m$ $(a \cdot b) \bmod m=((a \bmod m) \cdot(b \bmod m)) \bmod m$</p><p>因此我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。</p><p>更多模相关的内容请看：<a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getGoodIndices</span><span class="params">(<span class="keyword">int</span>[][] variables, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; variables.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = variables[i];</span><br><span class="line">            <span class="keyword">if</span> (powMod(powMod(v[<span class="number">0</span>], v[<span class="number">1</span>], <span class="number">10</span>), v[<span class="number">2</span>], v[<span class="number">3</span>]) == target) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// (a*b) mod c = ((a mod c) * (b mod c)) mod c</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * x % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; <span class="comment">// 相当于y/=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a><br>[2] <a href="https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/">https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回国了，开始好好准备找工。&lt;/p&gt;
&lt;p&gt;本周主题：快速幂&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240730每日一题—&lt;a href=&quot;https://leetcode.cn/problems/double-modular-exponentiation/description&quot;&gt;Double Modular Exponentiation&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（速食版）</title>
    <link href="http://silencezheng.top/2024/06/06/article130/"/>
    <id>http://silencezheng.top/2024/06/06/article130/</id>
    <published>2024-06-05T19:43:00.000Z</published>
    <updated>2024-06-05T19:44:07.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快速计算任意连续子数组元素和的数据结构。</p><p>树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为<br>Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。<br><span id="more"></span></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><blockquote><p>给你一个数组，如何快速地计算任意一段连续子数组的元素和？</p></blockquote><p><img src="/assets/post_img/article130/szsz.png" alt="bit"></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>下标从 $left$ 到 $right$ 的子数组元素和，可以看成是下标从 1 到 $right$ 的子数组元素和，减去下标从 1 到 $left−1$ 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。</p><p>按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 $O(1)$ 地查询（计算任意连续子数组的元素和）了。</p><h2 id="如果更新呢？"><a href="#如果更新呢？" class="headerlink" title="如果更新呢？"></a>如果更新呢？</h2><p>如果修改下标为1的元素，则所有前缀都需要更新（因为所有前缀包含该元素），意味着更新操作时间复杂度为$O(n)$。此时查询与更新的综合时间复杂度还是$O(n)$。</p><p>自然的，想到应该将前缀元素和继续进行拆分，令更新某元素时，仅影响部分“子前缀”，此时只需要更新影响到的部分即可。</p><p>因此，需要找到一种合适的拆分方法，能够把任意前缀拆分成若干<strong>子前缀</strong>，使更新操作的执行范围缩小到部分子前缀中。</p><h2 id="对于想继续探索的同学"><a href="#对于想继续探索的同学" class="headerlink" title="对于想继续探索的同学"></a>对于想继续探索的同学</h2><p>推荐文献[3]，较为全面的阐述了树状数组的来世今生，本文以让读者尽快掌握用法为主，不过多展开深入。</p><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>BIT的重要概念，抛开相关性质不谈，先说计算，lowbit(x)表示取数x的最低位1，常用<code>lowbit(x) = x &amp; -x</code>计算。</p><p>举例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span><span class="punctuation">,</span> lowbit(<span class="keyword">x</span>) <span class="operator">=</span> <span class="keyword">x</span> &amp; -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">计算过程：</span><br><span class="line">   <span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span></span><br><span class="line">  -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0110</span></span><br><span class="line"><span class="keyword">x</span>&amp;-<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><h2 id="树状数组-c-n-的查询与更新"><a href="#树状数组-c-n-的查询与更新" class="headerlink" title="树状数组 c[n] 的查询与更新"></a>树状数组 <code>c[n]</code> 的查询与更新</h2><p>对于原数组<code>a[n]</code>构建对应的树状数组<code>c[n]</code>，可推导得出：<code>c[x] = a[x-lowbit(x)+1] + ... + a[x]</code>，即区间<code>[x-lowbit(x)+1, x]</code>的元素和。</p><p>定义<code>query(x)</code>为查询原数组区间<code>[1, x]</code>上的元素和，则可写出利用<code>c[n]</code>实现$O(logn)$的查询代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 减去所有的lowbit后i为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))</span><br><span class="line">            ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>add(x, v)</code>为修改位置为在索引<code>x</code>的元素，加上<code>v</code>。则可写出利用<code>c[n]</code>实现$O(logn)$的更新代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = 树状数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)&#123;</span><br><span class="line">        c[x] += v;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容很好理解，抓住<code>c[x]</code>的定义就行了。</p><h2 id="树状数组-c-n-的构造"><a href="#树状数组-c-n-的构造" class="headerlink" title="树状数组 c[n] 的构造"></a>树状数组 <code>c[n]</code> 的构造</h2><p>最简单的，遍历原数组，调用<code>n</code>次<code>add</code>方法进行构造，时间复杂度$O(nlogn)$：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更快速的，考虑<code>c[x]</code>表示原数组区间<code>[x-lowbit(x)+1, x]</code>的元素和，可以先对原数组求一个前缀和数组<code>s[n]</code>，利用前缀和来更新树状数组，即<code>c[x] = s[x] - s[x-lowbit(x)]</code>，此时构造的时间复杂度为$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 求a的前缀和</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 用前缀和求出c</span></span><br><span class="line">c[i] = s[i] - s[i - lowbit(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分规则—逆序"><a href="#拆分规则—逆序" class="headerlink" title="拆分规则—逆序"></a>拆分规则—逆序</h2><p>按照逆序处理，每次处理的bit都是当前编号的最后的为1位。将每次处理的bit定义为<strong>lowbit</strong>。</p><p>对于前缀 $[1,i]$：</p><ul><li>如果 $i$ 是 2 的幂，那么 $[1,i]$ 无需拆分。</li><li>如果 $i$ 不是 2 的幂，那么先拆分出一个长为 $lowbit(i)$ 的关键区间 $[i−lowbit(i)+1,i]$，问题转换成剩下的 $[1,i−lowbit(i)]$ 如何拆分，这是一个规模更小的子问题。</li></ul><h1 id="例题一：分数字到两个数组"><a href="#例题一：分数字到两个数组" class="headerlink" title="例题一：分数字到两个数组"></a>例题一：<a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">分数字到两个数组</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; tree.length) &#123;</span><br><span class="line">            tree[i]++;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] resultArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            index.put(sortedNums[i], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Integer&gt; arr2 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">1</span>]));</span><br><span class="line">        BinaryIndexedTree tree1 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        BinaryIndexedTree tree2 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        tree1.add(index.get(nums[<span class="number">0</span>]));</span><br><span class="line">        tree2.add(index.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = arr1.size() - tree1.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">int</span> count2 = arr2.size() - tree2.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr1.size() &lt;= arr2.size())) &#123;</span><br><span class="line">                arr1.add(nums[i]);</span><br><span class="line">                tree1.add(index.get(nums[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.add(nums[i]);</span><br><span class="line">                tree2.add(index.get(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr1) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr2) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/">https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/</a><br>[2] <a href="https://blog.csdn.net/qq_63786973/article/details/127416700">https://blog.csdn.net/qq_63786973/article/details/127416700</a><br>[3] <a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">https://www.cnblogs.com/Last--Whisper/p/13823614.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;快速计算任意连续子数组元素和的数据结构。&lt;/p&gt;
&lt;p&gt;树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为&lt;br&gt;Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排列组合</title>
    <link href="http://silencezheng.top/2024/06/01/article129/"/>
    <id>http://silencezheng.top/2024/06/01/article129/</id>
    <published>2024-06-01T12:59:03.000Z</published>
    <updated>2024-08-23T17:06:48.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排列组合计算公式推导及代码实现。<br><span id="more"></span></p><h1 id="加法原理、乘法原理"><a href="#加法原理、乘法原理" class="headerlink" title="加法原理、乘法原理"></a>加法原理、乘法原理</h1><p><strong>分类计数原理</strong>：完成一件事情，存在$n$类方法，第1类有$m_1$种方式，第2类有$m_2$种方式，…，第$n$类有$m_n$种方式，则完成此事共有$N = m_1 + m_2 + … + m_n$种不同方法。 </p><p><strong>分步计数原理</strong>：若完成某事需经过$n$个步骤，第1步有$m_1$种方法，第2步有$m_2$种方法，…，第$n$步有$m_n$种方法，则总共有$N = m_1 \times m_2 \times \cdots \times m_n$种不同方法。</p><p><strong>区别</strong>：分类计数原理是加法规则，各类方法数相加求和；分步计数原理是乘法规则，各步骤方法数相乘得总数。</p><h1 id="排列（Arrangement）"><a href="#排列（Arrangement）" class="headerlink" title="排列（Arrangement）"></a>排列（Arrangement）</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>从$n$个不同元素中选取$m(m \leq n)$个元素的所有不同排列的个数，叫做从$n$个不同元素中选取$m$个元素的排列数，记作$\mathrm{A}_n^m$。 </p><h2 id="排列数公式"><a href="#排列数公式" class="headerlink" title="排列数公式"></a>排列数公式</h2><script type="math/tex; mode=display">\mathrm{A}_n^m = n(n-1)(n-2)\cdots(n-m+1) = \frac{n!}{(n-m)!}, \quad n, m \in \mathbb{N}^*, m \leq n</script><p>推导：从$n$个不同元素中选取$m$个元素进行排序，按计数原理分布进行，取第一个有$n$种取法，取第二个有$n-1$种取法…取第$m$个有$n-m+1$种取法，根据分步乘法原理推导出上式。</p><h2 id="排列数性质"><a href="#排列数性质" class="headerlink" title="排列数性质"></a>排列数性质</h2><ul><li>$\mathrm{A}_n^m = n\mathrm{A}_{n-1}^{m-1}$：为“某特定位置”先安排，再安排其余位置。</li><li>$\mathrm{A}_n^m = m\mathrm{A}_{n-1}^{m-1} + \mathrm{A}_{n-1}^m$：含特定元素的排列有$m\mathrm{A}_{n-1}^{m-1}$种，不含特定元素的排列有$\mathrm{A}_{n-1}^m$种。</li></ul><h1 id="组合（Combination）"><a href="#组合（Combination）" class="headerlink" title="组合（Combination）"></a>组合（Combination）</h1><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>从$n$个不同元素中选取$m$（$m \leq n$）个元素的所有不同组合的数目，称为从$n$个不同元素中取出$m$个元素的组合数，用符号$\mathrm{C}_n^m$表示。</p><h2 id="组合数公式"><a href="#组合数公式" class="headerlink" title="组合数公式"></a>组合数公式</h2><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!},\quad n,m\in \mathbb{N}^*,m\leq n</script><script type="math/tex; mode=display">\mathrm{C}_n^0=\mathrm{C}_n^n=1</script><p>证明：通过排列与组合的关系以及排列公式推导证明。</p><p>将排列问题$\mathrm{A}_n^m$分为两步：</p><ol><li><p><strong>第一步</strong>：从$n$个球中抽取$m$个，不考虑顺序，即组合问题$\mathrm{C}_n^m$；</p></li><li><p><strong>第二步</strong>：将抽出的$m$个球排序，即全排列$\mathrm{A}_m^m$。</p></li></ol><p>依据乘法原理，$\mathrm{A}_n^m=\mathrm{C}_n^m \mathrm{A}_m^m$，因此</p><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}</script><h2 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h2><ul><li>$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$：反转组合，未选的变选，选了的变未选，组合数相同。</li><li>递推公式$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$：含特定元素组合数为$\mathrm{C}_{n-1}^{m-1}$，不含特定元素组合数为$\mathrm{C}_{n-1}^m$。</li></ul><p><strong>示例</strong><br>令（$n=5$），($m=2$)。</p><p>从1，2，3，4，5中取出2个元素的组合$\mathrm{C}_n^m$：</p><p>12 13 14 15 23 24 25 34 35 45</p><p>这些组合要么含”1”，要么不含。</p><ul><li>含”1”的组合：12 13 14 15 → 挖去”1”得2 3 4 5 → 等价于从2，3，4，5中取出1个元素的组合。（此处m-1为1）</li><li>不含”1”的组合：23 24 25 34 35 45 → 等价于从2，3，4，5中取出2个元素的组合。（此处m为2）</li></ul><p>总方案数是上述两种情况的和，即$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$。</p><h2 id="组合数求和公式"><a href="#组合数求和公式" class="headerlink" title="组合数求和公式"></a>组合数求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><p>直观理解：从$n$个球中抽取0到$n$个球的组合数之和。</p><p>严谨证明可采用数学归纳法：</p><ol><li>当$n=1$，$\mathrm{C}_1^0+\mathrm{C}_1^1=2=2$成立。</li><li>假设$n=k$时公式成立，$\sum_{i=0}^{k} \mathrm{C}_k^i=2^n$，则$n=k+1$时亦成立。</li><li>由1、2归纳得公式对所有$n\in \mathbb{N}^*$成立。</li></ol><p>或用二项式定理简证：</p><script type="math/tex; mode=display">(a+b)^n=\sum_{k=0}^{n}\mathrm{C}_n^k a^{n-k}b^k</script><p>设$a=b=1$，</p><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><h3 id="相关公式"><a href="#相关公式" class="headerlink" title="相关公式"></a>相关公式</h3><p>由$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$推导：</p><script type="math/tex; mode=display">\mathrm{C}_n^0 + \mathrm{C}_n^2 + \mathrm{C}_n^4 + ... = \mathrm{C}_n^1 + \mathrm{C}_n^3 + \mathrm{C}_n^5 + ... =2^{n-1}</script><h2 id="Java：组合求和"><a href="#Java：组合求和" class="headerlink" title="Java：组合求和"></a>Java：组合求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">factorialWithRecursion</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorialWithRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">combination</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> numerator = factorialWithRecursion(n);</span><br><span class="line">    <span class="keyword">long</span> denominator1 = factorialWithRecursion(m);</span><br><span class="line">    <span class="keyword">long</span> denominator2 = factorialWithRecursion(n-m);</span><br><span class="line">    <span class="keyword">return</span> numerator/(denominator1*denominator2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展：组合数的加权求和公式"><a href="#拓展：组合数的加权求和公式" class="headerlink" title="拓展：组合数的加权求和公式"></a>拓展：组合数的加权求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>通常被称为 <strong>组合数的加权求和公式</strong> 或者 <strong>组合数的加权和公式</strong>。这个公式用于计算组合数 $\binom{n}{i}$ 与下标 $i$ 的乘积之和。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>二项式系数</strong>：$\binom{n}{i}$ 是从 $n$ 个元素中选择 $i$ 个元素的不同方式的数量。</li><li><strong>二项式定理</strong>：$\sum_{i=0}^{n} \binom{n}{i} = 2^n$，表示所有二项式系数的和等于 $2^n$。</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol><li><strong>简化求和</strong>：从 $i=1$ 开始求和，因为 $i=0$ 时 $i \binom{n}{i} = 0$。</li><li><strong>利用组合数性质</strong>：$i \binom{n}{i} = n \binom{n-1}{i-1}$。</li><li><strong>改变求和变量</strong>：令 $j = i-1$，则 $i = j + 1$。</li><li><strong>利用二项式定理</strong>：$\sum_{j=0}^{n-1} \binom{n-1}{j} = 2^{n-1}$。</li></ol><p>最终得到公式：</p><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>这个公式是组合数学中的一个重要结论，有助于快速计算组合数的加权求和。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/1024th/p/10623541.html">https://www.cnblogs.com/1024th/p/10623541.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;排列组合计算公式推导及代码实现。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之预定义CRUD</title>
    <link href="http://silencezheng.top/2024/03/24/article128/"/>
    <id>http://silencezheng.top/2024/03/24/article128/</id>
    <published>2024-03-24T08:54:43.000Z</published>
    <updated>2024-08-19T15:18:57.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>探究MyBatis Plus提供的预定义CRUD接口的实现方式。<br><span id="more"></span></p><h1 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h1><p>MBP提供两种包含预定义CRUD的接口：</p><ol><li><code>com.baomidou.mybatisplus.extension.service.IService</code></li><li><code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code></li></ol><p>其中<code>IService</code>接口是针对业务逻辑层的封装，并提供了批处理操作。<code>BaseMapper</code>则是对DAO层CRUD的封装。</p><h1 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h1><p><code>BaseMapper</code>的接口规范很简单，看代码就能明白，重点是了解MBP如何实现的<code>BaseMapper</code>。</p><p>在使用MyBatis的情况下，我们定义了Mapper接口，然后会在对应的XML文件中提供动态SQL及映射关系，或者直接在Mapper接口方法上添加注解，MyBatis将XML中的配置或者注解作为元数据进行解析，然后将解析后的SQL语句存至<code>org.apache.ibatis.session.Configuration</code>。MBP在MyBatis的基础上只做增强不做改变，则只要能够实现原pipeline将元数据解析成动态SQL存至<code>org.apache.ibatis.session.Configuration</code>即可。</p><p>MyBatis Plus的整体思路是使用自己的组件替换MyBatis中的组件，以实现自定义的逻辑。其中<code>MybatisPlusAutoConfiguration</code>类替代了MyBatis的自动配置类，这个类中包含<code>MybatisPlusProperties</code>属性。<code>MybatisPlusProperties</code>包含<code>mapperLocations</code>字段用于解析Mapper XML文件的位置，并汇总为<code>Resource</code>数组。</p><p>在<code>MybatisPlusAutoConfiguration#sqlSessionFactory</code>函数中，包含XML位置的<code>Resource</code>数组被设置到<code>MybatisSqlSessionFactoryBean.mapperLocations</code>下（<code>MybatisSqlSessionFactoryBean</code>也是MBP替换组件）。而后在<code>MybatisSqlSessionFactoryBean#buildSqlSessionFactory</code>函数中，XML文件被逐个读取并解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>XMLMapperBuilder</code>在解析过程中会调用<code>XMLMapperBuilder#bindMapperForNamespace</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">            <span class="keyword">this</span>.configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>configuration</code>为<code>MybatisSqlSessionFactoryBean</code>传入的<code>targetConfiguration</code>，即<code>MybatisConfiguration</code>（MBP替换组件）。此时<code>MybatisMapperRegistry#addMapper</code>调用<code>MybatisMapperRegistry#addMapper</code>方法。</p><p><code>MybatisMapperRegistry</code>也是一个MBP替换组件，继承并替换掉原本的<code>MapperRegistry</code>，其<code>addMapper</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MybatisMapperProxyFactory(type));</span><br><span class="line">            MybatisMapperAnnotationBuilder parser = <span class="keyword">new</span> MybatisMapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用MBP自定义的<code>MybatisMapperAnnotationBuilder#parse</code>方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入 CURD 动态 SQL</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过全局缓存工具<code>GlobalConfigUtils</code>获取<code>ISqlInjector</code>实例，调用<code>ISqlInjector#inspectInject</code>方法进行CRUD方法注入。在实现上，实际上是由<code>AbstractSqlInjector</code>实现了<code>ISqlInjector</code>接口，然后又由<code>DefaultSqlInjector</code>继承<code>AbstractSqlInjector</code>实现最终注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; modelClass = ReflectionKit.getSuperClassGenericType(mapperClass, Mapper.class, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 注入的方法</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperClass 当前mapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入的方法集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.1.2 add  mapperClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass,TableInfo tableInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> DeleteById(),</span><br><span class="line">                <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> UpdateById(),</span><br><span class="line">                <span class="keyword">new</span> SelectById(),</span><br><span class="line">                <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(String.format(<span class="string">&quot;%s ,Not found @TableId annotation, Cannot use Mybatis-Plus &#x27;xxById&#x27; Method.&quot;</span>,</span><br><span class="line">                tableInfo.getEntityType()));</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每一个函数都是继承了<code>com.baomidou.mybatisplus.core.injector.AbstractMethod</code>的类，包含一个<code>inject</code>注入方法。</p><h1 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h1><p><code>IService</code>的实现在<code>com.baomidou.mybatisplus.extension.service.impl.ServiceImpl</code>。</p><p><code>IService</code>依赖于Spring容器，而<code>BaseMapper</code>不依赖，原因是<code>IService</code>实例中会注入一个<code>BaseMapper</code>实例用于做CRUD操作，也就是上面的那一套。</p><p><code>IService</code>还支持批量操作，这部分源码比较好看，调用链路是：<code>com.baomidou.mybatisplus.extension.toolkit.SqlHelper#executeBatch -&gt; org.apache.ibatis.session#flushStatements</code></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/wjw465150/article/details/126896276">https://blog.csdn.net/wjw465150/article/details/126896276</a><br>[2] <a href="https://blog.csdn.net/zzuhkp/article/details/120174101">https://blog.csdn.net/zzuhkp/article/details/120174101</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;探究MyBatis Plus提供的预定义CRUD接口的实现方式。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>回归问题指标计算</title>
    <link href="http://silencezheng.top/2024/03/10/article127/"/>
    <id>http://silencezheng.top/2024/03/10/article127/</id>
    <published>2024-03-10T10:56:26.000Z</published>
    <updated>2024-05-01T17:34:10.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回归问题指标计算入门。<br><span id="more"></span></p><h1 id="RSE-Relative-Squared-Error"><a href="#RSE-Relative-Squared-Error" class="headerlink" title="RSE (Relative Squared Error)"></a><strong>RSE (Relative Squared Error)</strong></h1><p>相对平方误差是预测值与实际值之间的平方差与实际值的平方差的比率。计算公式如下：</p><script type="math/tex; mode=display">RSE = \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}</script><p>其中，$ y_i $ 是第 $ i $ 个观测值，$ \hat{y}_i $ 是对应的预测值，$ \bar{y} $ 是观测值的均值，$ n $ 是样本数量。</p><h1 id="RAE-Relative-Absolute-Error"><a href="#RAE-Relative-Absolute-Error" class="headerlink" title="RAE (Relative Absolute Error)"></a><strong>RAE (Relative Absolute Error)</strong></h1><p>相对绝对误差是预测值与实际值之间的绝对差与实际值的绝对差的比率。计算公式如下：</p><script type="math/tex; mode=display">RAE = \frac{\sum_{i=1}^{n} |y_i - \hat{y}_i|}{\sum_{i=1}^{n} |y_i - \bar{y}|}</script><h1 id="MSE-Mean-Squared-Error"><a href="#MSE-Mean-Squared-Error" class="headerlink" title="MSE (Mean Squared Error)"></a><strong>MSE (Mean Squared Error)</strong></h1><p>均方误差是预测值与实际值之间的平方差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2</script><h1 id="RMSE-Root-Mean-Squared-Error"><a href="#RMSE-Root-Mean-Squared-Error" class="headerlink" title="RMSE (Root Mean Squared Error)"></a><strong>RMSE (Root Mean Squared Error)</strong></h1><p>均方根误差是均方误差的平方根，它提供了预测误差的标准化度量。计算公式如下：</p><script type="math/tex; mode=display">RMSE = \sqrt{MSE}</script><h1 id="MAE-Mean-Absolute-Error"><a href="#MAE-Mean-Absolute-Error" class="headerlink" title="MAE (Mean Absolute Error)"></a><strong>MAE (Mean Absolute Error)</strong></h1><p>平均绝对误差是一种常用的回归问题评价指标，用于衡量预测值与真实值之间的偏差程度。它的计算基于所有预测值与对应真实值之间绝对误差的平均值，因此对所有个体错误给予相同权重，不考虑误差的方向，只关注其大小。MAE的计算公式如下：</p><script type="math/tex; mode=display">\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|</script><p>其中：</p><ul><li>$n$ 表示样本的数量。</li><li>$y_i$ 表示第 $ i $ 个样本的真实值。</li><li>$ \hat{y}_i $ 表示第 $ i $ 个样本的预测值。</li><li>$ | \cdot | $ 表示绝对值函数，确保误差值为非负。</li></ul><h1 id="MAPE-Mean-Absolute-Percentage-Error"><a href="#MAPE-Mean-Absolute-Percentage-Error" class="headerlink" title="MAPE (Mean Absolute Percentage Error)"></a><strong>MAPE (Mean Absolute Percentage Error)</strong></h1><p>平均绝对百分比误差是预测值与实际值之间的绝对百分比误差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MAPE = \frac{100}{n} \sum_{i=1}^{n} \left| \frac{y_i - \hat{y}_i}{y_i} \right|</script><h1 id="Correlation-Pearson-Correlation-Coefficient"><a href="#Correlation-Pearson-Correlation-Coefficient" class="headerlink" title="Correlation (Pearson Correlation Coefficient)"></a><strong>Correlation (Pearson Correlation Coefficient)</strong></h1><p>相关系数衡量了预测值与实际值之间的线性关系强度和方向。计算公式如下：</p><script type="math/tex; mode=display">\text{Correlation} = \frac{\sum_{i=1}^{n} (y_i - \bar{y})(\hat{y}_i - \bar{\hat{y}})}{\sqrt{\sum_{i=1}^{n} (y_i - \bar{y})^2 \sum_{i=1}^{n} (\hat{y}_i - \bar{\hat{y}})^2}}</script><p>其中，$ \bar{y} $ 和 $ \bar{\hat{y}} $ 分别是观测值和预测值的均值。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回归问题指标计算入门。&lt;br&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://silencezheng.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发体验</title>
    <link href="http://silencezheng.top/2024/02/08/article126/"/>
    <id>http://silencezheng.top/2024/02/08/article126/</id>
    <published>2024-02-07T18:40:36.000Z</published>
    <updated>2024-02-07T18:44:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。</p><p>但在做课题调研时我习惯使用<code>[n]</code>作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫<code>Reference Extension</code>吧。<br><span id="more"></span></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>0、更新npm、cnpm：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cnpm</span></span><br><span class="line">npm install -g cnpm -registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>1、安装 Yeoman 和 VS Code Extension Generator：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g yo generator-code</span><br></pre></td></tr></table></figure></p><p>2、创建一个新的插件项目<code>Reference Extension</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Reference Extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? reference-extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? Literature Citation Extension</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? Yes</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? npm</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> reference-extension</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>主要实现两个功能：</p><ol><li><code>[n]</code>格式索引增加项时自动递增（实际只实现了一部分）。</li><li><code>[n]</code>格式索引重新索引，包含删除项与增加项（实际只实现了一部分）。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 VSCode 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活插件的入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令：自动递增索引</span></span><br><span class="line">    <span class="keyword">let</span> disposableAutoIncrement = vscode.commands.registerTextEditorCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前光标位置</span></span><br><span class="line">            <span class="keyword">const</span> currentPosition = editor.selection.active;</span><br><span class="line">            <span class="keyword">const</span> currentLine = currentPosition.line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前行的文本内容，并匹配是否以 [n] 格式结尾</span></span><br><span class="line">            <span class="keyword">const</span> currentLineText = editor.document.lineAt(currentLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = currentLineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="comment">// 获取匹配到的数字，并计算下一个数字</span></span><br><span class="line">                <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> nextNumber = currentNumber + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自增逻辑</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// TODO： 这段有问题，要修改，而且还是没有做到回车前触发。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = currentLine + <span class="number">1</span>; line &lt; editor.document.lineCount; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> matchBelow = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (matchBelow) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentNumberBelow = <span class="built_in">parseInt</span>(matchBelow[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndexBelow = currentNumberBelow + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 替换下方方括号中的数字</span></span><br><span class="line">                            <span class="keyword">const</span> startPosBelow = <span class="keyword">new</span> vscode.Position(line, <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">const</span> endPosBelow = <span class="keyword">new</span> vscode.Position(line, matchBelow[<span class="number">0</span>].length);</span><br><span class="line">                            editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPosBelow, endPosBelow), <span class="string">`[<span class="subst">$&#123;newIndexBelow&#125;</span>] <span class="subst">$&#123;matchBelow[<span class="number">2</span>]&#125;</span>`</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果下方没有符合 [n] 格式索引的项，结束循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> newPosition = <span class="keyword">new</span> vscode.Position(currentLine + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    editBuilder.insert(newPosition, <span class="string">`[<span class="subst">$&#123;nextNumber&#125;</span>] `</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册命令：重新索引所有行的方括号</span></span><br><span class="line">    <span class="comment">// TODO：实际上只实现了删除一个索引时将下方索引都自动减1</span></span><br><span class="line">    <span class="keyword">let</span> disposableReindex = vscode.commands.registerCommand(<span class="string">&#x27;rext.reindex&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前行的行号</span></span><br><span class="line">            <span class="keyword">const</span> currentLine = editor.selection.active.line;</span><br><span class="line">            <span class="keyword">const</span> startLine = currentLine;</span><br><span class="line">            <span class="keyword">const</span> endLine = editor.document.lineCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义当前列表的索引</span></span><br><span class="line">            <span class="keyword">let</span> currentListIndex: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：匹配一下</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 查找当前列表的索引</span></span><br><span class="line">            <span class="keyword">const</span> lineText = editor.document.lineAt(startLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                currentListIndex = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：自动减1</span></span><br><span class="line">            <span class="keyword">if</span> (currentListIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// TODO：重新索引列表中的方括号数字</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = startLine; line &lt; endLine; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                            <span class="comment">// 获取当前方括号中的数字和新索引</span></span><br><span class="line">                            <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndex = currentNumber - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果当前数字不等于新索引，替换方括号中的数字</span></span><br><span class="line">                            <span class="keyword">if</span> (currentNumber !== newIndex) &#123;</span><br><span class="line">                                <span class="keyword">const</span> startPos = <span class="keyword">new</span> vscode.Position(line, match.index!);</span><br><span class="line">                                <span class="keyword">const</span> endPos = <span class="keyword">new</span> vscode.Position(line, match.index! + match[<span class="number">0</span>].length);</span><br><span class="line">                                editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPos, endPos), <span class="string">`[<span class="subst">$&#123;newIndex&#125;</span>] `</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听文档内容变化事件</span></span><br><span class="line">    vscode.workspace.onDidChangeTextDocument(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.document.languageId === <span class="string">&#x27;markdown&#x27;</span> &amp;&amp; event.document.fileName.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> range = event.contentChanges[<span class="number">0</span>].range;</span><br><span class="line">            <span class="comment">// 检查是否按下了回车键</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否删除了某一行</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;&#x27;</span> &amp;&amp; range.start.line !== range.end.line) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.reindex&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令注册到上下文订阅中，确保插件在激活期间有效</span></span><br><span class="line">    context.subscriptions.push(disposableAutoIncrement, disposableReindex);</span><br><span class="line"></span><br><span class="line">    process.stdout.write(<span class="string">&#x27;Debugging message\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件被停用时调用的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这代码写的很糙，只实现了部分功能，但是也确实没时间去学<code>markdown-it</code>的插件实现了，以后再去实现吧（正常来说我要实现的东西通过<code>markdown-it</code>自定义插件插入的形式实现更方便…在插件上写插件😂）。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>项目F5进行调试，创建一个Markdown文件，写入对应情景内容，别忘了在<code>package.json</code>中设置触发条件。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>要想发布插件到市场，需要创建在Azure DevOps上创建个人访问令牌，如果没有组织则需要先创建组织。可以用GitHub账户登陆Azure DevOps创建组织，比如<code>dev.azure.com/SilenceZheng66</code>。</p><p>然后创建项目，在项目中创建PAT（Personal Access Tokens）并记住它。下面需要在<a href="https://marketplace.visualstudio.com/manage/createpublisher">Visual Studio Marketplace</a>创建一个publisher，这里需要注意的是这里必须使用刚才创建个人访问令牌的微软账号，这里的publisher需要和package.json里的publisher字段一致。</p><p>准备就绪后，下载<code>vsce</code>，用来打包/发布/管理插件的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g vsce</span><br></pre></td></tr></table></figure><p>执行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">vsce login SilenceZheng66</span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">vsce publish --no-dependencies</span><br></pre></td></tr></table></figure><p>使用webpack打包插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnpm i --save-dev webpack webpack-cli ts-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># package.json 脚本如下：</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;vscode:prepublish&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>,</span><br><span class="line"><span class="string">&quot;compile&quot;</span>: <span class="string">&quot;webpack --mode none&quot;</span>,</span><br><span class="line"><span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --mode none --watch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html">https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html</a><br>[2] <a href="https://github.com/yzhang-gh/vscode-markdown">https://github.com/yzhang-gh/vscode-markdown</a><br>[3] <a href="https://juejin.cn/post/7327570230775201826">https://juejin.cn/post/7327570230775201826</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/459554765">https://zhuanlan.zhihu.com/p/459554765</a><br>[5] <a href="https://juejin.cn/post/6844903921555603470">https://juejin.cn/post/6844903921555603470</a><br>[6] <a href="https://markdown-it.github.io">https://markdown-it.github.io</a><br>[7] <a href="https://juejin.cn/post/7076649162653040647">https://juejin.cn/post/7076649162653040647</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。&lt;/p&gt;
&lt;p&gt;但在做课题调研时我习惯使用&lt;code&gt;[n]&lt;/code&gt;作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫&lt;code&gt;Reference Extension&lt;/code&gt;吧。&lt;br&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://silencezheng.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>SpEL使用入门</title>
    <link href="http://silencezheng.top/2023/12/30/article125/"/>
    <id>http://silencezheng.top/2023/12/30/article125/</id>
    <published>2023-12-29T17:00:25.000Z</published>
    <updated>2023-12-29T17:02:59.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。</p><p>SpEL是单独模块（<code>org.springframework.expression</code>），只依赖于core模块，不依赖于其他模块，可以单独使用。<br><span id="more"></span></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先从一个简单的“literal string expression”例子引入，所谓“literal string”就是指代码中直接使用双引号括起来的字符串（起码在Java下是这样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先创建了解析器<code>ExpressionParser</code>，负责解析表达式字符串，表达式字符串是由周围的单引号表示的字符串字面量。而后解析表达式，<code>Expression</code>接口负责评估所定义的表达式字符串。最后对表达式进行求值，获取信息。</p><p>通过这一流程可以总结SpEL在求表达式值时的一般步骤：</p><ol><li>创建解析器</li><li>解析表达式</li><li>构造上下文</li><li>表达式求值</li></ol><p>其中第三步构造上下文是一个可选步骤，当需要准备上下文变量时会使用。</p><p>PS：在调用 <code>parser.parseExpression</code> 和 <code>exp.getValue</code> 时，可能分别抛出两个异常：<code>ParseException</code> 和 <code>EvaluationException</code>。<br>PPS：Evaluate可以理解为“求值”或“计算”。</p><h2 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h2><p>SpEL支持多种功能，如调用方法、访问属性和调用构造函数，这里用一个例子快速过一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用concat方法</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();  <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性，invokes &#x27;getBytes()&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套属性，invokes &#x27;getBytes().length&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes.length&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> length = (Integer) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;new String(&#x27;hello world&#x27;).toUpperCase()&quot;</span>);</span><br><span class="line">String message = exp.getValue(String.class); <span class="comment">// HELLO WORLD</span></span><br></pre></td></tr></table></figure><h2 id="更常见的用法"><a href="#更常见的用法" class="headerlink" title="更常见的用法"></a>更常见的用法</h2><p>SpEL更常见的用法是提供一个表达式字符串，针对特定对象实例（称为根对象）进行求值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并设置一个日历对象</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数分别为name, birthday, nationality</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">// 将&quot;name&quot;解析为表达式</span></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br></pre></td></tr></table></figure><h2 id="全部语法"><a href="#全部语法" class="headerlink" title="全部语法"></a>全部语法</h2><p>关于如何编写正确的表达式，可以参见 <a href="https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html">https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html</a></p><h1 id="EvaluationContext（求值上下文）"><a href="#EvaluationContext（求值上下文）" class="headerlink" title="EvaluationContext（求值上下文）"></a>EvaluationContext（求值上下文）</h1><p><code>EvaluationContext</code>接口用于计算表达式，以解析属性、方法或字段，并帮助执行类型转换。Spring 提供了两种实现：</p><ul><li><p><code>SimpleEvaluationContext</code>：该接口公开了基本 SpEL 功能和配置选项的子集，适用于不需要完整 SpEL 语言语法且应受到有意义限制的表达式类别，包括但不限于数据绑定表达式和基于属性的过滤器。</p></li><li><p><code>StandardEvaluationContext</code>：提供全套 SpEL 功能和配置选项，可以用它来指定默认根对象，并配置所有可用的求值相关策略。</p></li></ul><p><code>SimpleEvaluationContext</code> 只支持 SpEL 语法的一个子集。它不包括 Java 类型引用、构造函数和 Bean 引用。它还要求使用者明确选择对表达式中属性和方法的支持级别，默认情况下，<code>create()</code>静态工厂方法只能对属性进行读取访问。用户还可以获取一个构建器来配置所需的特定支持级别，针对以下一种或几种组合：</p><ul><li>Custom PropertyAccessor only (no reflection)</li><li>Data binding properties for read-only access</li><li>Data binding properties for read and write</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>默认情况下，SpEL 使用 Spring core 中的转换服务（org.springframework.core.convert.ConversionService）。该转换服务为常见转换提供了许多内置转换器，但也具有完全可扩展性，因此您可以在类型间添加自定义转换。此外，它还具有泛型感知功能。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换，以保持遇到的任何对象的类型正确性。</p><p>举个例子，假设使用 <code>setValue()</code> 进行赋值是为了设置 List 属性。该属性的类型实际上是 <code>List&lt;Boolean&gt;</code>。SpEL会识别到在将列表元素放入其中之前，需要将其转换为布尔值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Boolean&gt; booleanList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">simple.booleanList.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;false&quot; is passed in here as a String. SpEL and the conversion service</span></span><br><span class="line"><span class="comment">// will recognize that it needs to be a Boolean and convert it accordingly.</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;booleanList[0]&quot;</span>).setValue(context, simple, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b is false</span></span><br><span class="line">Boolean b = simple.booleanList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h1><p>可以使用解析器配置对象（org.springframework.expression.spel.SpelParserConfiguration）来配置 SpEL 表达式解析器，该配置对象可控制某些表达式组件的行为。例如，在对数组或集合进行索引时，指定索引处的元素为空，SpEL 会自动创建该元素。这在使用由一连串属性引用组成的表达式时非常有用。如果用户对数组或列表进行索引，并指定一个超出数组或列表当前大小的索引，SpEL 可以自动增长数组或列表以容纳该索引。为了在指定的索引处添加元素，SpEL 将尝试使用元素类型的默认构造函数创建元素，然后再设置指定的值。如果元素类型没有默认构造函数，则会将空值添加到数组或列表中。如果没有转换器（内置或自定义的）知道如何设置值，空值将保留在数组或列表的指定索引处。</p><p>下面的示例演示了如何自动增长列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn on:</span></span><br><span class="line"><span class="comment">// - auto null reference initialization</span></span><br><span class="line"><span class="comment">// - auto collection growing</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">&quot;list[3]&quot;</span>);</span><br><span class="line"></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">Object o = expression.getValue(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.list will now be a real collection of 4 entries</span></span><br><span class="line"><span class="comment">// Each entry is a new empty String</span></span><br></pre></td></tr></table></figure><h1 id="表达式编译（提升求值速度）"><a href="#表达式编译（提升求值速度）" class="headerlink" title="表达式编译（提升求值速度）"></a>表达式编译（提升求值速度）</h1><p>Spring Framework 4.1 包含一个基本的表达式编译器。表达式通常是<strong>解释型</strong>的，这在求值过程中提供了很大的动态灵活性，但无法提供最佳性能。对于偶尔使用表达式的情况，这并无大碍，但当其他组件（如 Spring Integration）使用表达式时，性能可能会变得非常重要，而且对动态性也没有真正的需求。</p><p>SpEL 编译器旨在满足这一需求。在评估过程中，编译器会生成一个 Java 类，在运行时体现表达式的行为，并使用该类实现更快的表达式求值。由于缺乏围绕表达式的类型，编译器在执行编译时会使用在表达式的解释求值过程中收集到的信息。例如，编译器并不能纯粹从表达式中知道属性引用的类型，但在第一次解释求值时，编译器就能知道它是什么类型。当然，如果各种表达式元素的类型随着时间的推移而发生变化，那么根据这些派生信息进行编译就会带来麻烦。因此，编译最适合类型信息不会在重复求值时发生变化的表达式。</p><p>例如对于基本表达式<code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code>来说，由于涉及数组访问、一些属性去引用和数值操作，因此性能提升非常明显。在一个迭代 50000 次的微型基准运行示例中，使用解释器求值需要 75 毫秒，而使用该表达式的编译版本仅需 3 毫秒。</p><h2 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h2><p>编译器默认情况下是不开启的，可以通过两种不同的方式开启它。</p><ol><li>通过使用解析器配置过程打开</li><li>在将SpEL嵌入到其他组件中时，还可以使用Spring属性来打开</li></ol><p>编译器可以在三种模式下运行，这些模式在 org.springframework.expression.spel.SpelCompilerMode 枚举中：</p><ul><li><code>OFF</code> (默认)：编译器关闭。</li><li><code>IMMEDIATE</code>：在立即模式下，表达式会尽快编译。通常是在第一次解释求值之后。如果编译表达式失败（通常是由于类型改变），表达式求值的调用者将收到异常。</li><li><code>MIXED</code>：在混合模式下，表达式会随着时间的推移在解释模式和编译模式之间默默切换。经过一定次数的解释运行后，它们会切换到编译形式，如果编译形式出了问题（如前面所述的类型改变），表达式会自动再次切换回解释形式。之后，它可能会生成另一个编译形式并切换到它。基本上，用户在 <code>IMMEDIATE</code> 模式下获得的异常会在内部处理。</li></ul><p><code>IMMEDIATE</code> 模式之所以存在，是因为 <code>MIXED</code> 模式可能会给有副作用的表达式造成问题。如果一个编译表达式在部分成功后崩溃，那么它可能已经执行了影响系统状态的操作。如果发生了这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能会运行两次。</p><p>选择模式后，使用 <code>SpelParserConfiguration</code> 配置解析器。下面的示例演示了如何进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,</span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expr = parser.parseExpression(<span class="string">&quot;payload&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyMessage message = <span class="keyword">new</span> MyMessage();</span><br><span class="line"></span><br><span class="line">Object payload = expr.getValue(message);</span><br></pre></td></tr></table></figure><p>在指定编译器模式时，还可以指定一个类加载器（允许传递空值）。编译后的表达式将定义在一个子类加载器中，该类加载器将根据所提供的任何类型创建。重要的是，如果指定了类加载器，要确保它能看到表达式求值过程中涉及的所有类型。如果未指定类加载器，则会使用默认类加载器（通常是表达式求值过程中运行线程的上下文类加载器）。</p><p>配置编译器的第二种方法适用于 SpEL 嵌入其他组件的情况，这种情况下可能无法通过配置对象进行配置。在这种情况下，可以通过 JVM 系统属性（或 SpringProperties 机制）将 <code>spring.expression.compiler.mode</code> 属性设置为<code>SpelCompilerMode</code>枚举值。</p><h2 id="编译器的局限性"><a href="#编译器的局限性" class="headerlink" title="编译器的局限性"></a>编译器的局限性</h2><p>自 Spring Framework 4.1 以来，基本的编译框架已经到位。不过，该框架还不支持编译所有类型的表达式。最初的重点是可能在性能关键型上下文中使用的常见表达式。以下几种表达式暂时无法编译：</p><ul><li>涉及赋值的表达式</li><li>依赖转换服务的表达式</li><li>使用自定义解析器或访问器的表达式</li><li>使用选择或投影的表达式</li></ul><h1 id="使用SpEL定义Bean"><a href="#使用SpEL定义Bean" class="headerlink" title="使用SpEL定义Bean"></a>使用SpEL定义Bean</h1><p>用户可以在基于XML或注解的配置元数据中使用SpEL表达式来定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法形式为<code>#&#123; &lt;expression string&gt; &#125;</code>。这里忽略XML配置方式，用的不多了。</p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>要指定默认值，可在字段、方法、方法或构造函数参数上添加<code>@Value</code>注解。</p><p>1、设置一个字段的默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> <span class="comment">// 读取的是服务部署机器的region</span></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、注入属性set方法默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方式，当Spring容器创建 <code>PropertyValueTestBean</code> 对象时，它将调用 <code>setDefaultLocale</code> 方法并传入系统属性中 ‘user.region’ 对应的值，从而设置 <code>defaultLocale</code> 成员变量的值。</p><p>3、<code>@Autowired</code>和构造函数也可以使用 <code>@Value</code> 注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.country&#x27;]&#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>一些值得关注的功能…</p><h2 id="ClassType表达式"><a href="#ClassType表达式" class="headerlink" title="ClassType表达式"></a>ClassType表达式</h2><p>使用<code>T(Type)</code>来表示<code>java.lang.Class</code>实例，<code>Type</code>必须是类全限定名（<code>java.lang</code>包下的类除外）。使用ClassType表达式还可以访问类静态方法及类静态字段。</p><p>下面的例子展示了如何使用ClassType表达式和如何进行条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang包内的不需要使用全限定名</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(String)&quot;</span>).getValue(Class.class);</span><br><span class="line"><span class="comment">// 类静态字段访问</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(Integer).MAX_VALUE&quot;</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 类静态方法调用</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;</span>, ParserContext.TEMPLATE_EXPRESSION).getValue(Double.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：</span></span><br><span class="line"><span class="comment">// 算数运算表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;1 + 1&quot;</span>).getValue(Integer.class);</span><br><span class="line"><span class="comment">// 关系表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2==2&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 逻辑表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2&gt;1 and (NOT true or NOT false)&quot;</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="comment">// instanceof表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(Integer)&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="函数、对象、变量的定义及引用"><a href="#函数、对象、变量的定义及引用" class="headerlink" title="函数、对象、变量的定义及引用"></a>函数、对象、变量的定义及引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;路人甲java&quot;</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;lesson&quot;</span>, <span class="string">&quot;Spring系列&quot;</span>);</span><br><span class="line">        <span class="comment">//获取name变量，lesson变量</span></span><br><span class="line">        String name = parser.parseExpression(<span class="string">&quot;#name&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(name);</span><br><span class="line">        String lesson = parser.parseExpression(<span class="string">&quot;#lesson&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(lesson);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象</span></span><br><span class="line">        <span class="comment">// StandardEvaluationContext构造器传入root对象，可以通过#root来访问root对象</span></span><br><span class="line">        context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">&quot;我是root对象&quot;</span>);</span><br><span class="line">        String rootObj = parser.parseExpression(<span class="string">&quot;#root&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(rootObj);</span><br><span class="line">        <span class="comment">// #this用来访问当前上下文中的对象</span></span><br><span class="line">        String thisObj = parser.parseExpression(<span class="string">&quot;#this&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(thisObj);</span><br><span class="line">        <span class="comment">// 定义List对象，过滤List并做投影运算</span></span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>));</span><br><span class="line">        context.setVariable(<span class="string">&quot;primes&quot;</span>, primes);  <span class="comment">// 注册对象变量</span></span><br><span class="line">        List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(<span class="string">&quot;#primes.?[#this&gt;10]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(primesGreaterThanTen.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义方法</span></span><br><span class="line">        context.registerFunction(<span class="string">&quot;reverseString&quot;</span>, SpELTest.class.getDeclaredMethod(<span class="string">&quot;reverseString&quot;</span>, String.class));</span><br><span class="line">        log.info(parser.parseExpression(<span class="string">&quot;#reverseString(&#x27;hello&#x27;)&quot;</span>).getValue(context, String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><p>SpEL引入了Groovy语言中的安全导航运算符<code>(对象|属性)?.属性</code>，用来避免<code>?.</code>前边的表达式为null时抛出空指针异常，转而返回null。还可以使用<code>?:</code>选择在表达式为null时返回默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">tesla.setName(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// null时取默认值</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?:&#x27;Unknown&#x27;&quot;</span>).getValue(context, String.class));</span><br><span class="line"><span class="comment">// null时安全调用</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?.length()&quot;</span>).getValue(context, Integer.class).toString());</span><br></pre></td></tr></table></figure><h2 id="List运算"><a href="#List运算" class="headerlink" title="List运算"></a>List运算</h2><p>在 SpEL 中，<code>?[]</code> 和 <code>![]</code> 分别表示集合选择（collection selection）和集合投影（collection projection）。<code>?[]</code> 表达式用于选择满足指定条件的集合元素，<code>![]</code> 表达式用于对集合进行投影操作。</p><blockquote><p>集合投影或集合映射的基本思想是：通过对集合中的每个元素应用一个表达式，生成一个新的集合，该集合包含了原始集合中的元素经过某种转换后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELCollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inventor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Bei Jin&quot;</span>);</span><br><span class="line">        Inventor tesla1 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla1&quot;</span>, <span class="string">&quot;Shang Hai&quot;</span>);</span><br><span class="line">        Inventor tesla2 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla2&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Inventor tesla3 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla3&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        Inventor tesla4 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla4&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        List&lt;Inventor&gt; inventors = Arrays.asList(tesla, tesla1, tesla2, tesla3, tesla4);</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">&quot;inventors&quot;</span>, inventors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对List做各类运算：</span></span><br><span class="line">        <span class="comment">// 过滤，选择所有 nationality 字段为 &#x27;Serbian&#x27; 的 Inventor 对象</span></span><br><span class="line">        List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.?[nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 nationality 字段，并返回一个新的 List</span></span><br><span class="line">        List&lt;Inventor&gt; list1 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list1.toString());</span><br><span class="line">        <span class="comment">// 投影，对所有对象的 nationality 字段是否为 &#x27;Serbian&#x27; 进行判断，并返回一个新的布尔类型List</span></span><br><span class="line">        List&lt;Inventor&gt; list2 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list2.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 serbian 字段，并返回一个新的 List，与list1等同。</span></span><br><span class="line">        List&lt;Inventor&gt; list3 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![#this.getNationality()]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问Map"><a href="#访问Map" class="headerlink" title="访问Map"></a>访问Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问map</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">params.put(<span class="string">&quot;backOrderCode&quot;</span>, <span class="string">&quot;H12345764564&quot;</span>);</span><br><span class="line">context.setVariable(<span class="string">&quot;params&quot;</span>, params);</span><br><span class="line">Object object = parser.parseExpression(<span class="string">&quot;#params[backOrderCode]&quot;</span>).getValue(context);</span><br><span class="line">log.info(object.toString());</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/174786047">https://zhuanlan.zhihu.com/p/174786047</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/149920813">https://zhuanlan.zhihu.com/p/149920813</a><br>[3] <a href="https://docs.spring.io/spring-framework/reference/core/expressions.html">https://docs.spring.io/spring-framework/reference/core/expressions.html</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。&lt;/p&gt;
&lt;p&gt;SpEL是单独模块（&lt;code&gt;org.springframework.expression&lt;/code&gt;），只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>空洞卷积</title>
    <link href="http://silencezheng.top/2023/12/25/article124/"/>
    <id>http://silencezheng.top/2023/12/25/article124/</id>
    <published>2023-12-24T18:01:57.000Z</published>
    <updated>2023-12-24T18:07:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。<br><span id="more"></span></p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>空洞卷积最初的提出是为了解决图像分割的问题，常见的图像分割算法通常使用池化层和卷积层来增加感受域，同时也缩小了特征图尺寸(resolution)，然后再利用上采样还原图像尺寸，特征图缩小再放大的过程造成了精度上的损失，因此需要一种操作可以在增加感受域的同时保持特征图的尺寸不变，从而代替下采样和上采样操作，在这种需求下，空洞卷积就诞生了。当然，跳跃连接（skip connection）也是另一种弥补信息损失的方法。</p><p>空洞卷积自2016在ICLR上被提出后，本身是用在图像分割领域，但立马被Deepmind拿来应用到语音(WaveNet)和NLP领域，它在物体检测也发挥了重要的作用。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在常规卷积运算中，固定大小的滤波器在输入特征图上滑动，滤波器中的值与输入特征图中的相应值相乘以产生单个输出值。输出特征图中神经元的感受域被定义为滤波器可以“看到”的输入特征图中的区域。感受域的大小由滤波器的大小和卷积的步长决定。</p><p>相反，在膨胀卷积运算中，通过在滤波器值之间插入间隙来“扩张”滤波器。<strong>膨胀率</strong>(dilation rate) 决定了间隙的大小，它是一个可以调整的超参数。当膨胀率为 1 时，膨胀卷积简化为常规卷积。</p><p>膨胀率在不增加参数数量的情况下有效地增加了滤波器的感受域，因为滤波器的大小仍然相同，但值之间有间隙。这在需要更大感受域的情况下很有用，但增加滤波器的大小会导致参数数量和计算复杂性的增加。</p><p>下图描述了正常卷积与扩张卷积之间的差异，附加参数$l$（膨胀因子）表示输入扩张了多少。换句话说，根据该参数的值，滤波器中会跳过$(l-1)$个像素。</p><p><img src="/assets/post_img/article124/normalvsdilatedconv.png" alt="dc"></p><p>膨胀卷积的公式可表示如下：</p><script type="math/tex; mode=display">\left(F_{* l} k\right)(p)=\sum_{(s+l t=p)} F(s) k(t)</script><p>其中，$F(s)$为输入特征，$s$为各采样位置，$k(t)$表示卷积核$k$在$t$处的权重，${*l}$表示膨胀因子为$l$的膨胀卷积。</p><p>$(F_{* l} k)(p)$为在位置$p$处的输出。求和条件还需要再看下…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在Pytorch中实现空洞卷积十分简单，只需要指定dilation参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DilatedCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(DilatedCNN,self).__init__()</span><br><span class="line">    self.convlayers = nn.Sequential(</span><br><span class="line">      nn.Conv2d(in_channels = <span class="number">3</span>, out_channels = <span class="number">6</span>, kernel_size = <span class="number">9</span>, stride = <span class="number">1</span>, padding = <span class="number">0</span>, dilation=<span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding= <span class="number">0</span>, dilation = <span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">    )</span><br><span class="line">    self.fclayers = nn.Sequential(</span><br><span class="line">      nn.Linear(<span class="number">2304</span>,<span class="number">120</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">120</span>,<span class="number">84</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line">    )</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    x = self.convlayers(x)</span><br><span class="line">    x = x.view(-<span class="number">1</span>,<span class="number">2304</span>)</span><br><span class="line">    x = self.fclayers(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>网格效应（The Gridding Effect）</li><li>Long-ranged information might be not relevant.</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/113285797">https://zhuanlan.zhihu.com/p/113285797</a><br>[2] <a href="https://www.geeksforgeeks.org/dilated-convolution/">https://www.geeksforgeeks.org/dilated-convolution/</a><br>[3] <a href="https://developer.orbbec.com.cn/v/blog_detail/892">https://developer.orbbec.com.cn/v/blog_detail/892</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在Spring项目中使用数据库事务</title>
    <link href="http://silencezheng.top/2023/11/24/article123/"/>
    <id>http://silencezheng.top/2023/11/24/article123/</id>
    <published>2023-11-24T15:48:44.000Z</published>
    <updated>2023-11-24T15:57:36.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。</p><p>相关内容：InnoDB事务实现、Spring事务传播机制等。<br><span id="more"></span></p><h1 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong>。事务是一种用于维护数据一致性的机制，它确保了数据库在多个并发操作下仍然保持一致性。</p><p>事务（最小操作单元）存在的主要意图：</p><ul><li>在最小操作单元中保持稳定的操作，即使在故障时也能恢复到操作之前的状态保持数据一致性。</li><li>保持各个最小操作单元之间互相隔离，以防止互相交互产生的覆盖性错误。</li></ul><p>事务结束的两种可能方式：</p><ul><li><code>commit</code>：提交最小操作单元中的所有操作。</li><li><code>terminate</code>：操作终止，最小操作单元中所有修改无效。</li></ul><p>数据库操作的环境：</p><ul><li>共享-多用户并发访问</li><li>不稳定-潜在的硬件/软件故障</li></ul><p>事务所需环境：</p><ul><li>不共享 - 一个事务内的操作不受其他事务影响</li><li>稳定 - 即使面对系统故障，当前事务的操作也能保留现场</li></ul><p>一个事务一旦开始，则必须确保：</p><ul><li>所有操作必须可回溯</li><li>所有操作对后续操作的影响必须是可见的</li></ul><p>一个事务开始的过程中必须确保：在该事务结束之前其他事务看不到它的结果。如果事务中止，必须确保当前事务所有可能影响数据一致性的操作都会被清理。如果系统出现故障，必须确保重新启动时所有未提交的事务都会被清理。</p><p>关系型数据库大多遵循事务的四大特性：</p><ol><li>原子性（Atomicity）：事务是最小的执行单位，事务中的所有操作要么全部成功执行，要么全部失败回滚。如果其中任何一个操作失败，那么整个事务都会被回滚到初始状态。</li><li>一致性（Consistency）：事务在执行前后，数据库必须保持一致性状态。这意味着事务执行后，数据库的完整性约束仍然得以维护，以转账业务为例，双方存款总额应不变。</li><li>隔离性（Isolation）：事务的执行应该与其他事务相互隔离，即一个事务的执行不应该影响其他事务的执行。这确保了并发事务之间的数据不会互相干扰。</li><li>持久性（Durability）：一旦事务提交成功，对数据库的修改应该永久保存，即使数据库发生故障也不应该对其有影响。</li></ol><p>关于四大特性的一些理解：</p><blockquote><p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。只有保证了事务的持久性、原子性、隔离性之后，一致性才可能得到保障。</p></blockquote><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久性是为了能应对数据库崩溃的情况。</li></ul><h1 id="InnoDB事务实现"><a href="#InnoDB事务实现" class="headerlink" title="InnoDB事务实现"></a>InnoDB事务实现</h1><p>MySQL提供插件式存储引擎，这些存储引擎是基于表的，而不是数据库。</p><p>InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。它的特点是行锁设计，支持外键，并支持非锁定读，即默认读取操作不会产生锁。从MySQL数据库5.5.8版本开始，InnoDB存储引擎是MySQL默认的存储引擎。</p><p>在InnoDB引擎中实现事务最重要的东西就是日志系统，保证事务的四大特性主要依靠这两大日志：</p><ul><li><strong>redo log</strong>：保证事务持久性</li><li><strong>undo log</strong>：回滚日志，保证事务原子性</li></ul><p>两大日志系统分别保证了持久性和原子性，隔离性则是通过<strong>MVCC机制</strong>和<strong>锁机制</strong>来控制实现。</p><h2 id="Logical-logs-amp-Physical-logs"><a href="#Logical-logs-amp-Physical-logs" class="headerlink" title="Logical logs &amp; Physical logs"></a>Logical logs &amp; Physical logs</h2><p><strong>逻辑日志（Logical Logs）：</strong></p><ol><li><strong>记录内容</strong>：逻辑日志记录的是数据库操作的逻辑信息，例如SQL语句、表和列的名称、数据的逻辑结构等。它不关心底层数据的物理存储方式。</li><li><strong>用途</strong>：逻辑日志主要用于数据导入、导出、备份和恢复等高层次的数据操作。它允许将数据从一个数据库复制到另一个数据库，而不必考虑底层数据的物理结构。</li><li><strong>示例</strong>：MySQL的二进制日志（binlog）是一种逻辑日志，记录了SQL语句的执行顺序，以便在复制数据或进行数据备份时使用。</li></ol><p><strong>物理日志（Physical Logs）：</strong></p><ol><li><strong>记录内容</strong>：物理日志记录的是数据库操作对底层物理数据的实际修改，包括数据页的读写、磁盘块的分配和释放等。它关注数据的物理存储细节。</li><li><strong>用途</strong>：物理日志主要用于确保事务的持久性和恢复能力。它允许在系统崩溃或故障后恢复未提交的事务，以及将事务的修改应用到数据库中。</li><li><strong>示例</strong>：MySQL的重做日志（redo log）是一种物理日志，记录了事务对数据页的修改，以便在事务提交后将这些修改应用到数据文件中，或者在系统故障时恢复数据一致性。</li></ol><p>以上只是简要的概念解释，更多信息可以参见[6]。</p><h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>在介绍InnoDB的两大核心日志前，先简单聊一下MySQL的二进制日志，对理解Redo log的作用有帮助。</p><p>binlog = binary log，二进制日志，它记录了除了 select 之外所有的 DDL 和 DML 语句。以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog是MySQL的逻辑日志，并且由Server层进行记录，使用任何存储引擎的MySQL都会记录binlog日志。</p><p>binlog日志有两个最重要的使用场景：</p><ul><li>主从复制：mysql replication 在 master 端开启 binlog，master 把它的二进制日志传递给 slaves 来达到 master-slave 数据一致的目的。</li><li>数据恢复：通过 mysqlbinlog 工具来恢复数据。</li></ul><p>binlog 日志包括两类文件：</p><ol><li>二进制日志索引文件（文件名后缀为 .index）用于记录所有的二进制文件。</li><li>二进制日志文件（文件名后缀为 .00000*）记录数据库所有的 DDL 和 DML 语句事件。</li></ol><p>binlog文件是通过追加的方式写入的，可通过配置参数<code>max_binlog_size</code>设置每个 binlog 文件的大小，当文件大小大于给定值后，日志会发生滚动，之后的日志记录到新的文件上。</p><p>binlog日志有三种格式，分别为STATMENT、ROW和MIXED。在 MySQL 5.7.7之前，默认的格式是STATEMENT，MySQL 5.7.7之后，默认值是ROW。日志格式通过<code>binlog-format</code>指定。</p><p>我们假设数据库只有 binlog，那么数据文件的更新和写入 binlog 只有两种情况：</p><ol><li>先更新数据文件，再写入 binlog。</li><li>先写入 binlog，再更新数据文件。</li></ol><p>如果先更新数据文件，接着服务器宕机，则导致 binlog 中缺少最后的更新信息；如果先写 binlog 再更新数据则可能导致数据文件未被更新。所以在只有 binlog 的环境中的 MySQL 是不具备 crash-safe 的能力。</p><p>PS：这里关于binlog的写入机制不做过多展开，但也是分write和fsync两个步骤，时机由参数<code>sync_binlog</code>控制。</p><h2 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h2><p>Write-Ahead Logging策略是一种用于确保数据一致性和恢复能力的重要技术，为了保证恢复时可以从日志中看到最新的数据库状态，要求日志先于数据内容落盘。其核心思想是在修改数据之前，首先将这些修改操作记录到一个持久性的日志文件中，然后再将这些操作应用到实际的数据文件。注意这里的日志是比binlog更细粒度的日志。</p><p>除此之外，事务完成提交前还需要在日志中记录对应的Commit标记，以供恢复时了解当前的事务状态，因此还需要关注Commit标记和事务中数据内容的落盘顺序。根据日志中记录的内容可以分为三类：<strong>Undo-Only</strong>，<strong>Redo-Only</strong>，<strong>Redo-Undo</strong>。</p><h3 id="Undo-Only-Logging"><a href="#Undo-Only-Logging" class="headerlink" title="Undo-Only Logging"></a>Undo-Only Logging</h3><p>Undo-Only Logging的Log记录可以表示为<code>&lt;T, X, v&gt;</code>，事务$T$修改了$X$的值，$X$的旧值是v。事务提交时，需要通过强制Flush保证Commit标记落盘前，对应事务的所有数据落盘，即落盘顺序为Log记录-&gt;Data-&gt;Commit标记。恢复时可以根据Commit标记判断事务的状态，并通过Undo Log中记录的旧值将未提交事务的修改回滚。我们来审视一下Undo-Only对Durability及Atomic的保证：</p><ul><li>Durability of Updates：Data强制刷盘保证，已经Commit的事务由于其所有Data都已经在Commit标记之前落盘，因此会一直存在；</li><li>Failure Atomic：Undo Log内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>然而Undo-Only依然有不能Page内并发的问题，如果两个事务的修改落到一个Page中，一个事务提交前需要的强制Flush操作，会导致同Page所有事务的Data落盘，可能会早于对应的Log项从而损害WAL。同时，也会导致关键路径上过于频繁的磁盘随机访问。</li></ul><h3 id="Redo-Only-Logging"><a href="#Redo-Only-Logging" class="headerlink" title="Redo-Only Logging"></a>Redo-Only Logging</h3><p>不同于Undo-Only，采用Redo-Only的Log中记录的是修改后的新值。对应地，Commit时需要保证，Log中的Commit标记在事务的任何数据之前落盘，即落盘顺序为Log记录-&gt;Commit标记-&gt;Data。恢复时同样根据Commit标记判断事务状态，并通过Redo Log中记录的新值将已经Commit，但数据没有落盘的事务修改重放。</p><ul><li>Durability of Updates：Redo Log内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：阻止Commit前Data落盘保证，失败事务的修改不会出现在磁盘上，自然不可见。<br>Redo-Only同样有不能Page内并发的问题，Page中的多个不同事务，<strong>只要有一个未提交就不能刷盘，这些数据全部都需要维护在内存中，造成较大的内存压力</strong>。</li></ul><h3 id="Redo-Undo-Logging"><a href="#Redo-Undo-Logging" class="headerlink" title="Redo-Undo Logging"></a>Redo-Undo Logging</h3><p>可以看出的只有Undo或Redo的问题，主要来自于对Commit标记及Data落盘顺序的限制，而这种限制归根结底来源于Log信息中对新值或旧值的缺失。因此Redo-Undo采用同时记录新值和旧值的方式，来消除Commit和Data之间刷盘顺序的限制。</p><ul><li>Durability of Updates：Redo 内容保证，已提交事务的未刷盘的修改，利用Redo Log中的内容重放，之后可见；</li><li>Failure Atomic：Undo内容保证，失败事务的已刷盘的修改会在恢复阶段通过Undo日志回滚，不再可见。<br>如此一来，同Page的不同事务提交就变得非常简单。同时可以将连续的数据攒着进行批量的刷盘已利用磁盘较高的顺序写性能。</li></ul><h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入磁盘后，内存和磁盘上的数据页内容就一致了，称为“干净页”。刷脏页，即把脏页（内存中的修改过的数据页）刷新（flush）到磁盘上。</p><p>对于 InnoDB 存储引擎，缓冲池（buffer pool）是内存中的一个重要组成部分。当查询需要读取数据时，数据库首先查看缓冲池中是否已经有相应的数据页。如果数据页在缓冲池中，查询可以立即从内存中获取数据，而不必进行磁盘读取，这大大提高了性能。如果数据页不在缓冲池中（缓冲池未命中），数据库系统将从磁盘读取该数据页，并将其放入缓冲池中，以便将来的查询可以更快地访问。缓冲池的大小通常是可以配置的，数据库管理员可以根据系统的内存和性能需求来调整缓冲池的大小。</p><p>对于事务处理，数据的修改通常首先在内存中进行，然后等待事务提交。在事务提交之前，数据在内存中被认为是脏的，因为它们还未被写入到磁盘。下面有一段文字可以也可以帮助引出Redo log的作用。</p><blockquote><p>InnoDB 有 缓冲池（buffer pool）。缓冲池是物理页的缓存，对 InnoDB 的任何修改操作都会首先在缓冲池的 page 上进行，然后这样的页面将被标记为 dirty 并被放到专门的 flush list 上，后续将由专门的刷脏线程阶段性的将这些页面写入磁盘。这样的好处是避免每次写操作都操作磁盘导致大量的随机IO，阶段性的刷脏可以将多次对页面的修改 merge 成一次IO操作，同时异步写入也降低了访问的时延。</p><p>然而，如果在 dirty page 还未刷入磁盘时，server非正常关闭，这些修改操作将会丢失，如果写入操作正在进行，甚至会由于损坏数据文件导致数据库不可用。为了避免上述问题的发生，Innodb 将所有对页面的修改操作写入一个专门的文件，并在数据库启动时从此文件进行恢复操作，这个文件就是 redo log file。这样的技术推迟了缓冲池页面的刷新，从而提升了数据库的吞吐，有效的降低了访问时延。带来的问题是额外的写 redo log 操作的开销（顺序 IO，比随机 IO 快很多），以及数据库启动时恢复操作所需的时间。</p></blockquote><h2 id="Redo-log-Durability"><a href="#Redo-log-Durability" class="headerlink" title="Redo log (Durability)"></a>Redo log (Durability)</h2><p>Redo log包括两部分：一个是内存中的日志缓冲(redo log buffer)，另一个是磁盘上的日志文件(redo log file)。</p><p>在计算机操作系统中，用户空间(user space)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernel space)缓冲区(OS Buffer)。因此，redo log buffer写入redo log file实际上是先写入文件系统page cache，然后再通过系统调用fsync将其刷到redo log file中。由此可以得到redo log的三种状态：</p><ol><li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中。</li><li>写到磁盘 (write)，但是没有持久化，物理上是在文件系统的 page cache 里面。</li><li>调用fsync，持久化到磁盘。</li></ol><p>事务在执行过程中，对内存中数据页进行修改将生成redo log，生成的 redo log 是先写到 redo log buffer 中，然后通过某些方式刷入磁盘。这里所指的方式，个人理解主要有五种：</p><ol><li>后台线程每秒一次执行刷盘，并行轮询。</li><li>每个事务提交时依据策略刷盘。</li><li>当redo log buffer缓存可用空间小于一半的时候刷盘，整体空间受<code>innodb_log_buffer_size</code>控制。这个情况的刷盘仅指write，然后可能被后台线程刷盘，这也是未提交redo log刷盘的可能情况之一。</li><li>数据库服务器正常关闭时。</li><li>检查点，<strong>checkpoints</strong>。</li></ol><p>PS：另外两种情况是：1、事务执行过程中的 redo log 也是直接写在 redo log buffer 中的，即将事务的修改暂时保存于内存中，这些 redo log 也会被后台线程一起持久化到磁盘。即一个没有提交的事务的 redo log，也是可能已经持久化到磁盘的。2、事务并行，先提交的事务把其他事务的redo log buffer刷盘。</p><p>Redo log的在事务提交时的写入策略由参数<code>innodb_flush_log_at_trx_commit</code>控制，有以下三种取值选项：</p><ol><li>设置为<code>0</code>的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为<code>1</code>的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘（默认）；</li><li>设置为<code>2</code>的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>（TODO：这一部分应该有问题，内存中的数据也会写入，不过这时候落盘的脏数据就靠undo了）那么了解了redo log的写入机制后，它到底是如何实现保证数据库持久性的呢？下面我尝试从一个事务的开始进行分析。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Chain1:</span> 事务开始 -&gt; 数据页读取 -&gt; 事务执行（数据页修改 &amp; <span class="keyword">redo</span> log生成）-&gt; 事务提交 -&gt; 事务结束</span><br><span class="line"><span class="symbol">Chain2:</span>                           执行过程中会发生<span class="keyword">redo</span> log刷盘  依据策略决定是否直接刷盘    </span><br></pre></td></tr></table></figure><p>我把执行流程分为了两个链条，chain1是事务执行的流程，chain2是redo log部分InnoDB在对应位置可能采取的操作。下面我们在chain1的每个部分模拟掉电关机，看会发生什么事情。由于这一块内容实际上是崩溃恢复相关内容，我们先定义<strong>正常状态</strong>，<strong>正常状态</strong>指的是 MySQL 崩溃之前，数据页最后一次正确的刷新到磁盘的状态。</p><p>1、数据页读取：对数据库完整性无影响。<br>2、事务执行（redo log生成未落盘）：无影响，事务未提交。<br>3、事务执行（redo log生成已落盘）：无影响，事务未提交。<br>4、事务提交（redo log写入策略=1）：任意时间崩溃，都可以通过redo log执行恢复，损坏的数据页可以通过<strong>double write</strong>修复后再执行恢复。<br>5、事务提交（redo log写入策略=2）：如果在redo log刚写入未刷盘时断电，则会丢失上一秒的数据，仅mysqld崩溃不会丢失数据。<br>6、事务提交（redo log写入策略=0）：与上一情况相同，但如果崩溃情况降级，例如mysqld崩溃，也会丢失数据。</p><p>注意以上分析仅是简化版，更多细节如Checkpoints、Double write、LSN、Mini-Transaction等…需要多读书实践才能通透了，需要时再学习吧。</p><h2 id="Undo-log-Atomicity"><a href="#Undo-log-Atomicity" class="headerlink" title="Undo log (Atomicity)"></a>Undo log (Atomicity)</h2><p>Undo Log是InnoDB十分重要的组成部分，它的作用横贯InnoDB中两个最主要的部分，并发控制（Concurrency Control）和故障恢复（Crash Recovery），InnoDB中undo log的实现亦日志亦数据。</p><p>为保证原子性，InnoDB会在正常事务进行中，就不断的连续写入undo log，来记录本次修改之前的历史值。当故障真正发生时，可以在recovery过程中通过回放undo log将未提交事务的修改抹掉。此外，undo log也可以用来支持死锁处理或用户请求的事务回滚。</p><p>在并发控制中，主流数据库采用多版本并发控制，为每条记录保存多份历史数据供读事务访问，新的写入只需要添加新的版本即可，InnoDB利用undo log提供此功能。</p><p>在设计方面，undo log需要的是事务之间的并发，以及方便的多版本数据维护，其重放逻辑不希望因数据库物理存储变化而变化，因此InnoDB中的undo log采用<strong>逻辑日志</strong>。同时，InnoDB是把undo log当做一种数据来维护和使用的，其本身也像其他的数据库数据一样，会写自己对应的redo log，以此保证自己不出错。</p><h3 id="Undo-Record的内容"><a href="#Undo-Record的内容" class="headerlink" title="Undo Record的内容"></a>Undo Record的内容</h3><p>每当InnoDB中需要修改某条记录时，都会将其历史版本写入一个undo log中，对应的undo record是Update类型。当插入新的记录时，还没有一个历史版本，但为了方便事务回滚时做逆向（Delete）操作，还是会写入一个Insert类型的undo record。</p><p>对于Insert类型的undo record，它仅仅是为了可能的事务回滚准备的，并不在MVCC功能中承担作用，因此只需要用<strong>Key Fields</strong>记录对应数据库记录的主键，供回滚时查找记录位置即可。</p><p><img src="/assets/post_img/article123/insert_undo_record.png" alt=""></p><p>其中Undo Number是Undo的一个递增编号，Table ID用来表示是哪张表的修改。下面一组Key Fields的长度不定，因为对应表的主键可能由多个field组成，这里需要存储数据库记录完整的主键信息，回滚的时候可以通过这个信息在索引中定位到对应的记录。除此之外，在Undo Record的头尾还各留了两个字节用户记录其前序和后继Undo Record的位置。</p><p>对于Update类型的undo record，情况稍微复杂一些，由于MVCC需要保留记录的多个历史版本，当某个记录的历史版本还在被使用时，这个记录是不能被真正的删除的。因此，当需要删除时，其实只是修改对应记录的Delete Mark标记。对应的，如果这时这个记录又重新插入，其实也只是修改一下Delete Mark标记，也就是将这两种情况的删除和插入转变成了更新操作。再加上常规的更新记录，这种类型的undo record存在三种类型：<code>TRX_UNDO_UPD_EXIST_REC, TRX_UNDO_DEL_MARK_REC, TRX_UNDO_UPD_DEL_REC</code>。</p><p><img src="/assets/post_img/article123/update_undo_record.png" alt=""></p><p>除了<strong>Key Fields</strong>外，Update类型的undo record增加了以下内容：</p><ol><li>Transaction Id，记录了产生这个历史版本事务ID，用作后续MVCC中的版本可见性判断。</li><li>RollPtr，指向的是该记录的上一个版本的位置，沿着RollPtr可以找到一个记录的所有历史版本。</li><li>Update Fields，其中记录的就是当前这个记录版本相对于其之后的一次修改的Delta信息，包括所有被修改的Field的编号，长度和历史值。</li></ol><h3 id="Undo-Record的组织方式"><a href="#Undo-Record的组织方式" class="headerlink" title="Undo Record的组织方式"></a>Undo Record的组织方式</h3><p>每一次的修改都会产生至少一个Undo Record，现在考虑大量Undo Record如何组织起来支持高效访问与管理。首先是在不考虑物理存储的情况下的逻辑组织方式；之后，物理组织方式介绍如何将其存储到到实际16KB物理块中；然后文件组织方式介绍整体的文件结构；最后再介绍其在内存中的组织方式。</p><h4 id="逻辑组织方式-Undo-Log"><a href="#逻辑组织方式-Undo-Log" class="headerlink" title="逻辑组织方式 - Undo Log"></a>逻辑组织方式 - Undo Log</h4><p>每个事务会修改一组数据库记录，对应的会产生一组Undo Record，这些Undo Record首尾相连组成了这个事务的Undo Log。除了一个个的Undo Record之外，还在开头增加了一个Undo Log Header来记录一些必要的控制信息，因此，一个Undo Log的结构如下所示：</p><p><img src="/assets/post_img/article123/undo_log.png" alt=""></p><p><strong>Undo Log Header</strong>中记录了产生这个Undo Log的事务的Trx ID；Trx No是事务的提交顺序，也会用这个来判断是否能Purge，这个在后面会详细介绍；Delete Mark标明该Undo Log中有没有<code>TRX_UNDO_DEL_MARK_REC</code>类型的Undo Record，避免Purge时不必要的扫描；Log Start Offset中记录Undo Log Header的结束位置，方便之后Header中增加内容时的兼容；之后是一些Flag信息；Next Undo Log及Prev Undo Log标记前后两个Undo Log，这个会在接下来介绍；最后通过History List Node将自己挂载到为Purge准备的History List中。</p><p>索引中的同一个数据库记录被不同事务修改，会产生不同的历史版本，这些历史版本又通过<strong>Rollptr</strong>穿成一个链表，供MVCC使用。如下图所示：</p><p><img src="/assets/post_img/article123/undo_logical.png" alt=""></p><p>示例中有三个事务操作了表$t$上，主键id是1的记录，首先事务$I$插入了这条记录并且设置字段$a$的值为A，之后事务$J$和事务$K$分别将这条id为1的记录中的字段$a$的值修改为了B和C。$I$，$J$，$K$三个事务分别有自己的逻辑上连续的三条Undo Log，每条Undo Log有自己的Undo Log Header。从索引中的这条数据库记录沿着<strong>Rollptr</strong>可以依次找到这三个事务Undo Log中关于这条记录的历史版本。同时可以看出，Insert类型Undo Record中只记录了对应的主键值：<code>id=1</code>，而Update类型的Undo Record中还记录了对应的历史版本的生成事务Trx_id，以及被修改的字段$a$的历史值。</p><h4 id="物理组织格式-Undo-Segment"><a href="#物理组织格式-Undo-Segment" class="headerlink" title="物理组织格式 - Undo Segment"></a>物理组织格式 - Undo Segment</h4><p>一个事务会产生多大的Undo Log本身是不可控的，而最终写入磁盘却是按照固定的块大小为单位的，InnoDB中默认是16KB，因此需要考虑如何用固定的块大小承载不定长的Undo Log，以实现高效的空间分配、复用，避免空间浪费。InnoDB的基本思路是让多个较小的Undo Log紧凑存在一个Undo Page中，而对较大的Undo Log则随着不断的写入，按需分配足够多的Undo Page分散承载。下面来看这部分的物理存储方式：</p><p><img src="/assets/post_img/article123/undo_physical.png" alt=""></p><p>每个写事务开始写操作之前都需要持有一个Undo Segment，一个Undo Segment中的所有磁盘空间的分配和释放，也就是16KB Page的申请和释放，都是由一个FSP Segment管理的。</p><blockquote><p>FSP（File Space Page）是InnoDB存储引擎中的一个概念，表示文件空间段（Segment）。每个FSP Segment对应于一个表空间（tablespace），用于存储数据和索引。</p><p>在InnoDB中，数据和索引被组织为一个个页面（Page），而这些页面又按照一定的方式来组织并保存在FSP Segment中。FSP Segment是InnoDB存储引擎管理存储空间的基本单位。</p><p>FSP Segment包含多个连续的文件空间页（File Space Pages），这些页面可以是数据页、索引页或其他类型的页，以满足不同的存储需求。每个FSP Segment都有自己的FSP ID（File Space Page ID），用于唯一标识它。</p></blockquote><p>Undo Segment会持有至少一个Undo Page，每个Undo Page会在开头38字节到56字节记录Undo Page Header，其中记录Undo Page的类型、最后一条Undo Record的位置，当前Page还空闲部分的开头，也就是下一条Undo Record要写入的位置。Undo Segment中的第一个Undo Page还会在56字节到86字节记录<strong>Undo Segment Header</strong>，这就是这个Undo Segment中磁盘空间管理的Handle，其中记录的是这个Undo Segment的状态（State），包括TRX_UNDO_CACHED、TRX_UNDO_TO_PURGE等，还记录了这个Undo Segment中最后一条Undo Record的位置、这个FSP Segment的Header以及当前分配出来的所有Undo Page的链表。</p><p>Undo Page剩余的空间都是用来存放Undo Log的，对于像上图Undo Log 1，Undo Log 2这种较短的Undo Log，为了避免Page内的空间浪费，InnoDB会复用Undo Page来存放多个Undo Log，而对于像Undo Log 3这种比较长的Undo Log可能会分配多个Undo Page来存放。需要注意的是Undo Page的复用只会发生在第一个Page。</p><h4 id="文件组织方式-Undo-Tablespace"><a href="#文件组织方式-Undo-Tablespace" class="headerlink" title="文件组织方式 - Undo Tablespace"></a>文件组织方式 - Undo Tablespace</h4><p>每一时刻一个Undo Segment都是被一个事务独占的。每个写事务都会持有至少一个Undo Segment，当有大量写事务并发运行时，就需要存在多个Undo Segment。InnoDB中的Undo文件中准备了大量的Undo Segment的槽位，按照1024一组划分为<strong>Rollback Segment</strong>。每个<strong>Undo Tablespace</strong>最多会包含128个Rollback Segment，Undo Tablespace文件中的第三个Page会固定作为这128个Rollback Segment的目录，也就是<strong>Rollback Segment Arrary Header</strong>，其中最多会有128个指针指向各个Rollback Segment Header所在的Page。Rollback Segment Header是按需分配的，其中包含1024个Slot，每个<strong>Slot</strong>占四个字节，指向一个Undo Segment的First Page。除此之前还会记录该Rollback Segment中已提交事务的History List，后续的Purge过程会顺序从这里开始回收工作。</p><p>可以看出Rollback Segment的个数会直接影响InnoDB支持的最大事务并发数。MySQL 8.0由于支持了最多127个独立的Undo Tablespace，一方面避免了ibdata1的膨胀，方便undo空间回收，另一方面也大大增加了最大的Rollback Segment的个数，增加了可支持的最大并发写事务数。如下图所示：</p><p><img src="/assets/post_img/article123/undo_tablespace.png" alt=""></p><h4 id="内存组织结构"><a href="#内存组织结构" class="headerlink" title="内存组织结构"></a>内存组织结构</h4><p>上面介绍的都是Undo数据在磁盘上的组织结构，除此之外，在内存中也会维护对应的数据结构来管理Undo Log，如下图所示：</p><p><img src="/assets/post_img/article123/undo_memory.png" alt=""></p><p>对应每个磁盘Undo Tablespace会有一个<strong>undo::Tablespace</strong>的内存结构，其中最主要的就是一组<strong>trx_rseg_t</strong>的集合，trx_rseg_t对应的就是上面介绍过的一个Rollback Segment Header（目录），除了一些基本的元信息之外，trx_rseg_t中维护了四个trx_undo_t的链表，Update List中是正在被使用的用于写入Update类型Undo的Undo Segment；Update Cache List中是空闲空间比较多，可以被后续事务复用的Update类型Undo Segment;对应的，Insert List和Insert Cache List分别是正在使用中的Insert类型Undo Segment，和空间空间较多，可以被后续复用的Insert类型Undo Segment。因此<strong>trx_undo_t对应的就是上面介绍过的Undo Segment</strong>。接下来，我们就从Undo的写入、Undo用于Rollback、MVCC、Crash Recovery以及如何清理Undo等方面来介绍InnoDB中Undo的角色和功能。</p><h3 id="Undo-Log的写入"><a href="#Undo-Log的写入" class="headerlink" title="Undo Log的写入"></a>Undo Log的写入</h3><p>当写事务开始时，会先通过<strong>trx_assign_rseg_durable</strong>操作分配一个Rollback Segment，该事务的内存结构<strong>trx_t</strong>也会通过rsegs指针指向对应的trx_rseg_t内存结构，这里的分配策略很简单，就是依次尝试下一个Active的Rollback Segment。之后当第一次真正产生修改需要写Undo Record的时，会调用<strong>trx_undo_assign_undo</strong>操作来获得一个Undo Segment。这里会优先复用trx_rseg_t上<strong>Cached List</strong>中的trx_undo_t，也就是已经分配出来但没有被正在使用的Undo Segment，如果没有才调用<strong>trx_undo_create</strong>操作创建新的Undo Segment，trx_undo_create中会轮询选择当前Rollback Segment中可用的Slot，也是就值FIL_NUL的Slot，申请新的Undo Page，初始化Undo Page Header，Undo Segment Header等信息，创建新的trx_undo_t内存结构并挂到trx_rseg_t的对应List中。</p><p>获得了可用的Undo Segment之后，该事务会在合适的位置初始化自己的Undo Log Header，之后，其所有修改产生的Undo Record都会顺序的通过<strong>trx_undo_report_row_operation</strong>操作顺序的写入当前的Undo Log，其中会根据是insert还是update类型，分别调用trx_undo_page_report_insert或者trx_undo_page_report_modify。本文开始已经介绍过了具体的Undo Record内容。简单的讲，insert类型会记录插入Record的主键，update类型除了记录主键以外还会有一个update fileds记录这个历史值跟索引值的diff。之后指向当前Undo Record位置的Rollptr会返回写入索引的Record上。</p><p>当一个Page写满后，会调用<strong>trx_undo_add_page</strong>来在当前的Undo Segment上添加新的Page，新Page写入Undo Page Header之后继续供事务写入Undo Record，为了方便维护，这里有一个限制就是单条Undo Record不跨page，如果当前Page放不下，会将整个Undo Record写入下一个Page。</p><p>当事务结束（commit或者rollback）之后，如果只占用了一个Undo Page，且当前Undo Page使用空间小于page的3/4，这个Undo Segment会保留并加入到对应的insert/update cached list中。否则，insert类型的Undo Segment会直接回收，而update类型的Undo Segment会等待后台的Purge做完后回收。根据不同的情况，Undo Segment Header中的State会被从<code>TRX_UNDO_ACTIVE</code>改成<code>TRX_UNDO_TO_FREE</code>，<code>TRX_UNDO_TO_PURGE</code>或<code>TRX_UNDO_CACHED</code>，这个修改其实就是InnoDB的事务结束的标志，无论是Rollback还是Commit，在这个修改对应的Redo落盘之后，就可以返回用户结果，并且Crash Recovery之后也不会再做回滚处理。</p><h3 id="Undo-Log之回滚"><a href="#Undo-Log之回滚" class="headerlink" title="Undo Log之回滚"></a>Undo Log之回滚</h3><p>InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或者发生Crash，重启后对未提交的事务回滚。在Undo层面来看，这些回滚的操作是一致的，基本的过程就是从该事务的Undo Log中，从后向前依次读取Undo Record，并根据其中内容做逆向操作，恢复索引记录。</p><p>回滚的入口是函数<strong>row_undo</strong>，其中会先调用trx_roll_pop_top_rec_of_trx获取并删除该事务的最后一条Undo Record。如下图例子中的Undo Log包括三条Undo Records，其中Record 1在Undo Page 1中，Record 2，3在Undo Page 2中，先通过从Undo Segment Header中记录的Page List找到当前事务的最后一个Undo Page的Header，并根据Undo Page 2的Header上记录的Free Space Offset定位最后一条Undo Record结束的位置，当然实际运行时，这两个值是缓存在trx_undo_t的top_page_no和top_offset中的。利用Prev Record Offset可以找到Undo Record 3，做完对应的回滚操作之后，再通过前序指针Prev Record Offset找到前一个Undo Record，依次进行处理。处理完当前Page中的所有Undo Records后，再沿着Undo Page Header中的List找到前一个Undo Page，重复前面的过程，完成一个事务所有Page上的所有Undo Records的回滚。</p><p><img src="/assets/post_img/article123/undo_rollback.png" alt=""></p><p>拿到一个Undo Record之后，自然地，就是对其中内容的解析，这里会调用row_undo_ins_parse_undo_rec，从Undo Record中获取修改行的table，解析出其中记录的主键信息，如果是update类型，还会拿到一个update vector记录其相对于更新的一个版本的变化。</p><p><code>TRX_UNDO_INSERT_REC</code>类型的Undo回滚在row_undo_ins中进行，insert的逆向操作当然就是delete，根据从Undo Record中解析出来的主键，用row_undo_search_clust_to_pcur定位到对应的ROW， 分别调用row_undo_ins_remove_sec_rec和row_undo_ins_remove_clust_rec在二级索引和主索引上将当前行删除。</p><p>update类型的undo包括<code>TRX_UNDO_UPD_EXIST_REC</code>，<code>TRX_UNDO_DEL_MARK_REC</code>和<code>TRX_UNDO_UPD_DEL_REC</code>三种情况，他们的Undo回滚都是在row_undo_mod中进行，首先会调用row_undo_mod_del_unmark_sec_and_undo_update，其中根据从Undo Record中解析出的update vector来回退这次操作在所有二级索引上的影响，可能包括重新插入被删除的二级索引记录、去除其中的Delete Mark标记，或者用update vector中的diff信息将二级索引记录修改之前的值。之后调用row_undo_mod_clust同样利用update vector中记录的diff信息将主索引记录修改回之前的值。</p><p>完成回滚的Undo Log部分，会调用trx_roll_try_truncate进行回收，对不再使用的page调用trx_undo_free_last_page将磁盘空间交还给Undo Segment，这个是写入过程中trx_undo_add_page的逆操作。</p><h3 id="Undo-Log之故障恢复"><a href="#Undo-Log之故障恢复" class="headerlink" title="Undo Log之故障恢复"></a>Undo Log之故障恢复</h3><p>Crash Recovery时，需要利用Undo中的信息将未提交的事务的所有影响回滚，以保证数据库的Failure Atomic。前面提到过，InnoDB中的Undo其实是像数据一样处理的，也从上面的组织结构中可以看出来，Undo本身有着比Redo Log复杂得多、按事务分配而不是顺序写入的组织结构，其本身的Durability像InnoDB中其他的数据一样，需要靠Redo来保证。除了通用的一些MLOG_2BYTES、MLOG_4BYTES类型之外，Undo本身也有自己对应的Redo Log类型：<strong>MLOG_UNDO_INIT</strong>类型在Undo Page舒适化的时候记录初始化；在分配Undo Log的时候，需要重用Undo Log Header或需要创建新的Undo Log Header的时候，会分别记录<strong>MLOG_UNDO_HDR_REUSE</strong>和<strong>MLOG_UNDO_HDR_CREATE</strong>类型的Redo Record；<strong>MLOG_UNDO_INSERT</strong>是最常见的，在Undo Log里写入新的Undo Record都对应的写这个日志记录写入Undo中的所有内容；最后，<strong>MLOG_UNDO_ERASE_END</strong>对应Undo Log跨Undo Page时抹除最后一个不完整的Undo</p><blockquote><p>ARIES（Algorithms for Recovery and Isolation Exploiting Semantics）是一种事务恢复协议，用于数据库系统中的崩溃恢复和并发控制。它是一个经典的恢复算法，并被广泛应用于许多关系型数据库管理系统（RDBMS）。</p><p>ARIES本质是一种Redo-Undo的WAL实现。其正常运行过程为：修改数据之前先追加Log记录，Log内容同时包括Redo和Undo信息，每个日志记录产生一个标记其在日志中位置的递增LSN（Log Sequence Number）；数据页中记录最后修改的日志项LSN，以此来判断Page中的内容的新旧程度，实现幂等。故障恢复阶段需要通过Log中的内容恢复数据库状态，为了减少恢复时需要处理的日志量，ARIES会在正常运行期间周期性的生成Checkpoint，Checkpoint中除了当前的日志LSN之外，还需要记录当前活跃事务的最新LSN，以及所有脏页，供恢复时决定重放Redo的开始位置。需要注意的是，由于生成Checkpoint时数据库还在正常提供服务（Fuzzy Checkpoint），其中记录的活跃事务及脏页信息并不一定准确，因此需要Recovery阶段通过Log内容进行修正。</p><p>Recover过程：故障恢复包含三个阶段：Analysis，Redo和Undo。Analysis阶段的任务主要是利用Checkpoint及Log中的信息确认后续Redo和Undo阶段的操作范围，通过Log修正Checkpoint中记录的脏页集合信息，并用其中涉及最小的LSN位置作为下一步Redo的开始位置RedoLSN。同时修正Checkpoint中记录的活跃事务集合（未提交事务），作为Undo过程的回滚对象；Redo阶段从Analysis获得的RedoLSN出发，重放所有的Log中的Redo内容，注意这里也包含了未Commit事务；最后Undo阶段对所有未提交事务利用Undo信息进行回滚，通过Log的PrevLSN可以顺序找到事务所有需要回滚的修改。</p></blockquote><p>以ARIES过程为例，Crash Recovery的过程中会先重放所有的Redo Log，整个Undo的磁盘组织结构，也会作为一种数据类型也会通过上面讲到的这些Redo类型的重放恢复出来。之后在trx_sys_init_at_db_start操作中会扫描Undo的磁盘结构，遍历所有的Rollback Segment和其中所有的Undo Segment，通过读取Undo Segment Header中的State，可以知道在Crash前，最后持有这个Undo Segment的事务状态。如果是<code>TRX_UNDO_ACTIVE</code>，说明当时事务需要回滚，否则说明事务已经结束，可以继续清理Undo Segment的逻辑。之后，就可以恢复出Undo Log的内存组织模式，包括活跃事务的内存结构trx_t，Rollback Segment的内存结构trx_rseg_t，以及其中的trx_undo_t的四个链表。</p><p>Crash Recovery完成之前，会启动在srv_dict_recover_on_restart中启动异步回滚线程trx_recovery_rollback_thread，其中对Crash前还活跃的事务，通过trx_rollback_active进行回滚，这个过程与上面提到的Undo回滚是一致的。</p><h3 id="Undo-Log的清理"><a href="#Undo-Log的清理" class="headerlink" title="Undo Log的清理"></a>Undo Log的清理</h3><p>InnoDB在Undo Log中保存了多份历史版本来实现MVCC，当某个历史版本已经确认不会被任何现有的和未来的事务看到的时候，就应该被清理掉。因此就需要有办法判断哪些Undo Log不会再被看到。InnoDB中每个写事务结束时都会拿一个递增的编号trx_no作为事务的提交序号，而每个读事务会在自己的ReadView中记录自己开始的时候看到的最大的trx_no为m_low_limit_no。那么，如果一个事务的trx_no小于当前所有活跃的读事务Readview中的这个m_low_limit_no，说明这个事务在所有的读开始之前已经提交了，其修改的新版本是可见的， 因此不再需要通过undo构建之前的版本，这个事务的Undo Log也就可以被清理了。</p><p>这里不多深入，暂时用处不大，相关内容：Undo Purge、Undo Truncate、Undo Tablespace Truncate。</p><h2 id="MVCC和锁-Isolation"><a href="#MVCC和锁-Isolation" class="headerlink" title="MVCC和锁 (Isolation)"></a>MVCC和锁 (Isolation)</h2><p>多版本的目的是为了避免写事务和读事务的互相等待，那么每个读事务都需要在不对数据库记录加锁的情况下，找到对应的应该看到的历史版本。所谓历史版本就是假设在该只读事务开始的时候对整个DB打一个快照，之后该事务的所有读请求都从这个快照上获取。当然实现上不能真正去为每个事务打一个快照，这个时间空间都太高了。InnoDB的做法，是在读事务第一次读取的时候获取一份ReadView，并一直持有，其中记录所有当前活跃的写事务ID，由于写事务的ID是自增分配的，通过这个ReadView我们可以知道在这一瞬间，哪些事务已经提交哪些还在运行，根据Read Committed的要求，未提交的事务的修改就是不应该被看见的，对应地，已经提交的事务的修改应该被看到。</p><p>作为存储历史版本的Undo Record，其中记录的trx_id就是做这个可见性判断的，对应的数据库主索引的记录上也有这个值。当一个读事务拿着自己的ReadView访问某个表索引上的记录时，会通过比较记录上的trx_id确定是否是可见的版本，如果不可见就沿着Record或Undo Record中记录的rollptr一路找更老的历史版本。如下图所示，事务$R$开始需要查询表$t$上的id为1的记录，$R$开始时事务$I$已经提交，事务$J$还在运行，事务$K$还没开始，这些信息都被记录在了事务$R$的ReadView中。事务$R$从索引中找到对应的这条$Record_{1,C}$，对应的trx_id是$K$，不可见。沿着rollptr找到Undo中的前一版本$Record_{1,B}$，对应的trx_id是$J$，不可见。继续沿着rollptr找到$Record_{1,A}$，trx_id是$I$可见，返回结果。</p><p><img src="/assets/post_img/article123/undo_mvcc.png" alt=""></p><p>前面提到过，作为逻辑日志，Undo中记录的其实是前后两个版本的diff信息，而读操作最终是要获得完整的Record内容的，也就是说这个沿着rollptr指针一路查找的过程中需要用Undo Record中的diff内容依次构造出对应的历史版本，这个过程在函数row_search_mvcc中，其中trx_undo_prev_version_build会根据当前的rollptr找到对应的Undo Record位置，这里如果是rollptr指向的是insert类型，或者找到了已经Purge了的位置，说明到头了，会直接返回失败。否则，就会解析对应的Undo Record，恢复出trx_id、指向下一条Undo Record的rollptr、主键信息和diff信息update vector等信息。之后通过row_upd_rec_in_place，用update vector修改当前持有的Record拷贝中的信息，获得Record的这个历史版本。之后调用自己ReadView的changes_visible判断可见性，如果可见则返回用户。完成这个历史版本的读取。</p><p>TODO：补充关于锁的内容和MVCC的相关内容，并发事务问题-&gt;事务隔离级别-&gt;（隔离级别设置）-&gt;隔离级别的实现-&gt;锁（表、行、页）-&gt;MVCC（隐藏字段、undo、read view）。[3]</p><h1 id="Spring事务使用"><a href="#Spring事务使用" class="headerlink" title="Spring事务使用"></a>Spring事务使用</h1><p>先介绍Spring支持的两种事务管理方式，然后介绍Spring提供的主要事务管理接口。在实际开发中，我们通常使用<code>@Transactional</code>注解来开启事务，于是我们介绍这个注解中包含的事务属性参数（包括隔离级别、传播行为等等重要内容），并介绍如何使用该注解。</p><h2 id="两种事务管理方式"><a href="#两种事务管理方式" class="headerlink" title="两种事务管理方式"></a>两种事务管理方式</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过 <code>TransactionTemplate</code> 或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用。使用 <code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务管理（常用）"><a href="#声明式事务管理（常用）" class="headerlink" title="声明式事务管理（常用）"></a>声明式事务管理（常用）</h3><p>代码侵入性最小，实际是通过 AOP 实现（基于<code>@Transactional</code>的全注解方式使用最多）。</p><p>使用<code>@Transactional</code>注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-事务管理接口"><a href="#Spring-事务管理接口" class="headerlink" title="Spring 事务管理接口"></a>Spring 事务管理接口</h2><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：<code>PlatformTransactionManager</code>，（平台）事务管理器，Spring 事务策略的核心；<code>TransactionDefinition</code>，事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)；<code>TransactionStatus</code>，事务运行状态。我们可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。<code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="PlatformTransactionManager-事务管理器接口"><a href="#PlatformTransactionManager-事务管理器接口" class="headerlink" title="PlatformTransactionManager - 事务管理器接口"></a><code>PlatformTransactionManager</code> - 事务管理器接口</h3><p>Spring 并不直接管理事务，而是提供了多种事务管理器，通过这个接口，Spring 为各个平台如：JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。将事务管理行为抽象出来方便程序扩展。</p><p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionDefinition-事务属性定义"><a href="#TransactionDefinition-事务属性定义" class="headerlink" title="TransactionDefinition - 事务属性定义"></a><code>TransactionDefinition</code> - 事务属性定义</h3><p>事务管理器接口 <code>PlatformTransactionManager</code> 通过 <code>getTransaction(TransactionDefinition definition)</code> 方法来得到一个事务，这个方法里面的参数是 `TransactionDefinition</p><p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p><p>事务属性包含了 5 个方面：</p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus - 事务状态"></a><code>TransactionStatus</code> - 事务状态</h3><p><code>TransactionStatus</code>接口用来记录事务的状态，该接口定义了一组方法，用来获取或判断事务的相应状态信息。<code>PlatformTransactionManager.getTransaction()</code>方法返回一个 <code>TransactionStatus</code> 对象。<code>TransactionStatus</code> 接口内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h2><p><code>@Transactional</code>中包含的事务属性参数。</p><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题。</strong></p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>举例来说，在 A 类的<code>aMethod()</code>中调用了 B 类的<code>bMethod()</code>。这个时候就涉及到业务层方法之间互相调用的事务问题。如果<code>bMethod()</code>发生异常需要回滚，如何配置事务传播行为才能让<code>aMethod()</code>也跟着回滚呢？下面来看一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便使用，Spring 相应地定义了一个枚举类：<code>Propagation</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line">    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</span></span><br><span class="line">    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line">    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以非事务方式运行，如果当前存在事务，则抛出异常。</span></span><br><span class="line">    NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line">    NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务传播行为可能的值如下：</p><p>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></p><p><code>@Transactional</code>注解默认使用的事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p><ul><li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li><li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p><p>2.<code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod()</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为<code>bMethod()</code>开启了独立的事务。但是，如果<code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话，<code>aMethod()</code>同样也会回滚，因为这个异常被<code>aMethod()</code>的事务管理机制检测到了。</p><p>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></p><p>如果当前存在事务，就在嵌套事务内执行；如果当前没有事务，就执行与<code>TransactionDefinition.PROPAGATION_REQUIRED</code>类似的操作。嵌套事务回滚不影响外部事务。也就是说：</p><ul><li>在外部方法开启事务的情况下，在内部开启一个新的事务，作为嵌套事务存在。</li><li>如果外部方法无事务，则单独开启一个事务。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例来说，如果 <code>bMethod()</code> 回滚的话，<code>aMethod()</code>不会回滚。如果<code>aMethod()</code>回滚的话，<code>bMethod()</code>会回滚。</p><p>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。这种方式还是能保证全部回滚的，下面的三种则不一定了，需要看情况使用。</p><p>5.<code>TransactionDefinition.PROPAGATION_SUPPORTS</code><br>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>6.<code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code><br>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>7.<code>TransactionDefinition.PROPAGATION_NEVER</code><br>以非事务方式运行，如果当前存在事务，则抛出异常。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和事务传播行为一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 读未提交</span></span><br><span class="line">  READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line">  <span class="comment">// 读已提交</span></span><br><span class="line">  READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line">  <span class="comment">// 可重复读</span></span><br><span class="line">  REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line">  <span class="comment">// 可串行</span></span><br><span class="line">  SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">  Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次对每一种事务隔离级别进行介绍：</p><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别，Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务串行执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a>事务超时属性</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以整型的值来表示超时时间，其单位是秒，默认值为<code>-1</code>，这表示事务的超时时间取决于底层事务系统或者没有超时时间。</p><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于只有读取数据查询的事务，可以指定事务类型为 <code>readonly</code>，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p><p>为什么数据查询操作还要启用事务支持呢？拿Innodb举例子，根据<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">官网</a>描述：</p><blockquote><p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的sql语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p></blockquote><p>但是，如果你给方法加上了<code>@Transactional</code>注解的话，这个方法执行的所有sql会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p><p>如果不加<code>@Transactional</code>，每条sql会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p><p>分享一下关于事务只读属性，其他人的解答：</p><ul><li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li><li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</li></ul><h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（<code>RuntimeException</code> 的子类）时才会回滚，<code>Error</code>也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p><p>可以通过下面的方式回滚特定的异常类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure><h2 id="Transactional-注解使用详解"><a href="#Transactional-注解使用详解" class="headerlink" title="@Transactional 注解使用详解"></a><code>@Transactional</code> 注解使用详解</h2><h3 id="Transactional-的作用范围"><a href="#Transactional-的作用范围" class="headerlink" title="@Transactional 的作用范围"></a><code>@Transactional</code> 的作用范围</h3><ol><li>方法：推荐将注解使用于方法上，不过需要注意的是，该注解只能应用到 <code>public</code> 方法上，否则不生效。</li><li>类：如果这个注解使用在类上的话，表明该注解对该类中所有的 <code>public</code> 方法都生效。</li><li>接口：不推荐在接口上使用。</li></ol><h3 id="Transactional-的常用配置参数"><a href="#Transactional-的常用配置参数" class="headerlink" title="@Transactional 的常用配置参数"></a><code>@Transactional</code> 的常用配置参数</h3><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line"><span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用配置参数即：propagation、isolation、timeout、readOnly、rollbackFor，具体内容上节已列出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a><br>[2] <a href="https://blog.csdn.net/ITcreater000/article/details/115338657">https://blog.csdn.net/ITcreater000/article/details/115338657</a><br>[3] <a href="https://www.cnblogs.com/rickiyang/p/13652664.html">https://www.cnblogs.com/rickiyang/p/13652664.html</a><br>[4] <a href="https://dl.acm.org/doi/10.1145/289.291">https://dl.acm.org/doi/10.1145/289.291</a><br>[5] <a href="https://juejin.cn/post/6860252224930070536">https://juejin.cn/post/6860252224930070536</a><br>[6] <a href="https://spongecaptain.cool/post/database/logicalandphicallog/">https://spongecaptain.cool/post/database/logicalandphicallog/</a><br>[7] <a href="https://www.jianshu.com/p/646961b93c7e">https://www.jianshu.com/p/646961b93c7e</a><br>[8] <a href="https://zhuanlan.zhihu.com/p/394388285">https://zhuanlan.zhihu.com/p/394388285</a><br>[9] <a href="https://blog.csdn.net/qq_24854607/article/details/114639318">https://blog.csdn.net/qq_24854607/article/details/114639318</a><br>[10] <a href="https://blog.csdn.net/m0_71777195/article/details/130842268">https://blog.csdn.net/m0_71777195/article/details/130842268</a><br>[11] <a href="https://www.cnblogs.com/f66666/articles/10993873.html">https://www.cnblogs.com/f66666/articles/10993873.html</a><br>[12] <a href="http://catkang.github.io/2021/10/30/mysql-undo.html">http://catkang.github.io/2021/10/30/mysql-undo.html</a><br>[13] <a href="http://catkang.github.io/2020/02/27/mysql-redo.html">http://catkang.github.io/2020/02/27/mysql-redo.html</a><br>[14] <a href="http://catkang.github.io/2018/09/19/concurrency-control.html">http://catkang.github.io/2018/09/19/concurrency-control.html</a><br>[15] <a href="https://catkang.github.io/2023/08/08/mysql-buffer-pool.html">https://catkang.github.io/2023/08/08/mysql-buffer-pool.html</a><br>[16] <a href="https://mariadb.com/kb/en/innodb-undo-log">https://mariadb.com/kb/en/innodb-undo-log</a><br>[17] <a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">https://javaguide.cn/system-design/framework/spring/spring-transaction.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;谈论一切之前，使用的数据库一定要支持事务，本文以MySQL InnoDB存储引擎为例，从数据库事务基本原理出发，简要说明事务相关的主要知识，以及如何在Spring项目中使用，对于细节的描述少且模糊，需要不断完善。&lt;/p&gt;
&lt;p&gt;相关内容：InnoDB事务实现、Spring事务传播机制等。&lt;br&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
    <category term="MySQL" scheme="http://silencezheng.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Optional使用入门</title>
    <link href="http://silencezheng.top/2023/09/14/article122/"/>
    <id>http://silencezheng.top/2023/09/14/article122/</id>
    <published>2023-09-14T15:08:57.000Z</published>
    <updated>2023-09-14T15:11:44.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。</p><span id="more"></span><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional的机制类似于受检异常，强迫API调用者面对没有返回值的现实，因为程序直接返回 null 很可能导致调用端产生错误（空指针异常！）。</p><p>Optional 是用来作为方法返回值的，目的是清晰地表达返回值中没有结果的可能性。</p><h2 id="常用方法及调用方式"><a href="#常用方法及调用方式" class="headerlink" title="常用方法及调用方式"></a>常用方法及调用方式</h2><ul><li><p><code>of(value)</code>：创建一个包含指定非空值的 <code>Optional</code> 对象。</p></li><li><p><code>ofNullable(value)</code>：创建一个可能为空的 <code>Optional</code> 对象。如果传入的值为 <code>null</code>，则返回一个空的 <code>Optional</code>。</p></li><li><p><code>empty()</code>：创建一个空的 <code>Optional</code> 对象。</p></li><li><p><code>isPresent()</code>：检查 <code>Optional</code> 对象是否包含值。</p></li><li><p><code>get()</code>：获取 <code>Optional</code> 对象中的值。在调用之前应先使用 <code>isPresent()</code> 进行判断。</p></li></ul><p><code>Optional</code> 支持方法链式调用，使得我们可以在一系列操作中进行空值检查和转换。</p><p>下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (optionalValue.isPresent()) &#123;</span><br><span class="line">    String value = optionalValue.get();</span><br><span class="line">    System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; nullableValue = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">String result = nullableValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure><p>除了常用方法，还有一些方法可以对<code>Optional</code>对象进行快捷操作，如上面出现的<code>orElse</code>，下面介绍其中一些。</p><ul><li><p><code>orElse(T other)</code>：如果包含的值存在，则返回该值；如果不存在，则返回默认值 <code>other</code>。无论值是否存在，都会进行计算，并返回结果。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String defaultValue = emptyOptional.orElse(<span class="string">&quot;Default Value&quot;</span>);</span><br><span class="line">System.out.println(defaultValue); <span class="comment">// 输出：Default Value</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>：如果包含的值存在，则返回该值；如果不存在，则使用提供的 <code>Supplier</code> 函数来计算并返回值。与 <code>orElse()</code> 类似，但在值不存在时，<code>Supplier</code> 函数才会被调用。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseGet(() -&gt; expensiveOperation());</span><br><span class="line">System.out.println(computedValue); <span class="comment">// 调用 expensiveOperation() 方法，并输出其返回值</span></span><br></pre></td></tr></table></figure></li><li><p><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果包含的值存在，则返回该值；如果不存在，则抛出指定的异常。通过提供一个exceptionSupplier来生成异常对象。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String value = optionalValue.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>));</span><br><span class="line">System.out.println(value); <span class="comment">// 输出：Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">String computedValue = emptyOptional.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Value not found&quot;</span>)); <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></figure></li><li><p><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>：接受一个 Consumer 函数作为参数，并在包含的值存在时执行该函数。该方法无返回值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">optionalValue.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 输出：Value is present: Hello</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; emptyOptional = Optional.empty();</span><br><span class="line">emptyOptional.ifPresent(value -&gt; System.out.println(<span class="string">&quot;Value is present: &quot;</span> + value)); <span class="comment">// 由于值不存在，所以不执行任何操作</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1、不要使用<code>Optional</code>作为Java Bean实例域的类型<br>即避免以下这种代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; zip;</span><br><span class="line">    [access_modifier] [<span class="keyword">static</span>] [<span class="keyword">final</span>] Optional&lt;String&gt; telephone = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为 <code>Optional</code> 没有实现Serializable接口（不可序列化）</p><p>2、不要把容器类型包装在<code>Optional</code>中<br>即避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;List&lt;String&gt;&gt; fetchCartItems(<span class="keyword">long</span> id) &#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为容器类都有自己空值设计，如 <code>Collections.emptyList() Collections.emptySet() Collections.emptyMap() Stream.empty()</code> 等：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fetchCartItems</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    Cart cart = ... ;    </span><br><span class="line">    List&lt;String&gt; items = cart.getItems(); <span class="comment">// this may return null</span></span><br><span class="line">    <span class="keyword">return</span> items == <span class="keyword">null</span> ? Collections.emptyList() : items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、不要给<code>Optional</code>对象赋值 null<br>避免：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而应该用 <code>Optional.empty()</code> 表达空值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PREFER</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Cart&gt; <span class="title">fetchCart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Cart&gt; emptyCart = Optional.empty();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、尽量使用<code>Optional</code>提供的快捷API避免手写条件语句<br>代码更简洁。</p><p>5、使用 <code>equals</code> 而不是 <code>==</code> 来比较 <code>Optional</code> 的值<br><code>Optional</code> 的 <code>equals</code> 方法已经实现了内部值比较。</p><p>6、对于可能是空值的函数返回使用<code>Optional</code><br>对于读取值类型的函数使用是很好的实践。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/128481434">https://zhuanlan.zhihu.com/p/128481434</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Optional 是 Java 8 引进的一个新特性，它是一个容器对象，可以包含或不包含非空值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok原理简析</title>
    <link href="http://silencezheng.top/2023/09/11/article121/"/>
    <id>http://silencezheng.top/2023/09/11/article121/</id>
    <published>2023-09-11T13:32:25.000Z</published>
    <updated>2023-09-11T13:36:03.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok实现原理简析。<br><span id="more"></span></p><h2 id="JCP与JSR"><a href="#JCP与JSR" class="headerlink" title="JCP与JSR"></a>JCP与JSR</h2><p>JCP（Java Community Process）是管理 Java 生态（包括 J2SE、J2EE 等等）发展及指导和推动Java平台发展的合作组织，而JSR（Java Specification Request）则是由JCP提出的一种规范请求。</p><blockquote><p>JCP是由Sun Microsystems（现在是Oracle Corporation）创建的一个组织，负责制定和管理Java技术的发展。它包括了一系列专家组和工作组，这些组织和个人共同合作制定和更新Java规范。</p><p>JSR 是 Java 规范请求。这是由一个或多个成员提交给 PMO 的文件，以提议开发新规范或对现有规范进行重大修订。 JCP 计划目前正在开发许多 Java 技术规范，包括 Java™ Micro Edition (Java ME™)、Java™ Platform Enterprise Edition (Java EE™) 和 Java™ Standard Edition (Java SE™) 的下一版本。 JSR 还指由这些提案产生的规范开发工作。</p><p>JSR经历多个阶段，包括草案、提案、公开评论、维护和最终发布等。</p><p>PMO 即 Program Management Office，项目管理办公室是 Oracle 内部负责监督 Java 社区流程并管理项目日常运行的小组。该规范的实际开发是在专家组内进行的。</p></blockquote><p>JCP：<a href="https://jcp.org/en/home/index">https://jcp.org/en/home/index</a></p><h2 id="JSR-000269"><a href="#JSR-000269" class="headerlink" title="JSR-000269"></a>JSR-000269</h2><p>JSR-000269（JSR-269）的目标是定义并实现Java编译时注解处理器的标准API，或称为可插拔注解处理（Pluggable Annotation Processing），该JSR提供了一种机制，使开发人员能够在Java源代码编译过程中访问和处理注解，从而实现更高级的语义效果和自动化任务。</p><p>要完全的了解JSR-269的前因后果及技术细节，不应该在本文中寻找答案，本文仅铺垫一些形象化描述Lombok实现原理所必需的前置知识。总之，通过JSR-269的实现，开发人员可以利用编译时注解处理器的能力，以一种标准化和可扩展的方式对源代码进行自动化处理。这种处理包括生成额外的代码、进行静态分析、验证约束条件等。</p><p>JSR-000269的原始提出第一节如下：</p><blockquote><p>J2SE 1.5引入了一种新的Java语言机制“注解”，允许使用注解类型对类、字段和方法进行注解。这些注解通常由编译时工具或运行时库来处理，以实现新的语义效果。为了支持编译时的注解处理，这个JSR将定义API，允许使用标准可插拔的API创建注解处理器。这将简化创建注解处理器的任务，并且还可以自动发现适用于给定源文件的合适的注解处理器。</p><p>该规范将包括至少两个部分：一个部分是对Java编程语言进行建模的API部分，另一个部分用于声明注解处理器并控制它们的运行方式。由于注解是放置在程序元素上的，注解处理框架需要反映程序结构。注解处理器将能够指定它们处理的注解，并且多个处理器将能够合作运行。</p><p>处理器和程序结构API可以在编译时访问；即此功能补充了核心反射支持读取注解的能力。</p></blockquote><h2 id="Lombok代码注入原理"><a href="#Lombok代码注入原理" class="headerlink" title="Lombok代码注入原理"></a>Lombok代码注入原理</h2><p>Lombok使用了JSR-269的API，即<code>javax.annotation.processing</code>下的一组接口，在编译期时把 Lombok 的注解代码，转换为常规的 Java ⽅法⽽实现注⼊。</p><p>使用 <code>javac</code> 进行编译时，Lombok生成目标方法的流程如下：</p><ol><li>首先 <code>javac</code> 对源代码进行分析生成一棵抽象语法树(AST)</li><li>接着在运行过程中调用实现了 JSR-269 API 的 lombok 程序</li><li>接着编译器会调用 lombok 程序对上面得到的抽象语法树 AST 进行处理，找到其注解所在类对应的语法树(AST)，然后修改该语法树，增加注解对应的方法或代码片段到定义的相应树节点</li><li><code>javac</code> 使用修改后的抽象语法树生成最终的 class 文件</li></ol><h2 id="利用269API实现Setter注解"><a href="#利用269API实现Setter注解" class="headerlink" title="利用269API实现Setter注解"></a>利用269API实现Setter注解</h2><p>1、⾃定义注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MySetter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、自定义注解处理器<br>注解处理器是代码生成的核心，对语法树的操作需要使用自己JDK的<code>tools.jar</code>，涉及到的核心库主要为<code>com.sun.tools.javac</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">package</span> lombok.setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree.Kind;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.api.JavacTrees;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Flags;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.code.Type;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.processing.JavacProcessingEnvironment;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.JCTree;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeMaker;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.tree.TreeTranslator;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Context;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.ListBuffer;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Name;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.Names;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.javac.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.processing.*;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.SourceVersion;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.Element;</span><br><span class="line"><span class="keyword">import</span> javax.lang.model.element.TypeElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&quot;lombok.setter.MySetter&quot;)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetterProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JavacTrees javacTrees; <span class="comment">// 提供了待处理的抽象语法树</span></span><br><span class="line">    <span class="keyword">private</span> TreeMaker treeMaker; <span class="comment">// 封装了创建AST节点的一些方法</span></span><br><span class="line">    <span class="keyword">private</span> Names names; <span class="comment">// 提供了创建标识符的方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        <span class="comment">// 获取资源</span></span><br><span class="line">        <span class="keyword">this</span>.javacTrees = JavacTrees.instance(processingEnv);</span><br><span class="line">        Context context = ((JavacProcessingEnvironment) processingEnv).getContext();</span><br><span class="line">        <span class="keyword">this</span>.treeMaker = TreeMaker.instance(context);</span><br><span class="line">        <span class="keyword">this</span>.names = Names.instance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取MySetter注解的元素</span></span><br><span class="line">        Set&lt;? extends Element&gt; elementsAnnotatedWith = roundEnv.getElementsAnnotatedWith(MySetter.class);</span><br><span class="line">        elementsAnnotatedWith.forEach(element -&gt; &#123;</span><br><span class="line">            JCTree tree = javacTrees.getTree(element);</span><br><span class="line">            <span class="comment">// 使用 TreeTranslator 遍历抽象语法树</span></span><br><span class="line">            tree.accept(<span class="keyword">new</span> TreeTranslator() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassDef</span><span class="params">(JCTree.JCClassDecl jcClassDecl)</span> </span>&#123;</span><br><span class="line">                    List&lt;JCTree.JCVariableDecl&gt; jcVariableDeclList = List.nil();</span><br><span class="line">                    <span class="comment">// 在抽象树中找出所有变量</span></span><br><span class="line">                    <span class="keyword">for</span>(JCTree jcTree:jcClassDecl.defs) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(jcTree.getKind().equals(Kind.VARIABLE)) &#123;</span><br><span class="line">                            JCTree.JCVariableDecl jcVariableDecl = (JCTree.JCVariableDecl) jcTree;</span><br><span class="line">                            jcVariableDeclList = jcVariableDeclList.append(jcVariableDecl);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 对变量生成方法</span></span><br><span class="line">                    jcVariableDeclList.forEach(jcVariableDecl -&gt; &#123;</span><br><span class="line">                        jcClassDecl.defs = jcClassDecl.defs.prepend(makeGetterMethodDecl(jcVariableDecl));</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">super</span>.visitClassDef(jcClassDecl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCMethodDecl <span class="title">makeGetterMethodDecl</span><span class="params">(JCTree.JCVariableDecl jcVariableDecl)</span> </span>&#123;</span><br><span class="line">        ListBuffer&lt;JCTree.JCStatement&gt; statements = <span class="keyword">new</span> ListBuffer&lt;&gt;();</span><br><span class="line">        <span class="comment">// 生成表达式，例如 this.a = a;</span></span><br><span class="line">        JCTree.JCExpressionStatement aThis = makeAssignment(</span><br><span class="line">            treeMaker.Select(treeMaker.Ident(names.fromString(<span class="string">&quot;this&quot;</span>)), jcVariableDecl.getName()),</span><br><span class="line">            treeMaker.Ident(jcVariableDecl.getName())</span><br><span class="line">        );</span><br><span class="line">        statements.append(aThis);</span><br><span class="line">        JCTree.JCBlock block = treeMaker.Block(<span class="number">0</span>, statements.toList()); <span class="comment">// 创建代码块抽象语法树节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成入参</span></span><br><span class="line">        JCTree.JCVariableDecl param = treeMaker.VarDef( <span class="comment">// 创建一个变量定义节点</span></span><br><span class="line">            treeMaker.Modifiers(Flags.PARAMETER), <span class="comment">// 指定修饰符为入参</span></span><br><span class="line">            jcVariableDecl.getName(), <span class="comment">// 使用原始变量定义节点的名称作为入参的名称</span></span><br><span class="line">            jcVariableDecl.vartype, <span class="comment">// 使用原始变量定义节点的变量类型作为入参的类型</span></span><br><span class="line">            <span class="keyword">null</span> <span class="comment">// 表示入参没有初始值</span></span><br><span class="line">        );</span><br><span class="line">        List&lt;JCTree.JCVariableDecl&gt; parameters = List.of(param);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成返回对象</span></span><br><span class="line">        JCTree.JCExpression methodType = treeMaker.Type(</span><br><span class="line">            <span class="keyword">new</span> Type.JCVoidType()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结合内容生成方法</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.MethodDef(</span><br><span class="line">            treeMaker.Modifiers(Flags.PUBLIC),</span><br><span class="line">            getNewMethodName(jcVariableDecl.getName()),</span><br><span class="line">            methodType, List.nil(), parameters, List.nil(), block, <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Name <span class="title">getNewMethodName</span><span class="params">(Name name)</span> </span>&#123;</span><br><span class="line">        String s = name.toString();</span><br><span class="line">        <span class="comment">// 驼峰命名方法</span></span><br><span class="line">        <span class="keyword">return</span> names.fromString(</span><br><span class="line">            <span class="string">&quot;set&quot;</span> + s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>, name.length())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JCTree.<span class="function">JCExpressionStatement <span class="title">makeAssignment</span><span class="params">(JCTree.JCExpression lhs, JCTree.JCExpression rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成赋值语句的抽象语法树节点</span></span><br><span class="line">        <span class="keyword">return</span> treeMaker.Exec(</span><br><span class="line">            treeMaker.Assign(</span><br><span class="line">                lhs, <span class="comment">// left-hand side</span></span><br><span class="line">                rhs  <span class="comment">// right-hand side</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、编译注解处理器<br>之后所有操作都在MySetter的目录下进行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp /path/to/tools.jar MySetter* -d .</span><br></pre></td></tr></table></figure><p>4、编写和编译目标类<br>目标类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MySetter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用自定义注解处理器编译目标类：<code>javac -processor  lombok.setter.MySetterProcessor TestMySetter.java</code></p><p>编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySetter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Integer intt;</span><br><span class="line">    <span class="keyword">public</span> String strr;</span><br><span class="line">    <span class="keyword">public</span> Byte bytee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytee</span><span class="params">(Byte var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytee = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrr</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strr = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntt</span><span class="params">(Integer var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intt = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestMySetter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h2><p>前面形象化的讲述了Lombok的代码生成原理，但这些都发生在编译期，代码编辑器如何获取到这些信息并提前应用到代码提示上呢？Lombok给主流集成开发环境编写了Lombok插件，在使用Lombok的过程中不需要编译即可实现代码提示和代码补全，相关源码都公开在GitHub上（见[9]），有兴趣的读者可以自行阅读研究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://developer.aliyun.com/article/1081626">https://developer.aliyun.com/article/1081626</a><br>[2] <a href="https://blog.csdn.net/shouchenchuan5253/article/details/111658356">https://blog.csdn.net/shouchenchuan5253/article/details/111658356</a><br>[3] <a href="https://blog.csdn.net/weixin_43983762/article/details/105867398">https://blog.csdn.net/weixin_43983762/article/details/105867398</a><br>[4] <a href="https://juejin.cn/post/7103011031672176677">https://juejin.cn/post/7103011031672176677</a><br>[5] <a href="https://jcp.org/en/jsr/detail?id=269">https://jcp.org/en/jsr/detail?id=269</a><br>[6] <a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html">https://jcp.org/aboutJava/communityprocess/mrel/jsr269/index6.html</a><br>[7] <a href="https://projectlombok.org/">https://projectlombok.org/</a><br>[8] <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html">https://docs.oracle.com/javase/7/docs/technotes/guides/apt/GettingStarted.html</a><br>[9] <a href="https://github.com/projectlombok/lombok">https://github.com/projectlombok/lombok</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok实现原理简析。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Lombok之@Builder碎碎念</title>
    <link href="http://silencezheng.top/2023/09/10/article120/"/>
    <id>http://silencezheng.top/2023/09/10/article120/</id>
    <published>2023-09-10T12:23:30.000Z</published>
    <updated>2023-09-10T12:24:14.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lombok@Builder实现链式构建的弊病及替代方案。<br><span id="more"></span></p><h2 id="Builder的弊病"><a href="#Builder的弊病" class="headerlink" title="@Builder的弊病"></a>@Builder的弊病</h2><h3 id="存在继承关系时十分复杂"><a href="#存在继承关系时十分复杂" class="headerlink" title="存在继承关系时十分复杂"></a>存在继承关系时十分复杂</h3><p>错误用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：Implicit super constructor Parent() is undefined. Must explicitly invoke another constructor</span></span><br></pre></td></tr></table></figure></p><p>正确用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Child child = Child.builder()</span><br><span class="line">  .parentName(<span class="string">&quot;Andrea&quot;</span>)</span><br><span class="line">  .parentAge(<span class="number">38</span>)</span><br><span class="line">  .childName(<span class="string">&quot;Emma&quot;</span>)</span><br><span class="line">  .childAge(<span class="number">6</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>但如果父类使用了@Builder注解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时用原子类会报错：<code>Child中的builder()无法覆盖Parent中的builder()</code>。可以通过修改子类为如下形式解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Builder(builderMethodName = &quot;childBuilder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String parentName, <span class="keyword">int</span> parentAge, String childName, <span class="keyword">int</span> childAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentName, parentAge);</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">        <span class="keyword">this</span>.childAge = childAge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在链式构建子类对象时，就需要调用<code>Child.childBuilder()</code>了。即便如此，在继承层级多时也十分繁琐。</p><p>在Lombok1.18中，提供了@SuperBuilder注解，可以解决上述问题。使用示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String parentName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parentAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String childName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> childAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不可与-Data同时使用"><a href="#不可与-Data同时使用" class="headerlink" title="不可与@Data同时使用"></a>不可与@Data同时使用</h3><p>很多框架会使用类的无参构造函数创建对象，但是如果同时使⽤@Data和@Builder的话，会导致类的无参构造函数缺失。</p><p>并且，这种情况并不能通过手动添加无参构造函数或添加@NoArgsConstructor解决。</p><p>该问题只能通过引⼊注解@Tolerate来解决。</p><p>Lombok同时使⽤@Data和@Builder的时候，如果要⽣成⽆参构造，需要在代码⾥⾯⼿动引⼊注解@Tolerate，让Lombok在⽣成类的时候，对指定的构造函数不感知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer int1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Tolerate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-Accessors替代-Builder"><a href="#用-Accessors替代-Builder" class="headerlink" title="用@Accessors替代@Builder"></a>用@Accessors替代@Builder</h2><p>在为了链式编程而使用@Builder时，它并非最佳实践。@Builder会额外创建内部类，无法与@Data兼容，且处理继承关系十分复杂。</p><p>使用@Accessors(chain = true)实现链式编程是更好的选择，简单示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T payload;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Status status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.payload;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setPayload</span><span class="params">(T payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse&lt;T&gt; <span class="title">setStatus</span><span class="params">(Status status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="comment">// 假设Status也使用了@Accessors(chain = true)</span></span><br><span class="line">Status status = <span class="keyword">new</span> Status().setResponseCode(<span class="string">&quot;RESPONSE_CODE_IDENTIFIER&quot;</span>).setDescription(<span class="string">&quot;Bla Bla Bla&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> APIResponse().setStatus(status);</span><br></pre></td></tr></table></figure></p><p>实际运用时，如果属性较多，且分为必传属性和选填属性时，可以将必传参数定义在构造方法中，加上 @Accessors 注解，这样就可以实现必传参数的传入，又可以实现选填参数的链式调用。</p><p>假设 Student 类，它的 学生ID和年级和班级是必填的，姓名、性别、住址是选填的，那么示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义必传属性，使用 final 修饰，不提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> studentId; <span class="comment">// 学生ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> grade; <span class="comment">// 年级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> classNum; <span class="comment">// 班级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义选填属性，提供 setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String gender; <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 住址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造方法，接收必传参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> studentId, <span class="keyword">int</span> grade, <span class="keyword">int</span> classNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.studentId = studentId;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        <span class="keyword">this</span>.classNum = classNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">1001</span>, <span class="number">3</span>, <span class="number">8</span>) <span class="comment">// 创建一个学生对象，传入必传参数</span></span><br><span class="line">        .setName(<span class="string">&quot;张三&quot;</span>) <span class="comment">// 设置姓名</span></span><br><span class="line">        .setGender(<span class="string">&quot;男&quot;</span>) <span class="comment">// 设置性别</span></span><br><span class="line">        .setAddress(<span class="string">&quot;北京市朝阳区&quot;</span>); <span class="comment">// 设置住址</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.baeldung.com/lombok-builder-inheritance">https://www.baeldung.com/lombok-builder-inheritance</a><br>[2] <a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews">https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA%3D%3D&amp;mid=2247534735&amp;idx=1&amp;sn=c6363bff49edbe8b03b5789d2f5b18b9&amp;chksm=e92a7580de5dfc967aaaa7d696a95a7361c4188fe8a626037f51cb70c53466f9ee78efef369d&amp;scene=262&amp;from=industrynews</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Lombok@Builder实现链式构建的弊病及替代方案。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Lombok" scheme="http://silencezheng.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>匿名内部类</title>
    <link href="http://silencezheng.top/2023/09/02/article119/"/>
    <id>http://silencezheng.top/2023/09/02/article119/</id>
    <published>2023-09-02T10:10:40.000Z</published>
    <updated>2023-09-02T10:11:20.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java中的匿名类，Java8及以后。</p><p>涉及概念包括：<strong>等效<code>final</code></strong>，成员，变量，作用域。<br><span id="more"></span></p><h2 id="匿名内部类-Anonymous-Classes"><a href="#匿名内部类-Anonymous-Classes" class="headerlink" title="匿名内部类(Anonymous Classes)"></a>匿名内部类(Anonymous Classes)</h2><p>匿名内部类（匿名类）是一种在Java中用于创建临时性、一次性使用的类的特殊语法结构。它可以用来实现接口、继承类或创建临时对象等操作，通常在需要一个类的实例，但又不希望单独为之创建一个独立的类文件时使用。</p><p>匿名类可以使你的代码更加简洁，你可以在定义一个类的同时对其进行实例化。它与局部类很相似，不同的是它没有类名，如果某个局部类你只需要用一次，就可以使用匿名类来表达。</p><p>匿名类通常用于以下场景：</p><ol><li><p><strong>实现接口：</strong> 通过匿名类实现一个接口，从而创建一个接口的实例。</p></li><li><p><strong>继承类：</strong> 通过匿名类继承一个类，从而创建一个子类的实例。</p></li><li><p><strong>创建临时对象：</strong> 在一些临时需要的情况下，可以使用匿名类来创建对象。</p></li></ol><h2 id="匿名类与局部类对比"><a href="#匿名类与局部类对比" class="headerlink" title="匿名类与局部类对比"></a>匿名类与局部类对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAnonymousClasses</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含两个方法的HelloWorld接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、局部类EnglishGreeting实现了HelloWorld接口</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EnglishGreeting</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">            String name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HelloWorld englishGreeting = <span class="keyword">new</span> EnglishGreeting();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、匿名类实现HelloWorld接口</span></span><br><span class="line">        HelloWorld frenchGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">            String name = <span class="string">&quot;tout le monde&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;tout le monde&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Salut &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、匿名类实现HelloWorld接口</span></span><br><span class="line">        HelloWorld spanishGreeting = <span class="keyword">new</span> HelloWorld() &#123;</span><br><span class="line">            String name = <span class="string">&quot;mundo&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                greetSomeone(<span class="string">&quot;mundo&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetSomeone</span><span class="params">(String someone)</span> </span>&#123;</span><br><span class="line">                name = someone;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hola, &quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        englishGreeting.greet();</span><br><span class="line">        frenchGreeting.greetSomeone(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">        spanishGreeting.greet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        HelloWorldAnonymousClasses myApp = <span class="keyword">new</span> HelloWorldAnonymousClasses();</span><br><span class="line">        myApp.sayHello();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Hello world</span></span><br><span class="line">        <span class="comment">// Salut Fred</span></span><br><span class="line">        <span class="comment">// Hola, mundo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例中用局部类来初始化变量<code>englishGreeting</code>，用匿类来初始化变量<code>frenchGreeting</code>和<code>spanishGreeting</code>，两种实现之间有明显的区别：</p><p>1）局部类<code>EnglishGreeting</code>继承<code>HelloWorld</code>接口，有自己的类名，定义完成之后需要再用new关键字实例化才可以使用；</p><p>2）<code>frenchGreeting、spanishGreeting</code>在定义的时候就实例化了，定义完了就可以直接使用；</p><p>3）<strong>匿名类是一个表达式</strong>，因此在定义的最后用分号”;”结束。</p><h2 id="匿名类的语法"><a href="#匿名类的语法" class="headerlink" title="匿名类的语法"></a>匿名类的语法</h2><p>匿名类表达式的通用语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建匿名类实例</span></span><br><span class="line">SuperClassOrInterface obj = <span class="keyword">new</span> SuperClassOrInterface() &#123;</span><br><span class="line">    <span class="comment">// 成员变量（如果需要）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化块（如果需要）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">returnType <span class="title">methodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的关键点包括：</p><ul><li><p><code>SuperClassOrInterface</code>：匿名类可以继承一个类或实现一个接口，这个部分就是你要继承或实现的类或接口的类型。</p></li><li><p>成员变量：如果需要，在匿名类内部可以定义成员变量，可以在构造器、初始化块以及方法中使用。</p></li><li><p>初始化块：如果需要，在匿名类内部可以定义初始化块，用来初始化成员变量。</p></li><li><p>方法重写：匿名类可以重写父类或接口中的方法。</p></li><li><p><code>returnType</code>：重写方法的返回类型。</p></li><li><p><code>methodName()</code>：要重写的方法名。</p></li></ul><h2 id="匿名类对局部变量的访问规则，及对成员的声明及访问规则"><a href="#匿名类对局部变量的访问规则，及对成员的声明及访问规则" class="headerlink" title="匿名类对局部变量的访问规则，及对成员的声明及访问规则"></a>匿名类对局部变量的访问规则，及对成员的声明及访问规则</h2><p>与局部类一样，匿名类可以捕获变量，它们对外部域的局部变量具有相同的访问权限：</p><ol><li>匿名类可以访问其外部类的成员。</li><li>匿名类无法访问其外部域内未声明为<code>final</code>或实际上未声明为<code>final</code>的<strong>局部变量</strong>。</li><li>与嵌套类一样，匿名类中的类型（例如变量）声明会隐藏（<strong>shadow</strong>）外部域中具有相同名称的任何其他声明。</li></ol><p>匿名类对于其成员也有与局部类相同的限制：</p><ol><li>不能在匿名类中声明<strong>静态初始化块</strong>或<strong>成员接口</strong>。</li><li>匿名类可以具有静态成员，前提是它们是<strong>常量变量</strong>。</li></ol><p>匿名类中可以声明以下内容：</p><ul><li>字段</li><li>额外的方法（即使它们不实现父类的任何方法）</li><li>实例初始化块（Instance initializers）</li><li>局部类（Local classes）</li></ul><p>但是，<strong>在匿名类中不能声明构造函数</strong>（constructors）。</p><h2 id="匿名类访问外部类成员"><a href="#匿名类访问外部类成员" class="headerlink" title="匿名类访问外部类成员"></a>匿名类访问外部类成员</h2><p>一个有继承父类的匿名类示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String ANIMAL = <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外部类成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accessTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名类访问其外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnimalName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(bird.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鸟类，匿名子类，继承自Animal类，可以覆写父类方法</span></span><br><span class="line">    Animal bird = <span class="keyword">new</span> Animal(<span class="string">&quot;布谷鸟&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAnimalName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            accessTest();   <span class="comment">// 访问外部类成员方法</span></span><br><span class="line">            System.out.println(ANIMAL);  <span class="comment">// 访问外部类成员变量</span></span><br><span class="line">            <span class="keyword">super</span>.printAnimalName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bird.printAnimalName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalTest animalTest = <span class="keyword">new</span> AnimalTest();</span><br><span class="line">        animalTest.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 匿名类访问其外部类方法</span></span><br><span class="line">        <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">// 布谷鸟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，匿名类可以访问外部类的所有成员。事实上，他们甚至可以修改这些成员。</p><h2 id="匿名类访问局部变量"><a href="#匿名类访问局部变量" class="headerlink" title="匿名类访问局部变量"></a>匿名类访问局部变量</h2><p>匿名类与局部类对外部域<strong>局部变量</strong>的访问权限是相同的，先看下面局部类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outerValue = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 尝试修改局部变量 localValue，会发生什么？</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localValue = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalInner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 输出Value</span></span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类访问外部变量Int: &quot;</span> + outerValue);</span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类访问局部变量Int: &quot;</span> + localValue);</span><br><span class="line">                outerValue = <span class="number">20</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;内部方法内部类修改外部变量Int: &quot;</span> + outerValue);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 尝试修改局部变量 localValue，会发生什么？</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalInner localInner = <span class="keyword">new</span> LocalInner();</span><br><span class="line">        localInner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OuterClass outer = <span class="keyword">new</span> OuterClass();</span><br><span class="line">        outer.outerMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// 内部类方法访问外部类成员变量Int: 10</span></span><br><span class="line">        <span class="comment">// 内部类方法访问局部变量Int: 20</span></span><br><span class="line">        <span class="comment">// 内部类方法修改外部类成员变量Int: 20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出说明局部类可以访问外部类成员，也可以访问局部变量。但修改局部变量会发生什么？我们添加<code>localValue = 10;</code>在对应注释下并执行，会报错：<code>java: 从内部类引用的本地变量必须是最终变量或实际上的最终变量</code>。</p><p>这是因为局部类访问局部变量的先决条件是局部变量满足<code>final</code>或<strong>等效<code>final</code></strong>。简单来说，该局部变量必须在初始化后不被修改，无论是否声明为<code>final</code>。</p><p>匿名类对于局部变量的访问规则与局部类相同，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EffectivelyFinalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// Effectively Final，虽然没有声明为final，但不会再次修改</span></span><br><span class="line">        <span class="comment">// x = 20; // 如果尝试修改x的值，编译器将产生错误</span></span><br><span class="line"></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Value of x: &quot;</span> + x); <span class="comment">// 在匿名内部类中访问Effectively Final变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名类隐藏外部域声明"><a href="#匿名类隐藏外部域声明" class="headerlink" title="匿名类隐藏外部域声明"></a>匿名类隐藏外部域声明</h2><p>当在匿名类中声明具有与外部类相同名称的类型（例如变量）时，会发生隐藏（shadowing）现象。这意味着匿名类中的类型声明会覆盖外部类中具有相同名称的任何其他声明，从而隐藏外部类中的相应内容。</p><p>下面是一个示例，用于说明这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowingExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 外部类中的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">20</span>; <span class="comment">// 外部类中的局部变量</span></span><br><span class="line"></span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> value = <span class="number">30</span>; <span class="comment">// 匿名类中的局部变量，会隐藏外部类的局部变量</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Value in anonymous class: &quot;</span> + value); <span class="comment">// 访问匿名类中的局部变量</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Value in outer class method: &quot;</span> + ShadowingExample.<span class="keyword">this</span>.value); <span class="comment">// 访问外部类成员变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShadowingExample example = <span class="keyword">new</span> ShadowingExample();</span><br><span class="line">        example.performAction();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Value in anonymous class: 30</span></span><br><span class="line">        <span class="comment">// Value in outer class method: 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名类中，我们可以通过 <code>ShadowingExample.this.value</code> 访问外部类的成员变量，因为匿名类中的局部变量 <code>value</code> 隐藏了外部类的局部变量 <code>value</code>，但没有隐藏外部类的成员变量 <code>value</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html</a><br>[2] <a href="https://www.cnblogs.com/wuhenzhidu/p/anonymous.html">https://www.cnblogs.com/wuhenzhidu/p/anonymous.html</a><br>[3] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing">https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing</a><br>[4] <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java中的匿名类，Java8及以后。&lt;/p&gt;
&lt;p&gt;涉及概念包括：&lt;strong&gt;等效&lt;code&gt;final&lt;/code&gt;&lt;/strong&gt;，成员，变量，作用域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之配置自动填充</title>
    <link href="http://silencezheng.top/2023/08/26/article118/"/>
    <id>http://silencezheng.top/2023/08/26/article118/</id>
    <published>2023-08-26T05:12:19.000Z</published>
    <updated>2023-08-26T05:13:41.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过<code>MetaObjectHandler</code>接口，配置MyBatis-Plus的自动填充。</p><p>MyBatis-Plus版本：<code>3.4.3.4</code><br><span id="more"></span></p><h2 id="什么是自动填充"><a href="#什么是自动填充" class="headerlink" title="什么是自动填充"></a>什么是自动填充</h2><p>通常在建表时，会设置一些公共字段，例如创建人（creator）、更新人（uptater）、创建时间（create_time）、更新时间（update_time）等等。</p><p>每次将实体对象新增入库时，都要设置创建人和创建时间；每次更新实体对象时，都要设置更新人和更新时间；如果这些都放在业务代码中，很是繁琐，于是就需要配置自动填充来简化工作。</p><h2 id="MetaObjectHandler"><a href="#MetaObjectHandler" class="headerlink" title="MetaObjectHandler"></a>MetaObjectHandler</h2><p><code>MetaObjectHandler</code> 是 MyBatis-Plus 提供的一个接口类，通过实现该接口并重写其中的方法，可以在执行数据库操作（插入和更新）时自动填充某些字段的值。</p><p><code>MetaObjectHandler</code> 中有若干默认方法（已实现）和两个接口方法（需实现），接口方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MetaObject 是 MyBatis 的一个反射工具类，用于操作 Java 对象的属性。它提供了一系列方法来获取、设置、判断和操作 Java 对象的属性，使得在不直接调用 JavaBean 的 getter 和 setter 方法的情况下进行属性操作变得更加方便和灵活。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是一个基础的自动填充配置示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新增时填充</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, LocalDateTime.class, LocalDateTime.now()); <span class="comment">// 起始版本 3.3.0(推荐使用)</span></span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="keyword">this</span>.strictInsertFill(metaObject, <span class="string">&quot;createTime&quot;</span>, () -&gt; LocalDateTime.now(), LocalDateTime.class); <span class="comment">// 起始版本 3.3.3(推荐)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改时填充</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, LocalDateTime.class, LocalDateTime.now()); <span class="comment">// 起始版本 3.3.0(推荐)</span></span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;updateTime&quot;</span>, () -&gt; LocalDateTime.now(), LocalDateTime.class); <span class="comment">// 起始版本 3.3.3(推荐)</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想使用 <code>MetaObjectHandler</code>，需要在其实现类上添加 <code>@Component</code> 注解，然后将其注册为 Spring 的一个 Bean，这样 MyBatis Plus 就会自动调用其中定义的方法来进行字段值的填充。</p><p>然后，在实体类上添加注解，告知Mybatis-Plus需要预留注入SQL字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(value = &quot;create_time&quot;,fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure><p>填充策略包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FieldFill</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认不处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DEFAULT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UPDATE,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入和更新填充字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT_UPDATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>1、如果属性有值则不覆盖，如果sql中赋值了，自动填充又设置为其他值，则以sql中的值为准。</p><p>2、如果填充值为null则不填充，比如<code>this.setFieldValByName(“update_time”, null, metaObject);</code>实际是不会更新为null的。</p><p>3、填充处理器（如<code>MyMetaObjectHandler</code>）在 Spring Boot 中需要声明<code>@Component</code>或<code>@Bean</code>注入</p><p>4、最好不要在自定义mapper方法中使用填充，非要使用的话需要使用特定参数注解，如<code>@Param(&quot;et&quot;)</code>等。</p><p>5、<code>update(T t,Wrapper updateWrapper)</code>时<code>t</code>不能为空,否则自动填充失效，如<code>this.update(new User(), new UpdateWrapper&lt;User&gt;().set(&quot;name&quot;, &quot;张三&quot;)));</code>不能省略<code>new User()</code>。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;MetaObjectHandler&lt;/code&gt;接口，配置MyBatis-Plus的自动填充。&lt;/p&gt;
&lt;p&gt;MyBatis-Plus版本：&lt;code&gt;3.4.3.4&lt;/code&gt;&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>图卷积(GCN)学习</title>
    <link href="http://silencezheng.top/2023/08/15/article117/"/>
    <id>http://silencezheng.top/2023/08/15/article117/</id>
    <published>2023-08-15T15:11:28.000Z</published>
    <updated>2023-08-15T15:16:44.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图卷积学习记录，同时也涉及离散拉普拉斯算子内容，可能对视觉方向有帮助。</p><p>相关内容：卷积、傅立叶变换、拉普拉斯算子、狄利克雷能量、图卷积<br><span id="more"></span></p><h2 id="传统卷积"><a href="#传统卷积" class="headerlink" title="传统卷积"></a>传统卷积</h2><p>传统的卷积主要应用于Euclidean Structure的数据上（排列很整齐、Grid形式的），如图像、语句等，主要是因为欧式结构数据能够保证卷积的性质，即平移不变性，而Non-Euclidean无法保证平移不变性，通俗理解就是在拓扑图中每个顶点的相邻顶点数目都可能不同，那么当然无法用一个同样尺寸的卷积核来进行卷积运算。</p><h2 id="推广卷积到图"><a href="#推广卷积到图" class="headerlink" title="推广卷积到图"></a>推广卷积到图</h2><p>卷积定理指出，<strong>函数卷积的傅里叶变换是函数傅里叶变换的乘积</strong>。即一个域中的卷积对应于另一个域中的乘积, 例如时域中的卷积对应于频域中的乘积。</p><script type="math/tex; mode=display">\mathcal{F}\{f * g\}=\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}</script><p>其中 $\mathcal{F}(f)$ 表示 $f$ 的傅里叶变换。下面这种形式也成立：</p><script type="math/tex; mode=display">\mathcal{F}\{f \cdot g\}=\mathcal{F}\{f\} * \mathcal{F}\{g\}</script><p>借由傅里叶逆变换 $\mathcal{F}^{-1}$, 也可以写成：</p><script type="math/tex; mode=display">f * g=\mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\}</script><p>注意以上的写法只对特定形式定义的变换正确，变换可能由其它方式正规化，使得上面的关系式中出现其它的常数因子。</p><p>这一定理对拉普拉斯变换、双边拉普拉斯变换、Z变换、梅林变换和Hartley变换等各种傅里叶变换的变体同样成立。</p><p>利用卷积定理可以简化卷积的运算量。对于长度为 $n$ 的序列，按照卷积的定义进行计算，需要做 $2 n-1$ 组对位乘法，其计算复杂度为 $\mathcal{O}\left(n^2\right)$；而利用傅里叶变换将序列变换到频域上后，只需要一组对位乘法，利用傅里叶变换的快速算法之后，总的计算复杂度为 $\mathcal{O}(n \log n)$ 。这一结果可以在快速乘法计算中得到应用。</p><p>傅里叶变换又可以通过<strong>谱图理论</strong>推广到图上进行变换。</p><blockquote><p>谱图理论是图论与线性代数相结合的产物，它通过分析图的某些矩阵的特征值与特征向量而研究图的性质。拉普拉斯矩阵是谱图理论中的核心与基本概念，在机器学习与深度学习中有重要的应用。包括但不仅限于：流形学习数据降维算法中的拉普拉斯特征映射、局部保持投影，无监督学习中的谱聚类算法，半监督学习中基于图的算法，以及目前炙手可热的图神经网络等。还有在图像处理、计算机图形学以及其他工程领域应用广泛的图切割问题。理解拉普拉斯矩阵的定义与性质是掌握这些算法的基础。</p></blockquote><p>所以，Convolution —— Fourier —— Spectral Graph，卷积通过傅里叶变换和图（频谱域）发生了联系。</p><p>从整个的研究进程来看，首先是研究GSP（Graph Signal Processing）的学者提出了Graph上的Fourier Transformation，进而定义了Graph的Convolution，最后与深度学习结合起来，发展出来GCN。</p><h2 id="图傅立叶变换的实施"><a href="#图傅立叶变换的实施" class="headerlink" title="图傅立叶变换的实施"></a>图傅立叶变换的实施</h2><p>关于时域和频域，我在<a href="https://silencezheng.top/2022/10/05/article67/">高斯滤波和双边滤波</a>一文中已有一些介绍。</p><p>此处需要强调的一点是<strong>傅里叶级数是向量</strong>，一般描述向量的时候，都有对应的基，即在某组基下的坐标表示构成了向量。默认是单位基时，则不显式提到。频域下，某个曲线是表示成了关于正弦函数正交基下的傅里叶级数向量。而在时域下，某个曲线是表示成了关于时间的周期函数。不管时域还是频域，其实反映的都是同一个曲线，只是一个是用函数的观点，一个是用向量的观点。</p><p>图上的傅里叶变换是通过下述联系实施的：</p><ol><li>图拉普拉斯算子， Laplacian Operator —- Graph Laplacian Matrix。</li><li>图拉普拉斯的谱分解，Graph Laplacian Matrix —- Spectral Decomposition。</li><li>图上狄利克雷能量最小的基， Dirichlet Energy —- Orthonormal Basis —- Spectral Decomposition —- Eigenvectors</li><li>傅里叶变换，Fourier —- Fourier Basis —- Laplacian eigenfunctions</li></ol><p>根据4，可以证明，Fourier basis = Laplacian eigenfunctions，即傅立叶级数的基(和频率一一对应)是拉普拉斯算子的特征函数 (满足特征方程)。根据1，在图上，拉普拉斯算子为拉普拉斯矩阵。根据2，拉普拉斯矩阵的谱分解得到的特征向量(和特征值一一对应)类比特征函数。因此，<strong>传统傅里叶变换在图的拓展就是将正弦函数基替换换成图拉普拉斯矩阵的特征向量</strong>，正弦函数与频率一一对应，特征向量与特征值一一对应。而根据3，这一替换的根源意义在于，图拉普拉斯矩阵的特征向量作为一组基的话，这组基是图上狄利克雷能量最小的基。</p><blockquote><p>Laplacian Operator（拉普拉斯算子）和Laplacian eigenfunctions（拉普拉斯特征函数）是在图论和图信号处理中密切相关的概念。</p><ol><li><p>Laplacian Operator:<br>在图论中，Laplacian Operator是用来描述图的拓扑结构和节点之间连接关系的算子。对于一个无向图G，Laplacian Operator通常定义为度矩阵（Degree Matrix）D和邻接矩阵（Adjacency Matrix）A之间的差，即L = D - A。其中，度矩阵D是一个对角矩阵，其对角线元素是每个节点的度数（与该节点相连接的边的数量），邻接矩阵A描述了节点之间的连接关系。<br>Laplacian Operator有多种形式，常见的有度标准化Laplacian、随机游走标准化Laplacian等，不同的形式在不同的图信号处理任务中有不同的应用。</p></li><li><p>Laplacian eigenfunctions:<br>Laplacian eigenfunctions是指Laplacian Operator对应的特征函数，也称为拉普拉斯特征向量。Laplacian Operator的特征函数是在图上定义的一组正交函数，它们描述了图的振动模式和频率。</p></li></ol><p>对于图的Laplacian Operator L，它可以进行谱分解，得到一组特征向量（Laplacian eigenfunctions）和对应的特征值（Laplacian eigenvalues）。这些特征向量在图信号处理中具有重要的意义，它们构成了一个基，可以用于将图信号从原始的节点空间转换到频域空间，类似于傅里叶变换中的基函数。</p><p>Laplacian eigenfunctions对应的特征值可以用来表示图的结构和节点之间的连接关系，不同的特征值对应不同的频率，反映了图的振动特性。在图信号处理任务中，Laplacian eigenfunctions常常被用作图嵌入、图卷积神经网络（GCN）等方法的基础，以便有效地学习图的特征和结构。</p></blockquote><h2 id="图拉普拉斯算子"><a href="#图拉普拉斯算子" class="headerlink" title="图拉普拉斯算子"></a>图拉普拉斯算子</h2><p>先讨论常规连续拉普拉斯算子，然后通过<strong>有限差分法</strong>在离散网格上近似计算拉普拉斯算子，对其进行离散化。</p><blockquote><p>有限差分法是将导数或微分算子替换为差分的形式，从而将微分方程转化为差分方程。</p><p>差分方程是一种数学方程，用于描述离散点之间的关系，通常在数值计算和离散模型中使用。与微分方程类似，差分方程是在离散时间或空间上建立函数之间的关系，而不是连续变量的关系。</p></blockquote><p>最后，我们推广到图结构上。</p><h3 id="拉普拉斯算子（Laplacian-Operator）"><a href="#拉普拉斯算子（Laplacian-Operator）" class="headerlink" title="拉普拉斯算子（Laplacian Operator）"></a>拉普拉斯算子（Laplacian Operator）</h3><p>拉普拉斯算子的严格数学定义：多元函数$f(x_1,…,x_n)$的拉普拉斯算子是<strong>所有自变量的非混合二阶偏导数之和</strong>。</p><script type="math/tex; mode=display">\Delta f=\sum_{i=1}^n \frac{\partial^2 f}{\partial x_i^2}</script><p>基于定义，所有的__拉普拉斯算子都是其一个特例，或是某种情况下(比如离散情况下)的一种近似。很多时候我们之只能近似计算导数值，称为<strong>数值微分</strong>。</p><blockquote><p>数值微分是一种通过数值计算来近似计算函数的导数的方法。它在数值分析和科学计算中经常用于解决无法通过解析方法求得导数的问题，或者用于验证解析导数的结果。</p><p>数值微分的基本思想是利用函数在某一点附近的函数值来近似计算该点的导数。常见的数值微分方法包括：</p><ol><li><p><strong>中心差分法：</strong> 中心差分法使用函数在当前点的前后两个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}</script><p>这里，$h$ 是一个小的正数，代表点的间隔。</p></li><li><p><strong>前向差分法：</strong> 前向差分法使用函数在当前点和该点之后的一个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x+h) - f(x)}{h}</script></li><li><p><strong>后向差分法：</strong> 后向差分法使用函数在当前点和该点之前的一个邻近点的函数值来近似计算导数。它的计算公式如下：</p><script type="math/tex; mode=display">f'(x) \approx \frac{f(x) - f(x-h)}{h}</script></li></ol><p>数值微分方法的精度取决于间隔$h$的大小，过大的$h$可能引入较大的近似误差，而过小的$h$可能引入舍入误差。选择合适的$h$值是确保数值微分结果精度的关键。</p></blockquote><p>对于二阶导数，则有：</p><script type="math/tex; mode=display">\begin{aligned}f^{\prime \prime}(x) & \approx \frac{f^{\prime}(x)-f^{\prime}(x-\Delta x)}{\Delta x} \approx \frac{\frac{f(x+\Delta x)-f(x)}{\Delta x}-\frac{f(x)-f(x-\Delta x)}{\Delta x}}{\Delta x} \\& =\frac{f(x+\Delta x)+f(x-\Delta x)-2 f(x)}{(\Delta x)^2}\end{aligned}</script><p>下面考虑多元函数的偏导数。对于二元函数$f(x,y)$，其拉普拉斯算子可以用下面的公式近似计算：</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =\frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2} \\& \approx \frac{f(x+\Delta x, y)+f(x-\Delta x, y)-2 f(x, y)}{(\Delta x)^2}+\frac{f(x, y+\Delta y)+f(x, y-\Delta y)-2 f(x, y)}{(\Delta y)^2}\end{aligned}</script><h3 id="离散拉普拉斯算子"><a href="#离散拉普拉斯算子" class="headerlink" title="离散拉普拉斯算子"></a>离散拉普拉斯算子</h3><p>图像和图结构都是离散数据，其拉普拉斯算子必然要进行离散化。如果上面的二元函数进行离散化，对自变量的一系列点处的函数值进行采样，得到下面一系列点处的函数值，构成一个矩阵。</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}f\left(x_1, y_1\right) & f\left(x_2, y_1\right) & \ldots & f\left(x_n, y_1\right) \\f\left(x_1, y_2\right) & f\left(x_2, y_2\right) & \ldots & f\left(x_n, y_2\right) \\\ldots & \ldots & \ldots & \ldots \\f\left(x_1, y_n\right) & f\left(x_2, y_n\right) & \ldots & f\left(x_n, y_n\right)\end{array}\right]</script><p>在这里 $x$ 为水平方向， $y$ 为垂直方向。为了简化， 假设 $x$ 和 $y$ 的增量（步长）全为 $1$ ， 即：</p><script type="math/tex; mode=display">\Delta x=x_{i+1}-x_i=1, \Delta y=y_{i+1}-y_i=1</script><p>则点 $\left(x_i, y_j\right)$ 处的拉普拉斯算子可以用下面的公式近似计算：</p><script type="math/tex; mode=display">\begin{aligned}& \frac{f\left(x_i+\Delta x, y_j\right)+f\left(x_i-\Delta x, y_j\right)-2 f\left(x_i, y_j\right)}{(\Delta x)^2}+\frac{f\left(x_i, y_j+\Delta y\right)+f\left(x_i, y_j-\Delta y\right)-2 f\left(x_i, y_j\right)}{(\Delta y)^2} \\& \quad=\frac{f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)-2 f\left(x_i, y_j\right)}{1^2}+\frac{f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-2 f\left(x_i, y_j\right)}{1^2} \\& \quad=f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)+f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-4 f\left(x_i, y_j\right)\end{aligned}</script><p>这是一个非常优美的结果， 它就是 $\left(x_i, y_j\right)$ 的 4 个相邻点处的函数值之和与 $\left(x_i, y_j\right)$ 点处的函数值乘以 4 后的差值。如下图所示：</p><p><img src="/assets/post_img/article117/lisan-lapo.png" alt="lisan"></p><p>基于这种离散表示，拉普拉斯算子的计算公式可以写成如下形式：</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =f\left(x_{i+1}, y_j\right)+f\left(x_{i-1}, y_j\right)+f\left(x_i, y_{j+1}\right)+f\left(x_i, y_{j-1}\right)-4 f\left(x_i, y_j\right) \\& =f\left(x_{i+1}, y_j\right)-f\left(x_i, y_j\right)+f\left(x_{i-1}, y_j\right)-f\left(x_i, y_j\right) \\& +f\left(x_i, y_{j+1}\right)-f\left(x_i, y_j\right)+f\left(x_i, y_{j-1}\right)-f\left(x_i, y_j\right) \\& =\sum_{(k, l) \in N(i, j)}\left(f\left(x_k, y_l\right)-f\left(x_i, y_j\right)\right)\end{aligned}</script><p>其中 $N(i, j)$ 是 $\left(x_i, y_j\right)$ 邻居节点的集合。</p><p>这也给我们一种形象的结论：二维网格（离散二元函数）上计算某点的拉普拉斯算子就是计算上下左右四个自由度上的“变化和”。</p><p>PS：变化和是笔者的个人理解，也有人说是“微小变化后获得的增益”。另外，对于二维网格，也可以拓展出八个自由度的拉普拉斯算子。</p><h3 id="图上的拉普拉斯算子"><a href="#图上的拉普拉斯算子" class="headerlink" title="图上的拉普拉斯算子"></a>图上的拉普拉斯算子</h3><p>在图中，顶点的连接关系是任意的，这意味着顶点的邻居节点数量不固定。将拉普拉斯算子推广到图上，如果将图的顶点处的值看作是函数值，则在顶点$i$处的拉普拉斯算子为：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in N_i}\left(f_i-f_j\right)</script><p>其中 $N_i$ 是顶点 $i$ 的所有邻居顶点的集合。这里我们调换了 $f_i$ 和 $f_j$ 的位置， 和之前的拉普拉斯算子相比， 相当于多了一个负号。由于图的边可以带有权重， 我们可以在上面的计算公式中加上权重：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in N_i} w_{i j}\left(f_i-f_j\right)</script><p>如果 $j$ 不是 $i$ 的邻居, 则 $w_{i j}=0$ 。因此上面的式子也可以写成如下形式：</p><script type="math/tex; mode=display">\Delta f_i=\sum_{j \in V} w_{i j}\left(f_i-f_j\right)=\sum_{j \in V} w_{i j} f_i-\sum_{j \in V} w_{i j} f_j=d_i f_i-\mathbf{w}_i \mathbf{f}</script><p>这里的 $d_i$ 是顶点 $i$ 的加权度，$w_i$ 是邻接矩阵的第 $i$ 行, $f$ 是所有顶点的值构成的列向量, $w_i f$ 是二者的内积。对于图的所有顶点, 有</p><script type="math/tex; mode=display">\begin{aligned}\Delta f & =\left[\begin{array}{c}\Delta f_1 \\\ldots \\\Delta f_n\end{array}\right]=\left[\begin{array}{c}d_1 f_1-\mathbf{w}_1 \mathbf{f} \\\ldots \\d_n f_n-\mathbf{w}_n \mathbf{f}\end{array}\right]=\left[\begin{array}{ccc}d_1 & \ldots & \ldots \\\ldots & \ldots & \ldots \\\ldots & \ldots & d_n\end{array}\right]\left[\begin{array}{c}f_1 \\\ldots \\f_n\end{array}\right]-\left[\begin{array}{c}\mathbf{w}_1 \\\ldots \\\mathbf{w}_n\end{array}\right]\left[\begin{array}{c}f_1 \\\ldots \\f_n\end{array}\right] \\& =(\mathbf{D}-\mathbf{A}) \mathbf{f}\end{aligned}</script><p>上式的全称是：图拉普拉斯算子作用在由图节点信息构成的向量$f$上得到的结果等于<strong>图拉普拉斯矩阵</strong>和向量$f$的点积。</p><p>这也说明，<strong>在图上，拉普拉斯算子等于拉普拉斯矩阵</strong>。</p><h3 id="图拉普拉斯矩阵（Laplacian-Matrix）"><a href="#图拉普拉斯矩阵（Laplacian-Matrix）" class="headerlink" title="图拉普拉斯矩阵（Laplacian Matrix）"></a>图拉普拉斯矩阵（Laplacian Matrix）</h3><p>由此，我们推出了无向图上定义拉普拉斯矩阵的一种方式：</p><script type="math/tex; mode=display">L = D - A</script><p>其中，$L$是图拉普拉斯矩阵，$D$是加权度矩阵（Weighted Degree Matrix），$A$是邻接矩阵（Adjacency Matrix）。</p><p>由于$D$ 和 $A$都是对称矩阵，则无向图的拉普拉斯矩阵也是对称矩阵，它实际上代表了图的二阶导数。</p><p>显然无向图拉普拉斯矩阵每一行元素之和都为 0 。下面介绍拉普拉斯矩阵的若干重要性质（省略证明）：</p><p>1、对任意向量 $\mathbf{f} \in \mathbb{R}^n$ 有：</p><script type="math/tex; mode=display">\mathbf{f}^{\mathrm{T}} \mathbf{L} \mathbf{f}=\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n w_{i j}\left(f_i-f_j\right)^2</script><p>2、拉普拉斯矩阵是对称半正定矩阵;</p><p>3、拉普拉斯矩阵的最小特征值为 0 ，其对应的特征向量为常向量 1 ，即所有分量为 1 ;</p><p>4、拉普拉斯矩阵有 $n$ 个非负实数特征值，并且满足：</p><script type="math/tex; mode=display">0=\lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n</script><p>5（结论）、假设 $G$ 是一个有非负权重的无向图，其拉普拉斯矩阵 $L$ 的特征值0的重数 $k$ 等于图的联通分量的个数$A_1， \ldots, A_k$。特征值0的特征空间由这些联通分量所对应的特征向量$\mathbf{1}_{A_1}， \ldots, \mathbf{1}_{A_k}$所张成。</p><p>对于结论5，举一个例子进行说明：</p><p><img src="/assets/post_img/article117/jl5.png" alt="jl5"></p><p>上图有两个联通子图，其邻接矩阵为：</p><script type="math/tex; mode=display">\mathbf{A}=\left[\begin{array}{ccccc}0 & 0.37 & 0.37 & 0 & 0 \\0.37 & 0 & 0.14 & 0 & 0 \\0.37 & 0.14 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0.37 \\0 & 0 & 0 & 0.37 & 0\end{array}\right]</script><p>其加权度矩阵为：</p><script type="math/tex; mode=display">\mathbf{D}=\left[\begin{array}{ccccc}0.74 & 0 & 0 & 0 & 0 \\0 & 0.51 & 0 & 0 & 0 \\0 & 0 & 0.51 & 0 & 0 \\0 & 0 & 0 & 0.37 & 0 \\0 & 0 & 0 & 0 & 0.37\end{array}\right]</script><p>拉普拉斯矩阵为：</p><script type="math/tex; mode=display">\mathbf{L}=\mathbf{D}-\mathbf{A}=\left[\begin{array}{ccccc}0.74 & -0.37 & -0.37 & 0 & 0 \\-0.37 & 0.51 & -0.14 & 0 & 0 \\-0.37 & -0.14 & 0.51 & 0 & 0 \\0 & 0 & 0 & 0.37 & -0.37 \\0 & 0 & 0 & -0.37 & 0.37\end{array}\right]</script><p>它由如下两个子矩阵构成：</p><script type="math/tex; mode=display">\begin{aligned}& \mathbf{L}_1=\left[\begin{array}{ccc}0.74 & -0.37 & -0.37 \\-0.37 & 0.51 & -0.14 \\-0.37 & -0.14 & 0.51\end{array}\right] \\& \mathbf{L}_2=\left[\begin{array}{cc}0.37 & -0.37 \\-0.37 & 0.37\end{array}\right]\end{aligned}</script><p>每个子矩阵对应于图的一个联通分量。0 是每个子矩阵的 1 重特征值，由于有两个联通分量，因此 0 是整个图的拉普拉斯矩阵的 2 重特征值。两个线性无关的特征向量为：</p><script type="math/tex; mode=display">\begin{aligned}& \mathbf{1}_{A_1}=\left[\begin{array}{lllll}1 & 1 & 1 & 0 & 0\end{array}\right]^{\mathrm{T}} \\& \mathbf{1}_{A_2}=\left[\begin{array}{lllll}0 & 0 & 0 & 1 & 1\end{array}\right]^{\mathrm{T}}\end{aligned}</script><h3 id="归一化拉普拉斯矩阵（Normalized-Laplacian-Matrix）"><a href="#归一化拉普拉斯矩阵（Normalized-Laplacian-Matrix）" class="headerlink" title="归一化拉普拉斯矩阵（Normalized Laplacian Matrix）"></a>归一化拉普拉斯矩阵（Normalized Laplacian Matrix）</h3><p>图拉普拉斯矩阵有两种形式的归一化。</p><p>第一种称为<strong>对称归一化</strong>，定义为：</p><script type="math/tex; mode=display">\mathbf{L}_{\text {sym }}=\mathbf{D}^{-1 / 2} \mathbf{L D}^{-1 / 2}=\mathbf{I}-\mathbf{D}^{-1 / 2} \mathbf{A} \mathbf{D}^{-1 / 2}</script><p>这里 $D^{1 / 2}$ 是 $D$ 的所有元素计算正平方根得到的矩阵。位置为 $(i . j), i \neq j$ 的元素为将未归一化拉普拉斯矩阵对应位置处的元素 $l_{i j}$ 除以 $\sqrt{d_{i i} d_{j j}}$ 后形成的，主对角线上的元素为 1 ：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{L}_{\mathrm{sym}} & =\left[\begin{array}{cccc}1 / \sqrt{d_{11}} & 0 & \ldots & 0 \\0 & 1 / \sqrt{d_{22}} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / \sqrt{d_{n n}}\end{array}\right]\left[\begin{array}{cccc}l_{11} & l_{12} & \ldots & l_{1 n} \\l_{21} & l_{22} & \ldots & l_{2 n} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} & l_{n 2} & \ldots & l_{n n}\end{array}\right]\left[\begin{array}{cccc}1 / \sqrt{d_{11}} & 0 & \ldots & 0 \\0 & 1 / \sqrt{d_{22}} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / \sqrt{d_{n n}}\end{array}\right] \\& =\left[\begin{array}{cccc}1 & l_{12} / \sqrt{d_{11} d_{22}} & \ldots & l_{1 n} / \sqrt{d_{11} d_{n n}} \\l_{21} / \sqrt{d_{22} d_{11}} & 1 & \ldots & l_{2 n} / \sqrt{d_{22} d_{n n}} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} / \sqrt{d_{n n} d_{11}} & l_{n 2} / \sqrt{d_{n n} d_{22}} & \ldots & 1\end{array}\right]\end{aligned}</script><p>由于 $D^{1 / 2}$ 和 $L$ 都是对称矩阵, 因此 $L_{sym}$ 也是对称矩阵。如果图是联通的，则 $D$ 和 $D^{1 / 2}$ 都是可逆的对角矩阵，其逆矩阵分别为其主对角线元素的逆。</p><p>第二种称为<strong>随机漫步归一化</strong>，定义为：</p><script type="math/tex; mode=display">\mathbf{L}_{\mathrm{rw}}=\mathbf{D}^{-1} \mathbf{L}=\mathbf{I}-\mathbf{D}^{-1} \mathbf{A}</script><p>其位置为 $(i, j), i \neq j$ 的元素为将未归一化拉普拉斯矩阵对应位置处的元素 $l_{i j}$ 除以 $d_{i i}$ 后形成的，主对角线元素也为 1：</p><script type="math/tex; mode=display">\begin{aligned}\mathbf{L}_{\mathrm{rw}} & =\left[\begin{array}{cccc}1 / d_{11} & 0 & \ldots & 0 \\0 & 1 / d_{22} & \ldots & 0 \\\ldots & \ldots & \ldots & \ldots \\0 & 0 & \ldots & 1 / d_{n n}\end{array}\right]\left[\begin{array}{cccc}l_{11} & l_{12} & \ldots & l_{1 n} \\l_{21} & l_{22} & \ldots & l_{2 n} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} & l_{n 2} & \ldots & l_{n n}\end{array}\right] \\& =\left[\begin{array}{cccc}1 & l_{12} / d_{11} & \ldots & l_{1 n} / d_{11} \\l_{21} / d_{22} & 1 & \ldots & l_{2 n} / d_{22} \\\ldots & \ldots & \ldots & \ldots \\l_{n 1} / d_{n n} & l_{n 2} / d_{n n} & \ldots & 1\end{array}\right]\end{aligned}</script><p>下面介绍这两种归一化矩阵的若干重要性质：</p><p>1、对任意向量 $\mathbf{f} \in \mathbb{R}^n$ 有：</p><script type="math/tex; mode=display">\mathbf{f}^{\mathrm{T}} \mathbf{L}_{\mathrm{sym}} \mathbf{f}=\frac{1}{2} \sum_{i=1}^n \sum_{j=1}^n w_{i j}\left(\frac{f_i}{\sqrt{d_i}}-\frac{f_j}{\sqrt{d_j}}\right)^2</script><p>2、$\lambda$ 是矩阵 $L_{rw}$ 的特征值，$\mu$ 是特征向量, 当且仅当 $\lambda$ 是 $L_{sym}$ 的特征值且其特征向量为 $w=D^{1 / 2} \mu$。</p><p>3、$\mu$ 是矩阵 $L_{rw}$ 的特征值，$\mu$ 是对应的特征向量，当且仅当 $\lambda$ 和 $\mu$ 是广义特征值问题 $L u=\lambda D u$ 的解。</p><p>4、0 是矩阵 $L_{rw}$ 的特征值，其对应的特征向量为常向量 1 ，即所有分量为 1。 0 是矩阵 $L_{sym}$ 的特征值，其对应的特征向量为 $D^{1 / 2} 1$ 。</p><p>5、矩阵 $L_{sym}$ 和 $L_{rw}$ 是半正定矩阵，有 $n$ 个非负实数特征值, 并且满足：</p><script type="math/tex; mode=display">0=\lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n</script><p>6（结论）、和未归一化的拉普拉斯矩阵类似，假设 $G$ 是一个有非负权重的无向图，其归一化拉普拉斯矩阵 $L_{rw}$ 和 $L_{sym}$ 的特征值0的重数 $k$ 等于图的联通分量的个数 $A_1, \ldots, A_k$ 。</p><p>对于矩阵 $L_{rw}$，特征值0的特征空间由这些联通分量所对应的向量 $1_{A_1}, \ldots, 1_{A_k}$ 所张成。 $1_{A_i}$ 的定义与未归一化拉普拉斯矩阵0特征值的特征向量相同。</p><p>对于矩阵 $L_{sym}$, 特征值O的特征空间由这些联通分量所对应的向量 $\mathbf{D}^{1 / 2} \mathbf{1}_{A_1}, \ldots, \mathbf{D}^{1 / 2} \mathbf{1}_{A_k}$ 所张成。</p><h2 id="拉普拉斯矩阵的谱分解（Spectral-Decomposition）"><a href="#拉普拉斯矩阵的谱分解（Spectral-Decomposition）" class="headerlink" title="拉普拉斯矩阵的谱分解（Spectral Decomposition）"></a>拉普拉斯矩阵的谱分解（Spectral Decomposition）</h2><p>在矩阵范围内，不考虑过于复杂的数学概念，谱分解又称为特征值分解，只有方阵才能进行谱分解。</p><blockquote><p><strong>特征向量（Eigenvectors）</strong>：一个矩阵的特征向量是指一个非零向量，其在经过矩阵变换后只发生了伸缩而没有改变方向，只相差了一个常数倍数。换句话说，矩阵乘以特征向量后，相当于对该向量进行了一个比例的拉伸。</p><p><strong>特征值（Eigenvalues）</strong>：特征值是对应于特征向量的标量，它表示了在特征向量进行矩阵变换后的伸缩倍数。一个矩阵可以有多个特征向量和对应的特征值。</p></blockquote><p>对于一个方阵 $A$，谱分解的基本思想是将它表示为特征向量矩阵 $P$ 与对角特征值矩阵 $Λ$ 相乘的形式，即 $A = P <em> Λ </em> P^{-1} $。如果 $A$ 是对称矩阵，则 $P$ 是正交矩阵，则原式也可写作 $A = P <em> Λ </em> P^T$。</p><p>由于拉普拉斯矩阵是<strong>对称半正定</strong>的，我们可以得到以下性质：<br>1、一定有$n$个线性无关的特征向量（对称）。<br>2、矩阵的特征值一定非负（半正定）。<br>3、矩阵的特征向量相互正交，即所有特征向量构成的矩阵为正交矩阵（对称）。</p><p>所以，拉普拉斯矩阵 $L$ 的谱分解也可以写成 $P <em> Λ </em> P^T$ 的形式，如下所示：</p><script type="math/tex; mode=display">\boldsymbol{L}=\boldsymbol{\Phi} \boldsymbol{\Lambda} \boldsymbol{\Phi}^{\top}</script><p>$\Phi=\left(\phi_1, \phi_2, \ldots, \phi_n\right) \in \mathbb{R}^{\mathrm{n} \times n}$ 是正交矩阵，其列向量为单位特征向量。<br>$\Lambda=\operatorname{diag}\left(\lambda_1, \ldots, \lambda_n\right)$ 是由对应特征值构成的对角矩阵。</p><h2 id="狄利克雷能量（Dirichlet-Energy）"><a href="#狄利克雷能量（Dirichlet-Energy）" class="headerlink" title="狄利克雷能量（Dirichlet Energy）"></a>狄利克雷能量（Dirichlet Energy）</h2><p>狄利克雷能量衡量了函数的平滑性（Smoothness），越小说明函数越平滑。狄利克雷能量定义为:</p><script type="math/tex; mode=display">\mathrm{E}_{\mathrm{Dir}}(\boldsymbol{f})=\boldsymbol{f}^{\top} \boldsymbol{\Delta} \boldsymbol{f}</script><p>其中$f$ 是函数，$\Delta$ 是拉普拉斯算子。整个公式在图结构上的含义是，计算函数$\boldsymbol{f}$在图的节点上的变化程度，其中变化程度通过将函数$\boldsymbol{f}$映射到拉普拉斯矩阵的空间（$\boldsymbol{\Delta} \boldsymbol{f}$），并计算映射后的向量与原向量的内积来衡量。</p><p>在图论中，狄利克雷能量越小表示图中节点的函数在空间中变化越平滑，节点之间的连接或关系越紧密。这可以用于量化图中的平滑性和连通性。</p><p>那么，<strong>狄利克雷能量最小化问题对推广图傅立叶变换有什么帮助呢</strong>？</p><p>图傅立叶变换是将一个定义在图的节点上的函数映射到频谱域，类似于信号处理中的傅立叶变换。在连续信号的情况下，傅立叶变换将信号分解为不同频率的正弦和余弦函数。类似地，在图上，图傅立叶变换将一个函数分解为图中的基函数，<strong>这些基函数由狄利克雷能量最小化问题得到</strong>。</p><p>我们的目标是寻找图上狄利克雷能量最小的一组单位正交基（每个基都可以看成函数）。 巧合的是，这样的正交基正好就是对拉普拉斯矩阵 $L$ 进行谱分解得到的单位特征向量 $\phi_1, \ldots, \phi_n$ 。 这对我们从传统傅里叶变换推广到图上傅里叶变换时进行的类比和替换提供了理论解释。</p><h2 id="图傅立叶变换（Graph-Fourier-Transformation）"><a href="#图傅立叶变换（Graph-Fourier-Transformation）" class="headerlink" title="图傅立叶变换（Graph Fourier Transformation）"></a>图傅立叶变换（Graph Fourier Transformation）</h2><p>简单回顾傅立叶变换，然后推广到图。</p><h3 id="傅立叶变换（Fourier-Transformation）"><a href="#傅立叶变换（Fourier-Transformation）" class="headerlink" title="傅立叶变换（Fourier Transformation）"></a>傅立叶变换（Fourier Transformation）</h3><p>傅里叶变换于将一个函数从时间（或空间）域转换到频率域，以便分析其频率特性。傅里叶变换可以将一个信号分解成不同频率的成分，从而揭示出信号的频谱信息。</p><p>傅里叶变换的公式如下：</p><p>对于连续信号：</p><script type="math/tex; mode=display">F(\omega) = \int_{-\infty}^{\infty} f(t) e^{-j\omega t} dt</script><p>对于离散信号：</p><script type="math/tex; mode=display">F(k) = \sum_{n=0}^{N-1} f(n) e^{-j\frac{2\pi}{N}kn}</script><p>其中，$ F(\omega) $ 或 $ F(k)$ 是信号在频率域的表示，$ f(t) $ 或 $ f(n) $ 是信号在时间（或空间）域的表示，$ \omega $ 是角频率，$ j $ 是虚数单位， $ t $ 或 $ n $ 是时间（或空间）的变量。</p><p>$F(\omega)$ 就是傅里叶变换，得到的就是频域图，它在 $\omega_0$ 的值 $F(\omega_0)$ 表示 $f(x)$ 在 $\omega_0$ 频率对应的正交基上的系数。</p><p>下面两者称为傅里叶变换对, 可以相互转换:</p><script type="math/tex; mode=display">f(x) \Leftrightarrow F(\omega)</script><p>另外，$e^{-j\omega t}$ 是傅立叶基函数之一，也被称为<strong>复指数函数</strong>。傅立叶变换可以将一个函数从时域转换到频域，它将一个函数表示为不同频率的正弦和余弦函数的叠加。$e^{-j\omega t}$ 就是这些正弦和余弦函数的复数形式，参照$e^{jx} = \cos(x) + j \sin(x)$。</p><h3 id="傅立叶基函数（Fourier-Basis-Functions）"><a href="#傅立叶基函数（Fourier-Basis-Functions）" class="headerlink" title="傅立叶基函数（Fourier Basis Functions）"></a>傅立叶基函数（Fourier Basis Functions）</h3><p>傅立叶基函数（Fourier Basis Functions）是一组正交函数，用于展开和表示信号在频率域的成分。在傅立叶变换中，原始信号可以被分解为各种频率的正弦和余弦函数的线性组合，而这些正弦和余弦函数就构成了傅立叶基函数。</p><p>傅立叶基函数的具体形式取决于是连续信号还是离散信号。对于连续信号，傅立叶基函数是正弦和余弦函数，表达式如下：</p><script type="math/tex; mode=display">\phi_k(t) = \frac{1}{\sqrt{T}} \cdot \begin{cases} \cos(2\pi kft), & \text{for even}\ k \\ \sin(2\pi kft), & \text{for odd}\ k \end{cases}</script><p>其中，$k$ 为频率索引，$f$ 为信号的基本频率，$T$ 为信号的周期。</p><p>对于离散信号，傅立叶基函数是复指数函数，表达式如下：</p><script type="math/tex; mode=display">\phi_k[n] = \frac{1}{\sqrt{N}} \cdot e^{j2\pi kn/N}</script><p>其中，$k$ 为频率索引，$N$ 为信号的样本点数。</p><p>傅立叶基函数构成了频率域的正交基，意味着不同频率的基函数之间彼此正交。通过将信号在傅立叶基函数上的投影，我们可以得到信号在不同频率上的分量，从而实现频域分析。</p><p>傅立叶基函数是傅立叶变换的核心概念，它们的线性组合可以用来表示任何信号。</p><h3 id="图傅立叶变换"><a href="#图傅立叶变换" class="headerlink" title="图傅立叶变换"></a>图傅立叶变换</h3><p>首先，在图上，拉普拉斯算子等于拉普拉斯矩阵。复指数函数$e^{-j\omega t}$，即傅立叶变换的基函数，可以被证明是图上拉普拉斯算子的一个特征函数。</p><script type="math/tex; mode=display">\Delta e^{-j\omega t}=\frac{\partial^2 e^{-j\omega t}}{\partial t^2}=-\omega^2 e^{-j\omega t}</script><p>在图上作类比，令变量为 $x$，令频率为 $\mathrm{k}$ （注意与角频率的区别）， $\phi_{\mathrm{k}}$ 为图拉普拉斯算子 $L$ 的特征向量（满足 $L \phi_k=\lambda_k \phi_k$ ）。即在图中 $\Delta=\boldsymbol{L}, \mathrm{e}^{-\mathrm{jkx}}=\phi_k$ ，而 $\mathrm{k}$ 和特征值 $\lambda_{\mathrm{k}}$ 有关。</p><p>因此，为了在图上进行傅里叶变换，可以把传统傅里叶变换中的 $\mathrm{e}^{-\mathrm{jk} x}$ 换成 $\phi_k$ ，把频率 $\mathrm{k}$ 换为 特征值 $\lambda_{\mathrm{k}}$。</p><p>则图傅里叶变换写作:</p><script type="math/tex; mode=display">F\left(\lambda_k\right)=\hat{f_k}=\left\langle f, \phi_k\right\rangle</script><p>$f=\left(f_1, \ldots, f_n\right)$ 是由节点信息构成的n维向量。做个类似的解释，即特征值 $\lambda_k$ 下，$f$ 的 图傅里叶变换（振幅）等于 $f$ 与 $\lambda_k$ 对应的特征向量 $\phi_k$ 的内积。</p><p>推广到矩阵形式，图傅里叶变换:</p><script type="math/tex; mode=display">\hat{f} = \boldsymbol{\Phi}^{\top} f</script><p>其中, $\hat{f}=\left(\hat{f_1} , \hat{f_2}, \ldots, \hat{f_n}\right)$，即图傅里叶变换，即不同特征值(频率)下对应的振幅构成的向量。 $f=\left(f_1, \ldots, f_n\right)$ 是由节点信息构成的n维向量。</p><p>类似的，传统逆傅里叶变换（n个正弦波的叠加）：</p><script type="math/tex; mode=display">{ }^{-1}[F(k)]=f(x)=\sum_k F(k) e^{i k x}=\sum_k \frac{1}{2 \pi} \int_{-\infty}^{\infty} f\left(x^{\prime}\right) e^{-i k x^{\prime}} d x^{\prime} e^{i k x}</script><p>迁移到图上，$\mathrm{e}^{ikx} \mathrm{e}^{-ikx}=1$，两个基正交，类比于 $\left(\phi_{\mathrm{k}}^{\top} \phi_{\mathrm{k}}\right)_{\mathrm{i}}=1$，则图逆傅里叶变换：</p><script type="math/tex; mode=display">\mathrm{f}_{\mathrm{i}}=\sum_{\mathrm{k}=1}^{\mathrm{n}} \hat{\mathrm{f}_{\mathrm{k}}}\left(\boldsymbol{\phi}_k^{\top}\right)_{\mathrm{i}}</script><p>推广到矩阵形式，图逆傅立叶变换：</p><script type="math/tex; mode=display">f = \boldsymbol{\Phi} \hat{f}</script><h2 id="图卷积（Graph-Convolution）"><a href="#图卷积（Graph-Convolution）" class="headerlink" title="图卷积（Graph Convolution）"></a>图卷积（Graph Convolution）</h2><p>结合图傅立叶变换和卷积定理的结论，我们可以推导出图卷积，首先有：</p><script type="math/tex; mode=display">\begin{align}    f * g=\mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\} \\    \\    \hat{f} = \boldsymbol{\Phi}^{\top} f \\    \\    f = \boldsymbol{\Phi} \hat{f}\end{align}</script><p>下面令图为 $f$，卷积核为 $h$，则图卷积为 $f * h$，有：</p><script type="math/tex; mode=display">\begin{align}f * h = \mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{h\}\} \\= \mathcal{F}^{-1}\{\boldsymbol{\Phi}^{\top} f \odot \boldsymbol{\Phi}^{\top} h\} \\ = \boldsymbol{\Phi}\boldsymbol{\Phi}^{\top} f \odot \boldsymbol{\Phi}^{\top} h \\= \boldsymbol{\Phi}\boldsymbol{\Phi}^{\top} h \odot \boldsymbol{\Phi}^{\top} f \\= \boldsymbol{\Phi}\hat{h} \odot \boldsymbol{\Phi}^{\top} f \\= \boldsymbol{\Phi} \operatorname{diag}\left[\hat{h}\left(\lambda_1\right), \ldots, \hat{h}\left(\lambda_n\right)\right] \boldsymbol{\Phi}^T \boldsymbol{f}\end{align}</script><p>上式是我按自己的理解推导得来，如有错误，请联系我的邮箱赐教🙏，感谢。</p><p>对于卷积核的图傅里叶变换: $\hat{h}=\left(\hat{h}_1, \ldots, \hat{h}_n\right)$, 其中 $\hat{h}_k=\left\langle h, \phi_k\right\rangle, k=1,2 \ldots, n$。</p><p>对于把 $\hat{h}$ 组织成对角矩阵 $\operatorname{diag}\left[\hat{h}\left(\lambda_k\right)\right] \in \mathbb{R}^{N \times N}$，个人理解，并不是在改变向量的形状，而是在改变操作方式（转变成矩阵乘法），以更好地表达图卷积的运算。</p><p>深度学习中的卷积就是要设计可学习的卷积核，从公式可以看出，就是要设计 $\operatorname{diag}\left[\hat{h}\left(\lambda_1\right), \ldots, \hat{h}\left(\lambda_n\right)\right]$, 由此, 可以直接将其变为卷积核 $\operatorname{diag}\left[\theta_1, \ldots, \theta_n\right]$，而不需要再将卷积核进行傅里叶变换，相当于直接对变换后的参量进行学习，可以把它理解成可训练权重向量。</p><p>PS：本人还有一个问题没搞懂，是否图和卷积核要分别计算 $\boldsymbol{\Phi}$ ？</p><h3 id="一代GCN"><a href="#一代GCN" class="headerlink" title="一代GCN"></a>一代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1312.6203">Spectral Networks and Locally Connected Networks on Graphs</a></p><p>由上述图卷积可以得到第一代GCN：</p><script type="math/tex; mode=display">\boldsymbol{y}_{\text {output }}=\sigma\left(\boldsymbol{\Phi} \boldsymbol{g}_\theta \boldsymbol{\Phi}^T \boldsymbol{x}\right)=\sigma\left(\boldsymbol{\Phi} \operatorname{diag}\left[\theta_1, \ldots, \theta_n\right] \boldsymbol{\Phi}^T \boldsymbol{x}\right)</script><p>其中，$\boldsymbol{g}_{\boldsymbol{\theta}}=\text{diag}[\theta_1,…,\theta_n]$ 为卷积核，$\sigma$ 是激活函数，$\boldsymbol{x}$ 就是图上对应每个节点的特征构成的向量，$x=\left(x_1, x_2, \ldots, x_n\right)$，这里暂时对每个节点都使用标量，相当于通道数为 1 ，然后经过激活之后，得到输出 $\boldsymbol{y}_{\text {output, }}$ 之后传入下一层。</p><p>缺点：</p><ul><li>需要对拉普拉斯矩阵进行谱分解来求 $\boldsymbol{\Phi}$，在图很大的时候复杂度很高。 另外，还需要计算矩阵乘积，复杂度为 $O\left(n^2\right)$ 。</li><li>卷积核参数为 $n$，当图很大的时候，$n$ 会很大。</li><li>卷积核的spatial localization不好。</li></ul><blockquote><p>卷积核的空间定位（spatial localization）是指卷积核在输入数据的空间维度上的操作范围和影响范围。在卷积操作中，卷积核会在输入数据的不同位置上滑动，通过与输入数据的局部区域进行逐元素相乘并求和来生成输出。</p><p>在图像处理领域，卷积核的空间定位决定了卷积操作在图像中提取特征的方式。不同大小的卷积核和不同的卷积操作方式可以捕捉到图像中不同尺度和结构的特征。例如，小尺寸的卷积核可以捕捉到图像中的细节特征，而较大尺寸的卷积核则可以捕捉到图像中的整体结构特征。</p><p>在图卷积网络中，卷积核的空间定位也很重要。由于图数据不像图像一样具有规则的网格结构，卷积核的设计需要考虑图的拓扑结构。卷积核在图上的空间定位可以用来控制卷积操作在图节点之间传播信息的方式，从而捕捉到图的局部和全局特征。</p><p>因此，卷积核的空间定位在卷积操作中起到了至关重要的作用，它决定了卷积操作如何在输入数据的不同位置上进行特征提取。</p></blockquote><h3 id="二代GCN"><a href="#二代GCN" class="headerlink" title="二代GCN"></a>二代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1606.09375">Convolutional Neural Networks on Graphs with Fast Localized Spectral Filtering</a></p><p>图傅里叶变换是关于特征值(相当于普通傅里叶变换的频率)的函数，也就是 $F\left(\lambda_1\right), \ldots, F\left(\lambda_n\right)$，即 $F(\boldsymbol{\Lambda})$, 因此，将卷积核 $\boldsymbol{g}_\theta$ 写成 $\boldsymbol{g}_\theta(\Lambda)$，然后将 $\boldsymbol{g}_\theta(\Lambda)$ 定义为如下k阶多项式</p><script type="math/tex; mode=display">g_{\theta^{\prime}}(\mathbf{\Lambda}) \approx \sum_{k=0}^K \theta_k^{\prime} \mathbf{\Lambda}^k</script><p>这里的 $\Lambda$ 为以特征值为对角元素的对角矩阵，所以 $\Lambda^k$ 也是对角矩阵，通过求和之后，还是对角矩阵，就这一点来说，和 $g_\theta$ 本身是对角矩阵是非常吻合的。</p><p>将卷积公式带入，可以得到：</p><script type="math/tex; mode=display">\begin{aligned}g_{\theta^{\prime}} * x & \approx \Phi \sum_{k=0}^K \theta_k^{\prime} \boldsymbol{\Lambda}^k \boldsymbol{\Phi}^T \boldsymbol{x} \\& =\sum_{k=0}^K \theta_k^{\prime}\left(\boldsymbol{\Phi} \boldsymbol{\Lambda}^k \boldsymbol{\Phi}^T\right) x \\& =\sum_{k=0}^K \theta_k^{\prime}\left(\mathbf{\Phi} \boldsymbol{\Lambda} \boldsymbol{\Phi}^T\right)^k x \\& =\sum_{k=0}^K \theta_k^{\prime} \boldsymbol{L}^k x\end{aligned}</script><p>可以看出，这一代的GCN不需要做特征分解了，可以直接对Laplacian矩阵做变换，通过事先将Laplacian矩阵求出来，以及 $\boldsymbol{L}^k$ 求出来，前向传播的时候，就可以直接使用，复杂度为 $O\left(K n^2\right)$ 。</p><p>那么上式是如何体现localization呢？我们知道，矩阵的$k$次方可以用于求连通性，即1个节点经过$k$步能否到达另一个顶点，矩阵$k$次方结果中对应元素非0的话可达，为0不可达。那么 $\boldsymbol{L}^k$ 所表达的就是 k-hop 内的节点。又可以通过拉普拉斯算子的性质证明，如果两个节点的最短路径大于 $k$ 的话，$\boldsymbol{L}^k$ 在相应位置的元素值为0。</p><p>综上，相当于只有n节点的k-hop之内的邻居节点能够传递信息，实际上只利用了节点的K-Localized信息。</p><p>另外，作者提出可以使用切比雪夫展开式来近似 $\boldsymbol{L}^k$，因为任何 $\mathbf{k}$ 次多项式都可以使用切比雪夫展开式来近似，由此，引入切比雪夫多项式的 $K$ 阶截断获得 $\boldsymbol{L}^k$ 近似，从而获得对 $g_\theta(\boldsymbol{\Lambda})$ 的近似</p><script type="math/tex; mode=display">g_{\theta^{\prime}}(\mathbf{\Lambda}) \approx \sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\mathbf{\Lambda}})</script><p>其中，$\tilde{\boldsymbol{\Lambda}}=\frac{2}{\lambda_{\max }} \boldsymbol{\Lambda}-\boldsymbol{I}_n $ 为经图拉普拉斯矩阵 $L$ 的最大特征值（即谱半径）缩放后的特征向量矩阵（防止连乘爆炸），$ \boldsymbol{\theta}^{\prime} \in \mathbb{R}^K$ 为一个切比雪夫向量，$\theta_k^{\prime}$ 为第 $k$ 维分量，切比雪夫多项式 $T_k(x)$ 使用递归的方式进行定义：</p><script type="math/tex; mode=display">T_k(x)=2 x T_{k-1}(x)-T_{k-2}(x)</script><p>其中, $T_0(x)=1, T_1(x)=x$ 。</p><p>此时，用近似的卷积核带入到原公式，可得：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{g}_{\boldsymbol{\theta}^{\prime}} * \boldsymbol{x} & \approx \boldsymbol{\Phi} \sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{\Lambda}}) \boldsymbol{\Phi}^T \boldsymbol{x} \\& \approx \sum_{k=0}^K \theta_k^{\prime}\left(\boldsymbol{\Phi} T_k(\tilde{\boldsymbol{\Lambda}}) \boldsymbol{\Phi}^T\right) x \\& =\sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{L}}) \boldsymbol{x}\end{aligned}</script><p>其中，$\tilde{\boldsymbol{L}}=\frac{2}{\lambda_{\max }} \boldsymbol{L}-\boldsymbol{I}_n$ 。</p><p>因此，可以得到输出为：</p><script type="math/tex; mode=display">\boldsymbol{y}_{\text {output }}=\sigma\left(\sum_{k=0}^K \theta_k^{\prime} T_k(\tilde{\boldsymbol{L}}) \boldsymbol{x}\right)</script><p>其中参数向量 $\boldsymbol{\theta}^{\prime} \in \mathbb{R}^{k}$ 需要学习。</p><h3 id="三代GCN"><a href="#三代GCN" class="headerlink" title="三代GCN"></a>三代GCN</h3><p>论文：<a href="https://arxiv.org/abs/1609.02907">Semi-supervised Classification with Graph Convolutional Networks</a></p><p>这一代GCN直接取切比雪夫多项式中 $K=1$，此时模型是 1 阶近似，即每层卷积层只考虑了直接邻域，类似CNN中 $3 \times 3$ 的卷积核。并且，这一代GCN加深了深度而减小了宽度，若要建立多阶 proximity，只需要使用多个卷积层。同时，加入了一些参数约束，如 $\lambda_{\max }=2$ 和引入renormalization trick，大大简化了模型。</p><p>下面开始推导，将 $K=1, \quad \lambda_{\max }=2$ 带入可以得到：</p><script type="math/tex; mode=display">\begin{aligned}\boldsymbol{g}_{\theta^{\prime}} * \boldsymbol{x} & \approx \boldsymbol{\theta}_0^{\prime} \boldsymbol{x}+\theta_1^{\prime}\left(\boldsymbol{L}-\boldsymbol{I}_n\right) \boldsymbol{x} \\& =\boldsymbol{\theta}_0^{\prime} \boldsymbol{x}+\theta_1^{\prime}\left(\boldsymbol{L}-\boldsymbol{I}_n\right) \boldsymbol{x} \\& =\theta_0^{\prime} \boldsymbol{x}-\theta_1^{\prime}\left(\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}\right) \boldsymbol{x}\end{aligned}</script><p>最终转换步骤的解释如下：</p><script type="math/tex; mode=display">\boldsymbol{L}=\boldsymbol{D}^{-1 / 2}(\boldsymbol{D}-\boldsymbol{W}) \boldsymbol{D}^{-1 / 2}=\boldsymbol{I}_n-\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}</script><p>现在每个卷积核只有2个参数，为了进一步简化，令 $\theta_0^{\prime}=-\theta_1^{\prime}$，此时只含有一个参数 $\theta$：</p><script type="math/tex; mode=display">g_{\theta^{\prime}} * x=\theta\left(I_n+D^{-1 / 2} W D^{-1 / 2}\right) x</script><p>由于 $\boldsymbol{I}_n+\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2}$ 的谱半径 $[0,2]$ 太大，使用renormalization trick：</p><script type="math/tex; mode=display">\boldsymbol{I}_n+\boldsymbol{D}^{-1 / 2} \boldsymbol{W} \boldsymbol{D}^{-1 / 2} \rightarrow \tilde{\boldsymbol{D}}^{-1 / 2} \tilde{\boldsymbol{W}} \tilde{\boldsymbol{D}}^{-1 / 2}</script><p>其中，$\tilde{\boldsymbol{W}}=\boldsymbol{W}+\boldsymbol{I}_n$ (相当于加了self-connection，本来$\boldsymbol{W}$对角元素为0)，$\tilde{D}_{i j}=\Sigma_j \tilde{W}_{i j}$ 。</p><p>带入卷积公式：</p><script type="math/tex; mode=display">\underbrace{g_{\theta^{\prime}} * x}_{\mathbb{R}^{n \times 1}}=\theta(\underbrace{\tilde{D}^{-1 / 2} \tilde{W} \tilde{D}^{-1 / 2}}_{\mathbb{R}^{n \times n}}) \underbrace{x}_{\mathbb{R}^{n \times 1}}</script><p>如果推广到多通道，相当于每一个节点的信息是向量，且有多卷积核：</p><script type="math/tex; mode=display">x \in \mathbb{R}^{N \times 1} \rightarrow X \in \mathbb{R}^{N \times C}</script><p>其中，$N$ 是节点数量，$C$ 是通道数，或者称作表示节点的信息维度数。 $\mathrm{X}$ 是 节点的特征矩阵。</p><p>相应的卷积核参数变化：</p><script type="math/tex; mode=display">\theta \in \mathbb{R} \rightarrow \Theta \in \mathbb{R}^{C \times F}</script><p>其中，$F$ 为卷积核数量。</p><p>那么卷积结果写成矩阵形式为：</p><script type="math/tex; mode=display">\underbrace{Z}_{\mathbb{R}^{N \times F}}=\underbrace{\tilde{D}^{-1 / 2} \tilde{W} \tilde{D}^{-1 / 2}}_{\mathbb{R}^{N \times N}} \underbrace{X}_{\mathbb{R}^{N \times C}}  \underbrace{\Theta}_{\mathbb{R}^{C \times F}}</script><p>上述操作可以叠加多层，对输出$Z$激活一下，就可以作为下一层节点的特征矩阵。</p><p>这一代GCN特点：</p><ul><li>取 $K=1$，相当于直接取邻域信息，类似于 $3 \times 3$ 的卷积核。</li><li>由于卷积核宽度减小，可以通过增加卷积层数来扩大感受域，从而增强网络的表达能力。</li><li>增加了参数约束，比如 $\lambda_{\max } \approx 2$，引入重归一化trick。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/76296353">https://zhuanlan.zhihu.com/p/76296353</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/54505069">https://zhuanlan.zhihu.com/p/54505069</a><br>[3] <a href="http://xtf615.com/2019/02/24/gcn/">http://xtf615.com/2019/02/24/gcn/</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/362416124">https://zhuanlan.zhihu.com/p/362416124</a><br>[5] <a href="https://qddmj.cn/gcn-laplacian.htm">https://qddmj.cn/gcn-laplacian.htm</a><br>[6] <a href="https://zhuanlan.zhihu.com/p/170091053">https://zhuanlan.zhihu.com/p/170091053</a><br>[7] <a href="https://qddmj.cn/gcn-laplacian2.htm">https://qddmj.cn/gcn-laplacian2.htm</a><br>[8] <a href="https://zhuanlan.zhihu.com/p/41609577">https://zhuanlan.zhihu.com/p/41609577</a><br>[9] <a href="https://zhuanlan.zhihu.com/p/464121739">https://zhuanlan.zhihu.com/p/464121739</a><br>[10] <a href="https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#convolutional-layers">https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#convolutional-layers</a><br>[11] <a href="https://zhuanlan.zhihu.com/p/60014316">https://zhuanlan.zhihu.com/p/60014316</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;图卷积学习记录，同时也涉及离散拉普拉斯算子内容，可能对视觉方向有帮助。&lt;/p&gt;
&lt;p&gt;相关内容：卷积、傅立叶变换、拉普拉斯算子、狄利克雷能量、图卷积&lt;br&gt;</summary>
    
    
    
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="图论" scheme="http://silencezheng.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Yilia图片居中</title>
    <link href="http://silencezheng.top/2023/08/13/article116/"/>
    <id>http://silencezheng.top/2023/08/13/article116/</id>
    <published>2023-08-13T07:48:59.000Z</published>
    <updated>2023-08-13T07:50:37.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo博客，Yilia主题设置图片居中。</p><span id="more"></span><p>Yilia用了很久了，终于想起来动一下图片居中的毛病，原版是无法实现图片居中的，在<code>article-main.scss</code>中加个样式可以解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  // 要添加的</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但添加完需要重新编译主题项目，进入项目根目录执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 编译、压缩。</span></span><br><span class="line">npm run dist</span><br></pre></td></tr></table></figure></p><p>Yilia这个项目2017年后就没有维护了，注意在安装依赖时用Python2环境。</p><p>参考<a href="https://github.com/litten/hexo-theme-yilia/wiki/Yilia源码目录结构及构建须知">官方文档</a>。</p><p>在外部编译压缩完，替换source目录下的<code>main.XXX.css</code>文件就行了。</p><p>但如果项目编译环境有问题的话，这样替换还是容易造成其他bug，最稳妥的方式还是直接在已发布的<code>main.XXX.css</code>中搜索<code>.article img</code>然后进行修改。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo博客，Yilia主题设置图片居中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Yilia" scheme="http://silencezheng.top/tags/Yilia/"/>
    
  </entry>
  
</feed>
