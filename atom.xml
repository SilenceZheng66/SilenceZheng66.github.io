<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>silenceZheng66-BLOG</title>
  
  <subtitle>log</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2022-05-10T17:01:54.967Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>silenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring boot学习笔记01</title>
    <link href="http://silencezheng.top/2022/05/10/article35/"/>
    <id>http://silencezheng.top/2022/05/10/article35/</id>
    <published>2022-05-10T04:16:39.000Z</published>
    <updated>2022-05-10T17:01:54.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot学习笔记01"><a href="#Spring-boot学习笔记01" class="headerlink" title="Spring boot学习笔记01"></a>Spring boot学习笔记01</h1><ol><li>前言</li><li>概念</li><li>常见注解介绍</li></ol><h2 id="1-前言："><a href="#1-前言：" class="headerlink" title="1. 前言："></a>1. 前言：</h2><p>继续学习Spring boot～</p><span id="more"></span><h2 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h2><p>对Spring boot的宏观理解，它的诞生是为了简化 Spring 应用的搭建和开发过程，具有 Spring 一切优秀特性，而且使用更加简单，功能更加丰富，性能更加稳定而健壮。在Spring boot中我们使用基于注解和JAVA的配置方式，抛弃XML！</p><p>学习Spring boot最好还是对Spring、Servlet有基本的理解。</p><h3 id="2-1-三层架构"><a href="#2-1-三层架构" class="headerlink" title="2.1. 三层架构"></a>2.1. 三层架构</h3><p>注意区别MVC架构即可，MVC是表现层（Web层）的一个设计模式，真正意义的三层架构如下：</p><ul><li>A 表现层–Web层</li><li>B 业务层–Service层</li><li>C 持久层–Dao层</li></ul><h3 id="2-2-控制反转–IoC"><a href="#2-2-控制反转–IoC" class="headerlink" title="2.2. 控制反转–IoC"></a>2.2. 控制反转–IoC</h3><p>IoC——Inversion of Control，指的是将对象的创建权交给 Spring 去创建。使用 Spring 之前，对象的创建都是由我们自己在代码中new创建。而使用 Spring 之后。对象的创建都是给了 Spring 框架。控制反转可以用许多方式表达，依赖注入是其中一种方式。</p><h3 id="2-3-依赖注入–DI"><a href="#2-3-依赖注入–DI" class="headerlink" title="2.3. 依赖注入–DI"></a>2.3. 依赖注入–DI</h3><p>Dependency Injection，当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者。</p><p>Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。DI 主要有两种变体，即通过构造函数参数形式和通过setter方法形式：</p><ol><li>Constructor-based dependency injection，当容器调用带有多个参数的构造函数类时，实现基于构造函数的 DI，每个代表在其他类中的一个依赖关系。</li><li>Setter-based dependency injection，基于 setter 方法的 DI 是通过在调用无参数的构造函数或无参数的静态工厂方法实例化 bean 之后容器调用 beans 的 setter 方法来实现的。</li></ol><h3 id="2-4-面向切面编程–AOP"><a href="#2-4-面向切面编程–AOP" class="headerlink" title="2.4.  面向切面编程–AOP"></a>2.4.  面向切面编程–AOP</h3><p>先理解什么是切面。用刀把一个西瓜分成两瓣，切开的切口就是切面；炒菜，锅与炉子共同来完成炒菜，锅与炉子就是切面。web层级设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面。编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面。</p><p>其他的先忽略，需要仔细研究。</p><p>Spring 框架的 AOP 模块提供了面向方面的程序设计实现，可以定义诸如方法拦截器和切入点等，从而使实现功能的代码彻底的解耦出来。</p><h3 id="2-5-容器–Container"><a href="#2-5-容器–Container" class="headerlink" title="2.5.  容器–Container"></a>2.5.  容器–Container</h3><p>Spring 是一个容器，因为它包含并且管理应用对象的生命周期。Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans。在Spring中BeanFactory是IOC容器的实际代表者。</p><h3 id="2-6-“对象”–Bean"><a href="#2-6-“对象”–Bean" class="headerlink" title="2.6.  “对象”–Bean"></a>2.6.  “对象”–Bean</h3><p>Bean是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的。把配置元数据提供给 Spring 容器有基于XML、注解和JAVA三种方式。Bean的重要属性有作用域（scope）、初始化与销毁和与依赖注入相关的constructor-arg、properties、autowiring mode等。</p><h3 id="2-7-自动装配–Autowire"><a href="#2-7-自动装配–Autowire" class="headerlink" title="2.7.  自动装配–Autowire"></a>2.7.  自动装配–Autowire</h3><p>Spring 容器可以在不使用<code>&lt;constructor-arg&gt;</code>和<code>&lt;property&gt;</code>元素的情况下<strong>自动装配</strong>相互协作的 bean 之间的关系。Spring中可以使用<code>&lt;bean&gt;</code>元素的<strong>autowire</strong>属性为一个 bean 定义指定自动装配模式，选择由属性名或由属性数据类型自动装配。</p><p>以由属性名自动装配举例，在 XML 配置文件中 beans 的<em>auto-wire</em>属性设置为<em>byName</em>。然后尝试将它的属性与配置文件中定义为相同名称的 beans 进行匹配和连接。如果找到匹配项，它将注入这些 beans，否则，它将抛出异常。总的来说，如果在一个类A中使用了另一个类B作为属性，若不想显式的对B进行绑定，就可以使用自动装配。</p><p>Spring采用基于注解的方式配置时，@Autowired是最常用的注解之一，这个注解的功能就是为我们注入一个定义好的 bean。</p><h3 id="2-8-Spring-boot-starter"><a href="#2-8-Spring-boot-starter" class="headerlink" title="2.8. Spring boot starter"></a>2.8. Spring boot starter</h3><p>Spring Boot 将日常企业应用研发中的各种场景都抽取出来，做成一个个的 starter（启动器），starter 中整合了该场景下各种可能用到的依赖，用户只需要在 Maven 中引入 starter 依赖，SpringBoot 就能自动扫描到要加载的信息并启动相应的默认配置。starter 提供了大量的自动配置，让用户摆脱了处理各种依赖和配置的困扰。所有这些 starter 都遵循着约定成俗的默认配置，并允许用户调整这些配置，即遵循“约定大于配置”的原则。</p><p>以 spring-boot-starter-web 为例，它能够为提供 Web 开发场景所需要的几乎所有依赖，因此在使用 Spring Boot 开发 Web 项目时，只需要引入该 Starter 即可，而不需要额外导入 Web 服务器和其他的 Web 依赖。</p><p>spring-boot-starter-parent 是所有 Spring Boot 项目的父级依赖，它被称为 Spring Boot 的版本仲裁中心，可以对项目内的部分常用依赖进行统一管理。Spring Boot 项目可以通过继承 spring-boot-starter-parent 来获得一些合理的默认配置如默认 JDK 版本、默认字符集、依赖管理功能、资源过滤、默认插件配置、识别 application.properties（或yml）类型的配置文件。</p><h3 id="2-9-配置文件–Spring-boot-profile"><a href="#2-9-配置文件–Spring-boot-profile" class="headerlink" title="2.9. 配置文件–Spring boot profile"></a>2.9. 配置文件–Spring boot profile</h3><p>在实际的项目开发中，一个项目通常会存在多个环境，例如，开发环境、测试环境和生产环境等，不同环境的配置也不尽相同。</p><p>Spring Boot 的配置文件共有两种形式：.properties  文件和 .yml 文件，不管哪种形式，它们都能通过文件名的命名形式区分出不同的环境的配置，文件命名格式为：</p><p>application-{profile}.properties/yml</p><p>其中，{profile} 一般为各个环境的名称或简称，例如 dev、test 和 prod 等等。</p><h4 id="2-9-1-默认配置文件"><a href="#2-9-1-默认配置文件" class="headerlink" title="2.9.1. 默认配置文件"></a>2.9.1. 默认配置文件</h4><p>通常情况下，Spring Boot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 作为其默认配置文件，我们可以在该配置文件中对项目进行配置，但这并不意味着 Spring Boot 项目中只能存在一个 application.properties 或 application.yml。</p><h4 id="2-9-2-外部配置文件"><a href="#2-9-2-外部配置文件" class="headerlink" title="2.9.2. 外部配置文件"></a>2.9.2. 外部配置文件</h4><p>除了默认配置文件，Spring Boot 还可以加载一些位于项目外部的配置文件。我们可以通过如下 2 个参数，指定外部配置文件的路径：</p><ul><li>spring.config.location</li><li>spring.config.additional-location</li></ul><p>我们可以先将 Spring Boot 项目打包成 JAR 文件，然后在命令行启动命令中，使用命令行参数 –spring.config.location，指定外部配置文件的路径。</p><p><code>java -jar &#123;JAR&#125;  --spring.config.location=&#123;外部配置文件全路径&#125;</code></p><p>需要注意的是，使用该参数指定配置文件后，会使项目默认配置文件（application.properties 或 application.yml ）失效，Spring Boot 将只加载指定的外部配置文件。</p><h3 id="2-10-Spring-boot-配置"><a href="#2-10-Spring-boot-配置" class="headerlink" title="2.10. Spring boot 配置"></a>2.10. Spring boot 配置</h3><p>Spring Boot 不仅可以通过配置文件进行配置，还可以通过环境变量、命令行参数等多种形式进行配置。这些配置都可以让开发人员在不修改任何代码的前提下，直接将一套 Spring Boot  应用程序在不同的环境中运行。</p><h4 id="2-10-1-配置加载顺序"><a href="#2-10-1-配置加载顺序" class="headerlink" title="2.10.1. 配置加载顺序"></a>2.10.1. 配置加载顺序</h4><ol><li>命令行参数</li><li>来自 java:comp/env 的 JNDI 属性</li><li>Java 系统属性（System.getProperties()）</li><li>操作系统环境变量</li><li>RandomValuePropertySource 配置的 random.* 属性值</li><li>配置文件（YAML 文件、Properties 文件）</li><li>@Configuration 注解类上的 @PropertySource 指定的配置文件</li><li>通过 SpringApplication.setDefaultProperties 指定的默认属性</li></ol><p>以上所有形式的配置都会被加载，当存在相同配置内容时，高优先级的配置会覆盖低优先级的配置；存在不同的配置内容时，高优先级和低优先级的配置内容取并集，共同生效，形成互补配置。同一位置下，Properties 文件优先级高于 YAML 文件。</p><h4 id="2-10-2-自动配置"><a href="#2-10-2-自动配置" class="headerlink" title="2.10.2. 自动配置"></a>2.10.2. 自动配置</h4><p>Spring Boot 的<strong>自动配置</strong>是基于 Spring Factories 机制实现的。</p><p>Spring Factories 机制是 Spring Boot 中的一种服务发现机制，这种扩展机制与 Java SPI 机制十分相似。Spring Boot 会自动扫描所有 Jar 包类路径下 META-INF/spring.factories 文件，并读取其中的内容，进行实例化，这种机制也是 Spring Boot Starter 的基础。具体来说，spring-core 包里定义了 SpringFactoriesLoader 类，这个类会扫描所有 Jar 包类路径下的 META-INF/spring.factories 文件，并获取指定接口的配置。</p><p>spring.factories 文件本质上与 properties 文件相似，其中包含一组或多组键值对（key=vlaue），其中，key 的取值为接口的完全限定名；value 的取值为接口实现类的完全限定名，一个接口可以设置多个实现类，不同实现类之间使用“，”隔开。</p><p>基于以上，Spring boot的<strong>自动配置</strong>也是通过同样方式实现的，在 spring-boot-autoconfigure-xxx.jar 类路径下的 META-INF/spring.factories 中设置了 Spring Boot 自动配置的内容。</p><h3 id="2-11-拦截器"><a href="#2-11-拦截器" class="headerlink" title="2.11. 拦截器"></a>2.11. 拦截器</h3><p>拦截器可以根据 URL 对请求进行拦截，主要应用于登陆校验、权限验证、乱码解决、性能监控和异常处理等功能上。</p><p>在 Spring Boot 项目中，使用拦截器功能通常需要以下 3 步：</p><ol><li>定义拦截器；</li><li>注册拦截器；</li><li>指定拦截规则（如果是拦截所有，静态资源也会被拦截）。</li></ol><h4 id="2-11-1-定义拦截器"><a href="#2-11-1-定义拦截器" class="headerlink" title="2.11.1. 定义拦截器"></a>2.11.1. 定义拦截器</h4><p>只需要创建一个拦截器类，并实现 HandlerInterceptor 接口即可，该接口中定义以下 3 个方法（按需重写即可）：</p><ol><li>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)，该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</li><li>void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)，该方法在控制器处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改。</li><li>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)，该方法在视图渲染结束后执行，可以通过此方法实现资源清理、记录日志信息等工作。</li></ol><h4 id="2-11-2-注册拦截器"><a href="#2-11-2-注册拦截器" class="headerlink" title="2.11.2. 注册拦截器"></a>2.11.2. 注册拦截器</h4><p>创建一个实现了 WebMvcConfigurer 接口的配置类（使用了 @Configuration 注解的类），重写 addInterceptors() 方法，并在该方法中调用 registry.addInterceptor() 方法将自定义的拦截器注册到容器中。示例：</p><pre><code>@ConfigurationpublicclassMyMvcConfigimplementsWebMvcConfigurer&#123; ......    @Override    public void addInterceptors(InterceptorRegistryregistry)&#123;      registry.addInterceptor(newLoginInterceptor());    &#125;&#125;</code></pre><h4 id="2-11-3-指定拦截规则"><a href="#2-11-3-指定拦截规则" class="headerlink" title="2.11.3. 指定拦截规则"></a>2.11.3. 指定拦截规则</h4><p>在指定拦截器拦截规则时，可以调用两个方法，说明如下：</p><ul><li>addPathPatterns：该方法用于指定拦截路径，例如拦截路径为<code>/**</code>，表示拦截所有请求，包括对静态资源的请求。</li><li>excludePathPatterns：该方法用于排除拦截路径，即指定不需要被拦截器拦截的请求。</li></ul><p>示例：</p><p><code>registry.addInterceptor(newLoginInterceptor()).addPathPatterns(&quot;/**&quot;)</code></p><p>可以链式调用。</p><h2 id="3-常见注解介绍"><a href="#3-常见注解介绍" class="headerlink" title="3. 常见注解介绍"></a>3. 常见注解介绍</h2><h3 id="3-1-Autowired"><a href="#3-1-Autowired" class="headerlink" title="3.1. @Autowired"></a>3.1. @Autowired</h3><p><a href="https://www.w3cschool.cn/wkspring/rw2h1mmj.html">https://www.w3cschool.cn/wkspring/rw2h1mmj.html</a></p><p>这个注解是属于 Spring 的容器配置的一个注解，与它同属容器配置的注解还有：@Required,@Primary, @Qualifier 等等。</p><p>在 Spring 的世界当中，自动装配指的就是使用将 Spring 容器中的 bean 自动的和我们需要这个 bean 的类组装在一起，注入一个定义好的 bean。</p><p>用法：</p><ol><li>应用于字段</li><li>应用于构造函数</li><li>应用于 setter 方法</li><li>应用于具有任意名称和多个参数的方法</li><li>添加到需要该类型数组（或容器）的字段或方法，则 Spring 会从 ApplicationContext 中搜寻符合指定类型的所有 bean</li></ol><h3 id="3-2-RestController"><a href="#3-2-RestController" class="headerlink" title="3.2. @RestController"></a>3.2. @RestController</h3><p>在 Spring Boot 中，@Controller 注解是专门用于处理 Http 请求处理的，是以 MVC 为核心的设计思想的控制层。@RestController 则是 @Controller 的衍生注解，都是用来表示Spring某个类的是否可以接收HTTP请求。</p><p>@RestController是@Controller和@ResponseBody的结合体，两个标注合并起来的作用。@Controller类中的方法可以直接通过返回String跳转到jsp、ftl、html等模版页面。在方法上加@ResponseBody注解，也可以返回实体对象。@RestController类中的所有方法只能返回String、Object、Json等实体对象，不能跳转到模版页面。</p><p>用法（感觉有点问题）：</p><p>@Controller: 一般应用在有返回界面的应用场景下.例如，管理后台使用了 thymeleaf 作为模板开发，需要从后台直接返回 Model 对象到前台，那么这时候就需要使用 @Controller 来注解。</p><p>@RestController: 如果只是接口，那么就用 RestController 来注解.如前端页面全部使用了 Html、Jquery来开发，通过 Ajax 请求服务端接口，那么接口就使用 @RestController 统一注解。</p><h3 id="3-3-…Mapping"><a href="#3-3-…Mapping" class="headerlink" title="3.3. @…Mapping"></a>3.3. @…Mapping</h3><p>表示路由请求，可以设置各种操作方法。最基本的是@RequestMapping，@GetMapping、@PostMapping、@PutMapping、@DeleteMapping 是 @RequestMapping 的子集，分别表示用不同的请求方式的对应路由。</p><p>举例：</p><p><code>@RequestMapping(value=&quot;/add&quot;,method = RequestMethod.POST),params=&quot;myParam=xyz&quot;</code> 表示路由为 /add 的 POST 请求，但仅仅处理头部包括 myParam=xyz 的请求。</p><p><code>@GetMapping(&quot;/add&quot;)等价于@RequestMapping(method = RequestMethod.GET,value = &quot;/add&quot;)</code></p><h3 id="3-4-Configuration-和-Bean"><a href="#3-4-Configuration-和-Bean" class="headerlink" title="3.4. @Configuration 和 @Bean"></a>3.4. @Configuration 和 @Bean</h3><p>带有<strong>@Configuration</strong>的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。<strong>@Bean</strong>注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。例如：</p><pre><code>@Configurationpublic class HelloWorldConfig&#123;    @Bean     public HelloWorld helloWorld()&#123;        return new HelloWorld();       &#125;&#125;</code></pre><h3 id="3-5-SpringBootApplication"><a href="#3-5-SpringBootApplication" class="headerlink" title="3.5. @SpringBootApplication"></a>3.5. @SpringBootApplication</h3><p>所有 Spring Boot 项目的主启动程序类上都使用了一个 @SpringBootApplication 注解，该注解是 Spring Boot 中最重要的注解之一 ，也是 Spring Boot 实现自动化配置的关键。</p><p>@SpringBootApplication 是一个组合元注解，其主要包含两个注解：<strong>@SpringBootConfiguration</strong> 和 <strong>@EnableAutoConfiguration</strong>，其中 @EnableAutoConfiguration 注解是 SpringBoot 自动化配置的核心所在。</p><h4 id="3-5-1-EnableAutoConfiguration"><a href="#3-5-1-EnableAutoConfiguration" class="headerlink" title="3.5.1. @EnableAutoConfiguration"></a>3.5.1. @EnableAutoConfiguration</h4><p>@EnableAutoConfiguration 注解用于开启 Spring Boot 的自动配置功能， 它使用 Spring 框架提供的 @Import 注解通过 AutoConfigurationImportSelector类（选择器）给容器中导入自动配置组件。</p><h4 id="3-5-2-SpringBootConfiguration"><a href="#3-5-2-SpringBootConfiguration" class="headerlink" title="3.5.2. @SpringBootConfiguration"></a>3.5.2. @SpringBootConfiguration</h4><p>@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-boot学习笔记01&quot;&gt;&lt;a href=&quot;#Spring-boot学习笔记01&quot; class=&quot;headerlink&quot; title=&quot;Spring boot学习笔记01&quot;&gt;&lt;/a&gt;Spring boot学习笔记01&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;常见注解介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-前言：&quot;&gt;&lt;a href=&quot;#1-前言：&quot; class=&quot;headerlink&quot; title=&quot;1. 前言：&quot;&gt;&lt;/a&gt;1. 前言：&lt;/h2&gt;&lt;p&gt;继续学习Spring boot～&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据操作及数学基础--《动手学深度学习》笔记0x02</title>
    <link href="http://silencezheng.top/2022/05/05/article34/"/>
    <id>http://silencezheng.top/2022/05/05/article34/</id>
    <published>2022-05-04T16:49:29.000Z</published>
    <updated>2022-05-11T05:33:18.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据操作及数学基础–《动手学深度学习》笔记0x02"><a href="#数据操作及数学基础–《动手学深度学习》笔记0x02" class="headerlink" title="数据操作及数学基础–《动手学深度学习》笔记0x02"></a>数据操作及数学基础–《动手学深度学习》笔记0x02</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>这一笔记对应预备知识章节，包括数据操作、数据预处理、线性代数、微积分、概率论等。其中很多知识在学数一的时候都更深入理解过了，但是现在发现忘的差不多了，哎～</p><p>对应实践：<a href="https://github.com/silenceZheng66/deep_learning/blob/master/d2l/0x02.ipynb">https://github.com/silenceZheng66/deep_learning/blob/master/d2l/0x02.ipynb</a></p><p>在M1芯片的设备上使用miniforge安装pytorch：<code>conda install -c pytorch pytorch</code></p><span id="more"></span><h2 id="1-数据操作"><a href="#1-数据操作" class="headerlink" title="1. 数据操作"></a>1. 数据操作</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h3><h4 id="1-1-1-张量（tensor）"><a href="#1-1-1-张量（tensor）" class="headerlink" title="1.1.1 张量（tensor）"></a>1.1.1 张量（tensor）</h4><p>即n维数组，无论使用哪个深度学习框架，它的<em>张量类</em>（在MXNet中为<code>ndarray</code>， 在PyTorch和TensorFlow中为<code>Tensor</code>）都与Numpy的<code>ndarray</code>类似。 但深度学习框架又比Numpy的<code>ndarray</code>多一些重要功能： 首先，GPU很好地支持加速计算，而NumPy仅支持CPU计算； 其次，张量类支持自动微分。 这些功能使得张量类更适合深度学习。</p><p>张量表示由一个数值组成的数组，这个数组可能有多个维度。 具有一个轴的张量对应数学上的<em>向量</em>（vector）； 具有两个轴的张量对应数学上的<em>矩阵</em>（matrix）； 具有两个轴以上的张量没有特殊的数学名称。张量中的每个值都称为张量的<em>元素</em>（element）。</p><h4 id="1-1-2-运算符"><a href="#1-1-2-运算符" class="headerlink" title="1.1.2. 运算符"></a>1.1.2. 运算符</h4><p>我们的兴趣不仅限于读取数据和写入数据。 我们想在这些数据上执行数学运算，其中最简单且最有用的操作是<em>按元素</em>（elementwise）运算。 它们将标准标量运算符应用于数组的<strong>每个元素</strong>。 对于将两个数组作为输入的函数，按元素运算将二元运算符应用于两个数组中的<strong>每对位置对应的元素</strong>。 我们可以基于任何从标量到标量的函数来创建按元素函数。</p><p>对于任意具有相同形状的张量， 常见的标准算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>和<code>**</code>）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作。</p><h4 id="1-1-3-广播机制"><a href="#1-1-3-广播机制" class="headerlink" title="1.1.3. 广播机制"></a>1.1.3. 广播机制</h4><p>在上面的部分中，我们看到了如何在相同形状的两个张量上执行按元素操作。 在某些情况下，即使形状不同，我们仍然可以通过调用<em>广播机制</em>（broadcasting mechanism）来执行按元素操作。 这种机制的工作方式如下：首先，通过适当复制元素来扩展一个或两个数组， 以便在转换之后，两个张量具有相同的形状。 其次，对生成的数组执行按元素操作。</p><h4 id="1-1-4-索引和切片"><a href="#1-1-4-索引和切片" class="headerlink" title="1.1.4. 索引和切片"></a>1.1.4. 索引和切片</h4><p>就像在任何其他Python数组中一样，张量中的元素可以通过索引访问。 与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素。例如：我们可以用[-1]选择最后一个元素，可以用[1:3]选择第二个和第三个元素。</p><h4 id="1-1-5-内存变动"><a href="#1-1-5-内存变动" class="headerlink" title="1.1.5. 内存变动"></a>1.1.5. 内存变动</h4><p>运行一些操作可能会导致为新结果分配内存。 例如，如果我们用Y=X+Y，我们将取消引用Y指向的张量，而是指向新分配的内存处的张量。Python的id()函数给我们提供了内存中引用对象的确切地址。 运行Y=Y+X后，我们会发现id(Y)指向另一个位置。 这是因为Python首先计算Y+X，为结果分配新的内存，然后使Y指向内存中的这个新位置。</p><p>我们不希望内存在不必要时发生重新分配的情况，原因有两个：首先，我们不想总是不必要地分配内存。 在机器学习中，我们可能有数百兆的参数，并且在一秒内多次更新所有参数。 通常情况下，我们希望原地执行这些更新。 其次，如果我们不原地更新，其他引用仍然会指向旧的内存位置， 这样我们的某些代码可能会无意中引用旧的参数。</p><p>在这种情况下，我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如<code>Y[:]=&lt;expression&gt;</code>。</p><p>在节省内存开销方面，如果在后续计算中没有重复使用X， 我们也可以使用<code>X[:]=X+Y</code>或<code>X+=Y</code>来减少操作的内存开销。</p><h4 id="1-1-6-对象转换"><a href="#1-1-6-对象转换" class="headerlink" title="1.1.6. 对象转换"></a>1.1.6. 对象转换</h4><p>将深度学习框架定义的张量转换为NumPy张量（ndarray）很容易，反之也同样容易。 注意torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p><p>要将大小为1的张量转换为Python标量，可以调用item函数或Python的内置函数。</p><h3 id="1-2-以PyTorch为例，列举常见操作"><a href="#1-2-以PyTorch为例，列举常见操作" class="headerlink" title="1.2. 以PyTorch为例，列举常见操作"></a>1.2. 以PyTorch为例，列举常见操作</h3><p>虽然它被称为PyTorch，但是代码中使用torch而不是pytorch。</p><p><code>import torch</code></p><p>首先，我们可以使用arange创建一个行向量x。这个行向量包含以0开始的前12个整数，它们默认创建为整数。也可指定创建类型为浮点数。例如，张量x中有 12 个元素。除非额外指定，新的张量将存储在内存中，并采用基于CPU的计算。</p><p><code>x=torch.arange(12)</code></p><p>可以通过张量的shape属性来访问张量（沿每个轴的长度）的<em>形状</em>。</p><p><code>x.shape</code></p><p>如果只想知道张量中元素的总数，即形状的所有元素乘积，可以检查它的大小（size）。 因为这里在处理的是一个向量，所以它的shape与它的size相同。</p><p><code>x.numel()</code></p><p>要想改变一个张量的形状而不改变元素数量和元素值，可以调用reshape函数。 例如，可以把张量x从形状为（12,）的行向量转换为形状为（3,4）的矩阵。 这个新的张量包含与转换前相同的值，但是它被看成一个3行4列的矩阵。 要重点说明一下，虽然张量的形状发生了改变，但其元素值并没有变。 注意，通过改变张量的形状，张量的大小（size）不会改变。我们可以通过-1来调用此自动计算出维度的功能。 即我们可以用<code>x.reshape(-1,4)</code>或<code>x.reshape(3,-1)</code>来取代<code>x.reshape(3,4)</code>。</p><p><code>X=x.reshape(3,4)</code></p><p>有时，我们希望使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵。 我们可以创建一个形状为（2,3,4）的张量，其中所有元素都设置为0。<code>torch.ones((2,3,4))</code>则创建元素全为1的张量，但默认数据类型为float。</p><pre><code>torch.zeros((2,3,4))#结果：tensor([[[0.,0.,0.,0.],         [0.,0.,0.,0.],         [0.,0.,0.,0.]],        [[0.,0.,0.,0.],         [0.,0.,0.,0.],         [0.,0.,0.,0.]]])</code></pre><p>有时我们想通过从某个特定的概率分布中随机采样来得到张量中每个元素的值。 例如，当我们构造数组来作为神经网络中的参数时，我们通常会随机初始化参数的值。 以下代码创建一个形状为（3,4）的张量。 其中的每个元素都从均值为0、标准差为1的标准高斯分布（正态分布）中随机采样。</p><p><code>torch.randn(3,4)</code></p><p>我们还可以通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值。 在这里，最外层的列表对应于轴0，内层的列表对应于轴1。</p><p><code>torch.tensor([[2,1,4,3],[1,2,3,4],[4,3,2,1]])</code></p><p>在下面的例子中，我们使用逗号来表示一个具有5个元素的元组，其中每个元素都是按元素操作的结果。</p><pre><code>x=torch.tensor([1.0,2,4,8])y=torch.tensor([2,2,2,2])x+y,x-y,x*y,x/y,x**y# **运算符是求幂运算#结果：(tensor([3.,4.,6.,10.]),tensor([-1.,0.,2.,6.]),tensor([2.,4.,8.,16.]),tensor([0.5000,1.0000,2.0000,4.0000]),tensor([1.,4.,16.,64.]))</code></pre><p>“按元素”方式可以应用更多的计算，包括像求幂这样的一元运算符。</p><p><code>torch.exp(x)</code></p><p>我们也可以把多个张量<em>连结</em>（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。 我们只需要提供张量列表，并给出沿哪个轴连结。 下面的例子分别演示了当我们沿行（轴-0，形状的第一个元素） 和按列（轴-1，形状的第二个元素）连结两个矩阵时，会发生什么情况。 我们可以看到，第一个输出张量的轴-0长度（6）是两个输入张量轴-0长度的总和（3+3）； 第二个输出张量的轴-1长度（8）是两个输入张量轴-1长度的总和（4+4）。</p><pre><code>X=torch.arange(12,dtype=torch.float32).reshape((3,4))Y=torch.tensor([[2.0,1,4,3],[1,2,3,4],[4,3,2,1]])torch.cat((X,Y),dim=0),torch.cat((X,Y),dim=1)#结果：(tensor([[0.,1.,2.,3.],[4.,5.,6.,7.],[8.,9.,10.,11.],[2.,1.,4.,3.],[1.,2.,3.,4.],[4.,3.,2.,1.]]),tensor([[0.,1.,2.,3.,2.,1.,4.,3.],[4.,5.,6.,7.,1.,2.,3.,4.],[8.,9.,10.,11.,4.,3.,2.,1.]]))</code></pre><p>有时，我们想通过<em>逻辑运算符</em>构建二元张量。 以X==Y为例： 对于每个位置，如果X和Y在该位置相等，则新张量中相应项的值为1。 这意味着逻辑语句X==Y在该位置处为真，否则该位置为0。</p><pre><code>X==Y#结果：tensor([[False,True,False,True],[False,False,False,False],[False,False,False,False]])</code></pre><p>对张量中的所有元素进行求和，会产生一个单元素张量。</p><pre><code>X.sum()#结果：tensor(66.)</code></pre><p>在大多数情况下，我们将沿着数组中长度为1的轴进行广播，如下例子：</p><pre><code>a=torch.arange(3).reshape((3,1))b=torch.arange(2).reshape((1,2))a,b#结果：(tensor([[0],[1],[2]]),tensor([[0,1]]))</code></pre><p>由于a和b分别是3×1和1×2矩阵，如果让它们相加，它们的形状不匹配。 我们将两个矩阵<em>广播</em>为一个更大的3×2矩阵，如下所示：矩阵a将复制列， 矩阵b将复制行，然后再按元素相加。</p><pre><code>a+b#结果：tensor([[0,1],[1,2],[2,3]])</code></pre><p>如下所示，我们可以用[-1]选择最后一个元素，可以用[1:3]选择第二个和第三个元素：</p><p><code>X[-1],X[1:3]</code></p><p>除读取外，我们还可以通过指定索引来将元素写入矩阵。</p><p><code>X[1,2]=9</code></p><p>如果我们想为多个元素赋值相同的值，我们只需要索引所有元素，然后为它们赋值。 例如，[0:2,:]访问第1行和第2行，其中“:”代表沿轴1（列）的所有元素。虽然我们讨论的是矩阵的索引，但这也适用于向量和超过2个维度的张量。</p><p><code>X[0:2,:]=12</code></p><p>将深度学习框架定义的张量转换为NumPy张量（ndarray）很容易，反之也同样容易。 torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p><pre><code>A=X.numpy()B=torch.tensor(A)type(A),type(B)#结果：(numpy.ndarray,torch.Tensor)</code></pre><p>要将大小为1的张量转换为Python标量，我们可以调用<code>item</code>函数或Python的内置函数。</p><pre><code>a=torch.tensor([3.5])a,a.item(),float(a),int(a)#结果：(tensor([3.5000]),3.5,3.5,3)</code></pre><h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><p>在Python中常用的数据分析工具中，我们通常使用pandas软件包。 像庞大的Python生态系统中的许多其他扩展包一样，pandas可以与张量兼容。 本节我们将简要介绍使用pandas预处理原始数据，并将原始数据转换为张量格式的步骤。</p><h3 id="2-1-读取数据集"><a href="#2-1-读取数据集" class="headerlink" title="2.1. 读取数据集"></a>2.1. 读取数据集</h3><p>要从创建的CSV文件中加载原始数据集，我们导入pandas包并调用read_csv函数。</p><pre><code>data=pd.read_csv(data_file)print(data)#结果：   NumRooms  Alley0   NaN      Pave1   2.0      NaN2   4.0      NaN3   NaN      NaN</code></pre><h3 id="2-2-处理缺失值"><a href="#2-2-处理缺失值" class="headerlink" title="2.2. 处理缺失值"></a>2.2. 处理缺失值</h3><p>注意，“NaN”项代表缺失值。 为了处理缺失的数据，典型的方法包括<em>插值法</em>和<em>删除法</em>， 其中插值法用一个替代值弥补缺失值，而删除法则直接忽略缺失值。 </p><p>在对上面例子的处理中，我们将考虑插值法。通过位置索引iloc，我们将data分成inputs和outputs， 其中前者为data的前两列，而后者为data的最后一列。 对于inputs中缺少的数值，我们用同一列的均值替换“NaN”项。</p><pre><code>inputs,outputs=data.iloc[:,0:2],data.iloc[:,2]inputs=inputs.fillna(inputs.mean())print(inputs)#结果：  NumRooms  Alley0   3.0      Pave1   2.0      NaN2   4.0      NaN3   3.0      NaN</code></pre><p>对于inputs中的类别值或离散值，我们将“NaN”视为一个类别。 由于“巷子类型”（“Alley”）列只接受两种类型的类别值“Pave”和“NaN”，pandas可以自动将此列转换为两列“Alley_Pave”和“Alley_nan”。 巷子类型为“Pave”的行会将“Alley_Pave”的值设置为1，“Alley_nan”的值设置为0。 缺少巷子类型的行会将“Alley_Pave”和“Alley_nan”分别设置为0和1。Pandas中的get_dummies方法主要用于对类别型特征做<strong>One-Hot</strong>编码。dummy_na参数默认为False，增加一列表示空缺值，如果为False就忽略空缺值。</p><pre><code>inputs=pd.get_dummies(inputs,dummy_na=True)print(inputs)#结果：  NumRooms  Alley_Pave  Alley_nan0   3.0              1          01   2.0              0          12   4.0              0          13   3.0              0          1</code></pre><h3 id="2-3-转换为张量"><a href="#2-3-转换为张量" class="headerlink" title="2.3. 转换为张量"></a>2.3. 转换为张量</h3><p>现在inputs和outputs中的所有条目都是数值类型，它们需要转换为张量格式进行下一步操作。</p><pre><code>import torchX,y=torch.tensor(inputs.values),torch.tensor(outputs.values)</code></pre><h2 id="3-线性代数"><a href="#3-线性代数" class="headerlink" title="3. 线性代数"></a>3. 线性代数</h2><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1. 基础概念"></a>3.1. 基础概念</h3><p><strong>标量（scalar）</strong>：称仅包含一个数值的叫<em>标量</em>。标量由只有一个元素的张量表示时如<code>x=torch.tensor(3.0)</code>。</p><p><strong>变量（variable）</strong>：符号（x、y等）称为<em>变量</em>，它们表示未知的标量值。</p><p><strong>向量（vector）</strong>：可以将向量视为标量值组成的列表。 我们将这些标量值称为向量的<em>元素</em>（element）或<em>分量</em>（component）。向量的长度通常称为向量的<em>维度</em>。 当向量表示数据集中的样本时，它们的值具有一定的现实意义。例如，如果我们正在研究医院患者可能面临的心脏病发作风险，我们可能会用一个向量来表示每个患者， 其分量为最近的生命体征、胆固醇水平、每天运动时间等。我们通过一维张量处理向量，其长度任意，通过张量的索引来访问向量中任一元素。</p><p><strong>维度（dimension）</strong>：<em>向量</em>或<em>轴</em>的维度被用来表示<em>向量</em>或<em>轴</em>的长度，即向量或轴的元素数量。 然而，张量的维度用来表示张量具有的轴数。 在这个意义上，张量的某个轴的维数就是这个轴的长度。</p><p><strong>矩阵（matrix）</strong>：正如向量将标量从零阶推广到一阶，矩阵将向量从一阶推广到二阶，在代码中表示为具有两个轴的张量。当调用函数来实例化张量时， 我们可以通过指定两个分量m和n来创建一个形状为m×n的矩阵，如<code>A=torch.arange(20).reshape(5,4)</code>。在代码中访问矩阵的转置<code>A.T</code>。</p><p><strong>张量（tensor）</strong>：在线性代数中指代数对象，为我们提供了描述具有任意数量轴的n维数组的通用方法。向量是一阶张量，矩阵是二阶张量。它们的索引机制与矩阵类似。</p><p><strong>点积（dot product）</strong>：也就是内积，给定两个向量x,y∈Rd， 它们的<em>点积</em>（dot product）x⊤y（或⟨x,y⟩） 是相同位置的按元素乘积的和。点积在很多场合都很有用。 例如，给定一组由向量x∈Rd表示的值， 和一组由w∈Rd表示的权重。x中的值根据权重w的加权和， 可以表示为点积x⊤w。 当权重为非负数且和为1（即(∑i=1dwi=1)）时， 点积表示<em>加权平均</em>（weighted average）。 将两个向量规范化得到单位长度后，点积表示它们夹角的余弦。 在代码中使用<code>torch.dot(x,y)</code>表示，注意点积中只接收向量（1维）。</p><p><strong>矩阵-向量积（matrix-vector product）</strong>：将矩阵看作一个列向量，其中每一个元素为一个行向量，则矩阵-向量积为将该列向量的每个元素替换为对应行向量与向量的点积。在代码中使用张量表示矩阵-向量积，我们使用mv函数，接收一个矩阵（2维）和一个向量（1维）。 当我们为矩阵<code>A</code>和向量<code>x</code>调用<code>torch.mv(A,x)</code>时，会执行矩阵-向量积。 注意，<code>A</code>的列维数（沿轴1的长度）必须与<code>x</code>的维数（其长度）相同。</p><p><strong>矩阵乘法（matrix-matrix multiplication）</strong>：设A为n×k矩阵、B为k×m矩阵，可以将矩阵-矩阵乘法AB看作是简单地执行m次矩阵-向量积，并将结果拼接在一起，形成一个n×m矩阵。在代码中：<code>torch.mm(A,B)</code></p><p><strong>表示法</strong>：在《动手学深度学习》中，标量变量由普通小写字母表示（例如，x、y和z），用R表示所有（连续）<em>实数</em>标量的空间，将向量记为粗体、小写的符号 （例如，x、y和z)，认为列向量是向量的默认方向，通常用粗体、大写字母来表示矩阵 （例如，X、Y和Z），张量用特殊字体的大写字母表示（例如，X、Y和Z）。</p><h3 id="3-2-张量算法"><a href="#3-2-张量算法" class="headerlink" title="3.2. 张量算法"></a>3.2. 张量算法</h3><p>当我们开始处理图像时，张量将变得更加重要，图像以n维数组形式出现， 其中3个轴对应于高度、宽度，以及一个<em>通道</em>（channel）轴， 用于表示颜色通道（红色、绿色和蓝色）。</p><p>给定具有相同形状的任意两个张量，任何按元素二元运算的结果都将是相同形状的张量。例如，将两个相同形状的矩阵相加，会在这两个矩阵上执行元素加法。</p><pre><code>A=torch.arange(20,dtype=torch.float32).reshape(5,4)B=A.clone()# 通过分配新内存，将A的一个副本分配给BA, A+B</code></pre><p>两个矩阵的按元素乘法称为<em>Hadamard积</em>（Hadamard product）（数学符号⊙）。</p><p><code>A*B</code></p><p>将张量乘以或加上一个标量不会改变张量的形状，其中张量的每个元素都将与标量相加或相乘。</p><p><code>A*2, A+2</code></p><h3 id="3-3-降维"><a href="#3-3-降维" class="headerlink" title="3.3. 降维"></a>3.3. 降维</h3><p>我们可以对任意张量进行的一个有用的操作是计算其元素的和。 在数学表示法中，我们使用∑符号表示求和。在代码中，我们可以调用计算求和的函数<code>x.sum()</code>。</p><p>默认情况下，调用求和函数会沿所有的轴<strong>降低张量的维度</strong>，使它变为一个标量。 我们还可以指定张量沿哪一个轴来通过求和降低维度。 以矩阵为例，为了通过求和所有行的元素来降维（轴0），我们可以在调用函数时指定axis=0。 由于输入矩阵沿0轴降维以生成输出向量，因此输入轴0的维数在输出形状中消失。</p><pre><code>A_sum_axis0=A.sum(axis=0)A_sum_axis0,A_sum_axis0.shape#结果：(tensor([40.,45.,50.,55.]),torch.Size([4]))</code></pre><p>指定axis=1将通过汇总所有列的元素降维（轴1）。因此，输入轴1的维数在输出形状中消失。</p><pre><code>A_sum_axis1=A.sum(axis=1)A_sum_axis1,A_sum_axis1.shape#结果：(tensor([6.,22.,38.,54.,70.]),torch.Size([5]))</code></pre><p>沿着行和列对矩阵求和，等价于对矩阵的所有元素进行求和。如<code>A.sum(axis=[0,1])</code>。</p><p>一个与求和相关的量是<em>平均值</em>（mean或average）。 我们通过将总和除以元素总数来计算平均值。 在代码中，我们可以调用函数来计算任意形状张量的平均值。</p><pre><code>A.mean(),A.sum()/A.numel() #两者等价</code></pre><p>同样，计算平均值的函数也可以沿指定轴降低张量的维度。</p><pre><code>A.mean(axis=0),A.sum(axis=0)/A.shape[0]#结果：(tensor([8.,9.,10.,11.]),tensor([8.,9.,10.,11.]))</code></pre><h4 id="3-3-1-非降维求和"><a href="#3-3-1-非降维求和" class="headerlink" title="3.3.1. 非降维求和"></a>3.3.1. 非降维求和</h4><p>有时在调用函数来计算总和或均值时保持轴数不变会很有用。</p><pre><code>sum_A=A.sum(axis=1,keepdims=True)sum_A#结果：tensor([[6.],[22.],[38.],[54.],[70.]])</code></pre><p>例如，由于<code>sum_A</code>在对每行进行求和后仍保持两个轴，我们可以通过广播将A除以<code>sum_A</code>。如：<code>A/sum_A</code></p><p>如果我们想沿某个轴计算<code>A</code>元素的累积总和， 比如<code>axis=0</code>（按行计算），我们可以调用<code>cumsum</code>函数。 此函数不会沿任何轴降低输入张量的维度。</p><pre><code>A.cumsum(axis=0)#原本A：tensor([[0.,1.,2.,3.],        [4.,5.,6.,7.],        [8.,9.,10.,11.],        [12.,13.,14.,15.],        [16.,17.,18.,19.]])#结果：tensor([[0.,1.,2.,3.],        [4.,6.,8.,10.],        [12.,15.,18.,21.],        [24.,28.,32.,36.],        [40.,45.,50.,55.]])</code></pre><h3 id="3-4-范数"><a href="#3-4-范数" class="headerlink" title="3.4 范数"></a>3.4 范数</h3><p>线性代数中最有用的一些运算符是<em>范数</em>（norm）。 非正式地说，一个向量的<em>范数</em>告诉我们一个向量有多大。 这里考虑的<em>大小</em>（size）概念不涉及维度，而是分量的大小。</p><p>在线性代数中，向量范数是将向量映射到标量的函数f。 给定任意向量x，向量范数要满足一些属性。 第一个性质是如果我们按常数因子α缩放向量的所有元素， 其范数也会按相同常数因子的<em>绝对值</em>缩放。第二个性质是我们熟悉的三角不等式f(x+y)&lt;=f(x)+f(y)。第三个性质简单地说范数必须是非负的，这是有道理的。因为在大多数情况下，任何东西的最小的<em>大小</em>是0。 最后一个性质要求范数最小为0，当且仅当向量全由0组成。</p><p>假设n维向量x中的元素是x1,…,xn，其L2<em>范数</em>是向量元素平方和的平方根。在代码中，我们可以按如下方式计算向量的L2范数。在深度学习中，我们更经常地使用L2范数的平方。</p><pre><code>u=torch.tensor([3.0,-4.0])torch.norm(u)#结果：tensor(5.)</code></pre><p>L1范数，表示为向量元素的绝对值之和。与L2范数相比，L1范数受异常值的影响较小。 为了计算L1范数，我们将绝对值函数和按元素求和组合起来。</p><pre><code>torch.abs(u).sum()#结果：tensor(7.)</code></pre><p>L2范数和L1范数都是更一般的Lp范数的特例。</p><p>类似于向量的L2范数，矩阵X∈Rm×n的<em>Frobenius范数</em>（Frobenius norm）是矩阵元素平方和的平方根。Frobenius范数满足向量范数的所有性质，它就像是矩阵形向量的L2范数。 调用以下函数将计算矩阵的Frobenius范数。</p><pre><code>torch.norm(torch.ones((4,9)))#结果：tensor(6.)</code></pre><p>在深度学习中，我们经常试图解决优化问题：<em>最大化</em>分配给观测数据的概率;<em>最小化</em>预测和真实观测之间的距离。 用向量表示物品（如单词、产品或新闻文章），以便最小化相似项目之间的距离，最大化不同项目之间的距离。 <strong>目标</strong>，或许是深度学习算法最重要的组成部分（除了数据），通常被表达为范数。</p><h2 id="4-微积分和自动微分"><a href="#4-微积分和自动微分" class="headerlink" title="4. 微积分和自动微分"></a>4. 微积分和自动微分</h2><p>在深度学习中，我们“训练”模型，不断更新它们，使它们在看到越来越多的数据时变得越来越好。 通常情况下，变得更好意味着最小化一个<em>损失函数</em>（loss function）， 即一个衡量“我们的模型有多糟糕”这个问题的分数。 最终，我们真正关心的是生成一个模型，它能够在从未见过的数据上表现良好。 但“训练”模型只能将模型与我们实际能看到的数据相拟合。 因此，我们可以将拟合模型的任务分解为两个关键问题：</p><ul><li><em>优化</em>（optimization）：用模型拟合观测数据的过程；</li><li><em>泛化</em>（generalization）：数学原理和实践者的智慧，能够指导我们生成出有效性超出用于训练的数据集本身的模型。</li></ul><p>总结：</p><ul><li>微分和积分是微积分的两个分支，前者可以应用于深度学习中的优化问题。</li><li>导数可以被解释为函数相对于其变量的瞬时变化率，它也是函数曲线的切线的斜率。</li><li>梯度是一个向量，其分量是多变量函数相对于其所有变量的偏导数。</li><li>链式法则使我们能够微分复合函数。</li><li>深度学习框架可以自动计算导数：我们首先将梯度附加到想要对其计算偏导数的变量上。然后我们记录目标值的计算，执行它的反向传播函数，并访问得到的梯度。</li></ul><h3 id="4-1-导数、微分、偏导"><a href="#4-1-导数、微分、偏导" class="headerlink" title="4.1. 导数、微分、偏导"></a>4.1. 导数、微分、偏导</h3><p>我们首先讨论导数的计算，这是几乎所有深度学习优化算法的关键步骤。 在深度学习中，我们通常选择对于模型参数可微的损失函数。 简而言之，对于每个参数， 如果我们把这个参数<em>增加</em>或<em>减少</em>一个无穷小的量，我们可以知道损失会以多快的速度增加或减少。</p><p>假设我们有一个函数f，其输入和输出都是标量。 导数定义不用多说：<br>$$<br>f^{\prime}(x)=\lim _{h \rightarrow 0} \frac{f(x+h)-f(x)}{h}<br>$$<br>如果f′(a)存在，则称f在a处是<em>可微</em>（differentiable）的。如果f在一个区间内的每个数上都是可微的，则此函数在此区间中是可微的。可以将导数定义中的导数f′(x)解释为f(x)相对于x的<em>瞬时</em>（instantaneous）变化率。 所谓的瞬时变化率是基于x中的变化h，且h接近0。</p><p>要了解微分，以及对函数微分的法则。例如幂律（power rule）:<br>$$<br>D x^{n}=n x^{n-1}<br>$$<br>其中D为微分运算符。还要了解求偏导，这些都是基础。</p><h3 id="4-2-梯度"><a href="#4-2-梯度" class="headerlink" title="4.2. 梯度"></a>4.2. 梯度</h3><p>我们可以连结一个多元函数对其所有变量的偏导数，以得到该函数的<em>梯度</em>（gradient）向量。 具体而言，设函数f:Rn→R的输入是一个n维向量x=[x1,x2,…,xn]⊤，并且输出是一个标量。 函数f(x)相对于x的梯度是一个包含n个偏导数的向量<code>∇xf(x)=[∂f(x)\∂x1,∂f(x)\∂x2,…,∂f(x)\∂xn]⊤</code>,其中∇xf(x)通常在没有歧义时被∇f(x)取代。梯度对于设计深度学习中的优化算法有很大用处。</p><p>假设x为n维向量，在微分多元函数时经常使用以下规则:</p><ul><li>对于所有A∈Rm×n，都有∇xAx=A⊤</li><li>对于所有A∈Rn×m，都有∇xx⊤A=A</li><li>对于所有A∈Rn×n，都有∇xx⊤Ax=(A+A⊤)x</li><li>∇x‖x‖2=∇xx⊤x=2x</li></ul><p>同样，对于任何矩阵X，都有∇X‖X‖F2=2X。</p><h3 id="4-3-链式法则"><a href="#4-3-链式法则" class="headerlink" title="4.3. 链式法则"></a>4.3. 链式法则</h3><p>然而，上面方法可能很难找到梯度。 这是因为在深度学习中，多元函数通常是<em>复合</em>（composite）的， 所以我们可能没法应用上述任何规则来微分这些函数。 幸运的是，链式法则使我们能够微分复合函数。</p><p>让我们先考虑单变量函数。假设函数y=f(u)和u=g(x)都是可微的，根据链式法则有<code>dy\dx=(dy\du)(du\dx)</code></p><p>现在让我们把注意力转向一个更一般的场景，即函数具有任意数量的变量的情况。</p><p>假设可微分函数y有变量u1,u2,…,um，其中每个可微分函数ui都有变量x1,x2,…,xn。 注意，y是，x1,x2，…,xn的函数。 对于任意i=1,2,…,n，链式法则给出：<code>dy\dxi=(dy\du1)(du1\dxi)+(dy\du2)(du2\dxi)+⋯+(dy\dum)(dum\dxi)</code></p><h3 id="4-4-自动微分"><a href="#4-4-自动微分" class="headerlink" title="4.4. 自动微分"></a>4.4. 自动微分</h3><p>求导是几乎所有深度学习优化算法的关键步骤。 虽然求导的计算很简单，只需要一些基本的微积分。 但对于复杂的模型，手工进行更新是一件很痛苦的事情（而且经常容易出错）。</p><p>深度学习框架通过自动计算导数，即<em>自动微分</em>（automatic differentiation）来加快求导。 实际中，根据我们设计的模型，系统会构建一个<em>计算图</em>（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度。 这里，<em>反向传播</em>（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。设y为关于x的函数，调用<code>y.backward()</code>反向传播计算x的梯度<code>x.grad</code>。</p><p>反向传播参考：<a href="https://blog.csdn.net/Weary_PJ/article/details/105706318">https://blog.csdn.net/Weary_PJ/article/details/105706318</a></p><h4 id="4-4-1-非标量变量的反向传播"><a href="#4-4-1-非标量变量的反向传播" class="headerlink" title="4.4.1. 非标量变量的反向传播"></a>4.4.1. 非标量变量的反向传播</h4><p>当y不是标量时，向量y关于向量x的导数的最自然解释是一个矩阵。 对于高阶和高维的y和x，求导的结果可以是一个高阶张量。</p><p>然而，虽然这些更奇特的对象确实出现在高级机器学习中（包括深度学习中）， 但当我们调用向量的反向计算时，我们通常会试图计算一批训练样本中每个组成部分的损失函数的导数。 这里，我们的目的不是计算微分矩阵，而是单独计算批量中每个样本的偏导数之和。</p><h4 id="4-4-2-分离计算"><a href="#4-4-2-分离计算" class="headerlink" title="4.4.2. 分离计算"></a>4.4.2. 分离计算</h4><p>有时，我们希望将某些计算移动到记录的计算图之外。 例如，假设y是作为x的函数计算的，而z则是作为y和x的函数计算的。 想象一下，我们想计算z关于x的梯度，但由于某种原因，我们希望将y视为一个常数， 并且只考虑到x在y被计算后发挥的作用。</p><p>在这里，我们可以分离y来返回一个新变量u，该变量与y具有相同的值， 但丢弃计算图中如何计算y的任何信息。 换句话说，梯度不会向后流经u到x。</p><p>为了实现自动微分，PyTorch跟踪所有涉及张量的操作，可能需要为其计算梯度（即require_grad为True）。 这些操作记录为有向图。在代码上，上述分离计算可以通过使用<strong>detach（）</strong>方法在张量上构造一个新视图，该张量声明为不需要梯度，即从进一步跟踪操作中将其排除在外，因此不记录涉及该视图的子图。即对应上述的情况，令<code>u=y.detach()</code>，使用<code>z=u*x</code>替代原本的<code>z=y*x</code>。</p><h4 id="4-4-3-Python控制流的梯度计算"><a href="#4-4-3-Python控制流的梯度计算" class="headerlink" title="4.4.3. Python控制流的梯度计算"></a>4.4.3. Python控制流的梯度计算</h4><p>使用自动微分的一个好处是：即使构建函数的计算图需要通过Python控制流（例如，条件、循环或任意函数调用），我们仍然可以计算得到的变量的梯度。在下面的代码中，while循环的迭代次数和if语句的结果都取决于输入a的值。</p><pre><code>def f(a):  b=a*2  while b.norm()&lt;1000:    b=b*2  if b.sum()&gt;0:    c=b  else:    c=100*b  return c# 计算梯度a=torch.randn(size=(),requires_grad=True)d=f(a)d.backward()</code></pre><p>我们现在可以分析上面定义的f函数。 请注意，它在其输入a中是分段线性的。 换言之，对于任何a，存在某个常量标量k，使得f(a)=k*a，其中k的值取决于输入a。 因此，我们可以用d/a验证梯度是否正确。<code>a.grad==d/a</code>结果为真。</p><h2 id="5-概率"><a href="#5-概率" class="headerlink" title="5. 概率"></a>5. 概率</h2><p>简单地说，机器学习就是做出预测。</p><p>根据病人的临床病史，我们可能想预测他们在下一年心脏病发作的<em>概率</em>。 在飞机喷气发动机的异常检测中，我们想要评估一组发动机读数为正常运行情况的概率有多大。 在强化学习中，我们希望智能体（agent）能在一个环境中智能地行动。 这意味着我们需要考虑在每种可行的行为下获得高奖励的概率。 当我们建立推荐系统时，我们也需要考虑概率。 例如，假设我们为一家大型在线书店工作，我们可能希望估计某些用户购买特定图书的概率。 为此，我们需要使用概率学。 概率是一种灵活的语言，用于说明我们的确定程度，并且它可以有效地应用于广泛的领域中。</p><h3 id="5-1-基本概率论"><a href="#5-1-基本概率论" class="headerlink" title="5.1. 基本概率论"></a>5.1. 基本概率论</h3><p>以掷骰子为例，想知道看到1的几率有多大，而不是看到另一个数字。 如果骰子是公平的，那么所有六个结果{1,…,6}都有相同的可能发生， 因此我们可以说1发生的概率为6分之1。</p><p>然而现实生活中，对于我们从工厂收到的真实骰子，我们需要检查它是否有瑕疵。 检查骰子的唯一方法是多次投掷并记录结果。 对于每个骰子，我们将观察到{1,…,6}中的一个值。 对于每个值，一种自然的方法是将它出现的次数除以投掷的总次数， 即此<em>事件</em>（event）概率的<em>估计值</em>。<em>大数定律</em>（law of large numbers）告诉我们： 随着投掷次数的增加，这个估计值会越来越接近真实的潜在概率。</p><p>在统计学中，我们把从概率分布中抽取样本的过程称为<em>抽样</em>（sampling）。 笼统来说，可以把<em>分布</em>（distribution）看作是对事件的概率分配， 稍后我们将给出的更正式定义。 将概率分配给一些离散选择的分布称为<em>多项分布</em>（multinomial distribution）。</p><p>在代码中multinomial.Multinomial函数创建由 total_count 和 probs 或 logits（但不是两者）参数化的多项分布。 probs（概率）的最内层维度索引种类，所有其他维度索引批次。total_count表示总的实验次数。如：<code>multinomial.Multinomial(10,fair_probs).sample()</code>表示在fair_probs的概率下进行了10次实验得到的分布情况。在此基础上除10即可得到真实概率的估计。</p><h4 id="5-1-1-概率论公理"><a href="#5-1-1-概率论公理" class="headerlink" title="5.1.1. 概率论公理"></a>5.1.1. 概率论公理</h4><p>在处理骰子掷出时，我们将集合S={1,2,3,4,5,6}称为<em>样本空间</em>（sample space）或<em>结果空间</em>（outcome space）， 其中每个元素都是<em>结果</em>（outcome）。<em>事件</em>（event）是一组给定样本空间的随机结果。 例如，“看到5”（{5}）和“看到奇数”（{1,3,5}）都是掷出骰子的有效事件。 注意，如果一个随机实验的结果在A中，则事件A已经发生。 也就是说，如果投掷出3点，因为3∈{1,3,5}，我们可以说，“看到奇数”的事件发生了。<em>概率</em>（probability）可以被认为是将集合映射到真实值的函数。</p><p>性质：</p><ul><li>概率非负</li><li>全样本空间概率为1</li><li>对于<em>互斥</em>（mutually exclusive）事件（对于所有i≠j都有Ai∩Aj=∅）的任意一个可数序列A1,A2,…，序列中任意一个事件发生的概率等于它们各自发生的概率之和。</li></ul><h4 id="5-1-2-随机变量"><a href="#5-1-2-随机变量" class="headerlink" title="5.1.2. 随机变量"></a>5.1.2. 随机变量</h4><p>在我们掷骰子的随机实验中，我们引入了<em>随机变量</em>（random variable）的概念。 随机变量几乎可以是任何数量，并且它可以在随机实验的一组可能性中取一个值。 考虑一个随机变量X，其值在掷骰子的样本空间S={1,2,3,4,5,6}中。 我们可以将事件“看到一个5”表示为{X=5}或X=5， 其概率表示为P({X=5})或P(X=5)。 通过P(X=a)，我们区分了随机变量X和X可以采取的值（例如a）。</p><p>然而，这可能会导致繁琐的表示。 为了简化符号，一方面，我们可以将P(X)表示为随机变量X上的<em>分布</em>（distribution）： 分布告诉我们X获得某一值的概率。 另一方面，我们可以简单用P(a)表示随机变量取值a的概率。 由于概率论中的事件是来自样本空间的一组结果，因此我们可以为随机变量指定值的可取范围。 例如，P(1≤X≤3)表示事件{1≤X≤3}， 即{X=1,2,or,3}的概率。 等价地，P(1≤X≤3)表示随机变量X从{1,2,3}中取值的概率。这一节主要讨论离散型随机变量，连续型不咋考虑。</p><h3 id="5-2-处理多个随机变量"><a href="#5-2-处理多个随机变量" class="headerlink" title="5.2. 处理多个随机变量"></a>5.2. 处理多个随机变量</h3><p>例如图像包含数百万像素，因此有数百万个随机变量。 在许多情况下，图像会附带一个<em>标签</em>（label），标识图像中的对象。 我们也可以将标签视为一个随机变量。 我们甚至可以将所有元数据视为随机变量，例如位置、时间、光圈、焦距、ISO、对焦距离和相机类型。 所有这些都是联合发生的随机变量。 当我们处理多个随机变量时，会有若干个变量是我们感兴趣的。</p><h4 id="5-2-1-一些基本概念"><a href="#5-2-1-一些基本概念" class="headerlink" title="5.2.1. 一些基本概念"></a>5.2.1. 一些基本概念</h4><p><strong>联合概率（joint probability）</strong>：联合概率可以回答：A=a和B=b同时满足的概率是多少的问题，但对于任何a和b的取值，P(A=a,B=b)≤P(A=a)。</p><p><strong>条件概率（conditional probability）</strong>：用P(B=b∣A=a)表示它，它是B=b的概率，前提是A=a已发生。</p><p><strong>贝叶斯定理（Bayes’ theorem）</strong>：根据<em>乘法法则</em>（multiplication rule）可得到P(A,B)=P(B∣A)P(A)。 根据对称性，可得到P(A,B)=P(A∣B)P(B)。根据两式假设P(B)&gt;0，求解其中一个条件变量，我们得到P(A∣B)=P(B∣A)P(A)\P(B).</p><p><strong>边际化（marginalization）</strong>：为了能进行事件概率求和，我们需要<em>加法法则</em>（sum rule）， 即B的概率相当于计算A的所有可能选择，并将所有选择的联合概率聚合在一起。这也称为<em>边际化</em>（marginalization）。边际化结果的概率或分布称为<em>边缘概率</em>（marginal probability） 或<em>边缘分布</em>（marginal distribution）。</p><p><strong>依赖（dependence）与独立（independence）</strong>：如果两个随机变量A和B是独立的，意味着事件A的发生跟B事件的发生无关。 在这种情况下，通常将这一点表述为A⊥B。 根据贝叶斯定理，得到P(A∣B)=P(A)。 在所有其他情况下，我们称A和B依赖。 比如，两次连续抛出一个骰子的事件是相互独立的。 相比之下，灯开关的位置和房间的亮度并不是（因为可能存在灯泡坏掉、电源故障，或者开关故障）。两个随机变量是独立的，当且仅当两个随机变量的联合分布是其各自分布的乘积。</p><p><strong>期望（expectation，或平均值（average））</strong>：均值。</p><p><strong>方差（variance）</strong>：数据与平均数之差平方和的平均数，方差的平方根被称为<em>标准差</em>（standared deviation）。随机变量函数的方差衡量的是：当从该随机变量分布中采样不同值x时， 函数值偏离该函数的期望的程度。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据操作及数学基础–《动手学深度学习》笔记0x02&quot;&gt;&lt;a href=&quot;#数据操作及数学基础–《动手学深度学习》笔记0x02&quot; class=&quot;headerlink&quot; title=&quot;数据操作及数学基础–《动手学深度学习》笔记0x02&quot;&gt;&lt;/a&gt;数据操作及数学基础–《动手学深度学习》笔记0x02&lt;/h1&gt;&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;这一笔记对应预备知识章节，包括数据操作、数据预处理、线性代数、微积分、概率论等。其中很多知识在学数一的时候都更深入理解过了，但是现在发现忘的差不多了，哎～&lt;/p&gt;
&lt;p&gt;对应实践：&lt;a href=&quot;https://github.com/silenceZheng66/deep_learning/blob/master/d2l/0x02.ipynb&quot;&gt;https://github.com/silenceZheng66/deep_learning/blob/master/d2l/0x02.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在M1芯片的设备上使用miniforge安装pytorch：&lt;code&gt;conda install -c pytorch pytorch&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>M1芯片VMfusion安装win11教程</title>
    <link href="http://silencezheng.top/2022/04/04/article33/"/>
    <id>http://silencezheng.top/2022/04/04/article33/</id>
    <published>2022-04-04T09:26:33.000Z</published>
    <updated>2022-04-04T09:32:34.875Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要准备的有：VMfusion预览版（支持ARM架构）、Win11ARM版镜像（.iso）</p><span id="more"></span><p>下面开始安装：</p><ol><li>打开VMfusion创建自定虚拟机，操作系统选择Other 64-bit Arm</li><li>下一步虚拟磁盘那块点继续，不用设置</li><li>然后一定要注意选择 <strong>自定设置</strong> ，否则虚拟机会自动启动，就无法安装了。</li><li>自定设置时，cpu推荐4核以上，内存4g以上，硬盘容量52g以上（保险起见，实际30g也够用了）</li><li>dvd设置我们下载的win11镜像后，在启动磁盘处选择dvd启动（不选应该也会默认这个）</li><li>找到该虚拟机的安装位置，查看包内容，编辑vmx文件，把guestOS改为arm-windows11-64</li><li>启动虚拟机，点击任意按键进入安装界面</li><li>选择没有产品密钥，一直进入到选择操作系统界面</li><li>下面需要绕过TPM，首先按住fn+shift+f10打开cmd，输入regedit打开注册表编辑器</li><li>进到HKEY_LOCAL_MACHINE-&gt;SYSTEM-&gt;Setup下，新建项LabConfig</li><li>在该项创建两个DWORD值，key分别为BypassTPMCheck和BypassSecureBootCheck，value都为1</li><li>然后都关闭掉继续进行安装，到网络设置界面发现无法继续，打开cmd准备跳过</li><li>输入taskmgr打开任务管理器，详细信息中找到OOBE开头的进程关闭掉，然后全部关闭返回发现跳过了网络设置步骤</li><li>下面成功进入桌面后，需要配置好网络才能正常使用（装来玩扫雷当我没说），管理员身份打开cmd</li><li>输入命令<code>bcdedit /debug on</code> 启用默认启动项的内核调试</li><li>再输入 <code>bcdedit /dbgsettings net hostip:10.0.0.1 port:55555</code> 将目标计算机配置为使用以太网连接进行调试，并指定主计算机的 IP 地址和主机可用于连接到目标计算机的端口号。</li><li>重启系统后即可连接网络，配置完毕。</li></ol><p>解读：<br>10.X.X.X是私有地址（私有地址是互联网上不使用，而用在局域网络中的地址）<br><code>netstat -ano     查看所有端口使用情况</code><br><code>netstat -aon|findstr &quot;55555&quot; 查看55555端口pid</code><br><code>tasklist|findstr &quot;9088&quot; 查看pid对应程序</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先需要准备的有：VMfusion预览版（支持ARM架构）、Win11ARM版镜像（.iso）&lt;/p&gt;</summary>
    
    
    
    
    <category term="MacOS" scheme="http://silencezheng.top/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>机器学习概述--《动手学深度学习》笔记0x01</title>
    <link href="http://silencezheng.top/2022/04/01/article32/"/>
    <id>http://silencezheng.top/2022/04/01/article32/</id>
    <published>2022-03-31T17:55:28.000Z</published>
    <updated>2022-03-31T17:55:53.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习概述–《动手学深度学习》笔记0x01"><a href="#机器学习概述–《动手学深度学习》笔记0x01" class="headerlink" title="机器学习概述–《动手学深度学习》笔记0x01"></a>机器学习概述–《动手学深度学习》笔记0x01</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>终于得以继续升学，可以做一些自己喜欢的事情了，早就想跟李沐老师学习一下深度学习，该系列为《动手学深度学习v2》的笔记，希望自己能在九月前完结。</p><span id="more"></span><h2 id="1-什么是机器学习？"><a href="#1-什么是机器学习？" class="headerlink" title="1. 什么是机器学习？"></a>1. 什么是机器学习？</h2><p>机器学习（machine learning，ML）是一类强大的可以从经验中学习的技术。 通常采用观测数据或与环境交互的形式，机器学习算法会积累更多的经验，其性能也会逐步提高。应用场景可以有以下方面：</p><ul><li>编写一个程序，给出地理信息、卫星图像和一些历史天气信息，来预测明天的天气。</li><li>编写一个程序，给出自然文本表示的问题，并正确回答该问题。</li><li>编写一个程序，给出一张图像，识别出图像所包含的人，并在每个人周围绘制轮廓。</li><li>编写一个程序，向用户推荐他们可能喜欢，但在自然浏览过程中不太可能遇到的产品。</li></ul><p>通过机器学习算法解决问题时，我们不需要设计一个“明确地”实现功能的系统。 相反，我们定义一个灵活的程序算法，其输出由许多参数（parameter）决定。 然后我们使用数据集（dataset）来确定当下的“最佳参数集”，这些参数通过某种性能度量来获取完成任务的最佳性能。</p><p>总而言之，可以将这种“通过用数据集来确定程序行为”的方法看作是“用数据编程”（programming with data）。 比如，我们可以通过向机器学习系统，提供许多猫和狗的图片来设计一个“猫图检测器”。 通过这种方式，检测器最终可以学会：如果输入是猫的图片就输出一个非常大的正数，如果输入是狗的图片就会得出一个非常大的负数。 如果检测器不确定，它会输出接近于零的数…… 这个例子仅仅是机器学习常见应用的冰山一角。</p><h3 id="1-1-参数、模型、学习？"><a href="#1-1-参数、模型、学习？" class="headerlink" title="1.1. 参数、模型、学习？"></a>1.1. 参数、模型、学习？</h3><p>我们可以把<strong>参数（parameter</strong>看作是旋钮，我们可以转动旋钮来调整程序的行为。 </p><p><strong>模型（model）</strong>：任一调整参数后的程序</p><p><strong>模型族</strong>：通过操作参数而生成的所有不同程序（输入-输出映射）的集合</p><p><strong>学习算法（learning algorithm）</strong>：使用数据集来选择参数的元程序</p><p>在我们开始用机器学习算法解决问题之前，我们必须精确地定义问题，确定输入（input）和输出（output）的性质，并选择合适的模型族。</p><p>在机器学习中，<strong>学习（learning）</strong>是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<strong>训练（train）</strong>我们的模型。</p><h3 id="1-2-训练？"><a href="#1-2-训练？" class="headerlink" title="1.2. 训练？"></a>1.2. 训练？</h3><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令你满意。</li></ol><h3 id="1-3-核心组件！"><a href="#1-3-核心组件！" class="headerlink" title="1.3. 核心组件！"></a>1.3. 核心组件！</h3><p>无论我们遇到什么类型的机器学习问题，这些组件都将伴随我们左右：</p><ol><li>我们可以学习的<strong>数据</strong>（data）。</li><li>如何转换数据的<strong>模型</strong>（model）。</li><li>一个<strong>目标函数</strong>（objective function），用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的算法（algorithm）。</li></ol><h4 id="1-3-1-数据"><a href="#1-3-1-数据" class="headerlink" title="1.3.1. 数据"></a>1.3.1. 数据</h4><p>数据集由一个个<strong>样本</strong>组成，样本的说法可以有example, sample，data point或者data instance。</p><p>通常每个样本由一组称为<strong>特征</strong>（features，或协变量（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 在之前的监督学习问题中，要预测的是一个特殊的属性，它被称为<strong>标签</strong>（label，或目标（target））。</p><p>假设我们处理的是图像数据，每一张单独的照片即为一个样本，它的特征由每个像素数值的有序列表表示。 比如，200✖️200彩色照片由200✖️200✖️3个数值组成，其中的“3”对应于每个空间位置的红、绿、蓝通道的强度。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的<strong>维数</strong>（dimensionality）。 固定长度的特征向量是一个方便的属性，它有助于我们量化学习大量样本。</p><p>然而很多数据不可以用固定长度的向量表示，如果强行规范为固定长度，则会造成信息丢失。与传统机器学习方法相比，深度学习的一个主要优势是可以处理不同长度的数据。同时，虽然数据量越大得到的模型越强大，但首先需要保证数据的正确性。</p><h4 id="1-3-2-模型"><a href="#1-3-2-模型" class="headerlink" title="1.3.2. 模型"></a>1.3.2. 模型</h4><p>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由<strong>神经网络</strong>错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习（deep learning）。</p><h4 id="1-3-3-目标函数就是损失函数？过拟合是什么？"><a href="#1-3-3-目标函数就是损失函数？过拟合是什么？" class="headerlink" title="1.3.3. 目标函数就是损失函数？过拟合是什么？"></a>1.3.3. 目标函数就是损失函数？过拟合是什么？</h4><p>机器学习是“从经验中学习”。 这里所说的“学习”，是指自主提高模型完成某些任务的效能。如何定义提高呢？ 在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，我们称之为<strong>目标函数</strong>（objective function）。</p><p>我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<strong>损失函数</strong>（loss function，或cost function）。</p><p>我们通常将可用数据集分成两部分：<strong>训练集</strong>用于<strong>拟合</strong>模型参数，<strong>测试集</strong>用于评估<strong>拟合</strong>的模型。 然后我们观察模型在这两部分数据集的效能。</p><p>当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是<strong>“过拟合”</strong>（overfitting）的。</p><h4 id="1-3-4-优化算法"><a href="#1-3-4-优化算法" class="headerlink" title="1.3.4. 优化算法"></a>1.3.4. 优化算法</h4><p>一旦我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，我们接下来就需要一种算法，它能够搜索出<strong>最佳参数，以最小化损失函数</strong>。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong>梯度下降（gradient descent）</strong>。 </p><p>简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p><h3 id="1-4-常见机器学习问题"><a href="#1-4-常见机器学习问题" class="headerlink" title="1.4. 常见机器学习问题"></a>1.4. 常见机器学习问题</h3><p>监督学习（supervised learning）、无监督学习、与环境互动、强化学习。</p><h4 id="1-4-1-监督学习"><a href="#1-4-1-监督学习" class="headerlink" title="1.4.1. 监督学习"></a>1.4.1. 监督学习</h4><p><strong>监督学习</strong>（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。</p><p> 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到<strong>标签</strong>，即预测。</p><p>在工业中，大部分机器学习的成功应用都是监督学习。 这是因为在一定程度上，许多重要的任务可以清晰地描述为：在给定一组特定的可用数据的情况下，估计未知事物的概率。监督学习发挥作用的前提是数据集正确、真实。</p><p>监督学习的学习过程：</p><ol><li>从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签。 有时，这些样本已有标签（例如，患者是否在下一年内康复？）； 有时，我们可能需要人工标记数据（例如，将图像分类）。 这些输入和相应的标签一起构成了训练数据集。 </li><li>选择有监督的学习算法，它将训练数据集作为输入，并输出一个“完成学习模型”。 </li><li>将之前没见过的样本特征放到这个“完成学习模型”中，使用模型的输出作为相应标签的预测。</li></ol><p>即使使用简单的描述“给定输入特征的预测标签”，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量。 例如，我们使用不同的模型来处理“任意长度的序列”或“固定长度的序列”。</p><h5 id="1-4-1-1-回归"><a href="#1-4-1-1-回归" class="headerlink" title="1.4.1.1. 回归"></a>1.4.1.1. 回归</h5><p><strong>回归（regression）</strong>是最简单的监督学习任务之一。当标签取任意数值时，我们称之为回归问题。 我们的目标是生成一个模型，它的预测非常接近实际标签值。总而言之，判断回归问题的一个很好的经验法则是，任何有关“多少”的问题很可能就是回归问题。</p><h5 id="1-4-1-2-分类"><a href="#1-4-1-2-分类" class="headerlink" title="1.4.1.2. 分类"></a>1.4.1.2. 分类</h5><p>回归模型可以很好解决“有多少”的问题，分类模型则关注“哪一个”的问题。 在<strong>分类问题（classification）</strong>中，我们希望模型能够预测样本属于哪个类别（category，正式称为类（class））。 例如，对于手写数字，我们可能有10类，分别数字0到9。</p><p>最简单的分类问题是只有两类，我们称之为“二元分类”。在回归中，我们训练一个回归函数来输出一个数值； 而在分类中，我们训练一个分类器，它的输出即为预测的类别。</p><p>给定一个样本特征，我们的模型为每个可能的类分配一个概率。 比如，之前的猫狗分类例子中，分类器可能会输出图像是猫的概率为0.9，即分类器90%确定图像描绘的是一只猫。 预测类别的概率的大小传达了一种模型的不确定性。</p><p>当我们有两个以上的类别时，我们把这个问题称为<strong>多元分类（multiclass classification）</strong>问题。与解决回归问题不同，分类问题的常见损失函数被称为<strong>交叉熵（cross-entropy）</strong>。</p><p>分类可能变得比二元分类、多元分类复杂得多。 例如，有一些分类任务的变体可以用于寻找层次结构，层次结构假定在许多类之间存在某种关系。 因此，并不是所有的错误都是均等的。 我们宁愿错误地分入一个相关的类别，也不愿错误地分入一个遥远的类别，这通常被称为<strong>层次分类(hierarchical classification)</strong>。</p><h5 id="1-4-1-3-标记问题"><a href="#1-4-1-3-标记问题" class="headerlink" title="1.4.1.3. 标记问题"></a>1.4.1.3. 标记问题</h5><p>有些分类问题很适合于二元分类或多元分类，例如判断图片中是猫或者狗或者猪。但有时候图片中有多种对象（多种动物），或者出现了分类器不认识的新物种，那么分类模型就不适用了，此时我们可能想让模型描绘输入图像的内容。</p><p>学习预测不相互排斥的类别的问题称为<strong>多标签分类（multi-label classification）</strong>。如在对文献进行标记时机器学习算法可以提供临时标签，直到每一篇文章都有严格的人工审核。</p><h5 id="1-4-1-4-搜索"><a href="#1-4-1-4-搜索" class="headerlink" title="1.4.1.4. 搜索"></a>1.4.1.4. 搜索</h5><p>有时，我们不仅仅希望输出为一个类别或一个实值。 在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，我们的目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。 搜索结果的排序也十分重要，我们的学习算法需要输出有序的元素子集。 即使结果集是相同的，集内的顺序有时却很重要。</p><p>该问题的一种可能的解决方案：首先为集合中的每个元素分配相应的相关性分数，然后检索评级最高的元素。谷歌搜索引擎背后最初的秘密武器就是这种评分系统的早期例子，但它的奇特之处在于它不依赖于实际的查询。如今，搜索引擎使用机器学习和用户行为模型来获取网页相关性得分，很多学术会议也致力于这一主题。</p><h5 id="1-4-1-5-推荐系统"><a href="#1-4-1-5-推荐系统" class="headerlink" title="1.4.1.5. 推荐系统"></a>1.4.1.5. 推荐系统</h5><p>另一类与搜索和排名相关的问题是<strong>推荐系统（recommender system）</strong>，它的目标是向特定用户进行“个性化”推荐。 例如，对于电影推荐，科幻迷和喜剧爱好者的推荐结果页面可能会有很大不同。 类似的应用也会出现在零售产品、音乐和新闻推荐等等。</p><p>总的来说，推荐系统会为“给定用户和物品”的匹配性打分，这个“分数”可能是估计的评级或购买的概率。 由此，对于任何给定的用户，推荐系统都可以检索得分最高的对象集，然后将其推荐给用户。以上只是简单的算法，而工业生产的推荐系统要先进得多，它会将详细的用户活动和项目特征考虑在内。 推荐系统算法经过调整，可以捕捉一个人的偏好。</p><p>尽管推荐系统具有巨大的应用价值，但单纯用它作为预测模型仍存在一些缺陷。 首先，我们的数据只包含“审查后的反馈”：用户更倾向于给他们感觉强烈的事物打分。 例如，在五分制电影评分中，会有许多五星级和一星级评分，但三星级却明显很少。 此外，推荐系统有可能形成反馈循环：推荐系统首先会优先推送一个购买量较大（可能被认为更好）的商品，然而目前用户的购买习惯往往是遵循推荐算法，但学习算法并不总是考虑到这一细节，进而更频繁地被推荐。 综上所述，关于如何处理审查、激励和反馈循环的许多问题，都是重要的开放性研究问题。</p><h5 id="1-4-1-6-序列学习"><a href="#1-4-1-6-序列学习" class="headerlink" title="1.4.1.6. 序列学习"></a>1.4.1.6. 序列学习</h5><p>以上大多数问题都具有固定大小的输入和产生固定大小的输出。在这些情况下，模型只会将输入作为生成输出的“原料”，而不会“记住”输入的具体内容。</p><p>但是如果输入是连续的，我们的模型可能就需要拥有“记忆”功能。 比如在处理视频时，每个视频片段可能由不同数量的帧组成。 通过前一帧的图像，我们可能对后一帧中发生的事情更有把握。 语言也是如此，机器翻译的输入和输出都为文字序列。</p><p>这些问题是<strong>序列学习</strong>的实例，是机器学习最令人兴奋的应用之一。 序列学习需要摄取输入序列或预测输出序列，或两者兼而有之。 具体来说，输入和输出都是可变长度的序列，例如机器翻译和从语音中转录文本。 虽然不可能考虑所有类型的序列转换，但以下特殊情况值得一提。</p><ol><li><em>标记和解析</em>。这涉及到用属性注释文本序列。 换句话说，输入和输出的数量基本上是相同的。 例如，我们可能想知道动词和主语在哪里，或者，我们可能想知道哪些单词是命名实体。</li><li><em>自动语音识别</em>。在语音识别中，输入序列是说话人的录音，输出序列是说话人所说内容的文本记录。 它的挑战在于，与文本相比，音频帧多得多（声音通常以8kHz或16kHz采样）。 也就是说，音频和文本之间没有1:1的对应关系，因为数千个样本可能对应于一个单独的单词。 这也是“序列到序列”的学习问题，其中输出比输入短得多。</li><li><em>文本到语音</em>。这与自动语音识别相反。 换句话说，输入是文本，输出是音频文件。 在这种情况下，输出比输入长得多。 虽然人类很容易识判断发音别扭的音频文件，但这对计算机来说并不是那么简单。</li><li><em>机器翻译</em>。 在语音识别中，输入和输出的出现顺序基本相同。 而在机器翻译中，颠倒输入和输出的顺序非常重要。 换句话说，虽然我们仍将一个序列转换成另一个序列，但是输入和输出的数量以及相应序列的顺序大都不会相同。</li></ol><p>其他学习任务也有序列学习的应用。 例如，确定“用户阅读网页的顺序”是二维布局分析问题。 再比如，对话问题对序列的学习更为复杂：确定下一轮对话，需要考虑对话历史状态以及现实世界的知识…… 如上这些都是热门的序列学习研究领域。</p><h4 id="1-4-2-无监督学习"><a href="#1-4-2-无监督学习" class="headerlink" title="1.4.2. 无监督学习"></a>1.4.2. 无监督学习</h4><p>监督学习，即我们向模型提供巨大数据集：每个样本包含特征和相应标签值。</p><p><strong>无监督学习（unsupervised learning）</strong>是一类数据中不含有“目标”的机器学习问题，即老板可能会给你一大堆数据，然后让你用它做一些数据科学研究，却没有对结果有要求。</p><p>无监督学习应用举例：</p><ol><li><strong>聚类（clustering）</strong>问题：没有<strong>标签</strong>的情况下，我们是否能给数据分类呢？比如，给定一组照片，我们能把它们分成风景照片、狗、婴儿、猫和山峰的照片吗？同样，给定一组用户的网页浏览记录，我们能否将具有相似行为的用户聚类呢？</li><li><strong>主成分分析（principal component analysis）</strong>问题：我们能否找到少量的参数来准确地捕捉数据的线性相关属性？比如，一个球的运动轨迹可以用球的速度、直径和质量来描述。再比如，裁缝们已经开发出了一小部分参数，这些参数相当准确地描述了人体的形状，以适应衣服的需要。</li><li><strong>因果关系（causality）</strong>和<strong>概率图模型（probabilistic graphical models）</strong>问题：我们能否描述观察到的许多数据的根本原因？例如，如果我们有关于房价、污染、犯罪、地理位置、教育和工资的人口统计数据，我们能否简单地根据经验数据发现它们之间的关系？</li><li><strong>生成对抗性网络（generative adversarial networks）</strong>：为我们提供一种合成数据的方法，甚至像图像和音频这样复杂的非结构化数据。潜在的统计机制是检查真实和虚假数据是否相同的测试，它是无监督学习的另一个重要而令人兴奋的领域。</li></ol><h4 id="1-4-3-与环境互动"><a href="#1-4-3-与环境互动" class="headerlink" title="1.4.3. 与环境互动"></a>1.4.3. 与环境互动</h4><p>到目前为止，不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。这里所有学习都是在算法与环境断开后进行的，被称为<strong>离线学习（offline learning）</strong>。这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。</p><p>人们可能会期望人工智能不仅能够做出预测，而且能够<strong>与真实环境互动</strong>。 与预测不同，“与真实环境互动”实际上会影响环境。 这里的人工智能是“智能代理”，而不仅是“预测模型”。 因此，我们必须考虑到它的行为可能会影响未来的观察结果。</p><p>考虑“与真实环境互动”将打开一整套新的建模问题。</p><ul><li>环境还记得我们以前做过什么吗？</li><li>环境是否有助于我们建模？例如，用户将文本读入语音识别器。</li><li>环境是否想要打败模型？例如，一个对抗性的设置，如垃圾邮件过滤或玩游戏？</li><li>环境是否重要？</li><li>环境是否变化？例如，未来的数据是否总是与过去相似，还是随着时间的推移会发生变化？是自然变化还是响应我们的自动化工具而发生变化？</li><li>etc…</li></ul><p>当训练和测试数据不同时，最后一个问题提出了<strong>分布偏移（distribution shift）</strong>的问题。 接下来的强化学习问题，是一类明确考虑与环境交互的问题。</p><h4 id="1-4-4-强化学习"><a href="#1-4-4-强化学习" class="headerlink" title="1.4.4. 强化学习"></a>1.4.4. 强化学习</h4><p><strong>强化学习（reinforcement learning）</strong>使用机器学习开发与环境交互并采取行动。 这可能包括应用到机器人、对话系统，甚至开发视频游戏的人工智能（AI）。</p><p> <strong>深度强化学习（deep reinforcement learning）</strong>将深度学习应用于强化学习的问题，是非常热门的研究领域。 突破性的深度Q网络（Q-network）在雅达利游戏中仅使用视觉输入就击败了人类， 以及 AlphaGo 程序在棋盘游戏围棋中击败了世界冠军，是两个突出强化学习的例子。</p><p>在强化学习问题中，<strong>agent</strong>在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些<strong>观察（observation）</strong>，并且必须选择一个<strong>动作（action）</strong>，然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得<strong>奖励（reward）</strong>。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。强化学习的目标是产生一个好的<strong>策略（policy）</strong>。强化学习agent选择的“动作”受策略控制，即一个从环境观察映射到行动的功能。</p><p>强化学习框架的通用性十分强大。 例如，我们可以将任何监督学习问题转化为强化学习问题。 假设我们有一个分类问题，我们可以创建一个强化学习agent，每个分类对应一个“动作”。 然后，我们可以创建一个环境，该环境给予agent的奖励。 这个奖励与原始监督学习问题的损失函数是一致的。</p><p>强化学习还可以解决许多监督学习无法解决的问题。 例如，在监督学习中，我们总是希望输入与正确的标签相关联。 但在强化学习中，我们并不假设环境告诉agent每个观测的最优动作。 一般来说，agent只是得到一些奖励。 此外，环境甚至可能不会告诉我们是哪些行为导致了奖励。</p><p>以强化学习在国际象棋的应用为例。 唯一真正的奖励信号出现在游戏结束时：当agent获胜时，agent可以得到奖励1；当agent失败时，agent将得到奖励-1。 因此，强化学习者必须处理<strong>学分分配（credit assignment）</strong>问题：决定哪些行为是值得奖励的，哪些行为是需要惩罚的。</p><p>强化学习可能还必须处理部分可观测性问题。 也就是说，当前的观察结果可能无法阐述有关当前状态的所有信息。 比方说，一个清洁机器人发现自己被困在一个许多相同的壁橱的房子里。 推断机器人的精确位置（从而推断其状态），需要在进入壁橱之前考虑它之前的观察结果。</p><p>最后，在任何时间点上，强化学习agent可能知道一个好的策略，但可能有许多更好的策略从未尝试过的。 强化学习agent必须不断地做出选择：是应该利用当前最好的策略，还是探索新的策略空间（放弃一些短期回报来换取知识）。</p><p>当环境可被完全观察到时，我们将强化学习问题称为<strong>马尔可夫决策过程（markov decision process）</strong>。 当状态不依赖于之前的操作时，我们称该问题为上<strong>下文赌博机（contextual bandit problem）</strong>。 当没有状态，只有一组最初未知回报的可用动作时，这个问题就是经典的<strong>多臂赌博机（multi-armed bandit problem）</strong>。</p><h3 id="1-5-深度学习近况"><a href="#1-5-深度学习近况" class="headerlink" title="1.5. 深度学习近况"></a>1.5. 深度学习近况</h3><p>随机存取存储器没有跟上数据增长的步伐，同时算力的增长速度已经超过了现有数据的增长速度。 这意味着统计模型需要提高内存效率（这通常是通过添加非线性来实现的），同时由于计算预算的增加，能够花费更多时间来优化这些参数。 因此，机器学习和统计的关注点从（广义的）线性模型和核方法转移到了深度神经网络。 这也造就了许多深度学习的中流砥柱，如<strong>多层感知机</strong> 、<strong>卷积神经网络</strong>  、<strong>长短期记忆网络</strong>和<strong>Q学习</strong>  ，在相对休眠了相当长一段时间之后，在过去十年中被“重新发现”。</p><p>最近十年，在统计模型、应用和算法方面的进展就像寒武纪大爆发——历史上物种飞速进化的时期。 事实上，最先进的技术不仅仅是将可用资源应用于几十年前的算法的结果。 下面列举了帮助研究人员在过去十年中取得巨大进步的想法（虽然只触及了皮毛）：</p><ul><li>新的容量控制方法，如dropout，有助于减轻过拟合的危险。这是通过在整个神经网络中应用<strong>噪声注入</strong>来实现的，出于训练目的，用随机变量来代替权重。</li><li><strong>注意力机制</strong>解决了困扰统计学一个多世纪的问题：如何在不增加可学习参数的情况下增加系统的记忆和复杂性。研究人员通过使用只能被视为可学习的指针结构找到了一个优雅的解决方案。不需要记住整个文本序列（例如用于固定维度表示中的机器翻译），所有需要存储的都是指向翻译过程的中间状态的指针。这大大提高了长序列的准确性，因为模型在开始生成新序列之前不再需要记住整个序列。</li><li>多阶段设计。例如，存储器网络和神经编程器-解释器 。它们允许统计建模者描述用于推理的迭代方法。这些工具允许重复修改深度神经网络的内部状态，从而执行推理链中的后续步骤，类似于处理器如何修改用于计算的存储器。</li><li>另一个关键的发展是<strong>生成对抗网络</strong> 的发明。传统模型中，密度估计和生成模型的统计方法侧重于找到合适的概率分布（通常是近似的）和抽样算法。因此，这些算法在很大程度上受到统计模型固有灵活性的限制。<strong>生成式对抗性网络</strong>的关键创新是用具有可微参数的任意算法代替采样器。然后对这些数据进行调整，使得鉴别器（实际上是一个双样本测试）不能区分假数据和真实数据。通过使用任意算法生成数据的能力，它为各种技术打开了密度估计的大门。</li><li>在许多情况下，单个GPU不足以处理可用于训练的大量数据。在过去的十年中，构建并行和分布式训练算法的能力有了显著提高。设计可伸缩算法的关键挑战之一是深度学习优化的主力——<strong>随机梯度下降</strong>，它依赖于相对较小的小批量数据来处理。同时，小批量限制了GPU的效率。因此，在1024个GPU上进行训练，例如每批32个图像的小批量大小相当于总计约32000个图像的小批量。</li><li>并行计算的能力也对强化学习的进步做出了相当关键的贡献。这导致了计算机在围棋、雅达里游戏、星际争霸和物理模拟（例如，使用MuJoCo）中实现超人性能的重大进步。简而言之，如果有大量的（状态、动作、奖励）三元组可用，即只要有可能尝试很多东西来了解它们之间的关系，强化学习就会发挥最好的作用。仿真提供了这样一条途径。</li><li><strong>深度学习框架</strong>在传播思想方面发挥了至关重要的作用。允许轻松建模的第一代框架包括Caffe、Torch和Theano。许多开创性的论文都是用这些工具写的。到目前为止，它们已经被TensorFlow（通常通过其高级API Keras使用）、CNTK、Caffe 2和Apache MXNet所取代。第三代工具，即用于深度学习的命令式工具，使用类似于Python NumPy的语法来描述模型。这个想法被PyTorch、MXNet的Gluon API和Jax都采纳了。</li></ul><p>“系统研究人员构建更好的工具”和“统计建模人员构建更好的神经网络”之间的分工大大简化了工作。 例如，在2014年，对于卡内基梅隆大学机器学习博士生来说，训练线性回归模型曾经是一个不容易的作业问题。 而现在，这项任务只需不到10行代码就能完成，这让每个程序员轻易掌握了它。</p><h3 id="1-6-小结"><a href="#1-6-小结" class="headerlink" title="1.6. 小结"></a>1.6. 小结</h3><p>中间还有成功案例和特点的部分，略微有些难懂，先行跳过，日后再来总结。</p><ul><li>机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段。</li><li>表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习。</li><li>深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程。</li><li>最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（通过GPU）算力的突破来触发的。</li><li>整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;机器学习概述–《动手学深度学习》笔记0x01&quot;&gt;&lt;a href=&quot;#机器学习概述–《动手学深度学习》笔记0x01&quot; class=&quot;headerlink&quot; title=&quot;机器学习概述–《动手学深度学习》笔记0x01&quot;&gt;&lt;/a&gt;机器学习概述–《动手学深度学习》笔记0x01&lt;/h1&gt;&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;终于得以继续升学，可以做一些自己喜欢的事情了，早就想跟李沐老师学习一下深度学习，该系列为《动手学深度学习v2》的笔记，希望自己能在九月前完结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Search7.x学习笔记</title>
    <link href="http://silencezheng.top/2022/02/13/article31/"/>
    <id>http://silencezheng.top/2022/02/13/article31/</id>
    <published>2022-02-13T07:41:30.000Z</published>
    <updated>2022-04-12T05:32:49.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Elastic-Search7-x学习笔记"><a href="#Elastic-Search7-x学习笔记" class="headerlink" title="Elastic Search7.x学习笔记"></a>Elastic Search7.x学习笔记</h1><ol><li>前言</li><li>入门</li><li>深入</li></ol><h2 id="1-前言："><a href="#1-前言：" class="headerlink" title="1. 前言："></a>1. 前言：</h2><p>先从官方入门视频、官方文档和一些入门博客入手学习。</p><span id="more"></span><p>推荐博客系列：</p><p><a href="https://www.cnblogs.com/qdhxhz/p/11448451.html">https://www.cnblogs.com/qdhxhz/p/11448451.html</a></p><h2 id="2-入门："><a href="#2-入门：" class="headerlink" title="2. 入门："></a>2. 入门：</h2><ul><li>如何下载／运行 Elasticsearch<ul><li>使用容器环境安装ES和Kibana</li><li>在Linux系统中配置ES集群</li></ul></li><li>Elasticsearch概念简析</li><li>通过REST API执行CRUD<ul><li>ES集群相关命令</li><li>索引CRUD命令</li><li>文档CRUD命令</li><li>举例</li></ul></li><li>关于查询<ul><li>Query查询</li><li>Filter查询</li><li>举例</li><li>复合查询</li></ul></li><li>聚合：Elasticsearch 的面向和分析的主功能<ul><li>聚合概念</li><li>Metric聚合</li><li>Bucket聚合</li></ul></li></ul><h3 id="2-1-如何下载／运行-Elasticsearch，及其先决条件"><a href="#2-1-如何下载／运行-Elasticsearch，及其先决条件" class="headerlink" title="2.1. 如何下载／运行 Elasticsearch，及其先决条件"></a>2.1. 如何下载／运行 Elasticsearch，及其先决条件</h3><p>可以通过直接下载或者包管理工具下载ES和Kibana到本地，也可以使用容器安装ELK。</p><h4 id="2-1-1-使用容器环境安装ES和Kibana"><a href="#2-1-1-使用容器环境安装ES和Kibana" class="headerlink" title="2.1.1. 使用容器环境安装ES和Kibana"></a>2.1.1. 使用容器环境安装ES和Kibana</h4><p>通过docker可以运行单节点ES，也可以运行ES集群（通过compose），这里先安装单节点ES和单节点Kibana组成集群。<br>使用容器环境安装ES：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a>  </p><ol><li>创建桥接网络elastic  <code>docker network create elastic</code></li><li>拉取es7镜像  <code>docker pull docker.elastic.co/elasticsearch/elasticsearch:7.17.0</code></li><li>创建容器es01-test，网络为elastic，镜像为es7 <code>docker run --name es01-test --net elastic -p 127.0.0.1:9200:9200 -p 127.0.0.1:9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.17.0</code>  <strong>注意： 9200 是供 http 访问端口，9300 是供 tcp 访问的端口，如果不做端口映射，浏览器就不能访问 elasticsearch 的服务。</strong></li><li>查看es <code>http://127.0.0.1:9200</code></li></ol><p>使用容器环境安装Kibana：<a href="https://www.elastic.co/guide/en/kibana/current/docker.html">https://www.elastic.co/guide/en/kibana/current/docker.html</a></p><ol><li>在新的终端，拉kibana镜像 <code>docker pull docker.elastic.co/kibana/kibana:7.17.0</code></li><li>跑容器kib01-test <code>docker run --name kib01-test --net elastic -p 127.0.0.1:5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot; docker.elastic.co/kibana/kibana:7.17.0</code></li><li>查看kibana <code>http://localhost:5601</code>   这里kibana是没有数据的，需要添加，可以添加一个示例数据，我这里添加web log。</li></ol><p>终止、移除容器：</p><pre><code>docker stop es01-testdocker stop kib01-testdocker network rm elasticdocker rm es01-testdocker rm kib01-test</code></pre><h4 id="2-1-2-在Linux系统上配置Elasticsearch集群"><a href="#2-1-2-在Linux系统上配置Elasticsearch集群" class="headerlink" title="2.1.2. 在Linux系统上配置Elasticsearch集群"></a>2.1.2. 在Linux系统上配置Elasticsearch集群</h4><p>集群基础配置：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/important-settings.html#path-settings">https://www.elastic.co/guide/en/elasticsearch/reference/7.17/important-settings.html#path-settings</a><br>在elasticsearch.yml中可以配置存储路径（不建议动），集群名称，节点名称，网络等等。<strong>以及重要生产环境配置：discovery和cluster formation</strong>，这两项配置能使集群中的节点发现彼此并选举出一个主节点（master node）。<br>cluster.name：设置集群名称<br>node.name：设置节点名称<br>network.host：设置网络地址，默认是<code>127.0.0.1和[::1]</code>，可以用于开发但是不能用于生产。修改这个IP会使ES从开发模式变成<strong>生产模式</strong>，ES启动检测会发生变化。</p><p><strong>discovery.seed**</strong>_hosts<strong>：默认情况下，没有进行网络配置时，ES会绑定本地IP并监听9300和9305端口，与所在主机上的其他ES节点构成集群。当想要进行集群配置时，该参数可以接受集群中所有符合主节点条件的节点地址构成的 YAML 序列或数组（以 - 开头）。每个地址可以是 IP 地址，也可以是能够通过 DNS 解析为一个或多个 IP 地址的主机名。总之该参数下的节点能够被选举为主节点。<br><strong>cluster.initial</strong></strong>_master<strong>**_nodes</strong>：当第一次启动 Elasticsearch 集群时， 集群引导步骤会确定在第一次选举中计票的符合主节点资格的节点集。在<strong>生产模式</strong>下启动新集群时，必须通过此设置明确列出应在第一次选举中计票的符合主节点选举条件的节点集。<strong>注意！在集群首次启动成功后需要在各节点删除此配置，不要在重启集群或向集群中加入新节点时使用该配置</strong> 该配置项只能使用节点名称（node name），以YAML数组形式列出。</p><h3 id="2-2-Elasticsearch概念简析"><a href="#2-2-Elasticsearch概念简析" class="headerlink" title="2.2. Elasticsearch概念简析"></a>2.2. Elasticsearch概念简析</h3><h4 id="2-2-1-Index"><a href="#2-2-1-Index" class="headerlink" title="2.2.1. Index"></a>2.2.1. Index</h4><p>索引index是文档doc的容器，是一类文档的集合。<br>作为名词，类比关系型数据库，索引相当于SQL中的一个Database。索引由其名称(必须为全小写字符)进行标识。<br>作为动词，含义为保存一个文档到索引的过程。这类似于SQL语句中的 INSERT关键词。如果该文档已存在时那就相当于数据库的UPDATE。<br>关系型数据库通过增加一个B+树索引到指定的列上，以便提升数据检索速度。索引ElasticSearch 使用了一个叫做<strong>倒排索引</strong>的结构来达到相同的目的。<strong>mapping</strong>就是index的结构，相当于关系型数据库中的库表结构</p><h4 id="2-2-2-Document、Doc"><a href="#2-2-2-Document、Doc" class="headerlink" title="2.2.2. Document、Doc"></a>2.2.2. Document、Doc</h4><p>Index 里面单条的记录称为Document（文档）。等同于关系型数据库表中的行。</p><ul><li>_index：文档所属索引名称。</li><li>_type：文档所属类型名。</li><li>_id：Doc的主键。在写入的时候，可以指定该Doc的ID值，如果不指定，则系统自动生成一个唯一的UUID值。</li><li>_version：文档的版本信息。Elasticsearch通过使用version来保证对文档的变更能以正确的顺序执行，避免乱序造成的数据丢失。</li><li>_seq_no：严格递增的顺序号，每个文档一个，Shard级别严格递增，保证后写入的Doc的_seq_no大于先写入的Doc的_seq_no。</li><li>_primary_term：_/primary_term也和_seq_no一样是一个整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，_primary_term会递增1</li><li>found：查询的ID正确那么ture, 如果 Id 不正确，就查不到数据，found字段就是false。</li><li>_source：文档的原始JSON数据。</li></ul><h4 id="2-2-3-Type（被淘汰）"><a href="#2-2-3-Type（被淘汰）" class="headerlink" title="2.2.3. Type（被淘汰）"></a>2.2.3. Type（被淘汰）</h4><p>在7.0开始，一个索引只能建一个Type为_doc</p><h4 id="2-2-4-Cluster"><a href="#2-2-4-Cluster" class="headerlink" title="2.2.4. Cluster"></a>2.2.4. Cluster</h4><p>ElasticSearch集群实际上是一个分布式系统，它需要具备两个特性：高可用性和可扩展性。</p><ol><li>允许有节点停止服务</li><li>部分节点丢失，不会丢失数据</li><li>随着请求量的不断提升，数据量的不断增长，系统可以将数据分布到其他节点，实现水平扩展</li></ol><p>集群健康值有绿黄红三种状态：</p><ul><li>Green：所有主要分片和复制分片都可用</li><li>Yellow：所有主要分片可用，但不是所有复制分片都可用</li><li>Red：不是所有的主要分片都可用。当集群状态为red，它仍然正常提供服务，它会在现有存活分片中执行请求，我们需要尽快修复故障分片，防止查询数据的丢失。</li></ul><p>集群引导（Bootstrapping）是指首次启动 Elasticsearch集群需要在集群中的一个或多个符合主节点的节点上明确定义初始的主节点集。<br>从技术上讲，在集群中设置一个符合主节点资格的节点就足够cluster.initial_master_nodes了，并且只在设置值中提及该单个节点，但这在集群完全形成之前没有提供容错能力。<br>因此，最好使用至少三个符合主节点资格的节点进行引导，每个节点的cluster.initial_master_nodes设置都包含所有三个节点。</p><h4 id="2-2-5-Node"><a href="#2-2-5-Node" class="headerlink" title="2.2.5. Node"></a>2.2.5. Node</h4><p>节点是一个ElasticSearch的实例，其本质就是一个Java进程。一台机器上可以运行多个ElasticSearch实例，但是建议在生产环境中一台机器上只运行一个ElasticSearch实例。Node是组成集群的一个单独的服务器，用于存储数据并提供集群的搜索和索引功能。<br>与集群一样，节点也有一个唯一名字，默认在节点启动时会生成一个uuid作为节点名，该名字也可以手动指定。<br>单个集群可以由任意数量的节点组成。如果只启动了一个节点，则会形成一个单节点的集群。</p><h4 id="2-2-6-分片（Shard）"><a href="#2-2-6-分片（Shard）" class="headerlink" title="2.2.6. 分片（Shard）"></a>2.2.6. 分片（Shard）</h4><p>Primary Shard(主分片）</p><ul><li>ES中的shard用来解决节点的容量上限问题，通过主分片，可以将数据分布到集群内的所有节点之上。</li><li>一个节点对应一个ES实例</li><li>一个节点可以有多个index（索引）</li><li>一个index可以有多个shard（分片）</li><li>一个分片是一个lucene index（此处的index是lucene自己的概念，与ES的index不是一回事）</li><li>主分片数是在索引创建时指定，后续不允许修改，除非Reindex</li><li>一个索引中的数据保存在多个分片中(默认为一个)，相当于水平分表。一个分片便是一个Lucene 的实例，它本身就是一个完整的搜索引擎。我们的文档被存储和索引到分片内，但是应用程序是直接与索引而不是与分片进行交互。</li></ul><p>Replica Shard（副本）</p><ul><li>服务高可用：由于数据只有一份,如果一个node挂了,那存在上面的数据就都丢了,有了replicas,只要不是存储这条数据的node全挂了,数据就不会丢。因此分片副本不会与主分片分配到同一个节点</li><li>扩展性能：通过在所有replicas上并行搜索提高搜索性能.由于replicas上的数据是近实时的(near realtime),因此所有replicas都能提供搜索功能,通过设置合理的replicas数量可以极高的提高搜索吞吐量</li></ul><p>分片设定</p><ul><li>对于生产环境中分片的设定，需要提前做好容量规划，因为主分片数是在索引创建时预先设定的，后续无法修改。</li><li>分片数过小会导致后续无法增加节点进行水平扩展、导致分片的数据量太大，数据在重新分配时耗时</li><li>分片数过大会影响搜索结果的相关性打分，影响统计结果的准确性、单个节点上过多的分片，会导致资源浪费，同时也会影响性能；</li></ul><h4 id="2-2-7-倒排索引"><a href="#2-2-7-倒排索引" class="headerlink" title="2.2.7. 倒排索引"></a>2.2.7. 倒排索引</h4><p>ES的搜索功能是基于lucene,而lucene搜索的基本原理就是倒叙索引,倒序排序的结果跟分词的类型有关。<br>假设我们搜索谷歌地图之父,搜索流程会是这样分词,分词插件将句子分为3个term 谷歌,地图,之父，然后将这3个term拿到倒叙索引中去查找(会很高效,比如二分查找),如果匹配到了就拿对应的文档id,获得文档内容。<br>TF、IDF在结果排序中起到了作用。</p><h3 id="2-3-通过REST-API执行CRUD"><a href="#2-3-通过REST-API执行CRUD" class="headerlink" title="2.3. 通过REST API执行CRUD"></a>2.3. 通过REST API执行CRUD</h3><h4 id="2-3-1-ES集群相关命令"><a href="#2-3-1-ES集群相关命令" class="headerlink" title="2.3.1. ES集群相关命令"></a>2.3.1. ES集群相关命令</h4><p>_cat系列提供了一系列查询Elasticsearch集群状态的接口</p><ul><li>_cat/shards          #查看各shard的详细情况</li><li>_cat/nodes           #查看所有节点信息</li><li>_cat/count           #查看当前集群的doc数量</li><li>_cat/allocation      #查看单节点的shard分配整体情况</li><li>_cat/health          #查看集群当前状态：红、黄、绿</li><li>…etc</li><li>每个命令都支持使用?v参数，让输出内容表格显示表头; pretty则让输出缩进更规范。 如<code>GET _cat/health?v</code></li><li>？pretty参数可以使输出更美观<h4 id="2-3-2-索引CRUD命令"><a href="#2-3-2-索引CRUD命令" class="headerlink" title="2.3.2. 索引CRUD命令"></a>2.3.2. 索引CRUD命令</h4>查询索引举例<br>_cat/indices         #查看集群中所有index的详细信息<br>_cat/indices/{index} #查看集群中指定index的详细信息<br>_cat/segments        #查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘<br>_cat/segments/{index}#查看指定index的segment详细信息<br>_cat/indices?v&amp;health=yellow   #查询健康状态为yellow的索引<br>_cat/indices?v&amp;health=yellow&amp;s=docs.count:desc #根据文档数量进行索引排序</li></ul><p>创建索引举例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PUT student</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;:&#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>:<span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;mappings&quot;:&#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">        &quot;sid&quot;:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">        &quot;<span class="selector-tag">address</span>&quot;:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>&#125;,</span><br><span class="line">        &quot;age&quot;:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">        &quot;interests&quot;:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">        &quot;birthday&quot;:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;date&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>查看创建结果<code>GET /_cat/indices/student?v</code></p><p>更新索引<br>使用PUT也可以更新索引</p><p>删除索引<br><code>curl -X DELETE &quot;localhost:9200/index-name&quot;</code></p><h4 id="2-3-3-文档CRUD命令"><a href="#2-3-3-文档CRUD命令" class="headerlink" title="2.3.3. 文档CRUD命令"></a>2.3.3. 文档CRUD命令</h4><p>POST /uri用于创建，DELETE /uri/xxx用于删除，PUT /uri/xxx用于更新或创建，GET /uri/xxx用于查询。<br>POST与PUT的区别:</p><ol><li>在ES中,如果不确定文档的ID，那么就需要用POST，它可以自己生成唯一的文档ID。如果确定文档的ID，那么就可以用PUT，当然也可以用POST，它们都可以创建或修改文档（如果是修改，那么_version版本号提高1）</li><li>PUT、GET、DELETE是幂等的，而POST并不一定是幂等。如果你对POST也指定了文档ID,那它其实和PUT没啥区别，那它就是幂等。如果你没有指定文档ID那么就不是幂等操作了，因为同一数据，你执行多次POST，那么生成多个UUID的文档，也就是每POST一次都会新增一条数据</li></ol><p>创建文档：<br>PUT方式：<code>PUT  /student/_doc/1 &#123;&quot;name&quot;: &quot;xxx&quot;,&quot;country&quot;: &quot;tj&quot;,&quot;age&quot;: &quot;3&quot;,&quot;date&quot;: &quot;2019-09-04&quot;&#125;</code><br>POST方式：<code>POST  /student/_doc &#123;&quot;name&quot;: &quot;xxx&quot;,&quot;country&quot;: &quot;tj&quot;,&quot;age&quot;: &quot;3&quot;,&quot;date&quot;: &quot;2019-09-04&quot;&#125;</code><br>    - POST也可以指定文档ID,如果指定文档ID,那么就和PUT没有区别。ID不存在则创建，存在则更新并且_version版本+1.<br>    - 批量插入：通过_bulk接口，先声明所属index（一个json），而后跟n条数据（n个json）<br>查看文档：<code>GET  /student/_doc/1</code><br>更新文档：<br>PUT和POST执行的时候，如果指定的文档ID存在，那么就可以执行更新操作。不过它们执行的是全量更新，如果需要单独对某字段更新我们可以使用关键字_update。如<code>POST /student/_update/1 &#123;&quot;doc&quot; : &#123;&quot;age&quot;: 5&#125;&#125;</code><br>还可以通过<code>POST student/_update_by_query</code>api进行更新操作，也就是通过query进行更新<br>删除文档：<code>DELETE /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</code></p><h4 id="举点例子，实践一下上面的概念"><a href="#举点例子，实践一下上面的概念" class="headerlink" title="举点例子，实践一下上面的概念"></a>举点例子，实践一下上面的概念</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">查看es页面的接口信息：</span><br><span class="line">GET / </span><br><span class="line"></span><br><span class="line">查看集群文档数量：</span><br><span class="line">GET <span class="regexp">/_cat/</span><span class="keyword">count</span>?v</span><br><span class="line"></span><br><span class="line">查看集群中所有index的详细信息</span><br><span class="line">GET <span class="regexp">/_cat/i</span>ndices</span><br><span class="line"></span><br><span class="line">创建索引：</span><br><span class="line">PUT student</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>:<span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;sid&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;interests&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;birthday&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;date&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line">如果不创建索引直接插入数据，则会发生动态mapping</span><br><span class="line"></span><br><span class="line">删除索引：</span><br><span class="line"><span class="keyword">DELETE</span> student  </span><br><span class="line">      </span><br><span class="line">添加数据：</span><br><span class="line">POST student<span class="regexp">/_doc/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sid&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="string">&quot;interests&quot;</span>:<span class="string">&quot;摄影 旅游&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1990-06-19&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">查询数据：</span><br><span class="line">GET student<span class="regexp">/_doc/</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">更新数据：</span><br><span class="line">PUT student<span class="regexp">/_doc/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sid&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>:<span class="string">&quot;天津&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="number">32</span>,</span><br><span class="line">  <span class="string">&quot;interests&quot;</span>:<span class="string">&quot;摄影 打游戏&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1990-06-19&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除数据：</span><br><span class="line"><span class="keyword">DELETE</span> student<span class="regexp">/_doc/</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">批量添加数据：</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李明&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">1</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">32</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;摄影 打游戏&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1990-06-19&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;王一&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">2</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">27</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;旅游 画画&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1995-07-19&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李二&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">3</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">22</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;读书 打游戏&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2000-08-19&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">4</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;上海&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">42</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;滑雪 打篮球&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1980-09-19&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;刘墉&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">5</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;香港&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">17</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;摄影 打游戏 购物&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2005-06-30&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;student&quot;</span>&#125;&#125;</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;令狐冲&quot;</span>,<span class="string">&quot;sid&quot;</span>:<span class="number">6</span>,<span class="string">&quot;address&quot;</span>:<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;interests&quot;</span>:<span class="string">&quot;写代码 打游戏&quot;</span>,<span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;1999-06-25&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">查询全部：</span><br><span class="line">GET student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除全部doc：</span><br><span class="line">POST student/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-关于查询"><a href="#2-4-关于查询" class="headerlink" title="2.4. 关于查询"></a>2.4. 关于查询</h3><p>简单查询：就是按照文档_id，通过ES的RESTFUL API 的GET请求来进行文档查询<br>条件查询：</p><ul><li>条件查询请求的协议方法是POST方法(为什么使用get也可以查询)</li><li>条件查询需要使用_search关键字</li><li>条件查询需要在请求体内将条件写在一个json体内，如下面的query和filter<br>聚合查询：aggs是聚合查询的关键词<br>对mapping中的字段type，text表示可以进行全文搜索、进行分词的字段，keyword表示用于聚合查询、统计分析的字段，同一个字段可同时支持这两种type</li></ul><h4 id="2-4-1-Query查询"><a href="#2-4-1-Query查询" class="headerlink" title="2.4.1. Query查询"></a>2.4.1. Query查询</h4><p>Query context(查询上下文)这种语句在执行时既要计算文档是否匹配，还要计算文档相对于其他文档的匹配度有多高，匹配度越高，_score 分数就越高</p><ul><li>match查询<ul><li>match query: 知道分词器的存在，会对filed进行分词操作，然后再查询</li><li>match_all: 查询所有文档</li><li>multi_match: 可以指定多个字段</li><li>match_phrase: 短语匹配查询，ElasticSearch引擎首先分析（analyze）查询字符串，从分析后的文本中构建短语查询，这意味着必须匹配短语中的所有分词，并且保证各个分词的相对位置不变</li><li>文档字段属性如果是一个keyword类型，那就需要完全匹配才能命中。好比这个字段值是12345，那么你不论是1234还是123456都不会命中。</li><li>如果是match_phrase,那就是真正的包含关系。好比这个字段值是12345，那么你是1234就会命中，而123456不会命中。因为12345包含1234而不包含123456。</li></ul></li><li>term查询和terms查询<ul><li>term query: 会去倒排索引中寻找确切的term，它并不知道分词器的存在。这种查询适合keyword 、numeric、date</li><li>term:查询某个字段为该关键词的文档（它是相等关系而不是包含关系）</li><li>terms:查询某个字段里含有多个关键词的文档</li></ul></li><li>范围查询<ul><li>range: 实现范围查询</li><li>from, to：指定范围，如年龄、日期等</li><li>include_lower: 是否包含范围的左边界，默认是true</li><li>include_upper: 是否包含范围的右边界，默认是true</li></ul></li><li>wildcard查询<ul><li>允许使用通配符* 和?来进行查询, *代表0个或多个字符, ? 代表任意一个字符</li><li>如<code>&quot;name&quot;: &quot;徐*&quot;  &quot;name&quot;: &quot;徐小?&quot;</code></li><li>中文数据在使用通配符时可能有bug</li></ul></li><li>控制查询返回的数量和位置，通过from，size</li><li>通过_source指定返回的字段，或也可以控制显示要的字段和去除不需要的字段，此时可使用通配符*</li><li>通过sort:[{}]进行排序，如其中可填入<code>&quot;age&quot;:&#123;&quot;order&quot;: &quot;desc&quot;&#125;</code></li><li>fuzzy实现模糊查询，模糊查询可以在Match和 Multi-Match查询中使用以便解决拼写的错误，模糊度是基于Levenshteindistance计算与原单词的距离</li><li>highlight高亮搜索结果</li></ul><h4 id="2-4-2-Filter查询"><a href="#2-4-2-Filter查询" class="headerlink" title="2.4.2. Filter查询"></a>2.4.2. Filter查询</h4><ul><li>Filter context(过滤上下文)过滤上下文中的语句在执行时只关心文档是否和查询匹配，不会计算匹配度，也就是得分（score）</li><li>filter是不计算相关性的，同时可以cache。因此，filter速度要快于query</li><li>将上面的query替换为post_filter</li></ul><h4 id="2-4-3-复合查询"><a href="#2-4-3-复合查询" class="headerlink" title="2.4.3. 复合查询"></a>2.4.3. 复合查询</h4><h5 id="2-4-3-1-布尔查询bool-query"><a href="#2-4-3-1-布尔查询bool-query" class="headerlink" title="2.4.3.1. 布尔查询bool query"></a>2.4.3.1. 布尔查询bool query</h5><p>概念、特点:</p><ul><li>通过布尔逻辑将较小的查询组合成较大的查询</li><li>子查询可以任意顺序出现</li><li>可以嵌套多个查询，包括bool查询</li><li>如果bool查询中没有must条件，should中必须至少满足一条才会返回结果<br>操作符:</li><li>must：必须出现在匹配文档中 ，贡献算分</li><li>must_not：必须不能出现在匹配文档中，但不贡献算分 </li><li>should：选择性匹配，至少满足一条，贡献算分</li><li>filter：过滤子句，必须出现在匹配文档中，但不贡献算分</li></ul><h5 id="2-4-3-2-提高查询boosting-query"><a href="#2-4-3-2-提高查询boosting-query" class="headerlink" title="2.4.3.2. 提高查询boosting query"></a>2.4.3.2. 提高查询boosting query</h5><p>在bool复合查询我们可以通过 must_not+must 先剔除不想匹配的文档，再获取匹配的文档，但是有一种场景就是我并不需要完全剔除，而是把需要剔除的那部分文档的分数降低。这个时候就可以使用boosting query<br>boosting需要搭配三个关键字：positive , negative , negative_boost</p><ul><li>只有匹配了 positive查询 的文档才会被包含到结果集中</li><li>但是在匹配了 positive 的同时匹配了negative查询 的文档会被降低相关度并也包含在结果中，通过将文档原本的_score和negative_boost参数进行相乘来得到新的_score</li><li>所以negative_boost参数一般小于1.0，这样才能降低得分，如该参数等于0.5时匹配 negative 时会降低一半得分<br>应用场景:<br>例如搜索“苹果公司”相关信息，查询中用于匹配的信息为“苹果”。那么我们查询的条件是：must = ‘苹果’。但如果你的文档是 ‘苹果树’,’苹果水果’，那么此时如果匹配到其实没有任何意义。那么我们修改查询条件为：must = ‘苹果’ AND must_not = ‘树 or 水果’ 因为我们要查的苹果公司相关信息，如果你是苹果树那对我来讲确实是不匹配，所以直接过滤掉。但直接过滤会过于粗暴，因为一个文档中包含’苹果’和’树’那不代表一定是苹果树，而可能是 ‘苹果公司组织员工一起去种树’ 那么这条文档理应出现，此时产生了 boosting 应用的场景</li></ul><h5 id="2-4-3-3-固定分数查询constant-score"><a href="#2-4-3-3-固定分数查询constant-score" class="headerlink" title="2.4.3.3. 固定分数查询constant_score"></a>2.4.3.3. 固定分数查询constant_score</h5><p>常量分值查询，目的就是返回指定的score，一般都结合filter使用，因为filter context忽略score<br>例如 constant_score 中先加入一个filter，后跟<strong>boost参数</strong>，此时所有结果文档的score都会变为boost参数指定的值</p><h5 id="2-4-3-4-最佳匹配查询dis-max"><a href="#2-4-3-4-最佳匹配查询dis-max" class="headerlink" title="2.4.3.4.最佳匹配查询dis_max"></a>2.4.3.4.最佳匹配查询dis_max</h5><p>如果在查询中有多个匹配条件，则结果的得分只是取分数最高的那个query的分数<br>可以通过指定 <strong>tie**</strong>_breaker** 这个参数将其他匹配语句的评分也考虑其中，但最佳匹配语句依然占最终结果里的很大一部分<br>tie_breaker 参数提供了一种 dis_max 和 bool 之间的折中选择，它的评分方式如下：</p><ul><li>获得最佳匹配语句的评分 _score</li><li>将其他匹配语句的评分结果与 tie_breaker 相乘</li><li>对以上评分求和并规范化<br>tie_breaker 可以是 0 到 1 之间的浮点数，其中 0 代表使用 dis_max 最佳匹配语句的普通逻辑， 1 表示所有匹配语句同等重要。最佳的精确值需要根据数据与查询调试得出，但是合理值应该与零接近（处于 0.1 - 0.4 之间），这样就不会颠覆 dis_max 最佳匹配性质的根本</li></ul><h5 id="2-4-3-5-函数查询function-score-（简单介绍）"><a href="#2-4-3-5-函数查询function-score-（简单介绍）" class="headerlink" title="2.4.3.5. 函数查询function_score （简单介绍）"></a>2.4.3.5. 函数查询function_score （简单介绍）</h5><p>概念：</p><ul><li>function_score是处理分值计算过程的终极工具，它让你能够对所有匹配了主查询的每份文档调用一个函数来调整甚至是完全替换原来的_score</li><li>要使用function_score，用户必须定义一个查询和一个或多个函数，这些函数计算查询返回的每个文档的新分数<br>一些预定义的函数：</li><li>weight: 对每份文档适用一个简单的提升，且该提升不会被归约，例如当weight为2时，结果为2 * _score</li><li>field_value_factor: 使用文档中某个字段的值来改变_score，比如将受欢迎程度或者投票数量考虑在内</li><li>random_score: 使用一致性随机分值计算来对每个用户采用不同的结果排序方式，对相同用户仍然使用相同的排序方式</li><li>衰减函数Decay Function<ul><li>linear，exp，gauss等</li></ul></li><li>script_score: 使用自定义的脚本来完全控制分值计算逻辑。如果你需要以上预定义函数之外的功能，可以根据需要通过脚本进行实现。<br>使用场景举例：</li><li>假设有一个资讯类APP，我们希望让人阅读量高的文章出现在结果列表的头部，但是主要的排序依据仍然是全文搜索分值</li><li>当用户搜索酒店，它的要求是 1、离他目前位置1Km内 2、价格在500元内。如果我们只是使用一个 filter 排除所有市中心方圆 1KM以外的酒店，再用一个filter排除每晚价格超过500元的酒店，这种作法太过强硬，可能有一间房在2K米，但是超级便宜一晚只要100元，用户可能会因此愿意妥协住这间房。<br>官方文档： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html</a></li></ul><h4 id="举点Query和Filter的例子，数据接用上个例子中的。"><a href="#举点Query和Filter的例子，数据接用上个例子中的。" class="headerlink" title="举点Query和Filter的例子，数据接用上个例子中的。"></a>举点Query和Filter的例子，数据接用上个例子中的。</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">查询兴趣里包含<span class="string">&#x27;旅游&#x27;</span>的：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;interests&quot;</span>: <span class="string">&quot;旅游&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里只要interests包含<span class="string">&#x27;旅游&#x27;</span>,<span class="string">&#x27;旅&#x27;</span>,<span class="string">&#x27;游&#x27;</span>的都会命中</span><br><span class="line"></span><br><span class="line">查询name和address包含<span class="string">&#x27;北&#x27;</span>：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;query&quot;</span>: <span class="string">&quot;北&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fields&quot;</span>:[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;address&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">我们索引结构中，address属性是一个keyword类型，它是需要完全匹配，而不是包含的关系，所以只有当query北京时才能被查到</span><br><span class="line"></span><br><span class="line">查询兴趣里包含<span class="string">&#x27;摄影&#x27;</span>的：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match_phrase&quot;</span>:&#123;<span class="string">&quot;interests&quot;</span>: <span class="string">&quot;摄影&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里和match的区别是这里是真正包含<span class="string">&#x27;摄影&#x27;</span>，而不是只要满足其中一个字就会被模糊命中</span><br><span class="line"></span><br><span class="line">terms查询地址等于<span class="string">&quot;香港&quot;</span>或<span class="string">&quot;北京&quot;</span>的：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;address&quot;</span>:[<span class="string">&quot;香港&quot;</span>,<span class="string">&quot;北京&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">如果仅检索<span class="string">&#x27;香&#x27;</span>或<span class="string">&#x27;北&#x27;</span>那是无法命中的，因为keyword需要完全匹配才能命中，如果查询一个地址则使用term</span><br><span class="line"></span><br><span class="line">按成绩排序：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:[&#123;</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:&#123;<span class="string">&quot;order&quot;</span>: <span class="string">&quot;desc&quot;</span>&#125;</span><br><span class="line">      &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">范围查询：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;birthday&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;from&quot;</span>: <span class="string">&quot;1950-01-11&quot;</span>,</span><br><span class="line">                <span class="string">&quot;to&quot;</span>: <span class="string">&quot;2000-01-11&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;include_lower&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;include_upper&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通配符查询：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;wildcard&quot;</span>: &#123;</span><br><span class="line">             <span class="string">&quot;name&quot;</span>: <span class="string">&quot;李*&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">？符号中文似乎无法使用</span><br><span class="line"></span><br><span class="line">Filter查询age为23或32的：</span><br><span class="line"><span class="builtin-name">GET</span> student/_search</span><br><span class="line">&#123; </span><br><span class="line">  <span class="string">&quot;post_filter&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;terms&quot;</span>:&#123;<span class="string">&quot;age&quot;</span>:[32,23]&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-聚合：Elasticsearch-的面向和分析的主功能"><a href="#2-5-聚合：Elasticsearch-的面向和分析的主功能" class="headerlink" title="2.5.  聚合：Elasticsearch 的面向和分析的主功能"></a>2.5.  聚合：Elasticsearch 的面向和分析的主功能</h3><p>在Mysql中，我们可以获取一组数据的 最大值(Max)、最小值(Min)。同样我们能够对这组数据进行 分组(Group)。那么对于Elasticsearch中我们也可以实现同样的功能。<br><strong>官方对聚合有四个关键字: Metric(指标）、Bucketing(桶）、Matrix(矩阵）、Pipeline(管道</strong><br>聚合是Elasticsearch除全文检索功能外提供的针对Elasticsearch数据做统计分析的功能。它的实时性高,所有的计算结果都是即时返回。</p><ul><li>Metric(指标):   指标分析类型，如计算最大值、最小值、平均值等等 （对桶内的文档进行聚合分析的操作）</li><li>Bucket(桶):     分桶类型，类似SQL中的GROUP BY语法 （满足特定条件的文档的集合）</li><li>Pipeline(管道): 管道分析类型，基于上一级的聚合分析结果进行再分析</li><li>Matrix(矩阵):   矩阵分析类型（聚合是一种面向数值型的聚合，用于计算一组文档字段中的统计信息）</li><li>在查询请求体中以aggregations节点按规定语法定义聚合分析，可简写为aggs，如<code>&#123;&quot;aggs&quot; : &#123;&quot;&lt;aggregation_name&gt;&quot; :&#123;&quot;&lt;aggregation_type&gt;&quot; : &#123;&lt;aggregation_body&gt; &#125; &#125; &#125; &#125;</code> </li></ul><h4 id="2-5-1-Metric聚合"><a href="#2-5-1-Metric聚合" class="headerlink" title="2.5.1. Metric聚合"></a>2.5.1. Metric聚合</h4><p>官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html</a><br>简介：<br>桶(Bucket)能让我们划分文档到有意义的集合，但是最终我们需要的是对这些桶内的文档进行一些<strong>指标</strong>的计算。分桶是一种达到目的地的手段：它提供了一种给文档分组的方法来让我们可以计算感兴趣的指标。<br>大多数指标是简单的数学运算（如：最小值、平均值、最大值、汇总），这些是通过文档的值来计算的。<br>Metric聚合分析分为单值分析和多值分析两类</p><ul><li>单值分析：只输出一个分析结果，如min、max、avg、sum…</li><li>多值分析：输出多个分析结果，如stats、percentile、extended_stats、percentile_rank…<br>1、Avg（均值）<br>计算从聚合文档中提取的数值的平均数<br>如：<code>&#123;&quot;aggs&quot; : &#123;&quot;avg_grade&quot; : &#123; &quot;avg&quot; : &#123; &quot;field&quot; : &quot;grade&quot; &#125; &#125;&#125;&#125;</code><br>2、Max&amp;Min<br>计算从聚合文档中提取的数值的最值<br>如： <code>&quot;max_price&quot; : &#123; &quot;max&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125;</code><br>3、Sum（总和）<br>计算从聚合文档中提取的数值的总和<br>如： <code>&quot;hat_prices&quot; : &#123; &quot;sum&quot; : &#123; &quot;field&quot; : &quot;price&quot; &#125; &#125;</code><br>4、Cardinality(唯一值)<br>cardinality 求唯一值，即不重复的字段有多少（相当于mysql中的distinct）<br>如： <code>&quot;type_count&quot; : &#123;&quot;cardinality&quot; : &#123;&quot;field&quot; : &quot;type&quot;&#125; &#125;</code><br>5、Stats（统计）<br>stats 统计，请求后会直接显示多种聚合结果，count、min、max、avg、sum等<br>如： <code>&quot;grades_stats&quot; : &#123; &quot;stats&quot; : &#123; &quot;field&quot; : &quot;grade&quot; &#125; &#125;</code><br>6、Percentiles（文档占比）<br>对指定字段的值按从小到大累计每个值对应的文档数的占比，返回指定占比比例对应的值，如对字段 “load_time” 使用percentiles返回<code>&quot;50.0&quot;: 445.0,</code>，则表示占比为百分之五十的文档”load_time”值小于等于445<br>下面给几种使用方法：</li></ul><ul><li>默认取百分比，则按照[ 1, 5, 25, 50, 75, 95, 99 ]来统计，如： <code>&quot;percentiles&quot; : &#123; &quot;field&quot; : &quot;load_time&quot; &#125;</code></li><li>指定分位值，则可在body内增加如<code>&quot;percents&quot; : [95, 99, 99.9]</code></li><li>Keyed Response<ul><li>默认情况下，keyed标志设置为true，它将唯一的字符串键与每个存储桶相关联，并将范围作为哈希而不是数组返回</li><li>也可以修改keyed为false，在body内<code>&quot;keyed&quot;: false</code>，这样则会返回一个数组，通过结果也可以看出percentiles中键值对是按照百分比作键，字段值作值构成的<br>7、Percentile_Ranks<br>percentiles是通过指定百分比求文档值，这里通过文档值求百分比，即字段值作键，百分比作值<br>如： <code>&quot;percentile_ranks&quot; : &#123; &quot;field&quot; : &quot;load_time&quot; , &quot;values&quot; : [500,600] &#125;</code> ，返回结果若为 <code>&quot;500.0&quot;: 55.1, &quot;600.0&quot;: 64.0</code> 则表示 时间小于500的文档占比为55.1%，时间小于600的文档占比为64%<br>注意这里一定要通过values指定值数组<br>8、Top_Hits<br>一般用于分桶后获取该桶内匹配前n的文档列表，例如可以展示出某一个网站文档浏览前N名的文档</li></ul></li></ul><h4 id="2-5-2-Bucket聚合"><a href="#2-5-2-Bucket聚合" class="headerlink" title="2.5.2. Bucket聚合"></a>2.5.2. Bucket聚合</h4><p>简介：<br>简单来说桶就是满足特定条件的文档的集合，它会遍历文档中的内容，凡是符合某一要求的就放入一个桶中，分桶相当于 SQL 中的 group by。<br>当聚合开始被执行，每个文档里面的值通过计算来决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着开始聚合操作。<br>桶也可以被嵌套在其他桶里面。<br>1、Terms Aggregation<br>根据某一项的每个唯一的值的聚合<br>如：<code>&quot;terms&quot; : &#123; &quot;field&quot; : &quot;brand&quot; &#125;</code>，根据品牌分桶<br>常见使用：</p><ul><li>若只显示数量前n的桶，可通过size参数控制，如在body中加入<code>&quot;size&quot; : 3</code> 则只显示前三的桶</li><li>若分桶后需要排序，可通过order参数控制，如在body中加入<code>&quot;order&quot; : &#123; &quot;_count&quot; : &quot;asc&quot; &#125;</code></li><li>若要显示文档数量不小于n的桶，可通过<code>min_doc_count</code>参数控制，如： <code>&quot;min_doc_count&quot;: 3</code> 则只显示文档数量大于等于3的桶</li><li>也可使用精确的指定字段值分组，通过include参数控制，如： <code>&quot;include&quot; : [&quot;BMW&quot;, &quot;Audi&quot;]</code> 则只通过宝马和奥迪分桶<br>2、Filter Aggregation&amp;Filters Aggregation<br>Filter Aggregation指具体的域和具体的值，可以说是在 Terms Aggregation 的基础上进行了过滤，只对特定的值进行了聚合<br>Filter Aggreagtion 只能指定一个过滤条件，响应也只是单个桶。如果想要只对多个特定值进行聚合，使用 Filter Aggreagtion 只能进行多次请求。而使用 Filters Aggreagation 就可以解决上述的问题，它可以指定多个过滤条件，也是说可以对多个特定值进行聚合<br>3、Histogram Aggregation<br>Histogram与Terms聚合类似，都是数据分组，区别是Terms是按照Field的值分组，而Histogram可以按照指定的<strong>间隔</strong>对Field进行分组<br>如: <code>&quot;histogram&quot; : &#123;&quot;field&quot; : &quot;price&quot; , &quot;interval&quot; : 10000&#125;</code>表示根据价格区间为10000分桶<br>4、Range Aggregation<br>根据用户传递的范围参数作为桶，进行相应的聚合。在同一个请求中，可以传递多组范围，每组范围作为一个桶<br>如： <code>&quot;range&quot; : &#123; &quot;field&quot; : &quot;price&quot;, &quot;ranges&quot; : [ &#123; &quot;to&quot; : 50000 &#125;,&#123; &quot;from&quot; : 5000, &quot;to&quot; : 80000 &#125;, &#123; &quot;from&quot; : 80000 &#125; ] &#125;</code> 通过ranges参数的数组传递了三个范围，则返回结果中包含三个桶<br>也可以在ranges中指定key的名称，如： <code>[&#123; &quot;key&quot; : &quot;xiaoyu&quot;,  &quot;to&quot; : 50000 &#125;]</code><br>5、Date Aggregation<br>Date Aggregation是针对于时间格式数据的直方图聚合，基本的特性与 Histogram Aggregation 一致<br>可以实现按指定时间区间分桶等date相关操作，具体参见官方文档</li></ul><h2 id="3-深入"><a href="#3-深入" class="headerlink" title="3. 深入"></a>3. 深入</h2><ul><li>原理探究<ul><li>score</li><li>分词器</li><li>倒排索引</li></ul></li><li>安全性<ul><li>X-Pack</li></ul></li></ul><h3 id="3-1-原理探究"><a href="#3-1-原理探究" class="headerlink" title="3.1. 原理探究"></a>3.1. 原理探究</h3><h4 id="3-1-1-score"><a href="#3-1-1-score" class="headerlink" title="3.1.1. score"></a>3.1.1. score</h4><h4 id="3-1-2-分词器"><a href="#3-1-2-分词器" class="headerlink" title="3.1.2. 分词器"></a>3.1.2. 分词器</h4><h4 id="3-1-3-倒排索引"><a href="#3-1-3-倒排索引" class="headerlink" title="3.1.3. 倒排索引"></a>3.1.3. 倒排索引</h4><h3 id="3-2-安全性"><a href="#3-2-安全性" class="headerlink" title="3.2. 安全性"></a>3.2. 安全性</h3><p>Elasticsearch早期版本安全部分收费（7.1 &amp; 6.8 版本之前），实际中各个公司6.x，5.x,2.x,1.x都有在用，且非少数。多数只是使用nginx代理防护，不暴露端口，不外网映射。</p><p>如果9200或者改成其他端口的ES暴露在公网，一旦被扫到，集群及数据会受到灾难式影响。</p><h4 id="3-2-1-X-Pack"><a href="#3-2-1-X-Pack" class="headerlink" title="3.2.1. X-Pack"></a>3.2.1. X-Pack</h4><h5 id="3-2-1-1-啥是X-Pack"><a href="#3-2-1-1-啥是X-Pack" class="headerlink" title="3.2.1.1. 啥是X-Pack"></a>3.2.1.1. 啥是X-Pack</h5><p>X-Pack是Elastic Stack扩展功能，提供安全性，警报，监视，报告，机器学习和许多其他功能。 ES7.0+之后，默认情况下，当安装Elasticsearch时，会安装X-Pack，无需单独再安装（也就是内置了）。自6.8以及7.1+版本之后，基础级安全永久免费。</p><p>基础级安全包括：加密通信、基于角色的访问控制、文件和原生身份验证、Kibana功能控制、Kibana Spaces和API密钥管理。</p><h5 id="3-2-1-2-如何配置X-Pack"><a href="#3-2-1-2-如何配置X-Pack" class="headerlink" title="3.2.1.2. 如何配置X-Pack"></a>3.2.1.2. 如何配置X-Pack</h5><p>默认情况下，拥有安全免费许可证时，Elasticsearch安全功能被禁用。 要启用安全功能，需要设置xpack.security.enabled为true。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Elastic-Search7-x学习笔记&quot;&gt;&lt;a href=&quot;#Elastic-Search7-x学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Elastic Search7.x学习笔记&quot;&gt;&lt;/a&gt;Elastic Search7.x学习笔记&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;入门&lt;/li&gt;
&lt;li&gt;深入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1-前言：&quot;&gt;&lt;a href=&quot;#1-前言：&quot; class=&quot;headerlink&quot; title=&quot;1. 前言：&quot;&gt;&lt;/a&gt;1. 前言：&lt;/h2&gt;&lt;p&gt;先从官方入门视频、官方文档和一些入门博客入手学习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ElasticSearch" scheme="http://silencezheng.top/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot官网Guide学习笔记</title>
    <link href="http://silencezheng.top/2022/01/29/article30/"/>
    <id>http://silencezheng.top/2022/01/29/article30/</id>
    <published>2022-01-28T16:42:17.000Z</published>
    <updated>2022-05-10T04:20:11.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-boot官网Guide学习笔记"><a href="#Spring-boot官网Guide学习笔记" class="headerlink" title="Spring boot官网Guide学习笔记"></a>Spring boot官网Guide学习笔记</h1><ul><li>前言</li><li>第一个demo</li><li>构建RESTful风格的服务</li><li>连接MySQL</li><li>使用RESTful风格的服务</li><li>用Spring Boot构建Web应用</li><li>使用 Spring MVC 提供 Web 内容</li><li>保护 Web 应用程序，确认用户 </li></ul><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>先从各种guide入手，先对Spring程序结构体系有一个宏观了解，再结合文档进行精细化学习，文档地址（2.6.2版本）：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></p><span id="more"></span><h2 id="第一个demo"><a href="#第一个demo" class="headerlink" title="第一个demo"></a>第一个demo</h2><p><a href="https://spring.io/quickstart">https://spring.io/quickstart</a></p><ol><li>@SpringBootApplication、@RestController、@GetMapping</li><li>本地配置tomcat要开权限，不然idea不能启动tomcat</li><li>代码示例：<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@RestController</span></span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line"><span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">GetMapping</span>(<span class="string">&quot;/hello&quot;</span>)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">String</span> <span class="selector-tag">hello</span>(<span class="variable">@RequestParam</span>(value = <span class="string">&quot;name&quot;</span>, defaultValue = <span class="string">&quot;World&quot;</span>) String name) &#123;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">String</span><span class="selector-class">.format</span>(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="构建RESTful风格的服务"><a href="#构建RESTful风格的服务" class="headerlink" title="构建RESTful风格的服务"></a>构建RESTful风格的服务</h2><p><a href="https://spring.io/guides/gs/rest-service/#initial">https://spring.io/guides/gs/rest-service/#initial</a></p><ol><li>通过 mvn clean package将app进行打包（jar），终端可以直接运行java -jar</li><li>jar包和war包的区别，spring boot项目的jar包内建服务器可以直接运行</li><li>不需要web.xml，纯Java</li></ol><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><p><a href="https://spring.io/guides/gs/accessing-data-mysql/">https://spring.io/guides/gs/accessing-data-mysql/</a></p><ol><li>需要添加新依赖，bash进入mysql时若用sudo命令要先输入sudo密码再输入root密码</li><li>MySQL创建新用户后的%指允许在任何主机登陆，可换为ip或localhost（仅在本地）</li><li>在resources中修改application.properties文件，了解spring.jpa.hibernate.ddl-auto的四个类型，数据库用户和scheme也从这里配置</li><li>了解Hibernate ORM ，Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中。此demo通过Hibernate将user类映射到MySQL中，可通过Datagrip查看</li><li>用postman发送请求测试接口</li><li>进行安全测试，防止sql注入攻击，将用户权限设置为只能对数据操作而无法涉及数据表结构（scheme） </li></ol><h2 id="使用RESTful风格的服务"><a href="#使用RESTful风格的服务" class="headerlink" title="使用RESTful风格的服务"></a>使用RESTful风格的服务</h2><p><a href="https://spring.io/guides/gs/consuming-rest/">https://spring.io/guides/gs/consuming-rest/</a></p><ol><li>一般可以通过浏览器访问URL来使用一个web服务，但用变成方式来使用RESTful风格的服务是更有用的方法,这个demo要从接口中取数据放到springboot的控制台中以log形式显示</li><li>由于demo给定的接口无法访问（可能是墙的原因），CommandLineRunner启动会失败，故无法查看结果，接口应获得的内容如下：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">   type:</span> <span class="string">&quot;success&quot;</span>,</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">   value:</span> &#123;</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">      id:</span> <span class="number">10</span>,</span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">      quote:</span> <span class="string">&quot;Really loving Spring Boot, makes stand alone Spring apps easy.&quot;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125; 为一个两层结构的json对象</span><br></pre></td></tr></table></figure></li><li>@JsonIgnoreProperties表示任何未绑定在此类型中的属性都应被忽略，要将接口获得的数据与自定义的类型绑定（反序列化），需要使定义的变量名与json对象的键名完全一致，如果不匹配可以用@JsonProperty注释来指定json对象中的某个键（这也可以用于处理含特殊字符或其他不便于作为变量名出现的json键）</li></ol><h2 id="用spring-boot构建Web应用"><a href="#用spring-boot构建Web应用" class="headerlink" title="- 用spring boot构建Web应用"></a>- 用spring boot构建Web应用</h2><p><a href="https://spring.io/guides/gs/spring-boot/">https://spring.io/guides/gs/spring-boot/</a></p><ol><li>CommandLineRunner, ApplicationContext, DispatcherServlet</li><li>添加单元测试，先添加maven依赖. MockMvc, 两种测试。</li><li>Spring Boot Actuator，帮助监控和管理web应用。添加依赖到maven，通过<a href="http://localhost:8080/actuator">http://localhost:8080/actuator</a> 可访问。详细见：<a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/htmlsingle/#actuator">https://docs.spring.io/spring-boot/docs/2.5.0/reference/htmlsingle/#actuator</a></li><li>JMX，是Java Management Extensions(Java管理扩展)的缩写，是一个为应用程序植入管理功能的框架。</li><li>For more details about each of these REST endpoints and how you can tune their settings with an application.properties file (in src/main/resources), see the <a href="https://docs.spring.io/spring-boot/docs/2.5.0/reference/htmlsingle/#production-ready-endpoints">https://docs.spring.io/spring-boot/docs/2.5.0/reference/htmlsingle/#production-ready-endpoints</a></li><li>Groovy 另一门语言（基于Java）</li></ol><h2 id="使用-Spring-MVC-提供-Web-内容"><a href="#使用-Spring-MVC-提供-Web-内容" class="headerlink" title="- 使用 Spring MVC 提供 Web 内容"></a>- 使用 Spring MVC 提供 Web 内容</h2><p><a href="https://spring.io/guides/gs/serving-web-content/">https://spring.io/guides/gs/serving-web-content/</a></p><ol><li>Model object, easy to use in view template</li><li>Thymeleaf, 一个现代的服务器端 Java 模板引擎，适用于 Web 和独立环境。添加spring-boot-starter-thymeleaf</li><li>Spring-boot-devtools, 可以实现指定目录（默认为classpath路径）下的文件进行更改后，项目自动重启，更改后的代码自动生效，热部署节省了“编写更改代码、重新启动应用程序并刷新浏览器以查看更改”这一过程的时间，添加依赖</li><li>Spring boot app serves static content from resources in the classpath at /static (or /public). The index.html resource is used as a welcome page.</li></ol><h2 id="保护-Web-应用程序，确认用户"><a href="#保护-Web-应用程序，确认用户" class="headerlink" title="- 保护 Web 应用程序，确认用户"></a>- 保护 Web 应用程序，确认用户</h2><p><a href="https://spring.io/guides/gs/securing-web/">https://spring.io/guides/gs/securing-web/</a></p><ol><li>分两部分，先构建一个app(Spring MVC)，再用Spring Security做登录界面</li><li>Spring MVC负责请求的转发和视图管理</li><li>If Spring Security is on the classpath, Spring Boot automatically secures all HTTP endpoints with “basic” authentication. </li><li>第二部分，首先添加ss的两个依赖（本身和测试），然后编写安全类</li><li>根据配置，Spring Security提供了一个过滤器，可以拦截请求和验证用户的过滤器。如果用户无法验证，页面将被重定向到/login？error，您的页面显示适当的错误信息。成功退出登录后，您的申请将发送到/login?logout，您的页面将显示适当的成功信息。</li><li>更新hello页面，We display the username by using Spring Security’s integration with HttpServletRequest#getRemoteUser(). The “Sign Out” form submits a POST to /logout. Upon successfully logging out, it redirects the user to /login?logout.</li><li>关于Thymeleaf:</li></ol><blockquote><p>${user.name}表示“获取用户的变量，并调用其getName()方法”<br>通过标签中的th:text属性来填充该标签的一段内容，意思是$表达式只能写在th标签内部,不然不会生效,使用th:text标签的值替换div标签里面的值,至于div里面的原有的值只是为了给前端开发时做展示用的.这样的话很好的做到了前后端分离.意味着div标签中的内容会被表达式${session.book}的值所替代，无论模板中它的内容是什么，之所以在模板中“多此一举“地填充它的内容，完全是为了它能够作为原型在浏览器中直接显示出来。<br>访问spring-mvc中model的属性，语法格式为“${}”，如${user.id}可以获取model里的user对象的id属性<br>为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问。例如${ #dates.format(dateVar, ‘dd/MMM/yyyy HH:mm’)} 使用java.util.Date的功能方法类</p></blockquote><ol start="8"><li>结果是智能允许名为user密码为password的用户登录</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Spring-boot官网Guide学习笔记&quot;&gt;&lt;a href=&quot;#Spring-boot官网Guide学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Spring boot官网Guide学习笔记&quot;&gt;&lt;/a&gt;Spring boot官网Guide学习笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;第一个demo&lt;/li&gt;
&lt;li&gt;构建RESTful风格的服务&lt;/li&gt;
&lt;li&gt;连接MySQL&lt;/li&gt;
&lt;li&gt;使用RESTful风格的服务&lt;/li&gt;
&lt;li&gt;用Spring Boot构建Web应用&lt;/li&gt;
&lt;li&gt;使用 Spring MVC 提供 Web 内容&lt;/li&gt;
&lt;li&gt;保护 Web 应用程序，确认用户 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;先从各种guide入手，先对Spring程序结构体系有一个宏观了解，再结合文档进行精细化学习，文档地址（2.6.2版本）：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/&quot;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>双重指针，指针的指针！</title>
    <link href="http://silencezheng.top/2021/07/13/article29/"/>
    <id>http://silencezheng.top/2021/07/13/article29/</id>
    <published>2021-07-13T09:09:17.000Z</published>
    <updated>2022-05-10T16:59:41.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说来惭愧，从大一完了以后接触Java就觉得C好笨啊，于是现在重学数据结构的时候，总是遇到C语言的一些问题，今天终于对双重指针有了一定理解，但还有一些问题，待日后学习再解决吧。对了，此问题是由严蔚敏数据结构中，稀疏矩阵压缩存储的十字链表引申而来。</p><span id="more"></span><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>首先为了对新手友好，先放如下代码解决一下typedef方面的问题。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LNode&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct LNode *<span class="keyword">next</span>;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="regexp">//</span>等价于下面：</span><br><span class="line"><span class="regexp">//</span>struct LNode&#123;</span><br><span class="line"><span class="regexp">//</span>    int data;</span><br><span class="line"><span class="regexp">//</span>    struct LNode *<span class="keyword">next</span>;</span><br><span class="line"><span class="regexp">//</span>&#125;</span><br><span class="line"><span class="regexp">//</span>typedef struct LNode LNode;</span><br><span class="line"><span class="regexp">//</span>typedef struct LNode *LinkList;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就正式开始解决双重指针的问题啦，我将我的解释写在了注释中，读者可以边读代码边看注释进行理解（当然我的理解也可能有问题，欢迎大家评论告诉我～）。下面代码可以extern到main.c中跑一下，注意头文件。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  双重指针.c</span></span><br><span class="line"><span class="comment">//  test</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by silenceZheng on 2021/7/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ANode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ANode, * ALink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ALink *start;</span><br><span class="line">&#125;AList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pointerAsArray_int</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="number">6</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    a[<span class="number">3</span>] = data;</span><br><span class="line">    a[<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pointerAsArray_ptr</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    AList* alist = (AList *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(AList));</span><br><span class="line">    ALink* s = (ALink *)<span class="built_in">malloc</span>(<span class="number">3</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(ALink));</span><br><span class="line">    ALink node1 = (ALink)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ANode));</span><br><span class="line">    ALink node2 = (ALink)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ANode));</span><br><span class="line">    ALink node3 = (ALink)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ANode));</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    node1-&gt;data = <span class="number">1</span>;</span><br><span class="line">    node2-&gt;data = <span class="number">22</span>;</span><br><span class="line">    node3-&gt;data = data;</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 这里ALink*与上面int*的实质是一样的，只不过是“指针的指针”，ALink*指向ALink，其值为ALink的地址。</span></span><br><span class="line">    <span class="comment">// 由于我分配了3个ALink的空间，所以可以存放3个ALink成为数组。</span></span><br><span class="line">    <span class="comment">// 而ALink实质是ANode的指针，也就是结构体指针，所以需要再为ALink指向的东西（ANode）分配空间。</span></span><br><span class="line">    <span class="comment">// 这样就构成了AList中ALink*是一个指针，也是一个数组的头指针</span></span><br><span class="line">    <span class="comment">// 该数组中的每一个元素都是一个指针，指向一个ANode节点。</span></span><br><span class="line">    <span class="comment">// 下面开始将结点放到数组中。</span></span><br><span class="line">    s[<span class="number">0</span>] = node1;</span><br><span class="line">    s[<span class="number">1</span>] = node2;</span><br><span class="line">    s[<span class="number">2</span>] = node3;</span><br><span class="line">    alist-&gt;start = s;</span><br><span class="line">    <span class="comment">// 验证结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,alist-&gt;start[<span class="number">2</span>]-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,alist-&gt;start[<span class="number">0</span>]-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,alist-&gt;start[<span class="number">0</span>]-&gt;next-&gt;next-&gt;data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 说明与问题</span></span><br><span class="line">    <span class="comment">// ANode使用链表节点的结构是随便用的，事实上并不对阐述“指针的指针”这一概念有任何帮助。</span></span><br><span class="line">    <span class="comment">// 问题1. s[500] = node3; printf(&quot;%d\n&quot;,alist-&gt;start[500]-&gt;data);</span></span><br><span class="line">    <span class="comment">//       上面语句依然可以正确输出参数值，而实际上我只给ALink指针分配了3个ALink大小的空间。</span></span><br><span class="line">    <span class="comment">//       如果这样，那么为ALink*分配空间有什么意义？ 或者说分配的空间是固定的？而不分配</span></span><br><span class="line">    <span class="comment">//       则有可能丢失数据？</span></span><br><span class="line">    <span class="comment">// 问题2.    printf(&quot;%lu\n&quot;,sizeof(ANode));</span></span><br><span class="line">    <span class="comment">//          printf(&quot;%lu\n&quot;,sizeof(ALink));</span></span><br><span class="line">    <span class="comment">//          printf(&quot;%lu\n&quot;,sizeof(AList));</span></span><br><span class="line">    <span class="comment">//      输出结果分别为16、8、8，在我的电脑里int的size是4，为什么ANode是8？</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说来惭愧，从大一完了以后接触Java就觉得C好笨啊，于是现在重学数据结构的时候，总是遇到C语言的一些问题，今天终于对双重指针有了一定理解，但还有一些问题，待日后学习再解决吧。对了，此问题是由严蔚敏数据结构中，稀疏矩阵压缩存储的十字链表引申而来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="http://silencezheng.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac下配置MAP环境（mysql+apache+php）</title>
    <link href="http://silencezheng.top/2021/07/11/article28/"/>
    <id>http://silencezheng.top/2021/07/11/article28/</id>
    <published>2021-07-11T09:03:38.000Z</published>
    <updated>2021-07-11T09:07:26.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>发个库存，前一阵在Mac上捣鼓PHP，不想用MAMP，就自己搭了一下，凑活能用吧～<br>本文的目的是实现类WAMP集成环境的配置效果。</p><span id="more"></span><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ol><li>下载MySQL社区版，下载地址：<a href="https://dev.mysql.com/downloads/mysql/。">https://dev.mysql.com/downloads/mysql/。</a></li><li>点击安装，会让你设置密码，或提供一个随机密码，如果提供随机密码一定要记住。</li><li>打开系统偏好，启动数据库服务。</li><li>mysql -u root -p登陆。</li></ol><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><ol><li>使用Mac自带的Apache服务器。</li><li>sudo apachectl start启动服务器，浏览器输入localhost出现it works证明开启成功。</li><li>系统自带的服务器位于/etc/apache2下，打开httpd.conf配置文件，可以先备份一下。</li><li>LoadModule php7_module libexec/apache2/libphp7.so打开支持PHP7。</li><li>Include /private/etc/apache2/extra/httpd-vhosts.conf打开支持虚拟主机配置文件。</li><li>打开虚拟主机配置文件，同样可以先备份一下。</li><li> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">&lt;VirtualHost *<span class="number">:80</span>&gt;</span></span><br><span class="line">    <span class="attribute">ServerAdmin</span> webmaster@mysite.local</span><br><span class="line">    <span class="attribute"><span class="nomarkup">DocumentRoot</span></span> <span class="string">&quot;/Library/WebServer/Documents/testApache&quot;</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">ServerName</span></span> mysite.local</span><br><span class="line">    <span class="attribute">ErrorLog</span> <span class="string">&quot;/private/var/log/apache2/mysite.local-error_log&quot;</span></span><br><span class="line">    <span class="attribute">CustomLog</span> <span class="string">&quot;/private/var/log/apache2/mysite.local-access_log&quot;</span> common</span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure> 加入到文件中，这里描述的虚拟主机域名为mystie.local，根目录为/Library/WebServer/Documents/testApache。</li><li>编辑/etc/hosts文件，将域名绑定到127.0.0.1。 <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span>       localhost mysite.local</span><br></pre></td></tr></table></figure></li><li>sudo apachectl restart重启服务器，在上述根目录中加入index.php测试配置。</li></ol><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ol><li>Mac有自带PHP，这里演示使用homebrew下载新版本PHP配置。</li><li>brew install <a href="mailto:php@7.4">php@7.4</a>下载7.4版本的PHP。</li><li>brew services start <a href="mailto:php@7.4">php@7.4</a>启动PHP服务。</li><li>打开.bash_profile配置文件，添加 export PATH=”/opt/homebrew/opt/php@7.4/bin/:$PATH”将刚下的PHP加入环境变量。（这里的意思就是在PATH前加入该路径，:是Mac中环境变量的分隔符，和windows中;等同。）</li><li>打开zsh配置文件.zshrc，加入source ~/.bash_profile，使其刷新环境。</li><li>source ～/.zshrc，输入php -v检查是否安装成功。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;发个库存，前一阵在Mac上捣鼓PHP，不想用MAMP，就自己搭了一下，凑活能用吧～&lt;br&gt;本文的目的是实现类WAMP集成环境的配置效果。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MacOS" scheme="http://silencezheng.top/tags/MacOS/"/>
    
    <category term="PHP" scheme="http://silencezheng.top/tags/PHP/"/>
    
    <category term="MySQL" scheme="http://silencezheng.top/tags/MySQL/"/>
    
    <category term="Apache" scheme="http://silencezheng.top/tags/Apache/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客个性化设置（yilia主题）</title>
    <link href="http://silencezheng.top/2021/07/11/article27/"/>
    <id>http://silencezheng.top/2021/07/11/article27/</id>
    <published>2021-07-11T08:54:12.000Z</published>
    <updated>2021-07-11T09:01:49.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近依然在学习考研，祝自己能上岸吧，上岸后还有很多想做的事，学学Spring全家桶啥的，提升一下自己的技能库。最近发现李沐大神的动手学深度学习v2不错，茶余饭后看一看提升一下科研素质，以后发论文没准还是得靠这个，想用Java搞科研还没看出有什么门路。还准备每周在b站发俩做力扣的实战视频，水着玩儿也提高一下算法能力。说回正题，这个博文记录一下我在我的博客所做的一些个性化设置，持续更新～</p><span id="more"></span><h2 id="yilia添加字数统计和阅读时长功能"><a href="#yilia添加字数统计和阅读时长功能" class="headerlink" title="yilia添加字数统计和阅读时长功能"></a>yilia添加字数统计和阅读时长功能</h2><ol><li>安装 hexo-wordcount<br>在博客目录下打开Git Bash Here，输入命令:<br>npm i –save hexo-wordcount</li><li>文件配置<br>在theme\yilia\layout_partial\post下创建word.ejs文件：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:10px;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-keyboard-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= wordcount(post.content) %&gt;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="line">      <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-hourglass-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= min2read(post.content) %&gt;分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>然后在themes/yilia/layout/_partial/article.ejs中添加:<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-inner&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &lt;% if (post.link || post.title)</span><span class="xquery">&#123; %&gt;</span></span><br><span class="line"><span class="xquery">      <span class="xml"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;article-header&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="xquery">        &lt;%- partial(&#x27;post/title&#x27;, </span><span class="xquery">&#123;class_name: <span class="string">&#x27;article-title&#x27;</span>&#125;</span></span><span class="xml">) %&gt;</span></span><br><span class="line"><span class="xml">        &lt;% if (!post.noDate)</span><span class="xquery"><span class="xquery">&#123; %&gt;</span></span></span><br><span class="line"><span class="xquery"><span class="xquery">        &lt;<span class="meta">%-</span> partial(<span class="string">&#x27;post/date&#x27;</span>, &#123;class_name: <span class="string">&#x27;archive-article-date&#x27;</span>, date_format: null&#125;</span></span><span class="xml">) %&gt;</span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 需要添加的位置 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 开始添加字数统计--&gt;</span></span></span><br><span class="line"><span class="xml">        &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)</span><span class="xquery"><span class="xquery">&#123;%&gt;</span></span></span><br><span class="line"><span class="xquery"><span class="xquery">          &lt;<span class="meta">%-</span> partial(<span class="string">&#x27;post/word&#x27;</span>) %&gt;</span></span></span><br><span class="line"><span class="xquery"><span class="xquery">          &lt;% &#125;</span></span><span class="xml"> %&gt;</span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 添加完成 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>开启功能<br>在站点的_config.yml中添加下面代码:<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启字数统计</span></span><br><span class="line"><span class="comment">#不需要使用，直接设置值为false，或注释掉</span></span><br><span class="line"><span class="attr">word_count:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="添加不蒜子统计插件"><a href="#添加不蒜子统计插件" class="headerlink" title="添加不蒜子统计插件"></a>添加不蒜子统计插件</h2><ol><li>配置是否开启不蒜子访问量统计功能<br>在themes/yilia/_config.yml添加属性<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启访问量统计功能(不蒜子)</span></span><br><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>引入不蒜子并添加站点访问量<br>在themes/yilia/layout/_partial/footer.ejs末尾footer标签前添加如下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 不蒜子统计 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span></span><br><span class="line">                本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;display:none&#x27;</span>&gt;</span></span><br><span class="line">                本站访客数<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_uv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人</span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li><li>添加文章访问量<br>这种形式是：外面不显示，只在文章里面才显示，位置为右上角时间的右边。<br>在themes/yilia/layout/_partial/post/date.ejs开头添加如下代码<figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">&lt;%</span><span class="perl"> <span class="keyword">if</span> (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !<span class="keyword">index</span>)&#123; </span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!-- 不蒜子统计 --&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;display:none&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;&lt;%=</span></span></span><span class="perl"> class_name </span><span class="xml"><span class="tag"><span class="string">%&gt;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;icon-smile icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 阅读数：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">&lt;%</span><span class="perl"> &#125; </span><span class="xml">%&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="在hexo博客养一只猫"><a href="#在hexo博客养一只猫" class="headerlink" title="在hexo博客养一只猫"></a>在hexo博客养一只猫</h2><ol><li><p>安装模块</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> --save hexo-helper-live2d</span><br><span class="line"></span><br><span class="line">这里解释一下npm <span class="keyword">install</span>的命令含义：</span><br><span class="line">npm <span class="keyword">install</span> moduleName <span class="comment"># 安装模块到项目目录</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> -g moduleName <span class="comment"># -g 意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置。</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> --save moduleName <span class="comment"># --save的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖。</span></span><br><span class="line"></span><br><span class="line">npm <span class="keyword">install</span> --save-dev moduleName <span class="comment"># --save -dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。</span></span><br></pre></td></tr></table></figure></li><li><p>安装模型</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用 npm <span class="keyword">install</span> 模型名字安装。</span><br><span class="line">模型列表如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在hexo或者主题的_config.yml文件中添加如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D:</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">model:</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span></span><br><span class="line">  <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line"><span class="attr">display:</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="attr">width:</span> <span class="number">150</span> <span class="comment"># 显示位置及大小</span></span><br><span class="line">  <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">vOffset:</span> <span class="number">-20</span></span><br><span class="line"><span class="attr">mobile:</span></span><br><span class="line">  <span class="attr">show:</span> <span class="literal">false</span> <span class="comment"># 手机显示开关，建议关闭</span></span><br><span class="line"><span class="attr">react:</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure></li><li><p>遇到的问题…<br>在我配置好一切后，出现了不能更换模型的bug，怎么更改配置也没有用，我就尝试使用npm audit fix修复，看了一下报告大概是hexo等等插件的版本问题，然后强制fix了一波以后还是没好。。。一气之下我就把下载的东西都卸了，现在audit一下果然没问题了，然后重新用npm装一遍。。果然发现了些问题。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npm</span> WARN deprecated fsevents@<span class="number">1</span>.<span class="number">2</span>.<span class="number">13</span>: fsevents <span class="number">1</span> will break <span class="literal">on</span> node v<span class="number">14</span>+ and could be using insecure binaries. Upgrade to fsevents <span class="number">2</span>.</span><br><span class="line"><span class="attribute">npm</span> WARN deprecated chokidar@<span class="number">2</span>.<span class="number">1</span>.<span class="number">8</span>: Chokidar <span class="number">2</span> will break <span class="literal">on</span> node v<span class="number">14</span>+. Upgrade to chokidar <span class="number">3</span> with <span class="number">15</span>x less dependencies.</span><br><span class="line"><span class="attribute">npm</span> WARN deprecated hexo-bunyan@<span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span>: Please see https://github.com/hexojs/hexo-bunyan/issues/<span class="number">17</span></span><br><span class="line"><span class="attribute">npm</span> WARN deprecated core-js@<span class="number">2</span>.<span class="number">6</span>.<span class="number">12</span>: core-js@&lt;<span class="number">3</span>.<span class="number">3</span> is no longer maintained and not recommended for usage due to the number of issues. Because of the V<span class="number">8</span> engine whims, feature detection in old core-js versions could cause a slowdown up to <span class="number">100</span>x even if nothing is polyfilled. Please, upgrade your dependencies to the actual version of core-js.</span><br></pre></td></tr></table></figure><p>从上面的警告可以看出我目前使用的nodejs15版本对有些插件的支持是比较差的，按照提示我运行audit fix来修复一下，结果修复完出来了更多issue。。从8个变成13了😅，试了一遍还是改不了模型和位置，索性不安了。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近依然在学习考研，祝自己能上岸吧，上岸后还有很多想做的事，学学Spring全家桶啥的，提升一下自己的技能库。最近发现李沐大神的动手学深度学习v2不错，茶余饭后看一看提升一下科研素质，以后发论文没准还是得靠这个，想用Java搞科研还没看出有什么门路。还准备每周在b站发俩做力扣的实战视频，水着玩儿也提高一下算法能力。说回正题，这个博文记录一下我在我的博客所做的一些个性化设置，持续更新～&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://silencezheng.top/tags/Hexo/"/>
    
    <category term="yilia" scheme="http://silencezheng.top/tags/yilia/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客迁移之windows to macOS</title>
    <link href="http://silencezheng.top/2021/05/28/article26/"/>
    <id>http://silencezheng.top/2021/05/28/article26/</id>
    <published>2021-05-28T09:40:00.000Z</published>
    <updated>2022-05-04T16:51:52.281Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前在windows电脑上迁移过博客，但是没有记录过程，这次正好换到另一台电脑，迁移一下博客并记录一下。碰到了不少小坑～ 网上的方式各种麻烦，感觉我目前用的这种最简单粗暴。</p><span id="more"></span><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>node.js环境, git环境搭建好</li><li>cnpm替换npm，安装hexo框架cnpm install -g hexo-cli</li></ol><h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><ol><li>新建目录，hexo init创建博客。</li><li>cnpm install –save hexo-deployer-git，在blog目录下安装git部署插件。</li><li>将原博客的下列文件复制到新博客目录中<br> _config.yml<br>  package.json (不清楚有没有用到)<br>  scaffolds/ (不清楚有没有用到)<br>  source/<br>  themes/</li><li>hexo clean &amp;&amp; hexo g</li><li>hexo s本地测试, 没问题就可以发布了。</li></ol><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li>因为我原博客中添加了字数统计插件，所以第一次进行完第四步测试会报错，npm i –save hexo-wordcount在目录中添加插件解决。</li><li>当我首次发布到远端时，报错fatal: unable to access ‘<a href="https://github.com/silenceZheng66/silenceZheng66.github.io.git/&#39;">https://github.com/silenceZheng66/silenceZheng66.github.io.git/&#39;</a>: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443，看网上说是因为设置了https代理，<br>但当我去掉代理也没有反应，输入以下命令则可以成功发布。<br>git config –global http.sslBackend “openssl” </li><li>当解决2错误后，我注意到有另一个报错：FATAL err: Error: Spawn failed 大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容，解决办法如下：<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 删除<span class="string">.deploy_git</span>文件夹<span class="params">(如果没有跳过这步。)</span></span><br><span class="line">2. 输入git config <span class="params">--global</span> core.autocrlf <span class="literal">false</span></span><br><span class="line">然后，依次执行：</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">成功！</span><br></pre></td></tr></table></figure> 原理：<br> 1、不同操作系统下，处理行尾结束符的方法是不同的：</li></ol><p>　   　    windows下：CRLF（表示句尾使用回车换行两个字符，即windows下的”\r\n”换行）</p><pre><code>       unix下：LF（表示句尾，只使用换行）       mac下：CR（表示只使用回车）2、Git下处理“换行”（line ending）</code></pre><p>　　    core.autocrlf是git中负责处理lineending的变量，可以设置3个值：true，false，input。<br>    （1）设置为true【config –global core.autocrlf true】<br>          当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个文本文件(text file)。<br>　　　     它将把crlf变成LF。<br>    （2）设置为false【config –global core.autocrlf false】<br>          当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。<br>    （3）设置为input时，添加文件git仓库时，git把crlf编程lf。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置。<br>4. 某一篇博客中可能存在”’{连着#“字符串，去掉它，或者去掉”#”.否则generate时会报错！<br>5. github现在需要用token才能上传了，在config.yml里把url改成https://<your_token>@github.com/<USERNAME>/<REPO>.git，token从setting-&gt;developer tools里面申请。 (22.05.05更新)</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前在windows电脑上迁移过博客，但是没有记录过程，这次正好换到另一台电脑，迁移一下博客并记录一下。碰到了不少小坑～ 网上的方式各种麻烦，感觉我目前用的这种最简单粗暴。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://silencezheng.top/tags/Hexo/"/>
    
    <category term="MacOS" scheme="http://silencezheng.top/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>M1 MacBook配置arm版homebrew</title>
    <link href="http://silencezheng.top/2021/05/25/article25/"/>
    <id>http://silencezheng.top/2021/05/25/article25/</id>
    <published>2021-05-25T07:33:55.000Z</published>
    <updated>2021-07-11T08:52:53.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>呼～一转眼，五个多月没有更新啦，其实中间一直有在写，但是没有上传，主要是没有时间整理，加上在准备考研，准备考完后再全心投入到编程学习中咯。这篇分享一下M1 MacBook配置arm版homebrew，实测靠谱。</p><span id="more"></span><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>设置使用中科大镜像<br>HOMEBREW_CORE_GIT_REMOTE=<a href="https://mirrors.ustc.edu.cn/homebrew-core.git">https://mirrors.ustc.edu.cn/homebrew-core.git</a></p></li><li><p>安装homebrew<br>/bin/bash -c “$(curl -fsSL <a href="https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;">https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</a></p></li><li><p>添加 Homebrew 到 /Users/你的用户名/.zprofile 文件的 PATH 中，执行下面命令即可:<br>echo ‘eval “$(/opt/homebrew/bin/brew shellenv)”‘ &gt;&gt; /Users/你的用户名/.zprofile<br>eval “$(/opt/homebrew/bin/brew shellenv)”</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;呼～一转眼，五个多月没有更新啦，其实中间一直有在写，但是没有上传，主要是没有时间整理，加上在准备考研，准备考完后再全心投入到编程学习中咯。这篇分享一下M1 MacBook配置arm版homebrew，实测靠谱。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MacOS" scheme="http://silencezheng.top/tags/MacOS/"/>
    
    <category term="Homebrew" scheme="http://silencezheng.top/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>Python基础笔记-常用内置函数（一）</title>
    <link href="http://silencezheng.top/2020/12/31/article24/"/>
    <id>http://silencezheng.top/2020/12/31/article24/</id>
    <published>2020-12-31T11:41:55.000Z</published>
    <updated>2020-12-31T12:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录一下平时做项目用到的内置函数。<br>本篇函数包含：enumerate()、ord()、 shuffle() </p><span id="more"></span><h3 id="用法及示例"><a href="#用法及示例" class="headerlink" title="用法及示例"></a>用法及示例</h3><p><strong>enumerate()</strong><br>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。<br>Python 2.3. 以上版本可用，2.6 添加 start 参数。</p><p>语法： enumerate(sequence, [start=0])</p><p>参数： </p><ul><li>sequence – 一个序列、迭代器或其他支持迭代对象。</li><li>start – 下标起始位置。<br>该方法返回枚举对象。</li></ul><p>实例：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;seq = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> i, <span class="keyword">element</span> <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">...     print i, <span class="keyword">element</span></span><br><span class="line">... </span><br><span class="line"><span class="number">0</span> <span class="literal">one</span></span><br><span class="line"><span class="number">1</span> <span class="literal">two</span></span><br><span class="line"><span class="number">2</span> <span class="literal">three</span></span><br></pre></td></tr></table></figure><p><strong>ord()</strong><br>ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。</p><p>语法： ord(c)</p><p>返回值是对应的十进制整数。</p><p>实例：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="function"><span class="title"><span class="built_in">ord</span></span>(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title"><span class="built_in">ord</span></span>(<span class="string">&#x27;b&#x27;</span>)</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title"><span class="built_in">ord</span></span>(<span class="string">&#x27;c&#x27;</span>)</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>shuffle()</strong><br>shuffle() 方法将序列的所有元素随机排序。</p><p>语法(注意：shuffle()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法)：<br>import random<br>random.shuffle (lst )</p><p>参数： </p><ul><li>lst – 可以是一个列表。<br>该方法没有返回值。</li></ul><p>实例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">list = [<span class="number">20</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">5</span>]</span><br><span class="line">random.<span class="built_in">shuffle</span>(list)</span><br><span class="line">print <span class="string">&quot;随机排序列表 : &quot;</span>,  list</span><br><span class="line"></span><br><span class="line">random.<span class="built_in">shuffle</span>(list)</span><br><span class="line">print <span class="string">&quot;随机排序列表 : &quot;</span>,  list</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">随机排序列表 :  [<span class="number">16</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">随机排序列表 :  [<span class="number">16</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;记录一下平时做项目用到的内置函数。&lt;br&gt;本篇函数包含：enumerate()、ord()、 shuffle() &lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础笔记-面向对象</title>
    <link href="http://silencezheng.top/2020/12/31/article23/"/>
    <id>http://silencezheng.top/2020/12/31/article23/</id>
    <published>2020-12-31T09:14:55.000Z</published>
    <updated>2020-12-31T11:02:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>断更两个多月了，一直在忙学校的事情，疫情下压缩课时，每天都有很多事情要处理，现在终于放假了，继续<br>开始更新这两个月内的学习收获，这两个月在python和java的基础方面进行了很多实践，这篇来记录一下python的面向对象编程收获，都是一些基础知识。</p><span id="more"></span><h3 id="Python的面向对象编程"><a href="#Python的面向对象编程" class="headerlink" title="Python的面向对象编程"></a>Python的面向对象编程</h3><p>面向对象学的很多了，直接上一段类的代码分析一下就好，以下是一段我在项目中写的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">    _<span class="built_in">id</span> = <span class="string">&quot;Entity&quot;</span>    <span class="comment">#_id表示保护变量，只能允许其本身与子类进行访问，不能用于 from module import * ，__id表示私有变量，只能允许这个类本身进行访问。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  <span class="comment">#__init__是python中的特殊函数之一，作为构造函数。</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Something the player can interact with</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._collidable = <span class="literal">True</span>  <span class="comment">#与Java中不太相同的是，python的类变量不需要全部声明在类中。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_id</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_collide</span>(<span class="params">self, collidable</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        self._collidable = collidable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_collide</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._collidable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>     <span class="comment">#__str__和__repr__也是特殊函数，用于将值或者说类转化为字符串形式，但有区分，此处不细说。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.__class__.__name__&#125;</span>()&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要说明的是，在python中不引入模块的话是无法创建抽象类的，但我可以将Entity类当作抽象类来使用。<br>如果需要构建抽象类，下面是抽象类的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc <span class="comment">#利用abc模块实现抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">All_file</span>(<span class="params">metaclass=abc.ABCMeta</span>):</span></span><br><span class="line">    all_type=<span class="string">&#x27;file&#x27;</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment">#定义抽象方法，无需实现功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;子类必须定义读功能&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod </span><span class="comment">#定义抽象方法，无需实现功能</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&#x27;子类必须定义写功能&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Txt</span>(<span class="params">All_file</span>):</span> <span class="comment">#子类继承抽象类，但是必须定义read和write方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;文本数据的读取方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;文本数据的读取方法&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面继续说回刚刚我定义的实体类Entity，如下有几个类对其进行了继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wall</span>(<span class="params">Entity</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _<span class="built_in">id</span> = WALL</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.set_collide(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">Entity</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_hit</span>(<span class="params">self, game</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure><p>WALL是一个可以使用的类，而Item则是另一个抽象基类。这里raise用于抛出异常 类似java中throw。而调用父类方法需要用super().xxx<br>而Item是我需要用来创建各种游戏中角色的基类（这个项目是一个tkinter的游戏），如下是他的其中一个子类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveIncrease</span>(<span class="params">Item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    _<span class="built_in">id</span> = MOVE_INCREASE</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, moves=<span class="number">5</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._moves = moves</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_hit</span>(<span class="params">self, game</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; &quot;&quot;&quot;</span></span><br><span class="line">        player = game.get_player()</span><br><span class="line">        player.change_move_count(self._moves)</span><br><span class="line">        game.get_game_information().pop(player.get_position())</span><br></pre></td></tr></table></figure><p>为子类创建实例 –&gt;&gt; m=MoveIncrease()<br>调用实例函数 –&gt;&gt; m.on_hit(game)<br>调用实例变量 –&gt;&gt; m.id          当然调用的方式有很多比如getattr()之类，就不一一列举了。</p><p>python中的类还有一些内置属性：<br>“<strong>dict</strong>“ : 类的属性（包含一个字典，由类的数据属性组成）<br>“<strong>doc</strong>“ :类的文档字符串<br>“<strong>name</strong>“: 类名<br>“<strong>module</strong>“: 类定义所在的模块（类的全名是’<strong>main</strong>.className’，如果类位于一个导入模块mymod中，那么className.<strong>module</strong> 等于 mymod）<br>“<strong>bases</strong>“ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）</p><p>关于重写方法，只要在子类中使用与父类中相同函数名就可以了。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这只是面向对象最基础的部分，还有许多如运算符重载，垃圾回收等等没有写入进去，留待日后有心得再补充。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;断更两个多月了，一直在忙学校的事情，疫情下压缩课时，每天都有很多事情要处理，现在终于放假了，继续&lt;br&gt;开始更新这两个月内的学习收获，这两个月在python和java的基础方面进行了很多实践，这篇来记录一下python的面向对象编程收获，都是一些基础知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE基础笔记-多态(继承)，异常处理，文件流，比较器</title>
    <link href="http://silencezheng.top/2020/10/12/article22/"/>
    <id>http://silencezheng.top/2020/10/12/article22/</id>
    <published>2020-10-12T12:30:55.000Z</published>
    <updated>2020-10-12T12:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>两天做了两个很有意思的项目，一个Nim游戏，一个塔防游戏，对类与继承，比较器，异常处理和文件IO操作<br>的训练效果还是挺不错的，收获很多，写一篇笔记来记录一下学习效果。源代码有需要的可以微博联系我，<br>虽然我代码写的很乱哈。</p><span id="more"></span><h3 id="从Nim游戏中理解比较器，异常处理和文件流操作"><a href="#从Nim游戏中理解比较器，异常处理和文件流操作" class="headerlink" title="从Nim游戏中理解比较器，异常处理和文件流操作"></a>从Nim游戏中理解比较器，异常处理和文件流操作</h3><p>先来简述一下Nim游戏的规则吧，给出一堆石子的总数和每次允许取出的最大上限，两个玩家开始按<br>规则取石子，取走最后一个石子的玩家Lose，规则很简单。（关于这个游戏的继承我不详细说，有些简单，<br>塔防游戏要更复杂一些，用于对类与继承进行理解更加深刻。） 我们要做的任务就是：</p><ul><li>制作一个类Linux的命令行面板用于接收输入，注意：命令可能会有数量不等的参数传入。</li><li>游戏运行有100个用户同时存在，但游戏同一时间内只能存在一场对局。</li><li>用户的数据统计和基本信息在游戏界面程序启动时从文件中读取并在游戏程序关闭时写入文件。（也就是一个数据库）</li><li>要求能够实现添加玩家，添加AI玩家，删除玩家，编辑玩家基本信息，重置玩家数据统计，展示玩家信息，按数据统计顺序逆序排名等功能。</li><li>没错，这个游戏需要实现人机对战和机机对战。</li><li>程序要能够处理异常，包括移动石子数，参数不足和指令不存在。</li></ul><p>命令行面板如下图，下图展示的是commands功能：<br><img src="/assets/post_img/article22/nimcmd.png" alt="NIMCommands"><br><strong>类的设计</strong><br>那对游戏本身有了一个了解之后我们就要去设计类了，显然玩家分为人类玩家和AI玩家，让这两个类继承玩家类就好了，<br>因为AI除了在移动石子上不需要从键盘输入以外和人类玩家的其他信息都是一样的，所以只需要重写移动方法。<br>接下来一个NimGame类用来实现游戏主体，一个NimSys类用来管理命令行面板和其他功能，在需要游戏的时候，创建<br>一个游戏实体就好了。</p><p><strong>命令行面板实现</strong><br>项目要求指令有不同的参数传入，指令和参数间用空格隔开，参数和参数间用英文逗号隔开。<br>这里记录第一个问题，就是java的Scanner缺陷问题。<br><font color=#FF4500 size=4 face="黑体">1 Scanner的hasNext方法无法检测是否有下一个输入</font><br>java开发文档这样解释：<br>public boolean hasNext()<br>如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。</p><p>经过我各种实验发现这个方法在交互上没有任何作用，所以舍弃。于是改用另一种办法：在死循环中用next()与指令进行比对<br>配对成功进入对应函数，不成功抛出异常。 但问题在于，接受了next()后，如果同行有参数传入，如何处理？<br>关键在于<strong>nextLIne()</strong>函数，在同行读取了指令的情况下使用<strong>nextLIne()</strong>可以读取到指令后面的所有内容。<br>这样再用split处理就可以得到想要的参数数组了，同样，如果个数不够，抛出异常。<br>ps：去除字符串首尾空格用.trim()函数。</p><p><strong>玩家信息用文件流存储</strong><br>这个实现起来相对简单，方法也很多，我只提供一种读写方式作为参考。<br><font color=#FF4500 size=4 face="黑体">2 Buffered包装文件流处理</font></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">写入方法：</span><br><span class="line">String url = <span class="string">&quot;./players.dat&quot;</span>;<span class="comment">//存储地址</span></span><br><span class="line">        File database = <span class="keyword">new</span> <span class="constructor">File(<span class="params">url</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!database.exists<span class="literal">()</span>)&#123;</span><br><span class="line">            database.create<span class="constructor">NewFile()</span>;<span class="comment">//不存在就创建，注意mkdir是创建文件夹，文件要用createNewFile</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            database.delete<span class="literal">()</span>;</span><br><span class="line">            database.create<span class="constructor">NewFile()</span>;<span class="comment">//因为启动都要读取数据到缓存，所以退出时删了重写就好</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读入</span></span><br><span class="line">        <span class="keyword">if</span>(this.players.is<span class="constructor">Empty()</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            BufferedWriter writer = <span class="keyword">new</span> BufferedWriter (<span class="keyword">new</span> <span class="constructor">OutputStreamWriter(<span class="params">new</span> FileOutputStream(<span class="params">database</span>,<span class="params">false</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            NimPlayer value = null;</span><br><span class="line">            Iterator iter = this.players.iterator<span class="literal">()</span>;<span class="comment">//迭代器遍历玩家数组</span></span><br><span class="line">            <span class="keyword">while</span> (iter.has<span class="constructor">Next()</span>) &#123;</span><br><span class="line">                value = (NimPlayer) iter.next<span class="literal">()</span>;</span><br><span class="line">                String tmp = value.get<span class="constructor">INFO()</span>;<span class="comment">//给玩家一个格式化信息的方法便于写入</span></span><br><span class="line">                writer.write(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.flush<span class="literal">()</span>;<span class="comment">//强制将缓冲区中数据发送出去，不必等到缓冲区满</span></span><br><span class="line">            writer.close<span class="literal">()</span>;<span class="comment">//关闭流，习惯要好。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">读入方法：</span><br><span class="line">String url = <span class="string">&quot;./players.dat&quot;</span>;</span><br><span class="line">        File database = <span class="keyword">new</span> <span class="constructor">File(<span class="params">url</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (database.exists<span class="literal">()</span>)&#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">new</span> InputStreamReader(<span class="params">new</span> FileInputStream(<span class="params">database</span>)</span>,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                String stmp = reader.read<span class="constructor">Line()</span>;</span><br><span class="line">                <span class="keyword">if</span> (stmp==null)&#123;</span><br><span class="line">                    break;<span class="comment">//读到末尾</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    String<span class="literal">[]</span> tmp = stmp.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (tmp.length&gt;<span class="number">5</span>)&#123;</span><br><span class="line">                        NimAIPlayer tmpPlayer = <span class="keyword">new</span> <span class="constructor">NimAIPlayer(<span class="params">tmp</span>[0],<span class="params">tmp</span>[1],<span class="params">tmp</span>[2],Integer.<span class="params">parseInt</span>(<span class="params">tmp</span>[3])</span>,<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">tmp</span>[4])</span>);</span><br><span class="line">                        this.players.add(tmpPlayer);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        NimPlayer tmpPlayer = <span class="keyword">new</span> <span class="constructor">NimPlayer(<span class="params">tmp</span>[0],<span class="params">tmp</span>[1],<span class="params">tmp</span>[2],Integer.<span class="params">parseInt</span>(<span class="params">tmp</span>[3])</span>,<span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">tmp</span>[4])</span>);</span><br><span class="line">                        this.players.add(tmpPlayer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>玩家数组</strong><br>玩家数组这里我用ArrayList设置定长100处理（其实没必要），推荐个帖子：<a href="https://www.cnblogs.com/msymm/p/9872818.html">https://www.cnblogs.com/msymm/p/9872818.html</a></p><p><strong>玩家信息按字母a-z顺序打印</strong><br>这个功能实现起来用两个技巧，一个是compareTo方法对String类型的处理，一个是通过重写比较器Comparator的compara接口来<br>实现排序功能。话不多说直接上代码。<br><font color=#FF4500 size=3 face="黑体">3 比较器</font></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(console.players, <span class="keyword">new</span> Comparator&lt;NimPlayer&gt;<span class="literal">()</span> &#123;</span><br><span class="line">@Override</span><br><span class="line">public <span class="built_in">int</span> compare(NimPlayer s1, NimPlayer s2) &#123;</span><br><span class="line">String name1 = s1.get<span class="constructor">Username()</span>.<span class="keyword">to</span><span class="constructor">LowerCase()</span>;</span><br><span class="line">String name2 = s2.get<span class="constructor">Username()</span>.<span class="keyword">to</span><span class="constructor">LowerCase()</span>;</span><br><span class="line"><span class="built_in">int</span> num = name1.compare<span class="constructor">To(<span class="params">name2</span>)</span>;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//display all</span></span><br><span class="line"><span class="keyword">for</span> (NimPlayer aplayer:console.players) &#123;</span><br><span class="line">String info = <span class="string">&quot;&quot;</span>;</span><br><span class="line">info = info+aplayer.get<span class="constructor">Username()</span>+<span class="string">&quot;, &quot;</span>+aplayer.get<span class="constructor">Firstname()</span>+<span class="string">&quot;, &quot;</span>+aplayer.get<span class="constructor">Famname()</span>+<span class="string">&quot;, &quot;</span>+aplayer.get<span class="constructor">Turns()</span>+<span class="string">&quot; games, &quot;</span>+aplayer.get<span class="constructor">Wins()</span>+<span class="string">&quot; wins&quot;</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个重点要记住：形参s1的实参为数组中第二个对象。<br>举个例子：[Mike，Allen] 有一个这样的玩家数组，当用比较器排序时，传入参数s1为Allen，s2为Mike。然后String的compareTo方法<br>会比较字符串1的第一个字符跟字符串2的第一个字符不相等，则两个字符串都按照第一个字符的ASCII码顺序进行比较，其他字符都不用看<br>，并返回一个整型（ASCII码的差值）。这里a-m = 97-109 = -12 。 之后比较器会判断权重，因为返回了负数，所以后者会排在前面。</p><p><img src="/assets/post_img/article22/asc2.jpeg" alt="ASCII码"></p><p><strong>ranking按胜率排序</strong><br>按胜率排序，胜率相同按字母顺序排序。类似，直接上代码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//make ordered</span></span><br><span class="line">         Collections.<span class="built_in">sort</span>(<span class="keyword">this</span>.players, <span class="keyword">new</span> Comparator&lt;NimPlayer&gt;() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             <span class="keyword">public</span> <span class="built_in">int</span> compare(NimPlayer s1, NimPlayer s2) &#123;</span><br><span class="line">                 <span class="built_in">int</span> <span class="built_in">key</span> = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">String</span> name1 = s1.getUsername().toLowerCase();</span><br><span class="line">                 <span class="keyword">String</span> name2 = s2.getUsername().toLowerCase();</span><br><span class="line">                 <span class="built_in">int</span> num1 = name1.compareTo(name2);</span><br><span class="line">                 <span class="comment">//System.out.println(s1.getWinRate()+&quot;   &quot;+s2.getWinRate());</span></span><br><span class="line">                 <span class="keyword">double</span> dnum2 = s1.getWinRate() - s2.getWinRate();</span><br><span class="line">                 <span class="comment">//System.out.println(dnum2);</span></span><br><span class="line">                 <span class="keyword">if</span> (dnum2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                     <span class="built_in">key</span> =  <span class="number">-1</span>;</span><br><span class="line">                 &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dnum2==<span class="number">0</span>)&#123;</span><br><span class="line">                     <span class="built_in">key</span> = num1;</span><br><span class="line">                 &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dnum2&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                     <span class="built_in">key</span> =  <span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="built_in">key</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><p><strong>人机对战</strong><br>其他与人类玩家一样，只是在接受输入的使用通过判断是机器人玩家后，直接从机器人玩家中获取移动的石子数，<br>这里分享一个我写的Nim游戏必胜策略，不一定准确。可以通过简单测试。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">do</span> a <span class="keyword">input</span></span><br><span class="line">   <span class="built_in">public</span> <span class="type">boolean</span> isVictory(<span class="type">int</span> stoneremain, <span class="type">int</span> upperbound,<span class="type">int</span> <span class="keyword">move</span>)&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)&#123;</span><br><span class="line">           <span class="keyword">if</span>((stoneremain-<span class="keyword">move</span>) == k*(upperbound+<span class="number">1</span>)+<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">public</span> <span class="type">int</span> removeStone(<span class="type">int</span> upperbound,<span class="type">int</span> stoneremain)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="keyword">limit</span> = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (upperbound&gt;=stoneremain)&#123;</span><br><span class="line">           <span class="keyword">limit</span> = stoneremain;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (upperbound&lt;stoneremain)&#123;</span><br><span class="line">           <span class="keyword">limit</span> = upperbound;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> movedStones = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="keyword">limit</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span> (isVictory(stoneremain,upperbound,i))&#123;</span><br><span class="line">               movedStones = i;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (movedStones==<span class="number">0</span>)&#123;</span><br><span class="line">           movedStones = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="keyword">after</span> = stoneremain - movedStones;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">after</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="从塔防游戏中理解抽象类，继承，抽象方法和重写方法。"><a href="#从塔防游戏中理解抽象类，继承，抽象方法和重写方法。" class="headerlink" title="从塔防游戏中理解抽象类，继承，抽象方法和重写方法。"></a>从塔防游戏中理解抽象类，继承，抽象方法和重写方法。</h3><p>同样，简单说下题目。<br><img src="/assets/post_img/article22/bee.png" alt="Bee塔防"><br>图中有两类对象，地砖Tile和昆虫Insect，昆虫分为蜜蜂和马蜂，蜜蜂有三种，分别是BusyBee、StingyBee和TankyBee。<br>这个游戏可以用植物大战僵尸来类比，上面三种分别对应太阳花，豌豆射手和地刺。<br>下面主要从蜜蜂类来学习多态的一些方法。</p><p><strong>抽象类</strong><br>如果一个类中没有包含足够的信息来描绘一个具体的对象，将这个类称为抽象类。<br>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。在Java中抽象类表示的是一种继承关系，一个类只能继承<br>一个抽象类，而一个类却可以实现多个接口。举个例子来说明为什么要写一个抽象类，在植物大战僵尸的游戏流程中，只需要<br>出现豌豆射手和冰冻豌豆射手就好了，对“射手”这个父类没有实例化需求，那么将这个类设置为抽象类。同理，蜜蜂和马蜂同属<br>于昆虫类，故将昆虫类设置为抽象类。下面给一个我写的抽象类例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Tile myTile;</span><br><span class="line">    <span class="keyword">private</span> int hp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Insect(Tile aTile,int hp)&#123;</span><br><span class="line">        <span class="keyword">this</span>.myTile = aTile;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.myTile.addInsect(<span class="keyword">this</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Tile getPosition()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.myTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int getHealth()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setPosition(Tile newTile)&#123;</span><br><span class="line">        <span class="keyword">this</span>.myTile = newTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//other methods</span></span><br><span class="line">    <span class="keyword">public</span> void takeDamage(int damage)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> instanceof HoneyBee &amp;&amp; <span class="keyword">this</span>.myTile.isHive())&#123;</span><br><span class="line">            damage = (int) (damage*<span class="number">0.9</span>);</span><br><span class="line">            <span class="keyword">this</span>.hp = <span class="keyword">this</span>.hp-damage;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hp&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.myTile.removeInsect(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.hp = <span class="keyword">this</span>.hp-damage;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hp&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.myTile.removeInsect(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> boolean takeAction();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean equals(Object o)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>==o)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o instanceof Insect))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Insect io = (Insect) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.myTile.equals(io.myTile) &amp;&amp; <span class="keyword">this</span>.hp==io.hp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了基本的成员变量和构造方法，该抽象类中还包含一个抽象方法takeAction()和重写的equals方法。</p><p><strong>重写方法和继承</strong><br>重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！<br>重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。<br>下面给出蜜蜂类来再看一下重写方法，因为蜜蜂类也不需要实例化，所以设置为抽象类，继承昆虫这个抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HoneyBee</span> <span class="keyword">extends</span> <span class="title">Insect</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost4Food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoneyBee</span><span class="params">(Tile aTile, <span class="keyword">int</span> hp,<span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aTile, hp);  <span class="comment">//我们在继承父类时，不需要将同样的代码再写一遍，直接使用super关键字调用父类构造方法。</span></span><br><span class="line">        <span class="keyword">this</span>.cost4Food = cost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cost4Food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(o))&#123;  <span class="comment">//同样调用父类方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> HoneyBee))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HoneyBee io = (HoneyBee) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cost4Food == io.cost4Food)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=#FF4500 size=3 face="黑体">4 重写方法的一些规则</font></p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更高。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p>另外，关于为什么要重写equals方法，这里有一篇博客写的比较好：<a href="https://blog.csdn.net/panchao888888/article/details/80888592">https://blog.csdn.net/panchao888888/article/details/80888592</a><br>我这里从中摘录一些：<br><font color=#FF4500 size=3 face="黑体">5 为什么要重写equals()方法？</font><br>1.Object类中equals方法比较的是两个对象的引用地址，只有对象的引用地址指向同一个地址时，才认为这两个地址是相等的，否则这两个对象就不想等。</p><p>2.如果有两个对象，他们的属性是相同的，但是地址不同，这样使用equals()比较得出的结果是不相等的，而我们需要的是这两个对象相等，因此默认的equals()方法是不符合我们的要求的，这个时候我们就需要对equals()方法进行重写以满足我们的预期结果。</p><p>3.在java的集合框架中需要用到equals()方法进行查找对象，如果集合中存放的是自定义类型，并且没有重写equals()方法，则会调用Object父类中的equals()方法按照地址比较，往往会出现错误的结果，此时我们应该根据业务需求重写equals()方法。</p><p><strong>抽象方法</strong><br>抽象方法和抽象类的使用原因十分相似，都是为了个性化定制每个实体类的方法，而将方法名统一。<br>下面用StingyBee类继承蜜蜂类来具体看一下如何重写抽象方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StingyBee</span> <span class="title">extends</span> <span class="title">HoneyBee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> int attack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StingyBee(Tile aTile, int attack) &#123;</span><br><span class="line">        <span class="keyword">super</span>(aTile, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.attack = attack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean takeAction() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getPosition().isHive()||<span class="keyword">this</span>.getPosition().isOnThePath())&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.getPosition().getHornet()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.getPosition().isNest())&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.getPosition().getHornet().takeDamage(<span class="keyword">this</span>.attack);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Tile tmp = <span class="keyword">this</span>.getPosition().towardTheNest();</span><br><span class="line">                    <span class="keyword">if</span> (tmp.isNest())&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (tmp.isNest())&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (tmp.getHornet()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                                tmp.getHornet().takeDamage(<span class="keyword">this</span>.attack);</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                tmp = tmp.towardTheNest();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean equals(Object o)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.equals(o))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(o instanceof StingyBee))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StingyBee io = (StingyBee) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.attack == io.attack)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>断断续续写了三天才完成这篇文章，写的还是不是很满意，但是想记录的东西都记录下来了，有什么问题欢迎来微博找我交流。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;两天做了两个很有意思的项目，一个Nim游戏，一个塔防游戏，对类与继承，比较器，异常处理和文件IO操作&lt;br&gt;的训练效果还是挺不错的，收获很多，写一篇笔记来记录一下学习效果。源代码有需要的可以微博联系我，&lt;br&gt;虽然我代码写的很乱哈。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jQuery写法规范和chrome无法自动播放视频问题解决</title>
    <link href="http://silencezheng.top/2020/10/07/article21/"/>
    <id>http://silencezheng.top/2020/10/07/article21/</id>
    <published>2020-10-07T07:05:16.000Z</published>
    <updated>2020-10-07T14:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>做了个纯html实现引导页加网课视频答题demo的小项目，总结一下技术要点，太久不写html基础语法都不记得了。</p><span id="more"></span><p>1 <strong>jq入口函数以及js入口函数</strong><br>没有用入口函数可能导致一些功能失效报错。</p><p>jQuery 入口函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 开始写 jQuery 代码...</span></span><br><span class="line"> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。</p><p>如果在文档没有完全加载之前就运行函数，操作可能失败。</p><p>JavaScript 入口函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery 入口函数与 JavaScript 入口函数的区别：</p><ul><li>jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。</li><li>JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。</li></ul><p>2 <strong>jQuery选择器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;p&quot;</span>) 选取 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;p.intro&quot;</span>) 选取所有 <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;intro&quot;</span> 的 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;p#demo&quot;</span>) 选取所有 id=<span class="string">&quot;demo&quot;</span> 的 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;[href]&quot;</span>) 选取所有带有 href 属性的元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;[href=&#x27;#&#x27;]&quot;</span>) 选取所有带有 href 值等于 <span class="string">&quot;#&quot;</span> 的元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;[href!=&#x27;#&#x27;]&quot;</span>) 选取所有带有 href 值不等于 <span class="string">&quot;#&quot;</span> 的元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;[href$=&#x27;.jpg&#x27;]&quot;</span>) 选取所有 href 值以 <span class="string">&quot;.jpg&quot;</span> 结尾的元素。</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>,<span class="string">&quot;red&quot;</span>); <span class="comment">//css选择器</span></span><br></pre></td></tr></table></figure><p>3 <strong>html页面中的路径问题</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 相对路径写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ./ 表示当前文件所在目录，即404.html所在目录，即G:/testworkspace/ --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ./可省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;logo.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;./logo.png&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ../ 表示当前文件所在目录的上级目录，即G:/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;../testworkspace/logo.png&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- /表示根路径，即G:/ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;/testworkspace/logo.png&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 绝对路径写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;G:/testworkspace/logo.png&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般能用相对不要用绝对</p><p>4 <strong>实现视频播到一半弹出答题界面</strong><br>主要用currentTime和duration属性，在当前进度达到视频总长的一半时，用js操作弹出界面，<br>我是采用jq隐藏加显示的方式。<br>HTML5音视频相关DOM链接在这：<a href="https://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp">https://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</a></p><p>5 <strong>引导页加载自动播放和把video铺满全屏的方式</strong><br>这里我只说chrome可以使用的方法，因为objectfill貌似很多浏览器不兼容。<br>先说把视频铺满屏幕，下面是html文件中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;prevideo&#x27;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bt&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;skip()&quot;</span>&gt;</span>开始学习<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">video</span> <span class="attr">class</span> =<span class="string">&quot;video&quot;</span> <span class="attr">id</span> =<span class="string">&quot;video&quot;</span> <span class="attr">autoplay</span> <span class="attr">muted</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;src/insec.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span> /&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后是css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">                   <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">                   <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="selector-class">.prevideo</span>&#123;</span><br><span class="line">                   <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">                   <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">                   <span class="attribute">position</span>: absolute;    </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="selector-class">.video</span>&#123;</span><br><span class="line">                   <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">                   <span class="attribute">position</span>: absolute;</span><br><span class="line">                   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">                   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">                   <span class="attribute">min-width</span>: <span class="number">100%</span>;</span><br><span class="line">                   <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">                   <span class="attribute">object-fit</span>: fill;<span class="comment">/*这里是关键*/</span></span><br><span class="line">                   <span class="attribute">width</span>: auto;</span><br><span class="line">                   <span class="attribute">height</span>: auto;</span><br><span class="line">                   -ms-<span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">                   -webkit-<span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">                   <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">                   <span class="attribute">background-size</span>: cover;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="selector-id">#bt</span>&#123;</span><br><span class="line">                   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">                   <span class="attribute">left</span>: <span class="number">45%</span>;</span><br><span class="line">                   <span class="attribute">right</span>: <span class="number">45%</span>;</span><br><span class="line">                   <span class="attribute">bottom</span>: <span class="number">50%</span>;</span><br><span class="line">                   <span class="attribute">text-align</span>: center;</span><br><span class="line">                   <span class="attribute">position</span>: absolute;</span><br><span class="line">                   <span class="attribute">z-index</span>: <span class="number">102</span>;</span><br><span class="line">                   <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">                   <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">                   <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>然后是自动播放，chrome从某个版本后禁止了交互前自动播放视频，如果非要自动播放需要在video标签<br>加静音属性，即上面html代码中：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video <span class="keyword">class</span> =&quot;<span class="symbol">video</span>&quot; <span class="symbol">id</span> =&quot;<span class="symbol">video</span>&quot; <span class="symbol">autoplay</span> <span class="symbol">muted</span>&gt;</span><br></pre></td></tr></table></figure><p>6 <strong>js页面跳转</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">window.location.href</span>=<span class="string">&#x27;hello.html&#x27;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>7 <strong>video标签的controls属性</strong><br>controls 属性是一个 boolean(布尔) 属性。</p><p>controls 属性规定浏览器应该为视频提供播放控件。</p><p>如果设置了该属性，则规定不存在作者设置的脚本控件。</p><p>浏览器控件应该包括：</p><ul><li>播放</li><li>暂停</li><li>定位</li><li>音量</li><li>全屏切换</li><li>字幕（如果可用）</li><li>音轨（如果可用）    </li></ul><p>用法如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;video controls&gt;</span><span class="section">&lt;/video&gt;</span></span><br></pre></td></tr></table></figure><p>8 <strong>解决html页面在浏览器中乱码</strong><br>在html标签下面添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span><span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>扩展资料：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attribute">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;meta <span class="attribute">http-equiv</span>=<span class="string">&quot;Content-Language&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;zh-CN&quot;</span> /&gt;</span><br><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">&quot;author&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">&quot;Copyright&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">&quot;description&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span><br><span class="line">&lt;meta <span class="attribute">content</span>=<span class="string">&quot;&quot;</span> <span class="attribute">name</span>=<span class="string">&quot;keywords&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>第一行说明了他的文字编码<br>第二行说明了他采用的语言<br>第三行说明了他的作者<br>第四行说明了他的版权<br>第五行是对网站的简单描述<br>第六行是说明了本网站的关键字</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;做了个纯html实现引导页加网课视频答题demo的小项目，总结一下技术要点，太久不写html基础语法都不记得了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="http://silencezheng.top/tags/HTML/"/>
    
    <category term="Javascript" scheme="http://silencezheng.top/tags/Javascript/"/>
    
    <category term="Chrome" scheme="http://silencezheng.top/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用操作汇总</title>
    <link href="http://silencezheng.top/2020/10/05/article20/"/>
    <id>http://silencezheng.top/2020/10/05/article20/</id>
    <published>2020-10-05T12:08:24.000Z</published>
    <updated>2020-10-05T12:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做了下Linux上的网络诊断，Ubantu和CentOS用了一下，<br>感觉还是Ubantu更好用些，下面写点简单命令行操作用来给自己记录一下。</p><span id="more"></span><p><strong>复制</strong><br>cp–该命令的功能是将给出的文件或目录拷贝到另一文件或目录中。</p><p>语法： cp [选项] 源文件或目录 目标文件或目录<br>说明：该命令把指定的源文件复制到目标文件或把多个源文件复制到目标目录中。</p><p>该命令的各选项含义如下：</p><ul><li>-a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。</li><li>-d 拷贝时保留链接。</li><li>-f 删除已经存在的目标文件而不提示。</li><li>-i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。</li><li>-p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。</li><li>-r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。</li><li>-l 不作拷贝，只是链接文件。</li></ul><p>为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名已存在，用cp命令拷贝文件后，这个文件就会被新源文件覆盖，<br>因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。</p><p><strong>新建文件</strong><br>touch–在当前工作目录底下新建一个文件</p><p>语法：touch 文件名.后缀</p><p><strong>删除</strong><br>rm–删除文件和文件夹</p><p>语法：rm [选项] 文件名或文件夹名</p><p>该命令的各选项含义如下：</p><ul><li>-f、–force    强力删除，不要求确认</li><li>-i        每删除一个文件或进入一个子目录都要求确认</li><li>-I        在删除超过三个文件或者递归删除前要求确认</li><li>-r、-R    递归删除子目录</li><li>-d、-dir    删除空目录</li><li>-v、-verbose    显示删除结果</li></ul><p>下面删除文件夹的例子加深理解：<br>1 删除文件夹的内容包括文件夹：<br>rm -rf 文件夹的名字       （-r 是 循环的意思， f是不询问的意思）</p><p>2 删除文件夹的内容不包括文件夹：<br>rm -rf  文件夹的名字/*      (后面加上/*表示删除内容不删除文件夹)</p><p><strong>ls输出的文件和目录颜色含义（默认）</strong><br><font color=#000000 size=5 face="黑体">白色</font>：表示普通文件<br><font color=#0000FF size=5 face="黑体">蓝色</font>：表示目录<br><font color=#228B22 size=5 face="黑体">绿色</font>：表示可读执行文件<br><font color=#FF4500 size=5 face="黑体">红色</font>：表示压缩文件<br><font color=#AFEEEE size=5 face="黑体">浅蓝色</font>：链接文件<br><font color=#DC143C size=5 face="黑体">红色闪烁</font>：表示链接的文件有问题<br><font color=#FFFF00 size=5 face="黑体">黄色</font>：表示设备文件<br><font color=grey size=5 face="黑体">灰色</font>：表示其他文件</p><p>这个颜色可以在配置文件中修改。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近做了下Linux上的网络诊断，Ubantu和CentOS用了一下，&lt;br&gt;感觉还是Ubantu更好用些，下面写点简单命令行操作用来给自己记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://silencezheng.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTML中input控件接受docx文件问题解决</title>
    <link href="http://silencezheng.top/2020/10/05/article19/"/>
    <id>http://silencezheng.top/2020/10/05/article19/</id>
    <published>2020-10-05T09:09:24.000Z</published>
    <updated>2020-10-07T06:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近做web文件上传发现从前端控制文件格式的时候在input控件accept属性里找不到.docx，所以从网上查了下，解决了。</p><span id="more"></span><p>先给出部分accept可接受的信息表：</p><table><thead><tr><th>扩展名</th><th align="right">对应属性</th><th align="center">文件格式</th></tr></thead><tbody><tr><td>*.3gpp</td><td align="right">audio/3gpp, video/3gpp</td><td align="center">3GPP Audio/Video</td></tr><tr><td>*.ac3</td><td align="right">audio/ac3</td><td align="center">AC3 Audio</td></tr><tr><td>*.asf</td><td align="right">allpication/vnd.ms-asf</td><td align="center">Advanced Streaming Format</td></tr><tr><td>*.au</td><td align="right">audio/basic</td><td align="center">AU Audio</td></tr><tr><td>*.css</td><td align="right">text/css</td><td align="center">Cascading Style Sheets</td></tr><tr><td>*.csv</td><td align="right">text/csv</td><td align="center">Comma Separated Values</td></tr><tr><td>*.doc</td><td align="right">application/msword</td><td align="center">MS Word Document</td></tr><tr><td>*.dot</td><td align="right">application/msword</td><td align="center">MS Word Template</td></tr><tr><td>*.dtd</td><td align="right">application/xml-dtd</td><td align="center">Document Type Definition</td></tr><tr><td>*.dwg</td><td align="right">image/vnd.dwg</td><td align="center">AutoCAD Drawing Database</td></tr><tr><td>*.dxf</td><td align="right">image/vnd.dxf</td><td align="center">AutoCAD Drawing Interchange Format</td></tr><tr><td>*.gif</td><td align="right">image/gif</td><td align="center">Graphic Interchange Format</td></tr><tr><td>*.htm</td><td align="right">text/html</td><td align="center">HyperText Markup Language</td></tr><tr><td>*.html</td><td align="right">text/html</td><td align="center">HyperText Markup Language</td></tr><tr><td>*.jp2</td><td align="right">image/jp2</td><td align="center">JPEG-2000</td></tr><tr><td>*.jpe</td><td align="right">image/jpeg</td><td align="center">JPEG</td></tr><tr><td>*.jpeg</td><td align="right">image/jpeg</td><td align="center">JPEG</td></tr><tr><td>*.jpg</td><td align="right">image/jpeg</td><td align="center">JPEG</td></tr><tr><td>*.js</td><td align="right">text/javascript, application/javascript</td><td align="center">JavaScript</td></tr><tr><td>*.json</td><td align="right">application/json</td><td align="center">JavaScript Object Notation</td></tr><tr><td>*.mp3</td><td align="right">audio/mpeg</td><td align="center">MPEG Audio Stream, Layer III</td></tr><tr><td>*.mp4</td><td align="right">audio/mp4, video/mp4</td><td align="center">MPEG-4 Audio/Video</td></tr><tr><td>*.pdf</td><td align="right">application/pdf</td><td align="center">Portable Document Format</td></tr><tr><td>*.png</td><td align="right">image/png</td><td align="center">Portable Network Graphics</td></tr><tr><td>*.pot</td><td align="right">application/vnd.ms-powerpoint</td><td align="center">MS PowerPoint Template</td></tr><tr><td>*.pps</td><td align="right">application/vnd.ms-powerpoint</td><td align="center">MS PowerPoint Slideshow</td></tr><tr><td>*.ppt</td><td align="right">application/vnd.ms-powerpoint</td><td align="center">MS PowerPoint Presentation</td></tr><tr><td>*.svf</td><td align="right">image/vnd.svf</td><td align="center">Simple Vector Format</td></tr><tr><td>*.txt</td><td align="right">text/plain</td><td align="center">Plain Text</td></tr><tr><td>*.wdb</td><td align="right">application/vnd.ms-works</td><td align="center">MS Works Database</td></tr><tr><td>*.wps</td><td align="right">application/vnd.ms-works</td><td align="center">Works Text Document</td></tr><tr><td>*.xhtml</td><td align="right">application/xhtml+xml</td><td align="center">Extensible HyperText Markup Language</td></tr><tr><td>*.xlc</td><td align="right">application/vnd.ms-excel</td><td align="center">MS Excel Chart</td></tr><tr><td>*.xlm</td><td align="right">application/vnd.ms-excel</td><td align="center">MS Excel Macro</td></tr><tr><td>*.xls</td><td align="right">application/vnd.ms-excel</td><td align="center">MS Excel Spreadsheet</td></tr><tr><td>*.xlt</td><td align="right">application/vnd.ms-excel</td><td align="center">MS Excel Template</td></tr><tr><td>*.xlw</td><td align="right">application/vnd.ms-excel</td><td align="center">MS Excel Workspace</td></tr><tr><td>*.xml</td><td align="right">text/xml, application/xml</td><td align="center">Extensible Markup Language</td></tr><tr><td>*.zip</td><td align="right">aplication/zip</td><td align="center">Compressed Archive</td></tr></tbody></table><p>然后发现表中没有docx和xlsx等，继续查又发现了下图：<br><img src="/assets/post_img/article19/mme.png" alt="MIME"></p><p>尝试了该docx属性后发现无效。</p><p>最终通过：<br>    accept:”.docx”<br>发现在chrome中可用，不知道其他浏览器是不是也这样，可以直接用扩展名尝试。<br>不过这个accept属性只是一个伪限制，真要限制传入文件格式还得进行js方面的限制才行。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近做web文件上传发现从前端控制文件格式的时候在input控件accept属性里找不到.docx，所以从网上查了下，解决了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="http://silencezheng.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Maven学习日记-02</title>
    <link href="http://silencezheng.top/2020/10/05/article18/"/>
    <id>http://silencezheng.top/2020/10/05/article18/</id>
    <published>2020-10-05T08:31:01.000Z</published>
    <updated>2020-10-05T12:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>持续学习中，解决了项目创建多级包，Idea配置本地仓库等问题。<br>IDE：idea 2020.1.1<br>Maven：apache-maven-3.6.3</p><span id="more"></span><p><strong>如何在Idea项目中配置Maven本地仓库</strong></p><p>1 setting中搜索Maven找到Build Tools下的Maven，点击：</p><p><img src="/assets/post_img/article18/mvnlocal.png" alt="ML"><br>上图红色笔画出的三个位置修改成本地Maven的路径即可，repo（即本地仓库）解压Maven后是没有的，需要手动创建。</p><p>2 修改配置文件内容，配置文件位置在maven包下conf\settings.xml，添加本地仓库的路径。</p><p><img src="/assets/post_img/article18/mvnconf.png" alt="MC"></p><p>3 在配置文件中添加阿里云远程仓库（为提高下载速度，不需要可不修改）、</p><p>在settings.xml中mirrors下添加：</p><p><img src="/assets/post_img/article18/mvnali.png" alt="MA"></p><p>到这里基本配置就完成了，但是下次打开项目时仓库路径还会变回去，此时需要修改Idea中File下的默认设置：<br>（注意原本的other settings新版本中已经没有了，从for new中修改）</p><p><img src="/assets/post_img/article18/set.png" alt="Set"></p><p><strong>Idea项目创建多级包</strong><br>勾选取消下面图中的设置即可。<br><img src="/assets/post_img/article18/duo.png" alt="DUO"></p><p><strong>如何在一个Maven项目中创建多个子项目</strong></p><ol><li>新建一个Maven项目，不要使用骨架。</li><li>删除src文件</li><li>new module创建Maven子项目<br>效果如下：<br><img src="/assets/post_img/article18/fs.png" alt="FATHERANDSON"></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;持续学习中，解决了项目创建多级包，Idea配置本地仓库等问题。&lt;br&gt;IDE：idea 2020.1.1&lt;br&gt;Maven：apache-maven-3.6.3&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Maven" scheme="http://silencezheng.top/tags/Maven/"/>
    
    <category term="Idea" scheme="http://silencezheng.top/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>idea编写swing项目的一些心得</title>
    <link href="http://silencezheng.top/2020/09/18/article17/"/>
    <id>http://silencezheng.top/2020/09/18/article17/</id>
    <published>2020-09-18T11:04:57.000Z</published>
    <updated>2020-09-21T09:23:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天用swing写了一个小项目，发现idea编写swing项目比起eclipse来说也是方便了不少，<br>以前只觉得javafx牛逼，现在发现swing也还不错，有了idea内置的可视化编辑加持，对于<br>写个小图形界面十分好用。下面做简单分享。</p><span id="more"></span><p>快速创建swing项目：</p><ol><li>new-&gt;Swing-&gt;GUI Form,打开form文件，会得到设计界面，左边为属性栏，<br>中间是界面呈现，右边是组件栏。</li><li>fieldname为组件在代码中的id，text为显示内容，align属性设置布局方式。</li><li>设计完成后在类中alt+insert选择FormMain可以生成main函数，但是建议另创建一个函数<br>存储该代码，在需要时调用。并且在idea中创建的swing项目会跟有一个.form文件，我个人理解<br>是用来存储界面样式，这样的项目在eclipse中是不能运行的，我尝试过添加form.rt的jar包进eclipse中<br>也并不能解决问题，所以idea编辑的swing项目还是不要到其他ide中运行比较好。</li></ol><p>为组件添加事件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">close.addMouseListener(<span class="keyword">new</span> <span class="function"><span class="title">MouseAdapter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">mouseClicked</span>(<span class="params">MouseEvent e</span>)</span> &#123;</span><br><span class="line">              jna.close();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>控制swing窗口大小和弹出位置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">frame</span>.setSize(<span class="number">600</span>,<span class="number">500</span>);</span><br><span class="line"><span class="attribute">frame</span>.setPreferredSize(new Dimension(<span class="number">600</span>,<span class="number">500</span>));</span><br></pre></td></tr></table></figure><p>窗口跳转方式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (isSuper==true)&#123;</span><br><span class="line"><span class="comment">//跳转</span></span><br><span class="line"><span class="selector-tag">frame</span><span class="selector-class">.dispose</span>();</span><br><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">superview</span>()<span class="selector-class">.back</span>();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JList更新数据（用ArrayList list来维护数据）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">back.get<span class="constructor">ShowList()</span>.set<span class="constructor">ListData(<span class="params">list</span>)</span>;</span><br></pre></td></tr></table></figure><p>要使list可滚动可以将其放入滚动面板中。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>关于javafx还是swing的问题<br>javafx比较新，Oracle2008年才推出的，功能比较强大，并且持续更新。swing是比较老的GUI框架，已经停止更新了。<br>但javafx的问题可能在于参考文档较少，使用的人也不多。虽然运行速度稍快，但swing下功夫也可以做出好看的界面，<br>如JB。所以我认为时下来说，swing并不算过时。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天用swing写了一个小项目，发现idea编写swing项目比起eclipse来说也是方便了不少，&lt;br&gt;以前只觉得javafx牛逼，现在发现swing也还不错，有了idea内置的可视化编辑加持，对于&lt;br&gt;写个小图形界面十分好用。下面做简单分享。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Idea" scheme="http://silencezheng.top/tags/Idea/"/>
    
    <category term="Swing" scheme="http://silencezheng.top/tags/Swing/"/>
    
  </entry>
  
  <entry>
    <title>idea2020.2新变动</title>
    <link href="http://silencezheng.top/2020/09/11/article16/"/>
    <id>http://silencezheng.top/2020/09/11/article16/</id>
    <published>2020-09-11T02:49:57.000Z</published>
    <updated>2020-09-11T03:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>好家伙今天一早起来打开idea，差点以为我退回社区版了，查了一上午才知道在idea最新的2020.2版本已经移除了原本创建web项目的方法，<br>也更改了Spring的创建流程！这波操作属实有点。。。看不懂。<br>信息来源：<a href="https://blog.csdn.net/qq_45738810/article/details/107842532">https://blog.csdn.net/qq_45738810/article/details/107842532</a></p><span id="more"></span><p>更新简介：<br><img src="/assets/post_img/article16/idea2020.2%E6%9B%B4%E6%96%B0.png" alt="2020.2updates"></p><p>现在创建Web项目要先创建一个普通的JAVA项目，然后右键项目名Add Framework Support，就能看到原来的<br>Web Application4.0了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好家伙今天一早起来打开idea，差点以为我退回社区版了，查了一上午才知道在idea最新的2020.2版本已经移除了原本创建web项目的方法，&lt;br&gt;也更改了Spring的创建流程！这波操作属实有点。。。看不懂。&lt;br&gt;信息来源：&lt;a href=&quot;https://blog.csdn.net/qq_45738810/article/details/107842532&quot;&gt;https://blog.csdn.net/qq_45738810/article/details/107842532&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Idea" scheme="http://silencezheng.top/tags/Idea/"/>
    
  </entry>
  
</feed>
