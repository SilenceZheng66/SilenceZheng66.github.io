<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilenceZheng66-BLOG</title>
  
  <subtitle>silencezheng.top</subtitle>
  <link href="http://silencezheng.top/atom.xml" rel="self"/>
  
  <link href="http://silencezheng.top/"/>
  <updated>2024-10-04T17:57:07.824Z</updated>
  <id>http://silencezheng.top/</id>
  
  <author>
    <name>SilenceZheng66</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线段树</title>
    <link href="http://silencezheng.top/2024/10/05/article143/"/>
    <id>http://silencezheng.top/2024/10/05/article143/</id>
    <published>2024-10-04T17:55:12.000Z</published>
    <updated>2024-10-04T17:57:07.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线段树是算法竞赛中常用的用来维护“区间信息”的数据结构。线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p><span id="more"></span><h1 id="线段树（Segment-Tree）"><a href="#线段树（Segment-Tree）" class="headerlink" title="线段树（Segment Tree）"></a>线段树（Segment Tree）</h1><p>线段树将每个长度不为$1$的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>有个大小为$5$的数组 a={10,11,12,13,14}，要将其转化为线段树，有以下做法：设线段树的根节点编号为$1$，用数组 $d$ 来保存我们的线段树，$d_i$ 用来保存线段树上编号为 $i$ 的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。这棵线段树的形态如下图所示：</p><p><img src="/assets/post_img/article143/segt1.svg" alt="segt1"></p><p>图中每个节点中用红色字体标明的区间，表示该节点管辖的 $a$ 数组上的位置区间。如 $d_1$ 所管辖的区间就是 $[1,5]$（$a_1,a_2, \cdots ,a_5$），即 $d_1$ 所保存的值是 $a_1+a_2+ \cdots +a_5$，$d_1=60$ 表示的是 $a_1+a_2+ \cdots +a_5=60$。</p><p>通过观察不难发现，$d_i$ 的左儿子节点就是 $d_{2\times i}$，$d_i$ 的右儿子节点就是 $d_{2\times i+1}$。如果 $d_i$ 表示的是区间 $[s,t]$（即 $d_i=a_s+a_{s+1}+ \cdots +a_t$）的话，那么 $d_i$ 的左儿子节点表示的是区间 $[ s, \frac{s+t}{2} ]$，$d_i$ 的右儿子表示的是区间 $[ \frac{s+t}{2} +1,t ]$。</p><h2 id="建树过程"><a href="#建树过程" class="headerlink" title="建树过程"></a>建树过程</h2><p>可以使用递归建树，设当前的根节点为 $p$，如果根节点管辖的区间长度已经是 $1$，则可以直接根据 $a$ 数组上相应位置的值初始化该节点。否则我们将该区间从中点处分割为两个子区间，分别进入左右子节点递归建树，最后合并两个子节点的信息。</p><p>采用数组堆式存储（$2p$ 是 $p$ 的左儿子，$2p+1$ 是 $p$ 的右儿子），若有 $n$ 个叶子结点，则数组的范围最大为 $2^{\left\lceil\log{n}\right\rceil+1}$。</p><p>分析：容易知道线段树的深度是 $\left\lceil\log{n}\right\rceil$ 的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\left\lceil\log{n}\right\rceil}$ 个，又由于其为一棵完全二叉树，则其总节点个数 $2^{\left\lceil\log{n}\right\rceil+1}-1$。当然也可以直接把数组长度设为 $4n$，因为 $\frac{2^{\left\lceil\log{n}\right\rceil+1}-1}{n}$ 的最大值在 $n=2^{x}+1(x\in N_{+})$ 时取到，此时节点数为 $2^{\left\lceil\log{n}\right\rceil+1}-1=2^{x+2}-1=4n-5$。</p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>仍然以最开始的图为例，如果要查询区间 $[1,5]$ 的和，那直接获取 $d_1$ 的值即可。</p><p>如果要查询的区间为 $[3,5]$，此时就不能直接获取区间的值，但是 $[3,5]$ 可以拆成 $[3,3]$ 和 $[4,5]$，可以通过合并这两个区间的答案来求得这个区间的答案。</p><p>一般地，如果要查询的区间是 $[l,r]$，则可以将其拆成最多为 $O(\log n)$ 个“极大”的区间，合并这些区间即可求出 $[l,r]$ 的答案。</p><h2 id="区间修改与懒惰标记"><a href="#区间修改与懒惰标记" class="headerlink" title="区间修改与懒惰标记"></a>区间修改与懒惰标记</h2><p>如果要求修改区间 $[l,r]$，把所有包含在区间 $[l,r]$ 中的节点都遍历一次、修改一次，时间复杂度无法承受。我们这里要引入一个叫做 「懒惰标记」 的东西。</p><p>懒惰标记，简单来说，就是通过延迟对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><h2 id="Java线段树模版（4n内存）"><a href="#Java线段树模版（4n内存）" class="headerlink" title="Java线段树模版（4n内存）"></a>Java线段树模版（4n内存）</h2><p>需要注意的是，Java的泛型由于存在擦除，因此在编译后实际上并不能拿到类型信息，所有的类型都是基类，导致不能实现算数运算，在限定<code>Number</code>的情况下，可以使用<code>double</code>值计算结果，需要在外部调用后进行类型转换。</p><p>可以区间加/求和的线段树模板：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegTreeLazyRangeAdd</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] tree; <span class="comment">// 使用 double 数组来存储树节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] lazy; <span class="comment">// 懒惰标记数组</span></span><br><span class="line">    <span class="keyword">private</span> T[] arr; <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n, root, n4, end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegTreeLazyRangeAdd</span><span class="params">(T[] v)</span> </span>&#123;</span><br><span class="line">        n = v.length;</span><br><span class="line">        n4 = n * <span class="number">4</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        arr = v;</span><br><span class="line">        Arrays.fill(tree, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(lazy, <span class="number">0</span>);</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        build(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="keyword">null</span>; <span class="comment">// Clear reference to the original array</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != cr &amp;&amp; lazy[p] != <span class="number">0</span>) &#123;</span><br><span class="line">            lazy[p * <span class="number">2</span>] += lazy[p]; <span class="comment">// 更新左子树的懒惰标记</span></span><br><span class="line">            lazy[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p]; <span class="comment">// 更新右子树的懒惰标记</span></span><br><span class="line">            tree[p * <span class="number">2</span>] += lazy[p] * (cm - cl + <span class="number">1</span>); <span class="comment">// 更新左子树的值</span></span><br><span class="line">            tree[p * <span class="number">2</span> + <span class="number">1</span>] += lazy[p] * (cr - cm); <span class="comment">// 更新右子树的值</span></span><br><span class="line">            lazy[p] = <span class="number">0</span>; <span class="comment">// 重置当前节点的懒惰标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p]; <span class="comment">// 当前子区间被查询区间完全覆盖</span></span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// 使用 double 类型进行求和</span></span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) sum += rangeSum(l, r, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) sum += rangeSum(l, r, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123; <span class="comment">// 如果当前区间是要更新区间的子区间</span></span><br><span class="line">            lazy[p] += val; <span class="comment">// 懒惰标记增加</span></span><br><span class="line">            tree[p] += (cr - cl + <span class="number">1</span>) * val; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rangeAdd(l, r, val, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) rangeAdd(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p] = arr[s].doubleValue(); <span class="comment">// 使用 double 类型</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, m, p * <span class="number">2</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSum(l, r, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeAdd</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        rangeAdd(l, r, val, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以区间修改/求和的线段树模板:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegTreeLazyRangeSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] tree; <span class="comment">// 存储树节点的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] lazy; <span class="comment">// 懒惰标记数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] ifLazy; <span class="comment">// 懒惰标记的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] arr; <span class="comment">// 原始数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n, root, n4, end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegTreeLazyRangeSet</span><span class="params">(<span class="keyword">double</span>[] v)</span> </span>&#123;</span><br><span class="line">        n = v.length;</span><br><span class="line">        n4 = n * <span class="number">4</span>;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="keyword">double</span>[n4];</span><br><span class="line">        ifLazy = <span class="keyword">new</span> <span class="keyword">boolean</span>[n4];</span><br><span class="line">        arr = v;</span><br><span class="line">        Arrays.fill(tree, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(lazy, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(ifLazy, <span class="keyword">false</span>);</span><br><span class="line">        end = n - <span class="number">1</span>;</span><br><span class="line">        root = <span class="number">1</span>;</span><br><span class="line">        build(<span class="number">0</span>, end, <span class="number">1</span>);</span><br><span class="line">        arr = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cm = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl != cr &amp;&amp; ifLazy[p]) &#123;</span><br><span class="line">            lazy[p * <span class="number">2</span>] = lazy[p];</span><br><span class="line">            ifLazy[p * <span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">            lazy[p * <span class="number">2</span> + <span class="number">1</span>] = lazy[p];</span><br><span class="line">            ifLazy[p * <span class="number">2</span> + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">            tree[p * <span class="number">2</span>] = lazy[p] * (cm - cl + <span class="number">1</span>);</span><br><span class="line">            tree[p * <span class="number">2</span> + <span class="number">1</span>] = lazy[p] * (cr - cm);</span><br><span class="line">            lazy[p] = <span class="number">0</span>;</span><br><span class="line">            ifLazy[p] = <span class="keyword">false</span>; <span class="comment">// 重置当前节点的懒惰标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) <span class="keyword">return</span> tree[p]; <span class="comment">// 完全覆盖</span></span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// 使用 double 类型进行求和</span></span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) sum += rangeSum(l, r, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) sum += rangeSum(l, r, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= cl &amp;&amp; cr &lt;= r) &#123;</span><br><span class="line">            lazy[p] = val; <span class="comment">// 懒惰标记增加</span></span><br><span class="line">            ifLazy[p] = <span class="keyword">true</span>; <span class="comment">// 标记为懒惰</span></span><br><span class="line">            tree[p] = (cr - cl + <span class="number">1</span>) * val; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = cl + (cr - cl) / <span class="number">2</span>;</span><br><span class="line">        maintain(cl, cr, p); <span class="comment">// 维护当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) rangeSet(l, r, val, cl, m, p * <span class="number">2</span>); <span class="comment">// 左子树</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; m) rangeSet(l, r, val, m + <span class="number">1</span>, cr, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">            tree[p] = arr[s]; <span class="comment">// 使用 double 类型</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = s + (t - s) / <span class="number">2</span>;</span><br><span class="line">        build(s, m, p * <span class="number">2</span>); <span class="comment">// 构建左子树</span></span><br><span class="line">        build(m + <span class="number">1</span>, t, p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 构建右子树</span></span><br><span class="line">        tree[p] = tree[p * <span class="number">2</span>] + tree[p * <span class="number">2</span> + <span class="number">1</span>]; <span class="comment">// 更新当前节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">rangeSum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSum(l, r, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeSet</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">        rangeSet(l, r, val, <span class="number">0</span>, end, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线段树优化"><a href="#线段树优化" class="headerlink" title="线段树优化"></a>线段树优化</h2><ol><li>在叶子节点处无需下放懒惰标记，所以懒惰标记可以不下传到叶子节点。</li><li>下放懒惰标记可以写一个专门的函数<code>maintain</code>，降低代码编写难度。</li><li>标记永久化：如果确定懒惰标记不会在中途被加到溢出（即超过了该类型数据所能表示的最大范围），那么就可以将标记永久化。标记永久化可以避免下传懒惰标记，只需在进行询问时把标记的影响加到答案当中，从而降低程序常数。具体如何处理与题目特性相关，需结合题目来写。这也是树套树和可持久化数据结构中会用到的一种技巧。</li><li>动态开点线段树，即可以不一次性建好树，而是在最初只建立一个根结点代表整个区间。当我们需要访问某个子区间时，才建立代表这个区间的子结点。这种方式节省的空间有限（约$1/4$）。</li></ol><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><p>线段树的其他操作包括线段树合并、线段树分裂、线段树二分、线段树优化建图等，遇到相关题目时再做补充。</p><h1 id="例题1-Booking-Concert-Tickets-in-Groups"><a href="#例题1-Booking-Concert-Tickets-in-Groups" class="headerlink" title="例题1: Booking Concert Tickets in Groups"></a>例题1: <a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/description">Booking Concert Tickets in Groups</a></h1><p>将每一排座位看成一个整体，可将两种操作总结如下：</p><ul><li>gather：在前 maxRow 排中，找第一个还能至少有 k 个空座位的排，预定 k 个连续的座位。如果有这样的排，返回编号，以及在预定前有多少非空座位；如果没有这样的排，返回空列表。</li><li>scatter：在前 maxRow 个排中预定总量为 k 的座位。从左到右选择有空座位的排依次占座。如果无法预定总量为 k 的座位，则不执行操作，并返回 false；否则执行操作，并返回 true。</li></ul><p>此时将原问题压缩为一维数组，能这样做的原因是两种操作均不会产生“间隔的空座位”。因此需要的操作如下：</p><ul><li>求出前 maxRow 排中，第一个剩余容量 ≥k，也就是已预定量 ≤ m−k 的排。</li><li>维护每排的已预定量。</li><li>维护前 maxRow 排的已预定量之和，从而判断 scatter 能否实现。</li></ul><p>可以用线段树处理上述操作，线段树维护每个区间（区间即某几排）已预定量的最小值 $\min$ ，以及每个区间的已预定量之和 $sum$。</p><p>对于 gather，从线段树的根节点开始递归：</p><ul><li>如果当前区间 $\min &gt; m-k$, 则无法预定 $k$ 个连续座位，返回 0 。</li><li>如果当前区间长度为 1 ，返回区间端点。</li><li>如果左半区间 $\min \leq m-k$, 则答案在左半区间中, 递归左半区间。</li><li>否则如果 maxRow 在右半区间内, 递归右半区间。</li><li>否则返回 -1 ，表示没有符合条件的排。</li></ul><p>上述过程叫做<strong>线段树二分</strong>，</p><p>对于 scatter，如果区间 $[0$, maxRow] 的已预定量之和大于 $m \cdot(\operatorname{maxRow}+1)-k$ ，则无法执行操作。否则可以执行操作。从第一个没有装满，也就是已预定量 $\leq m-1$ 的排开始预定，这也可以用线段树二分求出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookMyShow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] min;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookMyShow</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.m = m;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span> &lt;&lt; (<span class="number">32</span> - Integer.numberOfLeadingZeros(n)); <span class="comment">// 比 4n 更小</span></span><br><span class="line">        min = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">long</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gather(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow) &#123;</span><br><span class="line">        <span class="comment">// 找第一个能预定 k 个座位的row</span></span><br><span class="line">        <span class="keyword">int</span> r = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - k);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123; <span class="comment">// 没有这样的row</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, r);</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, r, k); <span class="comment">// 预定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">scatter</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [0,maxRow] 的已预定量之和</span></span><br><span class="line">        <span class="keyword">long</span> s = querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, maxRow);</span><br><span class="line">        <span class="keyword">if</span> (s &gt; (<span class="keyword">long</span>) m * (maxRow + <span class="number">1</span>) - k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 空座位不足</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个没有定满的row开始</span></span><br><span class="line">        <span class="keyword">int</span> i = findFirst(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, maxRow, m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = Math.min(m - (<span class="keyword">int</span>) querySum(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, i), k);</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, i, left); <span class="comment">// 预定</span></span><br><span class="line">            k -= left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把下标 i 上的元素值增加 val</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            min[o] += val;</span><br><span class="line">            sum[o] += val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">            update(o * <span class="number">2</span>, l, m, i, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, i, val);</span><br><span class="line">        &#125;</span><br><span class="line">        min[o] = Math.min(min[o * <span class="number">2</span>], min[o * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        sum[o] = sum[o * <span class="number">2</span>] + sum[o * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [L,R] 内的元素和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum[o];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &lt;= m) &#123;</span><br><span class="line">            res = querySum(o * <span class="number">2</span>, l, m, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            res += querySum(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回区间 [0,R] 中 &lt;= val 的最靠左的位置，不存在时返回 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> R, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (min[o] &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 整个区间的元素值都大于 val</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (min[o * <span class="number">2</span>] &lt;= val) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span>, l, m, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt; m) &#123;</span><br><span class="line">            <span class="keyword">return</span> findFirst(o * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r, R, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/ds/seg/#%E5%AE%9E%E7%8E%B0">https://oi-wiki.org/ds/seg/#%E5%AE%9E%E7%8E%B0</a><br>[2] <a href="https://en.wikipedia.org/wiki/Segment_tree">https://en.wikipedia.org/wiki/Segment_tree</a><br>[3] <a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28">https://leetcode.cn/problems/booking-concert-tickets-in-groups/solutions/1523876/by-endlesscheng-okcu/?envType=daily-question&amp;envId=2024-09-28</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;线段树是算法竞赛中常用的用来维护“区间信息”的数据结构。线段树可以在 $O(\log N)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法</title>
    <link href="http://silencezheng.top/2024/10/01/article142/"/>
    <id>http://silencezheng.top/2024/10/01/article142/</id>
    <published>2024-10-01T13:20:17.000Z</published>
    <updated>2024-10-01T13:24:40.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用于生成全局唯一ID（分布式ID）的算法有多种，雪花算法（SnowFlake）是其中一个经典的常用算法。</p><span id="more"></span><h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><p>分布式ID的特点：</p><ul><li><strong>全局唯一性</strong>：不能出现有重复的ID标识，这是基本要求。</li><li><strong>递增性</strong>：确保生成ID对于用户或业务是递增的。</li><li><strong>高可用性</strong>：确保任何时候都能生成正确的ID。</li><li><strong>高性能性</strong>：在高并发的环境下依然表现良好。</li></ul><p>分布式ID的应用场景包括但不限于：</p><ul><li><strong>分布式数据库</strong>：生成唯一主键。</li><li><strong>消息队列</strong>：标识消息的唯一性。</li><li><strong>用户注册</strong>：为新用户生成唯一标识。</li></ul><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><p>SnowFlake最初是Twitter公司采用的一种算法，目的是在分布式系统中产生<strong>全局唯一且递增</strong>的ID。每一个雪花算法产生的ID都是一个的64bit的long类型的唯一ID。</p><h2 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h2><p><code>0 -- 41位时间戳 -- 10位机器ID -- 12位序列号</code></p><ol><li>最高1位是符号位，固定为0，表示id是正整数；</li><li>接下来41位存储毫秒级时间戳，表示从一个特定时间点（通常是 Unix 纪元时间）开始的毫秒数。这允许生成的 ID 持续大约 69 年，即 $2^{41} / (1000 <em> 60 </em> 60 * 24 \times 365) = 69$。</li><li>再接下10位存储机器码，包括高5位的<code>datacenterId</code>和低5位的<code>workerId</code>。最多可以部署$2^{10}=1024$台机器。</li><li>最后12位存储序列号，即在同一毫秒内生成的序列号，允许每个节点在同一毫秒内生成最多 4096 个 ID（$2^{12}$）。</li></ol><p>基于组成可以计算雪花算法在同一毫秒内最多可以生成的全局唯一ID数量为$1024 \times 4096 = 4194304$个。</p><h2 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h2><p>生成一个雪花 ID 的过程如下：</p><ol><li><strong>获取当前时间戳</strong>：计算当前的毫秒时间戳。</li><li><strong>检查时间戳是否回拨</strong>：如果当前时间小于上次生成 ID 的时间，说明时间回拨，可能会抛出异常或等待。</li><li><strong>生成序列号</strong>：如果当前时间与上次生成 ID 的时间相同且还有序列号可用，则序列号加1；否则阻塞至下一毫秒。</li><li><strong>拼接 ID</strong>：将时间戳、机器 ID 和序列号拼接成一个 64 位的整数。</li></ol><p>Java实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeIdWorker</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间截 (2015-01-01)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> twepoch = <span class="number">1420041600000L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大数据标识id，结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列在id中占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID向左移12位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id向左移17位(12+5)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间截向左移22位(5+5+12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作机器ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒内序列(0~4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId     工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnowflakeIdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">// 毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="comment">// 移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SnowflakeIdWorker idWorker = <span class="keyword">new</span> SnowflakeIdWorker(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idWorker.nextId();</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><ul><li>优点：<ul><li><strong>高并发</strong>：可以在分布式环境下高效生成唯一ID，支持高并发。</li><li><strong>有序性</strong>：生成的ID基于时间戳，具有一定的有序性，适合用于数据库的主键。</li><li><strong>低延迟</strong>：生成ID的速度快，通常在毫秒级别。</li></ul></li><li>缺点<ul><li><strong>时间回拨问题</strong>：如果服务器时间发生回拨，可能导致生成重复的ID，需要处理。</li><li><strong>机器 ID 管理</strong>：需要确保机器 ID 的唯一性，管理较为复杂。</li><li><strong>存储问题</strong>：ID 的长度较长（64 位），可能在某些系统中造成存储开销。</li></ul></li></ul><h2 id="部分开源的雪花算法实现"><a href="#部分开源的雪花算法实现" class="headerlink" title="部分开源的雪花算法实现"></a>部分开源的雪花算法实现</h2><ol><li>HuTool</li><li>百度UidGenerator</li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团Leaf</a></li></ol><p>各家对于时钟回拨都有不同的处理，以HuTool为例：</p><ul><li>如果时钟回拨不超过2秒，则会将现在的时间点置为上个产生id的时间点（超过2s就抛出异常了）；</li><li>如果上个时间点产生的id没有达到4095（超过4095就抛出异常了），即使产生了时钟回拨，也可以继续生成id。</li><li>如果出现时钟回拨，假设是5s，那么如果这5s内没有id需要生成，那么时钟回拨没有任何影响。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010">https://github.com/twitter-archive/snowflake/releases/tag/snowflake-2010</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/85837641">https://zhuanlan.zhihu.com/p/85837641</a><br>[3] <a href="https://blog.csdn.net/weixin_43024834/article/details/135039159">https://blog.csdn.net/weixin_43024834/article/details/135039159</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用于生成全局唯一ID（分布式ID）的算法有多种，雪花算法（SnowFlake）是其中一个经典的常用算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="分布式系统" scheme="http://silencezheng.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法</title>
    <link href="http://silencezheng.top/2024/10/01/article141/"/>
    <id>http://silencezheng.top/2024/10/01/article141/</id>
    <published>2024-10-01T11:48:10.000Z</published>
    <updated>2024-10-01T11:52:43.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看分片算法的时候了解到了一致性哈希，梳理一下相关内容。</p><p>其主要的使用场景包括：分布式存储（缓存、DB、文件）、负载均衡、分布式计算等。<br><span id="more"></span></p><h1 id="简单哈希函数的“扩容困境”"><a href="#简单哈希函数的“扩容困境”" class="headerlink" title="简单哈希函数的“扩容困境”"></a>简单哈希函数的“扩容困境”</h1><p>对于简单哈希函数<code>m = hash(o) mod n</code>，其中，<code>o</code>为对象名称，<code>n</code>为机器的数量，<code>m</code>为机器编号。当<code>n</code>增大时，所有<code>o</code>对应的<code>m</code>都可能发生变化，这些变化意味着将对象<code>o</code>的数据迁移到新的机器<code>m</code>。</p><p>假设我们有以下对象和机器：</p><ul><li>对象：<code>o1</code>, <code>o2</code>, <code>o3</code>, <code>o4</code></li><li>初始机器数量：<code>n = 3</code></li></ul><p>假设对每个对象应用哈希函数得到的哈希值如下：</p><ul><li><code>hash(o1) = 10</code></li><li><code>hash(o2) = 15</code></li><li><code>hash(o3) = 20</code></li><li><code>hash(o4) = 25</code></li></ul><p>可计算出初始数据分布如下：</p><ul><li>机器 0：<code>o2</code></li><li>机器 1：<code>o1</code>, <code>o4</code></li><li>机器 2：<code>o3</code></li></ul><p>现在，我们将机器数量增加到 <code>n = 5</code>，使用相同的哈希值，重新计算每个对象的新机器编号，得到的数据分布如下：</p><ul><li>机器 0：<code>o1</code>, <code>o2</code>, <code>o3</code>, <code>o4</code></li><li>机器 1：无</li><li>机器 2：无</li><li>机器 3：无</li><li>机器 4：无</li></ul><p>可以发现，要迁移的数据将十分多。</p><h1 id="一致性哈希（Consistent-Hash）"><a href="#一致性哈希（Consistent-Hash）" class="headerlink" title="一致性哈希（Consistent Hash）"></a>一致性哈希（Consistent Hash）</h1><p>一致性哈希(Consistent Hash)算法是1997年提出，是一种特殊的哈希算法，目的是解决分布式系统的数据分区问题：当分布式集群移除或者添加一个服务器时，必须尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。</p><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h2><p>一致性哈希算法本质上也是一种取模算法。只不过是对固定值<code>2^32</code>取模，这就使得一致性算法具备良好的单调性，即不管集群中有多少个节点，只要key值固定，那所请求的服务器节点也同样是固定的。</p><p>其算法的工作原理如下：</p><ol><li>一致性哈希算法将整个哈希值空间映射成一个虚拟的圆环，整个哈希空间的取值范围为<code>[0, 2^32 - 1]</code>；</li><li>计算各服务器节点的哈希值，并映射到哈希环上；</li><li>将服务发来的数据请求使用哈希算法算出对应的哈希值；</li><li>将计算的哈希值映射到哈希环上，同时沿圆环顺时针方向查找，遇到的第一台服务器就是所对应的处理请求服务器。</li><li>当增加或者删除一台服务器时，受影响的数据仅仅是新添加或删除的服务器到其环空间中前一台的服务器（也就是顺着逆时针方向遇到的第一台服务器）之间的数据，其他都不会受到影响。</li></ol><h2 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h2><p>算法原理其实很容易理解，但是这里面涉及到一些细节问题：</p><ol><li>数据请求如何寻找目标服务器？<ul><li>计算请求的哈希值后进行顺序查找，查找到哈希环末尾时跳回第一个元素继续顺序查找。</li></ul></li><li>在分布式存储的场景下扩容时，原定向到B节点的部分数据需要迁移到新节点C，如何对这部分存量数据进行迁移？<ol><li>从C节点逆序定位到上一个节点B；</li><li>对B中全部数据进行重哈希，识别出需迁移数据的范围；</li><li>将需迁移数据复制到C节点中，确认一致；</li><li>删除B节点上已迁移的数据。</li></ol></li><li>在分布式存储的场景下缩容时，原定向到B节点的所有数据需要迁移到新节点C，如何对这部分存量数据进行迁移？<ul><li>与扩容相似，先复制再删除，只是不需要确定数据范围，因为被删除节点的所有数据都需要迁移。</li></ul></li><li>在负载均衡场景下发生节点宕机时，一致性哈希有什么好处？<ul><li>仅宕机节点的流量会去到下一个节点，其余节点的流量不受影响。</li></ul></li><li>在分布式存储场景下发生节点故障怎么办？<ol><li>采用数据副本机制，在多个节点之间存储数据的副本，确保在节点失效时可以通过其他副本恢复数据。</li><li>实现健康检查机制，定期检测节点的状态，并在发现故障时快速重新分配数据。</li></ol></li></ol><h2 id="数据倾斜与虚拟节点"><a href="#数据倾斜与虚拟节点" class="headerlink" title="数据倾斜与虚拟节点"></a>数据倾斜与虚拟节点</h2><p><strong>数据倾斜</strong>（Data Skew）是指在分布式系统或大数据处理场景中，数据在某些节点或分片之间分布不均匀的现象。这种不均匀性导致某些节点或处理单元负载过重，而其他节点则相对空闲，从而影响系统的性能和响应时间。</p><p>有两种情况可能导致数据倾斜：</p><ol><li>当节点数量较少时，数据可能不均匀地分布在哈希环上，导致某些节点负载过重，而其他节点相对空闲。</li><li>如果节点在哈希环上的位置不够分散（用的哈希函数不够散列），可能导致某些节点的负载过高。</li></ol><p>可以通过<strong>虚拟节点</strong>的机制来解决数据倾斜问题。虚拟节点机制对每一个物理服务节点映射多个虚拟节点，将这些虚拟节点计算哈希值并映射到哈希环上，当请求找到某个虚拟节点后，将被重新映射到具体的物理节点。虚拟节点越多，哈希环上的节点就越多，数据分布就越均匀，从而避免了数据倾斜的问题。</p><p>假设一台服务器有 n 个虚拟节点。那么哈希计算时，可以使用<code>IP + 端口 + 编号</code>的形式进行哈希值计算。其中的编号就是 0 到 n 的数字。由于<code>IP + 端口</code>是一样的，所以这 n 个节点都是指向的同一台机器。</p><h2 id="Demo实现"><a href="#Demo实现" class="headerlink" title="Demo实现"></a>Demo实现</h2><p>数据节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODE_NO_PER_NODE = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; virtualNodeHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(VIRTUAL_NODE_NO_PER_NODE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(ip);</span><br><span class="line">        <span class="keyword">this</span>.ip = ip;</span><br><span class="line">        initVirtualNodes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVirtualNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String virtualNodeKey;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= VIRTUAL_NODE_NO_PER_NODE; i++) &#123;</span><br><span class="line">            virtualNodeKey = ip + <span class="string">&quot;#&quot;</span> + i;</span><br><span class="line">            virtualNodeHashes.add(HashUtils.hashcode(virtualNodeKey));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCacheItem</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        cacheMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCacheItem</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cacheMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeCacheItem</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        cacheMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getVirtualNodeHashes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> virtualNodeHashes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一致性哈希：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Integer, Node&gt; hashRing = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加节点</span></span><br><span class="line"><span class="comment">     * 每增加一个节点，就会在闭环上增加给定虚拟节点</span></span><br><span class="line"><span class="comment">     * 例如虚拟节点数是2，则每调用此方法一次，增加两个虚拟节点，这两个节点指向同一Node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(ip);</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(ip);</span><br><span class="line">        nodeList.add(node);</span><br><span class="line">        <span class="keyword">for</span> (Integer virtualNodeHash : node.getVirtualNodeHashes()) &#123;</span><br><span class="line">            hashRing.put(virtualNodeHash, node);</span><br><span class="line">            System.out.println(<span class="string">&quot;虚拟节点[&quot;</span> + node + <span class="string">&quot;] hash:&quot;</span> + virtualNodeHash + <span class="string">&quot;，被添加&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        nodeList.remove(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存数据</span></span><br><span class="line"><span class="comment">     * 先找到对应的虚拟节点，然后映射到物理节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node node = findMatchNode(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到节点:&quot;</span> + node.getIp());</span><br><span class="line">        <span class="keyword">return</span> node.getCacheItem(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加缓存</span></span><br><span class="line"><span class="comment">     * 先找到hash环上的节点，然后在对应的节点上添加数据缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        Node node = findMatchNode(key);</span><br><span class="line"></span><br><span class="line">        node.addCacheItem(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        findMatchNode(key).removeCacheItem(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获得一个最近的顺时针节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 为给定键取Hash，取得顺时针方向上最近的一个虚拟节点对应的实际节点</span></span><br><span class="line"><span class="comment">     *      * <span class="doctag">@return</span> 节点对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findMatchNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Node&gt; entry = hashRing.ceilingEntry(HashUtils.hashcode(key));</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry = hashRing.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哈希函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FNV1_32_HASH</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     *         object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hashcode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        String str = obj.toString();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;hash computer:&quot; + hash);</span></span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NODE_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRING_COUNT = <span class="number">100</span> * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConsistentHash consistentHash = <span class="keyword">new</span> ConsistentHash();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; sList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODE_SIZE; i++) &#123;</span><br><span class="line">            String ip = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;10.2.1.&quot;</span>).append(i)</span><br><span class="line">                    .toString();</span><br><span class="line">            consistentHash.addNode(ip);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成需要缓存的数据;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; STRING_COUNT; i++) &#123;</span><br><span class="line">            sList.add(RandomStringUtils.randomAlphanumeric(<span class="number">10</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据放入到缓存中。</span></span><br><span class="line">        <span class="keyword">for</span> (String s : sList) &#123;</span><br><span class="line">            consistentHash.put(s, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = RandomUtils.nextInt(<span class="number">0</span>, STRING_COUNT);</span><br><span class="line">            String key = sList.get(index);</span><br><span class="line">            String cache = (String) consistentHash.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;Random:&quot;</span>+index+<span class="string">&quot;,key:&quot;</span> + key + <span class="string">&quot;,consistentHash get value:&quot;</span> + cache +<span class="string">&quot;,value is:&quot;</span> + key.equals(cache));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出节点及数据分布情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : consistentHash.nodeList)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增一个数据节点</span></span><br><span class="line">        consistentHash.addNode(<span class="string">&quot;10.2.1.110&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = RandomUtils.nextInt(<span class="number">0</span>, STRING_COUNT);</span><br><span class="line">            String key = sList.get(index);</span><br><span class="line">            String cache = (String) consistentHash.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;Random:&quot;</span>+index+<span class="string">&quot;,key:&quot;</span> + key + <span class="string">&quot;,consistentHash get value:&quot;</span> + cache +<span class="string">&quot;,value is:&quot;</span> + key.equals(cache));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出节点及数据分布情况</span></span><br><span class="line">        <span class="keyword">for</span> (Node node : consistentHash.nodeList)&#123;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://developer.aliyun.com/article/1082388">https://developer.aliyun.com/article/1082388</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/129049724">https://zhuanlan.zhihu.com/p/129049724</a><br>[3] <a href="https://zhuanlan.zhihu.com/p/636719716">https://zhuanlan.zhihu.com/p/636719716</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/53711866">https://zhuanlan.zhihu.com/p/53711866</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>下一篇：Chord协议，第一代分布式哈希表（DHT）。</p><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看分片算法的时候了解到了一致性哈希，梳理一下相关内容。&lt;/p&gt;
&lt;p&gt;其主要的使用场景包括：分布式存储（缓存、DB、文件）、负载均衡、分布式计算等。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="分布式系统" scheme="http://silencezheng.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP13</title>
    <link href="http://silencezheng.top/2024/09/23/article140/"/>
    <id>http://silencezheng.top/2024/09/23/article140/</id>
    <published>2024-09-22T17:00:46.000Z</published>
    <updated>2024-09-22T17:01:29.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周的bus题挺有意思，学习了。</p><p>本周主题：动态规划、组合数学、BFS、优化建图</p><p>题目：</p><ul><li>240917每日一题—<a href="https://leetcode.cn/problems/bus-routes/description">Bus Routes</a></li><li>240920每日一题—<a href="https://leetcode.cn/problems/count-special-integers/description">Count Special Integers</a></li></ul><span id="more"></span><h1 id="Bus-Routes"><a href="#Bus-Routes" class="headerlink" title="Bus Routes"></a>Bus Routes</h1><blockquote><p>Bus Routes</p><p>You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.</p><p>For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … forever.<br>You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.</p><p>Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.</p></blockquote><p>这道题和地图应用中的公交路线计算非常贴合，实用价值很高。题意就是给了若干公交线路和起点终点，求最小换乘策略。</p><h2 id="优化建图-BFS"><a href="#优化建图-BFS" class="headerlink" title="优化建图+BFS"></a>优化建图+BFS</h2><p>由于求解的目标是最少乘坐的公交车数量，对于同一辆公交车，乘客可以在其路线中的任意车站间无代价地移动，于是我们可以把公交路线当作点。如果两条公交路线有相同车站，则可以在这两条路线间换乘公交车，那么这两条公交路线之间可视作有一条长度为$1$的边。这样建出的图包含的点数即为公交路线的数量，记作$n$。</p><p>完成了建图后，我们需要先明确新的图的起点和终点，然后使用广度优先搜索，计算出的起点和终点的最短路径，从而得到最少换乘次数。</p><p>注意到原本的起点车站和终点车站可能同时位于多条公交路线上，因此在新图上可能有多个起点和终点。对于这种情况，我们初始可以同时入队多个点，并在广度优先搜索结束后检查到各个终点的最短路径，取其最小值才是最少换乘次数。</p><p>实际建图时, 我们有以下两种方案：</p><ul><li>方案一：我们直接枚举左右两端点，检查两点对应的两公交路线是否有公共车站。利用哈希表，我们可以将单次比较的时间复杂度优化到均摊 $O(n)$ 。</li><li>方案二：我们遍历所有公交路线，记录每一个车站属于哪些公交路线。然后我们遍历每一个车站，如果有多条公交路线经过该点，则在这些公交路线之间连边。</li></ul><p>本题中我们采用方案二，据此还可以直接得到起点和终点在新图中对应的点。实际代码中，我们使用哈希映射来实时维护「车站所属公交路线列表」。假设当前枚举到公交路线 $i$ 中的车站 $site$, 此时哈希映射中已记录若干条公交路线经过车站 $site$, 我们只需要让点 $i$ 与这些点公交路线对应的点相连即可。完成了连线后, 我们再将公交路线 $i$ 加入到「车站 $site$ 所属公交路线列表」中。</p><p>特别地, 起点和终点相同时, 我们可以直接返回 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> source, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = routes.length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] edge = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">// key:车站, value:班次列表</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; rec = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> site : routes[i]) &#123;</span><br><span class="line">                List&lt;Integer&gt; list = rec.getOrDefault(site, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j : list) &#123;</span><br><span class="line">                    edge[i][j] = edge[j][i] = <span class="keyword">true</span>; <span class="comment">// 班次连线</span></span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                rec.put(site, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dis = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">// 记录从src到tgt的所有班次换乘数量</span></span><br><span class="line">        Arrays.fill(dis, -<span class="number">1</span>);</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bus : rec.getOrDefault(source, <span class="keyword">new</span> ArrayList&lt;Integer&gt;())) &#123;</span><br><span class="line">            dis[bus] = <span class="number">1</span>; <span class="comment">// 起点班次数量为1</span></span><br><span class="line">            que.offer(bus); <span class="comment">// 起点班次入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 广度优先搜索，所有班次每次仅向前探测一次，保证终点第一次被搜索到时路径最短</span></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.poll(); <span class="comment">// 队头出队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[x][y] &amp;&amp; dis[y] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(y); <span class="comment">// 加入队尾</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从能到终点的班次中筛选出最小距离</span></span><br><span class="line">        <span class="keyword">int</span> ret = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bus : rec.getOrDefault(target, <span class="keyword">new</span> ArrayList&lt;Integer&gt;())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[bus] != -<span class="number">1</span>) &#123;</span><br><span class="line">                ret = Math.min(ret, dis[bus]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret == Integer.MAX_VALUE ? -<span class="number">1</span> : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Count-Special-Integers"><a href="#Count-Special-Integers" class="headerlink" title="Count Special Integers"></a>Count Special Integers</h1><blockquote><p>Count Special Integers</p><p>We call a positive integer special if all of its digits are distinct.</p><p>Given a positive integer n, return the number of special integers that belong to the interval [1, n].</p></blockquote><p>到手首先考虑记忆化+暴力，用两个数组分别记录当前数字和每个数字的频次来避免重复计算，逐步从1增加到n计算，能过百分之八十，剩下超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 存放从1到10位的数字</span></span><br><span class="line">    <span class="keyword">int</span>[] check = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 计算arr是否有重复元素</span></span><br><span class="line">    <span class="keyword">int</span> waterLevel = <span class="number">0</span>; <span class="comment">// 表示当前到达过的最高位数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">0</span>]++;</span><br><span class="line">        check[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            recur(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x:check)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    valid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[p]&lt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(waterLevel&gt;=p) check[arr[p]]--;</span><br><span class="line">            <span class="keyword">else</span> waterLevel++;</span><br><span class="line">            arr[p]++;</span><br><span class="line">            check[arr[p]]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[p] = <span class="number">0</span>;</span><br><span class="line">            check[<span class="number">0</span>]++;</span><br><span class="line">            check[<span class="number">9</span>]--;</span><br><span class="line">            recur(p+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划-组合数学"><a href="#动态规划-组合数学" class="headerlink" title="动态规划+组合数学"></a>动态规划+组合数学</h2><p>另一种思路是通过组合数学拼出所有的特殊整数，这样就可以避免遍历所有可能的整数。将小于等于$n$的整数分为两种情况，记$n$十进制表示下位数为$k$：</p><ol><li>位数小于$k$的特殊整数。</li><li>位数等于$k$的特殊整数。</li></ol><p>对于位数小于 $k$ 的情况，分别计算位数为 1 到 $k-1$ 的情况下特殊整数的数量。考虑位数为 $k_0\left(k_0&lt;k\right)$的情况。因为 $k_0&lt;k$ ，所以任意放置数位上的数字，都能满足小于等于 $n$ 的条件。只需保证每一数位都互不相同。用组合数学的思路求解特殊整数的数量，从最高位开始考虑，可以有 9 种选择（除 0 外的任何整数），次高位也有 9 种选择（除最高位外的任何整数），接下来的数位的选择则依次减少 1 。把这些选择的可能性全部相乘则是位数为 $k_0$ 的特殊整数的数量。</p><p>接下来考虑位数等于 $k$ 的特殊整数。相同位数的数字比较大小，是从最高位开始比较，若不同，则最高位大的数字大；若相同，则比较次高位。次高位的比较原则和最高位一样。因此，我们在计算小于等于 $n$ 的特殊整数时，也需要按照这个原则。函数 $d p(mask, prefixSmaller)$ 用来计算以某些数字组合为前缀的特殊整数的数量。整数 mask 即表示了前叕中使用过的数字，二进制表示下，从最低位开始，第 $i$ 位如果为 1 则表示数字 $i$ 已经被使用过，在接下来的后缀中不能使用。布尔值 prefixSmaller 表示当前的前缀是否小于 $n$ 的前缀，如果是，则接下来的数字可以任意选择。如果不是，即当前的前缀等于 $n$ 的前缀，则接下来的数字只能小于或者等于 $n$ 同数位的数字。最后调用 $d p(0, f a l s e)$ 则为位数等于 $k$ 的特殊整数的数量。</p><p>最后把这两部分相加即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String nStr = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prod = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nStr.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res += prod;</span><br><span class="line">            prod *= <span class="number">9</span> - i;</span><br><span class="line">        &#125;</span><br><span class="line">        res += dp(<span class="number">0</span>, <span class="keyword">false</span>, nStr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> mask, <span class="keyword">boolean</span> prefixSmaller, String nStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.bitCount(mask) == nStr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> key = mask * <span class="number">2</span> + (prefixSmaller ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// 用参数组合生成key用于记忆化</span></span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(key)) &#123; <span class="comment">// 如果还没计算过，则计算当前参数下的组合数量</span></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> lowerBound = mask == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 初始最高位时下界为1</span></span><br><span class="line">            <span class="keyword">int</span> upperBound = prefixSmaller ? <span class="number">9</span> : nStr.charAt(Integer.bitCount(mask)) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = lowerBound; i &lt;= upperBound; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((mask &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123; <span class="comment">// 数字i未被使用过</span></span><br><span class="line">                    <span class="comment">// 把i加入mask列表表示使用过</span></span><br><span class="line">                    res += dp(mask | (<span class="number">1</span> &lt;&lt; i), prefixSmaller || i &lt; upperBound, nStr); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo.put(key, res); <span class="comment">// 在mask先进a后进b的情况下，后续mask先进b后进a的运算可以省略。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解记录"><a href="#题解记录" class="headerlink" title="题解记录"></a>题解记录</h1><p>还有一题有些意思不过写出来了，贴一下<a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/solutions/2921670/kuai-man-zhi-zhen-yi-ci-bian-li-ji-bai-9-bps8/">我的题解</a>。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/count-special-integers/solutions/2916434/tong-ji-te-shu-zheng-shu-by-leetcode-sol-7qai/?envType=daily-question&amp;envId=2024-09-20">https://leetcode.cn/problems/count-special-integers/solutions/2916434/tong-ji-te-shu-zheng-shu-by-leetcode-sol-7qai/?envType=daily-question&amp;envId=2024-09-20</a><br>[2] <a href="https://leetcode.cn/problems/bus-routes/solutions/847860/gong-jiao-lu-xian-by-leetcode-solution-yifz/?envType=daily-question&amp;envId=2024-09-17">https://leetcode.cn/problems/bus-routes/solutions/847860/gong-jiao-lu-xian-by-leetcode-solution-yifz/?envType=daily-question&amp;envId=2024-09-17</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周的bus题挺有意思，学习了。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、组合数学、BFS、优化建图&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240917每日一题—&lt;a href=&quot;https://leetcode.cn/problems/bus-routes/description&quot;&gt;Bus Routes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240920每日一题—&lt;a href=&quot;https://leetcode.cn/problems/count-special-integers/description&quot;&gt;Count Special Integers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP12</title>
    <link href="http://silencezheng.top/2024/09/15/article139/"/>
    <id>http://silencezheng.top/2024/09/15/article139/</id>
    <published>2024-09-15T15:32:15.000Z</published>
    <updated>2024-09-15T15:32:55.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周忙废了…挑战一天写完一周的题。</p><p>本周主题：双指针、枚举、单调队列</p><p>题目：</p><ul><li>240910每日一题—<a href="https://leetcode.cn/problems/count-increasing-quadruplets/description">Count Increasing Quadruplets</a></li><li>240912每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description">Find the Maximum Number of Marked Indices</a></li><li>240913每日一题—<a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description">Maximum Number of Robots Within Budget</a></li></ul><span id="more"></span><h1 id="Maximum-Number-of-Robots-Within-Budget"><a href="#Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="Maximum Number of Robots Within Budget"></a>Maximum Number of Robots Within Budget</h1><blockquote><p>Maximum Number of Robots Within Budget</p><p>You have n robots. You are given two 0-indexed integer arrays, chargeTimes and runningCosts, both of length n. The ith robot costs chargeTimes[i] units to charge and costs runningCosts[i] units to run. You are also given an integer budget.</p><p>The total cost of running k chosen robots is equal to max(chargeTimes) + k * sum(runningCosts), where max(chargeTimes) is the largest charge cost among the k robots and sum(runningCosts) is the sum of running costs among the k robots.</p><p>Return the maximum number of consecutive robots you can run such that the total cost does not exceed budget.</p></blockquote><p>首先注意题目要求启动的机器人序列连续，则构成一个窗口，窗口内计算cost要小于budget且窗口尽量大。每次窗口移动可能会影响两个点进而影响窗口cost，一个是最大充电时间，一个是总体启动时间消耗。则这道题可以看为<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的变体题目。</p><p>因此先来把<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">Sliding Window Maximum</a>的<strong>单调队列</strong>做法搞懂。</p><p>PS：这道题我之前也写了一个<a href="https://leetcode.cn/problems/sliding-window-maximum/solutions/2795111/treemap-by-silencezheng66-kb1i/">TreeMap的题解</a>，比较复杂，正好这次学一下单调队列的解法。</p><p><strong>「单调队列」即满足单调性的双端队列</strong>，双端队列左侧为队首，右侧为队尾。</p><h2 id="前置题目：Sliding-Window-Maximum"><a href="#前置题目：Sliding-Window-Maximum" class="headerlink" title="前置题目：Sliding Window Maximum"></a>前置题目：Sliding Window Maximum</h2><blockquote><p>Sliding Window Maximum</p><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p><p>Return the max sliding window.</p></blockquote><p>题目比较容易理解，就是取一个定长的滑窗在数组上滑出若干个最值，难点就是用尽量少的时间计算每个窗口中的最值。</p><p>由于我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 $i$ 和 $j$, 其中 $i$ 在 $j$的左侧 $(i&lt;j)$ ，并且 $i$ 对应的元素不大于 $j$ 对应的元素（nums $[i] \leq n u m s[j]$） ，则当滑动窗口向右移动时，只要 $i$ 还在窗口中，那么 $j$ 一定也还在窗口中，这是 $i$ 在 $j$ 的左侧所保证的。因此, 由于 nums [j] 的存在, nums [i] 一定不会是滑动窗口中的最大值了, 我们可以将 nums [i]永久地移除。</p><p>因此我们可以<strong>使用一个队列存储所有还没有被移除的下标</strong>。在队列中, 这些<strong>下标按照从小到大的顺序被存储, 并且它们在数组 nums 中对应的值是严格单调递减的</strong>。因为如果队列中有两个相邻的下标, 它们对应的值相等或者递增, 那么令前者为 $i$, 后者为 $j$, 就对应了上面所说的情况, 即 $n u m s[i]$ 会被移除，这就产生了矛盾。</p><p>当滑动窗口向右移动时, 我们需要把一个新的元素放入队列中。为了保持队列的性质, 我们会不断地将新的元素与队尾的元素相比较, 如果前者大于等于后者, 那么队尾的元素就可以被永久地移除, 我们将其弹出队列。我们需要不断地进行此项操作, 直到队列为空或者新的元素小于队尾的元素。</p><p>由于队列中下标对应的元素是严格单调递减的, 因此此时队首下标对应的元素就是滑动窗口中的最大值。同时，隨着窗口向右移动，队首元素可能会不在窗口中，我们还需要不断从队首弹出元素, 直到队首元素在窗口中为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 先填充第一个窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = nums[deque.peekFirst()]; <span class="comment">// 队首为窗口最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐元素移动窗口</span></span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            <span class="comment">// 抛弃不在窗口中的最值</span></span><br><span class="line">            <span class="keyword">while</span> (deque.peekFirst() &lt;= i - k) &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出答案，注意peek只检查并不丢弃</span></span><br><span class="line">            ans[i - k + <span class="number">1</span>] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题解（单调队列）：Maximum-Number-of-Robots-Within-Budget"><a href="#题解（单调队列）：Maximum-Number-of-Robots-Within-Budget" class="headerlink" title="题解（单调队列）：Maximum Number of Robots Within Budget"></a>题解（单调队列）：Maximum Number of Robots Within Budget</h2><p>本题相较于<code>Sliding Window Maximum</code>有几点需要注意：</p><ol><li>窗口大小不固定，队首弹出与budget相关而与窗口大小无关；</li><li><code>chargeTimes</code>的最值处理逻辑相同；</li><li>求解需要知道窗口左侧的位置，需要维护窗口左侧下标。</li></ol><p>队列中存储的还是<code>chargeTimes</code>的下标，因为下标与<code>runningCosts</code>一一对应，则计算总消耗时共用计算即可，本质上可以用单调队列还是因为两点，一是连续窗口，二是最值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumRobots</span><span class="params">(<span class="keyword">int</span>[] chargeTimes, <span class="keyword">int</span>[] runningCosts, <span class="keyword">long</span> budget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 维护左侧下标</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// 用于与预算比较</span></span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; chargeTimes.length; right++) &#123;</span><br><span class="line">            <span class="comment">// 1. 入队，与前置题目逻辑相同</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[right] &gt;= chargeTimes[q.peekLast()]) &#123;</span><br><span class="line">                q.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            q.addLast(right);</span><br><span class="line">            sum += runningCosts[right]; <span class="comment">// 累计cost</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 窗口左端右移，通过预算与消耗比较判断</span></span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; chargeTimes[q.peekFirst()] + (right - left + <span class="number">1</span>) * sum &gt; budget) &#123;</span><br><span class="line">                <span class="comment">// 出队逻辑，在左移过程中遇到最值要同步出队</span></span><br><span class="line">                <span class="keyword">if</span> (q.peekFirst() == left) &#123;</span><br><span class="line">                    q.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= runningCosts[left++]; <span class="comment">// 减去移出元素cost</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 更新答案</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Number-of-Marked-Indices"><a href="#Find-the-Maximum-Number-of-Marked-Indices" class="headerlink" title="Find the Maximum Number of Marked Indices"></a>Find the Maximum Number of Marked Indices</h1><blockquote><p>Find the Maximum Number of Marked Indices</p><p>You are given a 0-indexed integer array nums.</p><p>Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:</p><p>Pick two different unmarked indices i and j such that 2 * nums[i] &lt;= nums[j], then mark i and j.<br>Return the maximum possible number of marked indices in nums using the above operation any number of times.</p></blockquote><p>这题我一开始的思路是按值排序后从大到小匹配，但这样贪心还是不能获得最佳答案，需要从如何获得最优解的角度考虑。当可获得最优解时，长度为 $n$ 的数组最多只会产生 $\left\lfloor\frac{n}{2}\right\rfloor$ 对匹配, 因此对数组从小到大排序以后, 我们将数组一分为二, 左侧元素只会与右侧元素匹配。</p><p>这样操作就可以解决直接排序匹配中找不到最优配对的问题，对于右侧的一个元素，其最优配对的符合条件的元素既不是比他次大的元素，也不是全局最小的元素，而是划分成两半后左侧的符合条件的最大元素。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>具体的, 我们令 $m=\left\lfloor\frac{n}{2}\right\rfloor$, 尝试将下标在 $[0, m-1]$ 范围内的元素 $n u m s[i]$ 与下标在 $[m, n-1]$ 范围内的元素 $n u m s[j]$ 进行匹配。我们从小到大枚举 $i$ ，然后找到最小的 $j$ 使其满足 $2 \times$ $n u m s[i] \leq n u m s[j]$ 。那些末满足条件而被跳过的 nums $[j]$ 将被忽略。持续这一过程,直到 $i=m$ 或 $j=n$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumOfMarkedIndices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m; i &lt; m &amp;&amp; j &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="number">2</span> * nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Count-Increasing-Quadruplets-HARD"><a href="#Count-Increasing-Quadruplets-HARD" class="headerlink" title="Count Increasing Quadruplets HARD"></a>Count Increasing Quadruplets <font color=#FF4500 size=4 face='黑体'>HARD</font></h1><blockquote><p>Count Increasing Quadruplets</p><p>Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.</p><p>A quadruplet (i, j, k, l) is increasing if:</p><ul><li>0 &lt;= i &lt; j &lt; k &lt; l &lt; n, and</li><li>nums[i] &lt; nums[k] &lt; nums[j] &lt; nums[l].</li></ul></blockquote><p>这道题直接暴力能解决一半，剩下一半学习成本有点高了，直接看灵神题解即可，现在没时间学了，感觉意义不大。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12">https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/solutions/2905207/qiu-chu-zui-duo-biao-ji-xia-biao-by-leet-0j2m/?envType=daily-question&amp;envId=2024-09-12</a><br>[2] <a href="https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10">https://leetcode.cn/problems/count-increasing-quadruplets/solutions/2080632/you-ji-qiao-de-mei-ju-yu-chu-li-pythonja-exja/?envType=daily-question&amp;envId=2024-09-10</a><br>[3] <a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13">https://leetcode.cn/problems/maximum-number-of-robots-within-budget/solutions/1798725/by-endlesscheng-7ukp/?envType=daily-question&amp;envId=2024-09-13</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周忙废了…挑战一天写完一周的题。&lt;/p&gt;
&lt;p&gt;本周主题：双指针、枚举、单调队列&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240910每日一题—&lt;a href=&quot;https://leetcode.cn/problems/count-increasing-quadruplets/description&quot;&gt;Count Increasing Quadruplets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240912每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/description&quot;&gt;Find the Maximum Number of Marked Indices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240913每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description&quot;&gt;Maximum Number of Robots Within Budget&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP11</title>
    <link href="http://silencezheng.top/2024/09/08/article138/"/>
    <id>http://silencezheng.top/2024/09/08/article138/</id>
    <published>2024-09-08T14:31:23.000Z</published>
    <updated>2024-09-08T14:32:02.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周感觉还可以吧，有两道周赛做过的题。</p><p>一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。</p><p>本周主题：滑动窗口、枚举、动态规划</p><p>题目：</p><ul><li>240902每日一题—<a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description">Maximize the Confusion of an Exam</a></li><li>240905每日一题—<a href="https://leetcode.cn/problems/happy-students/description">Happy Students</a></li><li>240907每日一题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description">Find the Maximum Length of a Good Subsequence II</a><span id="more"></span><h1 id="Maximize-the-Confusion-of-an-Exam"><a href="#Maximize-the-Confusion-of-an-Exam" class="headerlink" title="Maximize the Confusion of an Exam"></a>Maximize the Confusion of an Exam</h1><blockquote><p>Maximize the Confusion of an Exam</p><p>A teacher is writing a test with n true/false questions, with ‘T’ denoting true and ‘F’ denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).</p><p>You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:<br>Change the answer key for any question to ‘T’ or ‘F’ (i.e., set answerKey[i] to ‘T’ or ‘F’).</p><p>Return the maximum number of consecutive ‘T’s or ‘F’s in the answer key after performing the operation at most k times.</p></blockquote></li></ul><p>这道题本来想考虑DP，状态为“最后一个元素为i，替换次数为j时的最大连续子串长度”，但有问题，最后一个元素可能会被替换，且最大子串只在全替换为T或F时才出现，怎么弄怎么别扭，还是用滑窗吧。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>在指定字符的情况下，可以计算其最大连续数目。使用滑动窗口的方法，从左到右枚举右端点，维护区间中另一种字符的数量为 sum，当 sum 超过 k，我们需要让左端点右移，直到 sum≤k。移动过程中，我们记录滑动窗口的最大长度，即为指定字符的最大连续数目。答案为分别指定字符为 T 和 F 时的最大连续数目的较大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(String answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxConsecutiveChar(answerKey, k, <span class="string">&#x27;T&#x27;</span>), maxConsecutiveChar(answerKey, k, <span class="string">&#x27;F&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxConsecutiveChar</span><span class="params">(String answerKey, <span class="keyword">int</span> k, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            sum += answerKey.charAt(right) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">                sum -= answerKey.charAt(left++) != ch ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Happy-Students"><a href="#Happy-Students" class="headerlink" title="Happy Students"></a>Happy Students</h1><blockquote><p>Happy Students</p><p>You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.</p><p>The ith student will become happy if one of these two conditions is met:</p><ul><li>The student is selected and the total number of selected students is strictly greater than nums[i].</li><li>The student is not selected and the total number of selected students is strictly less than nums[i].</li></ul><p>Return the number of ways to select a group of students so that everyone remains happy.</p></blockquote><p>一开始拿到没想出好办法，回溯暴力了一下，超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> Set&lt;Set&lt;Integer&gt;&gt; mem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        mem = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        bt(nums, set, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bt</span><span class="params">(List&lt;Integer&gt; nums, Set&lt;Integer&gt; selected, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&lt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(selected.size()&gt;=nums.get(i))&#123;</span><br><span class="line">                    success = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(success&amp;&amp;!mem.contains(selected))&#123;</span><br><span class="line">            mem.add(selected);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(selected.toString());</span></span><br><span class="line">        <span class="keyword">if</span>(p==nums.size()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(selected.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line">            selected.add(i);</span><br><span class="line">            bt(nums, selected, p+<span class="number">1</span>);</span><br><span class="line">            selected.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上需要想明白选中人数为k时方案唯一，再按照这个思路去枚举就可以了。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>根据题意可知，假设数组 nums 的长度为 n，此时设选中学生人数为 k，此时 k∈[0,n]，k 应满足如下：</p><ul><li>所有满足 nums[i]&lt;k 的学生应被选中；</li><li>所有满足 nums[i]&gt;k 的学生不应被选中；</li><li>不能存在 nums[i]=k 的学生；</li></ul><p>这意味着在确定当前已择中学生人数的前提下，则此时选择方案是唯一的，为方便判断，我们把 nums 从小到大排序。我们枚举选中的人数 k，由于 nums 已有序，此时最优分组一定是前 k 个学生被选中，剩余的 n−k 个学生不被选中，此时只需要检测选中的 k 个学生中的最大值是否满足小于 k，未被选中的学生中的最小值是否满足大于 k 即可，如果同时满足上述两个条件，则该分配方案可行，最终返回可行的方案计数即可，需要注意处理好边界 0 与 n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countWays</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Collections.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="comment">// 前 k 个元素的最大值是否小于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums.get(k - <span class="number">1</span>) &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 后 n - k 个元素的最小值是否大于 k</span></span><br><span class="line">            <span class="keyword">if</span> (k &lt; n &amp;&amp; nums.get(k) &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Find-the-Maximum-Length-of-a-Good-Subsequence-II"><a href="#Find-the-Maximum-Length-of-a-Good-Subsequence-II" class="headerlink" title="Find the Maximum Length of a Good Subsequence II"></a>Find the Maximum Length of a Good Subsequence II</h1><blockquote><p>Find the Maximum Length of a Good Subsequence II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p></blockquote><p>周赛原题，当时DP都没想出来，这周把基础DP想通了，先写一下。</p><ol><li>拆分子问题：从seq中取出最后一个，则有两种情况<ul><li>情况一：seq中的前后不等对数量不变，则原问题变成了[0,i]上不超过k的</li><li>情况二：不等对数量减1，原问题变成了[0,i]上不超过k-1的</li></ul></li><li>定义状态<code>dp[i][j]</code>表示最后一个数为i时不超过j的最大长度</li><li>状态转移：<code>dp[i][j]</code> = Max(遍历0到i-1中和i位置元素相同的j取最大, 遍历[0,i-1][j-1]取最大)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> maxInd = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[o]==nums[i]&amp;&amp;max&lt;=dp[o][j])&#123;</span><br><span class="line">                        max = dp[o][j];</span><br><span class="line">                        maxInd = o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> max2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> maxInd2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;i;o++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(max2&lt;=dp[o][j-<span class="number">1</span>])&#123;</span><br><span class="line">                            max2 = dp[o][j-<span class="number">1</span>];</span><br><span class="line">                            maxInd2 = o;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(max2&gt;max)&#123;</span><br><span class="line">                        max = max2;</span><br><span class="line">                        maxInd = maxInd2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) res=Math.max(res, dp[i][k]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么这道题不能用01背包的状态来做呢？看起来不就是一个从一堆元素中选若干个的问题吗？这是因为01背包中，背包容量实际上包含了前序选择信息的最优解，即在当前背包容量支持放入当前物品时一定会选择放入。而对于本题来说，当前状态的前一个或上一个（指j-1和i-1）状态并不一定是对于本状态转移来说最优的，因为当前元素和前序元素中的某个值匹配时产生了更优解，而这个更优解是随遍历元素不断变动的。</p><p>想通了这一点，舒服多了。。。当时困扰我好几天。</p><p>然而上面的方法在大数据范围下还是不行，存在太多循环计算，下面介绍优化方案。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>PS：这题解写的依托，还是看我之前周赛时候的题解吧。</p><p>我们在上面的方案基础上优化，上面的时间复杂度是$O(n^2k)$。假设当前元素<code>i</code>的前序元素为<code>x</code>，可以枚举两种情况：</p><ul><li><p>nums $[i] \neq n u m s[x]$, 对于此情况, 可以维护一个长度为 $k$ 的辅助数组 $z d$ 。其中 $z d[j]$ 表示枚举到位置 $i$ 之前，有 $j$ 个数字与其在序列中的后一个不相等的最长合法序列的长度，那么可以直接写出转移 $d p[i][j]=z d[j-1]+1$ 。</p></li><li><p>nums $[i]=n u m s[x]$, 假设有下标 $a&lt;b&lt;c$, 并且 nums $[a]=$ $n u m s[b]=\operatorname{nums}[c]$, 对于 $c$ 来说如果选取由 $a$ 转移过来计算答案, 那么一定不如 $a \rightarrow b \rightarrow c$ 更优, 所以会选取下标最近的相同的数进行转移。针对这种情况， $d p$ 使用哈希表维护能节省一些空间，并且在哈希表中用 $n u m s[i]$ 替换 $i$ 。</p></li></ul><p>在每一次遍历 $i$ 计算完后更新 $z d$ ，最后的 $z d[k]$ 就是答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; dp = <span class="keyword">new</span> HashMap&lt;Integer, <span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] zd = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = nums[i];</span><br><span class="line">            dp.putIfAbsent(v, <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] tmp = dp.get(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                tmp[j] = tmp[j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp[j] = Math.max(tmp[j], zd[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                zd[j] = Math.max(zd[j], tmp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zd[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04">https://leetcode.cn/problems/happy-students/solutions/2895368/rang-suo-you-xue-sheng-bao-chi-kai-xin-d-45br/?envType=daily-question&amp;envId=2024-09-04</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周感觉还可以吧，有两道周赛做过的题。&lt;/p&gt;
&lt;p&gt;一个感悟是，做题要遵守基本法，空间和时间是此消彼长的，动态规划的状态定义也是有章可循的。&lt;/p&gt;
&lt;p&gt;本周主题：滑动窗口、枚举、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240902每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/description&quot;&gt;Maximize the Confusion of an Exam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240905每日一题—&lt;a href=&quot;https://leetcode.cn/problems/happy-students/description&quot;&gt;Happy Students&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240907每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description&quot;&gt;Find the Maximum Length of a Good Subsequence II&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP10</title>
    <link href="http://silencezheng.top/2024/09/01/article137/"/>
    <id>http://silencezheng.top/2024/09/01/article137/</id>
    <published>2024-08-31T17:12:14.000Z</published>
    <updated>2024-08-31T17:13:14.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>DPDPDP</p><p>本周主题：二分查找、动态规划、记忆化搜索</p><p>题目：</p><ul><li>240827每日一题—<a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description">Find the Median of the Uniqueness Array</a></li><li>240828每日一题—<a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description">Minimum Substring Partition of Equal Character Frequency</a><span id="more"></span><h1 id="Find-the-Median-of-the-Uniqueness-Array"><a href="#Find-the-Median-of-the-Uniqueness-Array" class="headerlink" title="Find the Median of the Uniqueness Array"></a>Find the Median of the Uniqueness Array</h1><blockquote><p>Find the Median of the Uniqueness Array</p><p>You are given an integer array nums. The uniqueness array of nums is the sorted array that contains the number of distinct elements of all the subarrays of nums. In other words, it is a sorted array consisting of distinct(nums[i..j]), for all 0 &lt;= i &lt;= j &lt; nums.length.</p><p>Here, distinct(nums[i..j]) denotes the number of distinct elements in the subarray that starts at index i and ends at index j.</p><p>Return the median of the uniqueness array of nums.</p><p>Note that the median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the smaller of the two values is taken.</p></blockquote></li></ul><p>容易分析出以下解题步骤：</p><ol><li>find out a way to express all the subarrays<ol><li>which means 0,0\1,1...\n-1,n-1; 0,1\1,2...\n-2,n-1; … 0,n-2\1,n-1; 0,n-1</li><li>we can find out there were n+n-1+…+2+1 subarrays in total.</li><li>which means there were (n*(n+1))/2 elements in uniqueness array.</li></ol></li><li>find out how many “distinctors” in there<ol><li>the max value of them should be 1,2,…,n</li><li>we can find a way to calculate them from the base subarrs, like from 1 number</li></ol></li></ol><p>总结一下：</p><ol><li>uniqueness array中一共有(n<em>(n+1))/2个元素，中位数位置在(n</em>(n+1))/4向下取整。</li><li>这些元素可以被分类，其中n个的范围为[1, 1]，n-1个的范围为[1, 2]，…，1个的范围为[1, n]。</li></ol><p>基于以上分析，可以写出暴力法，显然超时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Set&lt;Integer&gt;[] sets = <span class="keyword">new</span> HashSet[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">            sets[i].add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) list.add(sets[i].size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                sets[j].add(nums[i+j]);</span><br><span class="line">                list.add(sets[j].size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list.size()%<span class="number">2</span>==<span class="number">0</span>?list.get(list.size()/<span class="number">2</span>-<span class="number">1</span>):list.get(list.size()/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现上述总结2中存在单调性，考虑使用二分查找。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>设数组 nums 的长度为 $n$, 我们令 $c_t$ 表示数组 nums 中至多含有 $t$ 个不同元素的子数组数目，实际 $t$ 的取值范围为： $t \in[1, \operatorname{distinct}[0 \cdots n-1]]$ 。此时可以发现 $t$ 越大，则 $c_t$ 也越大, 且满足 $c_n=\frac{n \times(n+1)}{2}$ 。我们可以观察到 $c_t$ 呈现单调性, 因此可以考虑使用二分查找, 如果 $c_t&lt;$ median 则 $t$ 一定不是中位数, 因此利用二分查找找到 $t$ 的上限, 此时找到满足 $c_t \geq$ median 时最小的 $t$, 即为唯一性数组的中位数。</p><p>因此需要寻找一种方法计算$c_t$，注意到若数组$nums[i, j]$中至多含有 $t$ 个不同元素，则该数组的所有子数组也至多含有 $t$ 个不同元素。这里$nums[i, j]$可以用一个窗口表示，即双指针。$c_t$随$t$单调不减，可以用二分查找找到合适的t，判定是否合适的条件是是否$c_t \geq$ median，如果是的话则缩小$t$，否则增加$t$。</p><p>子数组越长, 则不同元素个数只会变大或不变，满足单调性。我们用哈希表 cnt 统计窗口子数组 $n u m s[i \cdots j]$ 中不同元素出现的次数。枚举窗口右端点 $i$ ，把 $n u m s[i]$ 加入到哈希表 cnt 中, 即此时 $n u m s[i]$ 出现次数加 1 。如果哈希表 cnt 中元素的数目超过 $t$ ，就不断移出窗口左端点元素 $n u m s[j]$ ，即此时 $n u m s[j]$ 出现的次数减去 1 ，如果 nums $[j]$ 出现次数等于 0 , 则将其从哈希表 cnt 中移除, 直到 cnt 中元素的数目等于 $t$ 为止。此时窗口的右端点为 $i$, 则此时子数组 nums $[j \cdots i]$, nums $[j+1 \cdots i]$, nums $[j+$ $2 \cdots i], \cdots$, nums $[i \cdots i]$ 都满足不同元素数目小于等于 $t$, 一共有 $i-j+1$ 个, 加到总数 tot 中, 最终的总数 $c_t=t o t$ 。我们每次检测是否满足 $c_t \geq$ median, 如果满足则缩小 $t$, 直到找到最小的 $t$ 返回即可。</p><p>实际二分查找时, $t$ 的下限取 1 , 此时一定不存在 0 个元素的子数组, $t$ 的上限为 $n$, 所有子数组的不同元素数目不超过 $n$ 。设 $m=\operatorname{distinct}[0 \cdots n-1]$ ，实际 $t$ 的取值范围为 $[1, m]$ ，且在该区间 $[1, m]$ 上的取值连续，因此一定可以找到属于某个子数组的 distinct 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfUniquenessArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">long</span> median = ((<span class="keyword">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>, hi = n;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(nums, mid, median)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测数组中不同元素数目小于等于 t 的连续子数组数目是否大于等于 median</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> t, <span class="keyword">long</span> median)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// j，i为左右指针，遍历数组计算c_t</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cnt.put(nums[i], cnt.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (cnt.size() &gt; t) &#123;</span><br><span class="line">                cnt.put(nums[j], cnt.get(nums[j]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (cnt.get(nums[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.remove(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            tot += i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot &gt;= median;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Minimum-Substring-Partition-of-Equal-Character-Frequency"><a href="#Minimum-Substring-Partition-of-Equal-Character-Frequency" class="headerlink" title="Minimum Substring Partition of Equal Character Frequency"></a>Minimum Substring Partition of Equal Character Frequency</h1><blockquote><p>Minimum Substring Partition of Equal Character Frequency</p><p>Given a string s, you need to partition it into one or more balanced<br>substrings. For example, if s == “ababcc” then (“abab”, “c”, “c”), (“ab”, “abc”, “c”), and (“ababcc”) are all valid partitions, but (“a”, “bab”, “cc”), (“aba”, “bc”, “c”), and (“ab”, “abcc”) are not. The unbalanced substrings are bolded.Return the minimum number of substrings that you can partition s into.</p><p>Note: A balanced string is a string where each character in the string occurs the same number of times.</p></blockquote><p>以后看到这种最值选元素的…直接开DP就完了，最差也是等同暴力吧。</p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>首先可以确定一定存在分割方案（都分成单字母）。</p><p>对于一个字符串<code>s</code>，从末尾分割出长度为<code>x</code>的平衡子串，则问题变成剩余字符串最少能分割出多少个平衡子串。这将原问题分解为<strong>相似且规模更小的子问题</strong>，可以递归求解。</p><blockquote><p>注 1：从右往左思考，主要是为了方便把递归翻译成递推。从左往右思考也是可以的。<br>注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。<br>注 3：这里的思考可以理解成从“最后一步”出发，划分子问题，即最后一步一定是划分出一个平衡子串，则考虑剩余部分的子问题即可，此时划分出最后一步不影响剩余部分的正确求解。反观贪心，如果尝试一次找到一个最长的平衡子串，则可能影响整体最优，因此这类问题最好通过DP+枚举解决。</p></blockquote><p>下面考虑<strong>状态定义与转移</strong>，假设剩余前缀字符串为<code>s[0...i]</code>，定义状态<code>f(i)</code>为剩余<code>s[0...i]</code>时最少能分割出多少平衡子串，则可以通过枚举<code>j=0,1,..,i</code>，找到平衡子串<code>s[j...i]</code>，则问题转化为求解状态 <code>f(j-1)</code>，实现递归求解<code>f(i)</code>。可以枚举所有<code>j</code>，找到最小的<code>f(j-1)</code>。</p><p>有一种方法可以<strong>快速判断子串平衡</strong>，即在倒序枚举<code>j</code>的同时，用一个哈希表（或者数组）统计子串<code>s[j...i]</code>每个字符的出现次数。如果子串中每个字母的出现次数都相等，那么子串是平衡的。进一步优化，设子串<code>s[j...i]</code>中有<code>k</code>种字母，字母出现次数的最大值为<code>maxCnt</code>。子串是平衡的，当且仅当子串长度<code>i−j+1</code>等于<code>k⋅maxCnt</code>。</p><p>原问题表示为<code>f(n-1)</code>，则可递归计算：<code>f(n-1) = 1+f(x) = ... = m + f(-1) = m</code>。其中<code>x</code>表示第一次求得的最小<code>f(j-1)</code>对应的<code>j</code>，<code>m</code>表示最终划分出的平衡子串数量。分析至此可以写出暴力递归解法一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力递归在数据范围大的情况下依然会TTL，注意到枚举<code>j</code>的过程中存在大量重复计算，考虑使用记忆化减少计算。由于递归函数幂等，可以对<code>入参+返回</code>的组合进行记忆化。使用一个数组<code>memo</code>来记录：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个 memo 数组中。</li><li>如果一个状态不是第一次遇到（memo 中保存的结果不等于 memo 的初始值），那么可以直接返回 memo 中保存的结果。</li></ul><p>注意<code>memo</code>数组的初始值一定不能等于要记忆化的值，否则会跳过首次计算。因为递归求解等同于递归搜索，此类算法亦可称为<strong>记忆化搜索</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> dfs(n - <span class="number">1</span>, s, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>[] s, <span class="keyword">int</span>[] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 之前计算过</span></span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>, maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                res = Math.min(res, dfs(j - <span class="number">1</span>, s, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = res; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化搜索为自顶向下计算，即从<code>f(n-1)</code>开始递归搜索。动态规划则是考虑自底向上的计算，即从<code>f(0)</code>开始计算。</p><p>定义状态<code>dp[i]</code>表示剩余字符串为<code>s[0...i]</code>时最少能分割出多少平衡子串，则有状态转移方程：</p><script type="math/tex; mode=display">dp[i] = \min _{j=0}^i dp[j]+1，其中s[j...i]平衡</script><p>另外由于递归边界为<code>f(-1)</code>，则用<code>dp[0]</code>存放初始状态<code>dp[0] = 0</code>，剩余状态右移一位（递归边界对应DP初状态）。最终返回结果为<code>dp[n]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSubstringsInPartition</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(cnt, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                k += cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                maxCnt = Math.max(maxCnt, cnt[s[j] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i - j + <span class="number">1</span> == k * maxCnt) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28">https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/solutions/2775377/hua-fen-xing-dpji-yi-hua-sou-suo-di-tui-s1nq0/?envType=daily-question&amp;envId=2024-08-28</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;DPDPDP&lt;/p&gt;
&lt;p&gt;本周主题：二分查找、动态规划、记忆化搜索&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240827每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array/description&quot;&gt;Find the Median of the Uniqueness Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240828每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-substring-partition-of-equal-character-frequency/description&quot;&gt;Minimum Substring Partition of Equal Character Frequency&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP9</title>
    <link href="http://silencezheng.top/2024/08/25/article136/"/>
    <id>http://silencezheng.top/2024/08/25/article136/</id>
    <published>2024-08-24T17:08:04.000Z</published>
    <updated>2024-08-24T17:45:52.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。</p><p>本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP</p><p>题目：</p><ul><li>240819每日一题—<a href="https://leetcode.cn/problems/student-attendance-record-ii/description">Student Attendance Record II</a></li><li>240820每日一题—<a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description">Find Number of Ways to Reach the K-th Stair</a></li><li>240822每日一题—<a href="https://leetcode.cn/problems/minimum-array-end/description">Minimum Array End</a></li><li>240823每日一题—<a href="https://leetcode.cn/problems/find-products-of-elements-of-big-array/description">Find Products of Elements of Big Array</a></li><li>240824每日一题—<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description">Partition to K Equal Sum Subsets</a></li></ul><p>PS：腾子音乐的笔也忒难了<br><span id="more"></span></p><h1 id="Student-Attendance-Record-II-（HARD）"><a href="#Student-Attendance-Record-II-（HARD）" class="headerlink" title="Student Attendance Record II （HARD）"></a>Student Attendance Record II <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Student Attendance Record II</p><p>An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p><ul><li>‘A’: Absent.</li><li>‘L’: Late.</li><li>‘P’: Present.</li></ul><p>Any student is eligible for an attendance award if they meet both of the following criteria:</p><ul><li>The student was absent (‘A’) for strictly fewer than 2 days total.</li><li>The student was never late (‘L’) for 3 or more consecutive days.</li></ul><p>Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.</p></blockquote><p>初次分析时，可得到如下限制：</p><ol><li>最多只能有两个<code>A</code></li><li><code>L</code>可能被<code>A</code>或<code>P</code>隔开</li><li><code>L</code>只能出现单独的一个或连续的两个</li><li><code>L</code>的最大数量为<code>n/3*2 + n-(n/3*2)</code>，即把出勤分为若干个三元组与一个末尾，三元组中均存在两个<code>L</code>，末尾均为<code>L</code></li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>可以使用动态规划计算可奖励的出勤记录的数量。</p><p>由于可奖励的出勤记录要求缺勤次数少于 2 和连续迟到次数少于 3，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定（由于不会记录连续迟到次数等于或多于 3 的情况，因此非结尾的连续迟到次数一定少于 3，只需要记录结尾连续迟到次数即可）。</p><p>定义 $d p[i][j][k]$ 表示前 $i$ 天有 $j$ 个 ‘$\mathrm{A}$’ 且结尾有连续 $k$ 个 ‘ L ‘ 的可奖励的出勤记录的数量, 其中 $0 \leq i \leq$ $n, 0 \leq j \leq 1,0 \leq k \leq 2$ 。</p><p>当 $i=0$ 时，没有任何出勤记录，此时 ‘ $A$ ‘的数量和结尾连续 ‘ $L$ ‘ 的数量一定是 0 ，因此动态规划的边界情况是 $d p[0][0][0]=1$ 。</p><p>当 $1 \leq i \leq n$ 时， $d p[i][][]$ 的值从 $d p[i-1][][]$ 的值转移得到，计算每个状态的值需要考虑第 $i$ 天的出勤记录:</p><ul><li>如果第 $i$ 天的出勤记录是 ‘ P ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量不变，结尾连续 ${ }^{\prime} \mathrm{L}$ ‘ 的数量清零，因此对 $0 \leq j \leq 1$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][0]:=d p[i][j][0]+\sum_{k=0}^2 d p[i-1][j][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ $A$ ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘ $A$ ‘的数量加 1 ，结尾连续 ‘ $L$ ‘ 的数量清零，此时要求前 $i-1$ 天的出勤记录记录中的 ‘ $A$ ‘的数量必须为 0 ，否则前 $i$ 天的出勤记录至少有 2 个 ‘ $A$ ‘，不满足可奖励的条件，因此有</li></ul><script type="math/tex; mode=display">d p[i][1][0]:=d p[i][1][0]+\sum_{k=0}^2 d p[i-1][0][k]</script><ul><li>如果第 $i$ 天的出勤记录是 ‘ L ‘，则前 $i$ 天和前 $i-1$ 天的出勤记录相比， ‘A’ 的数量不变，结尾连续 ${ }^{\prime} L$ ‘ 的数量加 1 , 此时要求前 $i-1$ 天的出勤记录记录中的结尾连续 ‘ $L$ ‘ 的数量不超过 1 ，否则前 $i$天的出勤记录的结尾至少有 3 个 ‘ $L$ ‘，不满足可奖励的条件，因此对 $0 \leq j \leq 1$ 和 $1 \leq k \leq 2$ ，有</li></ul><script type="math/tex; mode=display">d p[i][j][k]:=d p[i][j][k]+d p[i-1][j][k-1]</script><p>上述状态转移方程对于<code>i=1</code>也适用。计算长度为 n 的所有可奖励的出勤记录的数量，即为计算 <code>dp[n][][]</code> 的所有元素之和。计算过程中需要将结果对<code>10^9+7</code>取模。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// 长度，A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][<span class="number">0</span>] = (dp[i][j][<span class="number">0</span>] + dp[i - <span class="number">1</span>][j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[n][j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据状态转移，发现可以利用滚动数组优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkRecord</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// A 的数量，结尾连续 L 的数量</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[][] dpNew = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 以 P 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][<span class="number">0</span>] = (dpNew[j][<span class="number">0</span>] + dp[j][k]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 A 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                dpNew[<span class="number">1</span>][<span class="number">0</span>] = (dpNew[<span class="number">1</span>][<span class="number">0</span>] + dp[<span class="number">0</span>][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 以 L 结尾的数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                    dpNew[j][k] = (dpNew[j][k] + dp[j][k - <span class="number">1</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = dpNew;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                sum = (sum + dp[j][k]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：逐渐理解DP似乎就是一种限制条件枚举的解法，列出限制，逐条件枚举，例如01背包就是在枚举背包容量。</p><h1 id="Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）"><a href="#Find-Number-of-Ways-to-Reach-the-K-th-Stair-（HARD）" class="headerlink" title="Find Number of Ways to Reach the K-th Stair （HARD）"></a>Find Number of Ways to Reach the K-th Stair <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h1><blockquote><p>Find Number of Ways to Reach the K-th Stair</p><p>You are given a non-negative integer k. There exists a staircase with an infinite number of stairs, with the lowest stair numbered 0.</p><p>Alice has an integer jump, with an initial value of 0. She starts on stair 1 and wants to reach stair k using any number of operations. If she is on stair i, in one operation she can:</p><ul><li>Go down to stair i - 1. This operation cannot be used consecutively or on stair 0.</li><li>Go up to stair i + 2jump. And then, jump becomes jump + 1.<br>Return the total number of ways Alice can reach stair k.<br>Note that it is possible that Alice reaches the stair k, and performs some operations to reach the stair k again.</li></ul></blockquote><p>容易想到递归方式穷举所有可能性，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveMachine</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> jump, <span class="keyword">boolean</span> canDown, <span class="keyword">int</span> ops)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;ks+<span class="number">1</span>||ops&gt;<span class="number">61</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==ks)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        moveMachine(i+(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, jump), jump+<span class="number">1</span>, <span class="keyword">true</span>, ops+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(canDown) moveMachine(i-<span class="number">1</span>, jump, <span class="keyword">false</span>, ops+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToReachStair</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ks = k;</span><br><span class="line">        moveMachine(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> k==<span class="number">1</span>?<span class="number">4</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力穷举用例只能通过50%，组合数学法见官解。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>两道题都是组合+位运算的类型，例题一必须完全掌握，第二题以目前水平能写个七八十就可以了。</p><h2 id="例题一：Minimum-Array-End"><a href="#例题一：Minimum-Array-End" class="headerlink" title="例题一：Minimum Array End"></a>例题一：Minimum Array End</h2><blockquote><p>Minimum Array End</p><p>You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 &lt;= i &lt; n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.</p><p>Return the minimum possible value of nums[n - 1].</p></blockquote><p>题目还是很好理解的，仔细分析一下就知道是要从<code>x</code>开始逐步往<code>0</code>位上填1，直到填出第n-1个数，填充过程保持数组递增。我的第一次解法如下，会OOM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 存储低位到高位的0位置，后续按顺序拼mask就行了</span></span><br><span class="line">        List&lt;Long&gt; masks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(last&lt;=Long.MAX_VALUE&amp;&amp;masks.size()&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((last&amp;x)==<span class="number">0</span>)&#123;</span><br><span class="line">                masks.add(last);</span><br><span class="line">                <span class="keyword">int</span> len = masks.size();</span><br><span class="line">                <span class="comment">// 存储组合</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                    masks.add(last^masks.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            last&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>?x:(x^masks.get(n-<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到的卡点是计算目标值需要存储前序值，需要压缩空间。可以用另一种视角来看填<code>0</code>位的过程，即把<code>x</code>上的<code>1</code>位都提出来，剩下的位置上按<code>1、2、...、n-1</code>的值去填即可，例如对于<code>x = 100010, n = 4</code>，可以看作是向<code>0000</code>上依次填<code>0001, 0010, 0011</code>，则可得出答案<code>100111</code>。因此，可以确定目标值为把<code>n-1</code>的二进制插入到<code>x</code>的<code>0</code>位中，解法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">minEnd</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回值可能的最大位数，即两个long的长度减去各自的前导0，当x全是1时出现。</span></span><br><span class="line">        <span class="keyword">int</span> bitCount = <span class="number">128</span> - Long.numberOfLeadingZeros(n) - Long.numberOfLeadingZeros(x);</span><br><span class="line">        <span class="keyword">long</span> res = x;</span><br><span class="line">        <span class="keyword">long</span> m = n - <span class="number">1</span>; <span class="comment">// 要填到0位的所有bit</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录x中已经填过的bit</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitCount; ++i) &#123;</span><br><span class="line">            <span class="comment">// 逐位查看是否是0</span></span><br><span class="line">            <span class="keyword">if</span> (((res &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 对于是0的位置，如果n-1也为0则不处理，如果为1则用异或填入</span></span><br><span class="line">                <span class="keyword">if</span> (((m &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    res |= (<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题二：Find-Products-of-Elements-of-Big-Array-（HARD）"><a href="#例题二：Find-Products-of-Elements-of-Big-Array-（HARD）" class="headerlink" title="例题二：Find Products of Elements of Big Array （HARD）"></a>例题二：Find Products of Elements of Big Array <font color=#FF4500 size=4 face='黑体'>（HARD）</font></h2><blockquote><p>Find Products of Elements of Big Array</p><p>The powerful array of a non-negative integer x is defined as the shortest sorted array of powers of two that sum up to x. The table below illustrates examples of how the powerful array is determined. It can be proven that the powerful array of x is unique.</p><p>The array big_nums is created by concatenating the powerful arrays for every positive integer i in ascending order: 1, 2, 3, and so on. Thus, big_nums begins as [1, 2, 1, 2, 4, 1, 4, 2, 4, 1, 2, 4, 8, …].</p><p>You are given a 2D integer matrix queries, where for queries[i] = [fromi, toi, modi] you should calculate (big_nums[fromi] <em> big_nums[fromi + 1] </em> … * big_nums[toi]) % modi.</p><p>Return an integer array answer such that answer[i] is the answer to the ith query.</p></blockquote><p>思路：首先看如何定位<code>bignums[i]</code>的值，从数位的角度考虑，对于<code>01000</code>来说，其之前的元素个数其实就是1、2、3个1在3个格子中有多少种排列，然后再乘元素数<code>C31*1+C32*2+C33*3 = 12</code>，可以应用<strong>组合数的加权求和公式</strong>。用<code>b(x)</code>表示<code>b(x)</code>位为1，其余为0的二进制数，<code>x</code>从0开始，则<code>b(x)</code>的下标为<code>n*2^(n-1)</code>。对于任意一个下标<code>y</code>，考虑遍历<code>i</code>，找到首个小于<code>y</code>的<code>i*2^(i-1)</code>，然后模拟遍历数位找到<code>bignums[from]</code>的值，继续模拟遍历，找到<code>bignums[to]</code>之间的若干值，求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findProductsOfElements(<span class="keyword">long</span>[][] queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="keyword">long</span> from = queries[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">long</span> to = queries[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> mod = queries[k][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> lastSmallInd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> lastPower = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i&lt;=from)&#123;</span><br><span class="line">                    lastSmallInd = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, i-<span class="number">1</span>) * i;</span><br><span class="line">                    lastPower = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> startOuterVal = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, lastPower);</span><br><span class="line">            <span class="keyword">int</span> startVal = startOuterVal;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(lastSmallInd&lt;from)&#123;</span><br><span class="line">                <span class="comment">// 模拟</span></span><br><span class="line">                <span class="keyword">int</span> startInd = lastSmallInd;</span><br><span class="line">                <span class="keyword">while</span>(startInd&lt;from)&#123;</span><br><span class="line">                    startOuterVal++;</span><br><span class="line">                    <span class="keyword">int</span> tmp = Integer.bitCount(startOuterVal); <span class="comment">// 减去最大的1</span></span><br><span class="line">                    <span class="keyword">if</span>(startInd+tmp&lt;from) startInd+=tmp;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 逐位右移寻找</span></span><br><span class="line">                        <span class="keyword">int</span> sov = startOuterVal;</span><br><span class="line">                        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 元素计数</span></span><br><span class="line">                        <span class="keyword">int</span> bitCnt = -<span class="number">1</span>; <span class="comment">// 位数计数</span></span><br><span class="line">                        <span class="keyword">while</span> (startInd+cnt&lt;from) &#123;</span><br><span class="line">                            <span class="comment">// 判断末位是否为1</span></span><br><span class="line">                            <span class="keyword">if</span>((sov&amp;<span class="number">1</span>)==<span class="number">1</span>) cnt++;</span><br><span class="line">                            sov&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                            bitCnt++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startVal = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, bitCnt);</span><br><span class="line">                        startInd+=cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开始计算结果</span></span><br><span class="line">            <span class="keyword">long</span> mul = startVal;</span><br><span class="line">            <span class="keyword">long</span> remain = to-from; <span class="comment">// to-from个元素还没计算</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(remain&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(startVal&lt;startOuterVal)&#123;</span><br><span class="line">                    startVal&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remain&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 有重合的1</span></span><br><span class="line">                    <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>)&#123;</span><br><span class="line">                        remain--;</span><br><span class="line">                        mul*=startVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                startOuterVal++;</span><br><span class="line">                startVal = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((startVal&amp;startOuterVal)!=<span class="number">0</span>) remain--;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            ans[k] = (<span class="keyword">int</span>) (mul%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法可以通过95%的用例，全通的解法可以参考官解。</p><h1 id="Partition-to-K-Equal-Sum-Subsets"><a href="#Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="Partition to K Equal Sum Subsets"></a>Partition to K Equal Sum Subsets</h1><blockquote><p>Partition to K Equal Sum Subsets</p><p>Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>1 &lt;= k &lt;= nums.length &lt;= 16<br>1 &lt;= nums[i] &lt;= 10^4<br>The frequency of each element is in the range [1, 4].</p></blockquote><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><blockquote><p>状态压缩就是使用某种方法，简明扼要地以最小代价来表示某种状态，通常是用一串01数字（二进制数）来表示各个点的状态。这就要求使用状态压缩的对象的点的状态必须只有两种，0 或 1；当然如果有三种状态用三进制来表示也未尝不可。</p><p>状态压缩的目的一方面是缩小了数据存储的空间，另一方面是在状态对比和状态整体处理时能够提高效率。这样就要求状态数据中的单元个数不能太大，比如用int来表示一个状态的时候，状态的单元个数不能超过32（32位的机器），所以题目一般都是至少有一维的数据范围很小。</p></blockquote><p>状压DP就是使用状态压缩的动态规划。动态规划问题通常有两种，一种是对递归问题的记忆化求解，另一种是把大问题看作是多阶段的决策求解。这里用的便是后一种，这带来一个需求，即存储之前的状态，再由状态及状态对应的值推演出状态转移方程最终得到最优解。</p><p>回到本题，题目给定长度为 $n$ 的数组 $nums$，和整数 $k$，我们需要判断是否能将数组分成 $k$ 个总和相等的非空子集。首先计算数组的和 $all$，如果 $all$ 不是 $k$ 的倍数，那么不可能能有合法方案，此时直接返回 $False$。否则我们需要得到 $k$ 个和为 $per= all/k$的集合。</p><p>数组长度在16以内，则可以用一个整数 $S$ 来表示当前可用的数字集合：从低位到高位, 第 $i$ 位为 0 则表示数字 nums $[i]$ 可以使用, 否则表示 nums [i] 已被使用。然后我们用 $d p[S]$ 来表示在可用的数字状态为 $S$ 的情况下是否可能可行, 初始全部状态为记录为不可行状态 False, 只记 $d p[0]=$ True 为可行状态。</p><p>我们每次对于当前状态下从可用的数字中选择一个数字, 若此时选择全部数字取模后小于等于 per。则说明选择该数字后的状态再继续往下添加数字是可能能满足题意的，并且此时标记状为可能可行状态，否则就一定不能达到满足。最终返回 $d p[U]$即可, 其中 $U$ 表示全部数字使用的集合状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> all = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">if</span> (all % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> per = all / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[n - <span class="number">1</span>] &gt; per) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始DP</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 所有可能的状态</span></span><br><span class="line">        <span class="keyword">int</span>[] curSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; n]; <span class="comment">// 状态对应的总和？</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dp[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curSum[i] + nums[j] &gt; per) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 状态i中j物品可用</span></span><br><span class="line">                <span class="keyword">if</span> (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 定位下一个状态，即选了j物品后的状态</span></span><br><span class="line">                    <span class="keyword">int</span> next = i | (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                    <span class="comment">// 如果是不可用状态，说明还没更新过</span></span><br><span class="line">                    <span class="keyword">if</span> (!dp[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对per取余表示删除已存满的子集</span></span><br><span class="line">                        curSum[next] = (curSum[i] + nums[j]) % per;</span><br><span class="line">                        dp[next] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全为1的状态下是否可用，即取走全部元素后是否可行</span></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/">https://algo.itcharge.cn/10.Dynamic-Programming/07.State-DP/01.State-DP/</a><br>[2] <a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve">https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315?from=nowcoder_improve</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;周赛依然没空打，面笔太多辽，感觉这周数位题比较多，写周六的hard题用了两个小时还是没能全A，不过思路没问题，表扬一下自己。&lt;/p&gt;
&lt;p&gt;本周主题：三维动态规划（三个限制）、组合数学、位运、状态压缩DP&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240819每日一题—&lt;a href=&quot;https://leetcode.cn/problems/student-attendance-record-ii/description&quot;&gt;Student Attendance Record II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240820每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/description&quot;&gt;Find Number of Ways to Reach the K-th Stair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240822每日一题—&lt;a href=&quot;https://leetcode.cn/problems/minimum-array-end/description&quot;&gt;Minimum Array End&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240823每日一题—&lt;a href=&quot;https://leetcode.cn/problems/find-products-of-elements-of-big-array/description&quot;&gt;Find Products of Elements of Big Array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240824每日一题—&lt;a href=&quot;https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/description&quot;&gt;Partition to K Equal Sum Subsets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS：腾子音乐的笔也忒难了&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>xxl-job源码阅读（一）：定时任务执行链路分析</title>
    <link href="http://silencezheng.top/2024/08/19/article135/"/>
    <id>http://silencezheng.top/2024/08/19/article135/</id>
    <published>2024-08-19T15:15:50.000Z</published>
    <updated>2024-08-19T15:25:11.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>xxl-job源码阅读第一章：定时任务执行链路分析</p><p>一时兴起，花一下午看了一遍这部分源码，写的不错。</p><p>PS：写完才发现有官方文档讲解…尴尬😅<br><span id="more"></span></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="部署xxl-job-admin"><a href="#部署xxl-job-admin" class="headerlink" title="部署xxl-job-admin"></a>部署xxl-job-admin</h2><p>官网文档秒了。</p><p>地址：<a href="https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8">https://www.xuxueli.com/xxl-job/#%E4%BA%8C%E3%80%81%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8</a></p><h2 id="装载配置类"><a href="#装载配置类" class="headerlink" title="装载配置类"></a>装载配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobHandlerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses:http://ip:8008/xxl-job-admin-1.8.2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname:appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath:./xxlLogs&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxlJobExecutor <span class="title">xxlJobExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        XxlJobExecutor xxlJobExecutor = <span class="keyword">new</span> XxlJobExecutor();</span><br><span class="line">        xxlJobExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobExecutor.setAppName(appName);</span><br><span class="line">        xxlJobExecutor.setLogPath(logPath);</span><br><span class="line">        <span class="keyword">return</span> xxlJobExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现任务接口"><a href="#实现任务接口" class="headerlink" title="实现任务接口"></a>实现任务接口</h2><p>注意两点：</p><ol><li><code>@JobHandler</code>注解用于唯一识别任务</li><li>实现了<code>IJobHandler</code>接口才会被加载到任务列表中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@JobHandler(value = &quot;AutoSendEmailScheduler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoSendEmailScheduler</span> <span class="keyword">extends</span> <span class="title">IJobHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UniqueIdenAutoUpdateAndSendEmail uniqueIdenAutoUpdateAndSendEmail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">execute</span><span class="params">(String startDate)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler start, startDate:&#123;&#125;&quot;</span>, startDate);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        ReturnT&lt;String&gt; result = <span class="keyword">new</span> ReturnT&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uniqueIdenAutoUpdateAndSendEmail.autoSendEmail(startDate);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;AutoSendEmailScheduler fail, startDate:&#123;&#125;&quot;</span>, startDate, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        result.setCode(SUCCESS_CODE);</span><br><span class="line">        log.info(<span class="string">&quot;AutoSendEmailScheduler end, cost &#123;&#125;ms&quot;</span>, System.currentTimeMillis() - start);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Xxl-job-Server端源码分析"><a href="#Xxl-job-Server端源码分析" class="headerlink" title="Xxl-job Server端源码分析"></a>Xxl-job Server端源码分析</h1><p>版本：xxl-job-core1.9.1</p><h2 id="统一入口-—-执行器"><a href="#统一入口-—-执行器" class="headerlink" title="统一入口 — 执行器"></a>统一入口 — 执行器</h2><p>执行器即<code>XxlJobExecutor</code>，被注册为上下文，主要是为了能用<code>ApplicationContext</code>获取各种信息，例如Bean信息等等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxlJobExecutor</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="加载任务处理器"><a href="#加载任务处理器" class="headerlink" title="加载任务处理器"></a>加载任务处理器</h3><p>把刚才自己定义的定时任务处理器和其他所有加入了<code>@JobHandler</code>注解的类加载进来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, IJobHandler&gt; jobHandlerRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IJobHandler&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IJobHandler <span class="title">registJobHandler</span><span class="params">(String name, IJobHandler jobHandler)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobHandlerRepository.put(name, jobHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initJobHandlerRepository</span><span class="params">(ApplicationContext applicationContext)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init job handler action</span></span><br><span class="line">    Map&lt;String, Object&gt; serviceBeanMap = applicationContext.getBeansWithAnnotation(JobHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceBeanMap!=<span class="keyword">null</span> &amp;&amp; serviceBeanMap.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (serviceBean <span class="keyword">instanceof</span> IJobHandler)&#123;</span><br><span class="line">                String name = serviceBean.getClass().getAnnotation(JobHandler.class).value();</span><br><span class="line">                IJobHandler handler = (IJobHandler) serviceBean;</span><br><span class="line">                <span class="keyword">if</span> (loadJobHandler(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;xxl-job jobhandler naming conflicts.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                registJobHandler(name, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化客户端（调度中心）"><a href="#初始化客户端（调度中心）" class="headerlink" title="初始化客户端（调度中心）"></a>初始化客户端（调度中心）</h3><p>xxl-job是C/S架构的，客户端是RPC服务的调用者，即<code>xxl-job-admin</code>，带有一个前端。这里可以有多个调度中心，是因为支持集群部署。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; adminBizList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initAdminBizList</span><span class="params">(String adminAddresses, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adminAddresses!=<span class="keyword">null</span> &amp;&amp; adminAddresses.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String address: adminAddresses.trim().split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (address!=<span class="keyword">null</span> &amp;&amp; address.trim().length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// http://ip:port/xxl-job-admin-1.8.2 + /api</span></span><br><span class="line">                String addressUrl = address.concat(AdminBiz.MAPPING);</span><br><span class="line">                AdminBiz adminBiz = (AdminBiz) <span class="keyword">new</span> NetComClientProxy(AdminBiz.class, addressUrl, accessToken).getObject();</span><br><span class="line">                <span class="keyword">if</span> (adminBizList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    adminBizList = <span class="keyword">new</span> ArrayList&lt;AdminBiz&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                adminBizList.add(adminBiz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;AdminBiz&gt; <span class="title">getAdminBizList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adminBizList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="初始化RPC服务器工厂"><a href="#初始化RPC服务器工厂" class="headerlink" title="初始化RPC服务器工厂"></a>初始化RPC服务器工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NetComServerFactory serverFactory = <span class="keyword">new</span> NetComServerFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initExecutorServer</span><span class="params">(<span class="keyword">int</span> port, String ip, String appName, String accessToken)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// valid param</span></span><br><span class="line">    port = port&gt;<span class="number">0</span>?port: NetUtil.findAvailablePort(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start server</span></span><br><span class="line">    NetComServerFactory.putService(ExecutorBiz.class, <span class="keyword">new</span> ExecutorBizImpl());   <span class="comment">// rpc-service, base on jetty</span></span><br><span class="line">    NetComServerFactory.setAccessToken(accessToken);</span><br><span class="line">    serverFactory.start(port, ip, appName); <span class="comment">// jetty + registry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务执行线程池"><a href="#任务执行线程池" class="headerlink" title="任务执行线程池"></a>任务执行线程池</h3><p>并没有用线程池，而是一个并发哈希表。这里有个疑问，如果并发线程量过大是不是有安全问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, JobThread&gt; JobThreadRepository = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, JobThread&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">registJobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread newJobThread = <span class="keyword">new</span> JobThread(jobId, handler);</span><br><span class="line">    newJobThread.start();</span><br><span class="line">    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job regist JobThread success, jobId:&#123;&#125;, handler:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;jobId, handler&#125;);</span><br><span class="line"></span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.put(jobId, newJobThread);  <span class="comment">// putIfAbsent | oh my god, map&#x27;s put method return the old value!!!</span></span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newJobThread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeJobThread</span><span class="params">(<span class="keyword">int</span> jobId, String removeOldReason)</span></span>&#123;</span><br><span class="line">    JobThread oldJobThread = JobThreadRepository.remove(jobId);</span><br><span class="line">    <span class="keyword">if</span> (oldJobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldJobThread.toStop(removeOldReason);</span><br><span class="line">        oldJobThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobThread <span class="title">loadJobThread</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>&#123;</span><br><span class="line">    JobThread jobThread = JobThreadRepository.get(jobId);</span><br><span class="line">    <span class="keyword">return</span> jobThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>该服务器用于获取请求、执行任务，是核心的执行逻辑。</p><p>主体是封装了一个jetty服务器（servlet容器，HTTP协议），利用反射实现服务调用。</p><p>相关类如下：</p><ul><li>NetComServerFactory：RPC服务器工厂类，同时负责维护RPC服务。</li><li>JettyServer：核心类，真正运行的服务器。</li><li>JettyServerHandler：jetty的handler，负责执行任务。</li><li>ExecutorBiz：包含RPC方法的接口，被工厂类加载并执行请求调用的RPC方法。</li><li>ExecutorBizImpl：真正提供服务的类，实现了ExecutorBiz接口。</li><li>JobThread：真正执行任务（完成Job）的线程，维护一个阻塞队列用于执行任务。</li><li>ExecutorRegistryThread：用于将服务器注册到客户端上，或取消注册。</li><li>TriggerCallbackThread：维护一个阻塞队列，用于对任务执行结果实施callback。</li></ul><h3 id="NetComServerFactory"><a href="#NetComServerFactory" class="headerlink" title="NetComServerFactory"></a>NetComServerFactory</h3><p>入口中初始化的就是这个Server工厂，工厂里面内容很简单，简化后如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器，核心类</span></span><br><span class="line">JettyServer server = <span class="keyword">new</span> JettyServer(); <span class="comment">//有start(), destroy()两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC服务存储，通过反射加载进来</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 认证token，携带正确token的请求才能被执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String accessToken;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中放入ExecutorBiz的方法，Key是接口名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putService</span><span class="params">(Class&lt;?&gt; iface, Object serviceBean)</span></span>&#123;</span><br><span class="line">    serviceMap.put(iface.getName(), serviceBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化中设置token的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAccessToken</span><span class="params">(String accessToken)</span> </span>&#123;</span><br><span class="line">    NetComServerFactory.accessToken = accessToken;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真正实现RPC服务调用的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcResponse <span class="title">invokeService</span><span class="params">(RpcRequest request, Object serviceBean)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">        String methodName = request.getMethodName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] parameters = request.getParameters();</span><br><span class="line"></span><br><span class="line">        FastClass serviceFastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod serviceFastMethod = serviceFastClass.getMethod(methodName, parameterTypes);</span><br><span class="line"></span><br><span class="line">        Object result = serviceFastMethod.invoke(serviceBean, parameters);</span><br><span class="line"></span><br><span class="line">        response.setResult(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        response.setError(t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="JettyServer"><a href="#JettyServer" class="headerlink" title="JettyServer"></a>JettyServer</h3><p><code>JettyServer</code>包含服务器（非阻塞线程池）、注册线程、回调线程三部分。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port, <span class="keyword">final</span> String ip, <span class="keyword">final</span> String appName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The Server</span></span><br><span class="line">                server = <span class="keyword">new</span> Server(<span class="keyword">new</span> ExecutorThreadPool());  <span class="comment">// 非阻塞</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// HTTP connector</span></span><br><span class="line">                ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);</span><br><span class="line">                connector.setHost(ip);</span><br><span class="line">                connector.setPort(port);</span><br><span class="line">                server.setConnectors(<span class="keyword">new</span> Connector[]&#123;connector&#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set a handler</span></span><br><span class="line">                HandlerCollection handlerc =<span class="keyword">new</span> HandlerCollection();</span><br><span class="line">                handlerc.setHandlers(<span class="keyword">new</span> Handler[]&#123;<span class="keyword">new</span> JettyServerHandler()&#125;);</span><br><span class="line">                server.setHandler(handlerc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Start server</span></span><br><span class="line">                server.start();</span><br><span class="line">                <span class="comment">// Start Registry-Server</span></span><br><span class="line">                ExecutorRegistryThread.getInstance().start(port, ip, appName);</span><br><span class="line">                <span class="comment">// Start Callback-Server</span></span><br><span class="line">                TriggerCallbackThread.getInstance().start();</span><br><span class="line"></span><br><span class="line">                server.join();  <span class="comment">// block until thread stopped</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>); <span class="comment">// daemon, service jvm, user thread leave &gt;&gt;&gt; daemon leave &gt;&gt;&gt; jvm leave</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// destroy Registry-Server</span></span><br><span class="line">        ExecutorRegistryThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// destroy Callback-Server</span></span><br><span class="line">        TriggerCallbackThread.getInstance().toStop();</span><br><span class="line">        <span class="comment">// 关闭服务器</span></span><br><span class="line">        server.stop();</span><br><span class="line">        server.destroy();</span><br><span class="line">        <span class="comment">// 关闭总线程</span></span><br><span class="line">        <span class="keyword">if</span> (thread.isAlive()) &#123;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是这里的<code>ExecutorThreadPool</code>是jetty自己封装的<code>ThreadPoolExecutor</code>，最大线程池大小为256, 线程timeout为1分钟，并使用了<code>Unbounded LinkedBlockingQueue</code>作为任务队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Using an unbounded queue makes the maxThreads parameter useless</span></span><br><span class="line">    <span class="comment">// Refer to ThreadPoolExecutor javadocs for details</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">256</span>, <span class="number">256</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JettyServerHandler"><a href="#JettyServerHandler" class="headerlink" title="JettyServerHandler"></a>JettyServerHandler</h3><p>这个类就是用来衔接jetty接到的请求和实际处理方法<code>NetComServerFactory#invokeService</code>的，对入参出参和异常进行一些处理。</p><p>简化代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyServerHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// invoke</span></span><br><span class="line">        RpcResponse rpcResponse = doInvoke(request);</span><br><span class="line">        <span class="comment">// serialize response</span></span><br><span class="line">        <span class="keyword">byte</span>[] responseBytes = HessianSerializer.serialize(rpcResponse);</span><br><span class="line">        </span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">        baseRequest.setHandled(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        OutputStream out = response.getOutputStream();</span><br><span class="line">        out.write(responseBytes);</span><br><span class="line">        out.flush();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RpcResponse <span class="title">doInvoke</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// deserialize request</span></span><br><span class="line">            <span class="keyword">byte</span>[] requestBytes = HttpClientUtil.readBytes(request);</span><br><span class="line">            <span class="keyword">if</span> (requestBytes == <span class="keyword">null</span> || requestBytes.length==<span class="number">0</span>) &#123;</span><br><span class="line">                RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">                rpcResponse.setError(<span class="string">&quot;RpcRequest byte[] is null&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> rpcResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) HessianSerializer.deserialize(requestBytes, RpcRequest.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// invoke</span></span><br><span class="line">            RpcResponse rpcResponse = NetComServerFactory.invokeService(rpcRequest, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            RpcResponse rpcResponse = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">            rpcResponse.setError(<span class="string">&quot;Server-error:&quot;</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ExecutorBizImpl"><a href="#ExecutorBizImpl" class="headerlink" title="ExecutorBizImpl"></a>ExecutorBizImpl</h3><p>真正执行任务的类，实现了<code>ExecutorBiz</code>接口。</p><p><code>ExecutorBiz</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorBiz</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 心跳，用于确认服务器状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">beat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 判断任务是否在执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">idleBeat</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 终止任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">kill</span><span class="params">(<span class="keyword">int</span> jobId)</span></span>;</span><br><span class="line">    <span class="comment">// 读日志，返回日志内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;LogResult&gt; <span class="title">log</span><span class="params">(<span class="keyword">long</span> logDateTim, <span class="keyword">int</span> logId, <span class="keyword">int</span> fromLineNum)</span></span>;</span><br><span class="line">    <span class="comment">// 根据参数执行任务，TriggerParam里携带jobId</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ExecutorBizImpl</code>通过上下文<code>XxlJobExecutor</code>获取资源（例如<code>JobThread</code>）实现各个功能，这里我们只关注<code>run</code>方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">run</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试加载已有线程，没有则都置为空</span></span><br><span class="line">    <span class="comment">// load old：jobHandler + jobThread</span></span><br><span class="line">    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());</span><br><span class="line">    IJobHandler jobHandler = jobThread!=<span class="keyword">null</span>?jobThread.getHandler():<span class="keyword">null</span>;</span><br><span class="line">    String removeOldReason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里有几种执行模式，bean、glue和script，通常自己实现的是用bean模式，需要验证一下</span></span><br><span class="line">    <span class="comment">// 验证如果原来的jobHandler不对，那么也要置空</span></span><br><span class="line">    <span class="comment">// valid：jobHandler + jobThread</span></span><br><span class="line">    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());</span><br><span class="line">    <span class="keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// new jobhandler</span></span><br><span class="line">        IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        <span class="keyword">if</span> (jobThread!=<span class="keyword">null</span> &amp;&amp; jobHandler != newJobHandler) &#123;</span><br><span class="line">            <span class="comment">// change handler, need kill old thread</span></span><br><span class="line">            removeOldReason = <span class="string">&quot;更换JobHandler或更换任务模式,终止旧任务线程&quot;</span>;</span><br><span class="line">            jobThread = <span class="keyword">null</span>;</span><br><span class="line">            jobHandler = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = newJobHandler;</span><br><span class="line">            <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;job handler [&quot;</span> + triggerParam.getExecutorHandler() + <span class="string">&quot;] not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());</span><br><span class="line">                jobHandler = <span class="keyword">new</span> GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (glueTypeEnum!=<span class="keyword">null</span> &amp;&amp; glueTypeEnum.isScript()) &#123;</span><br><span class="line">        <span class="comment">// valid old jobThread</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// valid handler</span></span><br><span class="line">        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobHandler = <span class="keyword">new</span> ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;glueType[&quot;</span> + triggerParam.getGlueType() + <span class="string">&quot;] is not valid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据设置的阻塞策略，选择是否丢弃已有线程</span></span><br><span class="line">    <span class="comment">// executor block strategy</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// discard when running</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;阻塞处理策略-生效：&quot;</span>+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) &#123;</span><br><span class="line">            <span class="comment">// kill running jobThread</span></span><br><span class="line">            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;</span><br><span class="line">                removeOldReason = <span class="string">&quot;阻塞处理策略-生效：&quot;</span> + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();</span><br><span class="line">                jobThread = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just queue trigger</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册新的任务线程并添加任务</span></span><br><span class="line">    <span class="comment">// replace thread (new or exists invalid)</span></span><br><span class="line">    <span class="keyword">if</span> (jobThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push data to queue</span></span><br><span class="line">    ReturnT&lt;String&gt; pushResult = jobThread.pushTriggerQueue(triggerParam);</span><br><span class="line">    <span class="keyword">return</span> pushResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JobThread"><a href="#JobThread" class="headerlink" title="JobThread"></a>JobThread</h3><p>这是最终执行任务的线程，通过前面的分析可以看到，一项任务被最终交付给了TriggerQueue，并等待完成执行回调实现异步执行。</p><p>那么什么是TriggerQueue？它是一个存放Trigger参数的<code>LinkedBlockingQueue</code>阻塞队列，用于存放待执行的任务。</p><p><code>JobThread</code>会按指定的时间间隔轮询该队列，尝试取出任务执行。任务执行结束后，将结果交给Callback线程执行回调。</p><p>还有一些其他细节，例如唯一日志ID的维护（通过Set），终止任务的实现（多种情况），可以参考代码分析。</p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(JobThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> jobId;</span><br><span class="line">    <span class="keyword">private</span> IJobHandler handler;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;TriggerParam&gt; triggerQueue;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashSet&lt;Integer&gt; triggerLogIdSet;     <span class="comment">// avoid repeat trigger for the same TRIGGER_LOG_ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String stopReason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">false</span>;    <span class="comment">// if running job</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleTimes = <span class="number">0</span>;          <span class="comment">// idel times</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobThread</span><span class="params">(<span class="keyword">int</span> jobId, IJobHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jobId = jobId;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.triggerQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;TriggerParam&gt;();</span><br><span class="line">        <span class="keyword">this</span>.triggerLogIdSet = <span class="keyword">new</span> ConcurrentHashSet&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IJobHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * new trigger to queue</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> triggerParam</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title">pushTriggerQueue</span><span class="params">(TriggerParam triggerParam)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// avoid repeat</span></span><br><span class="line">        <span class="keyword">if</span> (triggerLogIdSet.contains(triggerParam.getLogId())) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; repeate trigger job, logId:&#123;&#125;&quot;</span>, triggerParam.getLogId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">&quot;repeate trigger job, logId:&quot;</span> + triggerParam.getLogId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        triggerLogIdSet.add(triggerParam.getLogId());</span><br><span class="line">        triggerQueue.add(triggerParam);</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kill job thread</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stopReason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">(String stopReason)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread.interrupt只支持终止线程的阻塞状态(wait、join、sleep)，</span></span><br><span class="line"><span class="comment">         * 在阻塞出抛出InterruptedException异常,但是并不会终止运行的线程本身；</span></span><br><span class="line"><span class="comment">         * 所以需要注意，此处彻底销毁本线程，需要通过共享变量方式；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.stopReason = stopReason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is running job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunningOrHasQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> running || triggerQueue.size()&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// execute</span></span><br><span class="line">        <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">            idleTimes++;</span><br><span class="line"></span><br><span class="line">            TriggerParam triggerParam = <span class="keyword">null</span>;</span><br><span class="line">            ReturnT&lt;String&gt; executeResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// to check toStop signal, we need cycle, so wo cannot use queue.take(), instand of poll(timeout)</span></span><br><span class="line">                triggerParam = triggerQueue.poll(<span class="number">3L</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    running = <span class="keyword">true</span>;</span><br><span class="line">                    idleTimes = <span class="number">0</span>;</span><br><span class="line">                    triggerLogIdSet.remove(triggerParam.getLogId());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// log filename, like &quot;logPath/yyyy-MM-dd/9999.log&quot;</span></span><br><span class="line">                    String logFileName = XxlJobFileAppender.makeLogFileName(<span class="keyword">new</span> Date(triggerParam.getLogDateTim()), triggerParam.getLogId());</span><br><span class="line">                    XxlJobFileAppender.contextHolder.set(logFileName);</span><br><span class="line">                    ShardingUtil.setShardingVo(<span class="keyword">new</span> ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// execute</span></span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute start -----------&lt;br&gt;----------- Param:&quot;</span> + triggerParam.getExecutorParams());</span><br><span class="line">                    executeResult = handler.execute(triggerParam.getExecutorParams());</span><br><span class="line">                    <span class="keyword">if</span> (executeResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        executeResult = IJobHandler.FAIL;</span><br><span class="line">                    &#125;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(finish) -----------&lt;br&gt;----------- ReturnT:&quot;</span> + executeResult);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (idleTimes &gt; <span class="number">30</span>) &#123;</span><br><span class="line">                        XxlJobExecutor.removeJobThread(jobId, <span class="string">&quot;excutor idel times over limit.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (toStop) &#123;</span><br><span class="line">                    XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread toStop, stopReason:&quot;</span> + stopReason);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">                e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));</span><br><span class="line">                String errorMsg = stringWriter.toString();</span><br><span class="line">                executeResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, errorMsg);</span><br><span class="line"></span><br><span class="line">                XxlJobLogger.log(<span class="string">&quot;&lt;br&gt;----------- JobThread Exception:&quot;</span> + errorMsg + <span class="string">&quot;&lt;br&gt;----------- xxl-job job execute end(error) -----------&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(triggerParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// callback handler info</span></span><br><span class="line">                    <span class="keyword">if</span> (!toStop) &#123;</span><br><span class="line">                        <span class="comment">// commonm</span></span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), executeResult));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// is killed</span></span><br><span class="line">                        ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [业务运行中，被强制终止]&quot;</span>);</span><br><span class="line">                        TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// callback trigger request in queue</span></span><br><span class="line">        <span class="keyword">while</span>(triggerQueue !=<span class="keyword">null</span> &amp;&amp; triggerQueue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            TriggerParam triggerParam = triggerQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (triggerParam!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// is killed</span></span><br><span class="line">                ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">&quot; [任务尚未执行，在调度队列中被终止]&quot;</span>);</span><br><span class="line">                TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), stopResult));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// destroy</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job JobThread stoped, hashCode:&#123;&#125;&quot;</span>, Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TriggerCallbackThread"><a href="#TriggerCallbackThread" class="headerlink" title="TriggerCallbackThread"></a>TriggerCallbackThread</h3><p>回调线程，用于处理执行完的任务结果，通知调度中心执行完毕。</p><p>同样的，使用一个阻塞队列存放待回调的执行结果。</p><p>代码简化后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriggerCallbackThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TriggerCallbackThread instance = <span class="keyword">new</span> TriggerCallbackThread();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TriggerCallbackThread <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// job results callback queue</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt; callBackQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;HandleCallbackParam&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pushCallBack</span><span class="params">(HandleCallbackParam callback)</span></span>&#123;</span><br><span class="line">        getInstance().callBackQueue.add(callback);</span><br><span class="line">        logger.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, push callback request, logId:&#123;&#125;&quot;</span>, callback.getLogId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callback thread</span></span><br><span class="line">    <span class="keyword">private</span> Thread triggerCallbackThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> toStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        triggerCallbackThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// normal callback</span></span><br><span class="line">                <span class="keyword">while</span>(!toStop)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        HandleCallbackParam callback = getInstance().callBackQueue.take();</span><br><span class="line">                        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// callback list param</span></span><br><span class="line">                            List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                            <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                            callbackParamList.add(callback);</span><br><span class="line">                            <span class="comment">// callback, will retry if error</span></span><br><span class="line">                            <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                                doCallback(callbackParamList);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// last callback</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;HandleCallbackParam&gt; callbackParamList = <span class="keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();</span><br><span class="line">                    <span class="keyword">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);</span><br><span class="line">                    <span class="keyword">if</span> (callbackParamList!=<span class="keyword">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        doCallback(callbackParamList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        triggerCallbackThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        triggerCallbackThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        toStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// interrupt and wait</span></span><br><span class="line">        triggerCallbackThread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerCallbackThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do callback, will retry if error</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCallback</span><span class="params">(List&lt;HandleCallbackParam&gt; callbackParamList)</span></span>&#123;</span><br><span class="line">        <span class="comment">// callback, will retry if error</span></span><br><span class="line">        <span class="keyword">for</span> (AdminBiz adminBiz: XxlJobExecutor.getAdminBizList()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ReturnT&lt;String&gt; callbackResult = adminBiz.callback(callbackParamList);</span><br><span class="line">                <span class="keyword">if</span> (callbackResult!=<span class="keyword">null</span> &amp;&amp; ReturnT.SUCCESS_CODE == callbackResult.getCode()) &#123;</span><br><span class="line">                    callbackResult = ReturnT.SUCCESS;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback success, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback fail, callbackParamList:&#123;&#125;, callbackResult:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Object[]&#123;callbackParamList, callbackResult&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job callback error, callbackParamList：&#123;&#125;&quot;</span>, callbackParamList, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>总结一下，一个定时任务（run请求）从调度中心出发到执行完毕的链路为：<br><code>JettyServer</code>-&gt;<br>    <code>JettyServerHandler</code>-&gt;<br>        <code>NetComServerFactory#invokeService</code>-&gt;<br>            <code>ExecutorBizImpl#run</code>-&gt;<br>                    <code>JobThread</code>-&gt;<br>                        <code>TriggerCallbackThread</code>-&gt;<br>                            <code>AdminBiz#callback</code></p><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;xxl-job源码阅读第一章：定时任务执行链路分析&lt;/p&gt;
&lt;p&gt;一时兴起，花一下午看了一遍这部分源码，写的不错。&lt;/p&gt;
&lt;p&gt;PS：写完才发现有官方文档讲解…尴尬😅&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="xxl-job" scheme="http://silencezheng.top/tags/xxl-job/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP3</title>
    <link href="http://silencezheng.top/2024/08/18/article134/"/>
    <id>http://silencezheng.top/2024/08/18/article134/</id>
    <published>2024-08-18T15:32:17.000Z</published>
    <updated>2024-08-18T15:33:52.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。</p><p>本周主题：动态规划、贪心</p><p>题目：</p><ul><li>240619每日一题—<a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description">Maximum Strictly Increasing Cells in a Matrix</a></li><li>240622每日一题—<a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/">Lexicographically Smallest Beautiful String</a><span id="more"></span>这两道Hard题稍微看看理解一下就行了，暂时没太多可归纳的，可记忆的点就是二维排序和回文判别（只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串）。</li></ul><h1 id="动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix"><a href="#动态规划-—-Maximum-Strictly-Increasing-Cells-in-a-Matrix" class="headerlink" title="动态规划 — Maximum Strictly Increasing Cells in a Matrix"></a>动态规划 — Maximum Strictly Increasing Cells in a Matrix</h1><blockquote><p>Maximum Strictly Increasing Cells in a Matrix</p><p>Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell.</p><p>From the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.</p><p>Your task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.</p><p>Return an integer denoting the maximum number of cells that can be visited.</p></blockquote><p>设 <strong>$d[i][j]$ 为移动到单元格 $(i, j)$ 的最大步数</strong>, 其中 $(i, j)$ 可以作为起始单元格, 也可以是从其他单元格移动而来。那么我们会考虑从第 $i$ 行以及第 $j$ 列上矩阵数值小于 $\operatorname{mat}[i][j]$ 的位置进行转移, 即取以下数值中的最大值:</p><ul><li>第 $i$ 行： $\max \left(d[i]\left[j^{\prime}\right]+1\right)$ ，其中 $\operatorname{mat}[i]\left[j^{\prime}\right]&lt;\operatorname{mat}[i][j]$ ；</li><li>第 $j$ 列： $\max \left(d\left[l^{\prime}\right][j]+1\right)$ ，其中 $\operatorname{mat}\left[i^{\prime}\right][j]&lt;\operatorname{mat}[[][j]$ 。</li></ul><p>因此, 整个状态空间在进行转移时是有序的, 我们可以对 mat 进行排序, 从小到大进行转移。但在转移时, 每个状态都要扫描一遍对应的行和列, 时间复杂度为 $O(n+m)$, 而整体求解的时间复杂度为 $O(n m(n+m))$, 可能会超时, 因此需要进行优化。</p><p>考虑到所有的 $d[i][j]$ 在更新时, 值只会越来越大, 而转移过程中我们只考虑对应行和对应列上 $d$ 的最大值（由于大于 mat $[i][j]$ 的位置还末遍历到, 它们的状态还末更新, 可设置为 0 )。因此, 设置长度为 $m$ 的数组 row 来维护每一行 $d$ 的最大值, 设置长度为 $n$ 的数组 $c o l$ 来维护每一列的最大值，这样一来:</p><script type="math/tex; mode=display">d[i][j]=\max (\operatorname{row}[i], \operatorname{col}[j])+1</script><p>在每次更新了 $d[i][j]$ 后, 需要更新 $r o w[i]$ 和 $col[j]$ 。另外需要注意的是, 由于 mat 中可能包含相同数字, 我们需要同时更新它们的 $d$ 值, 然后再同时更新它们对应的 row 和 col。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIncreasingCells</span><span class="params">(<span class="keyword">int</span>[][] mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.length, n = mat[<span class="number">0</span>].length;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; mp = <span class="keyword">new</span> HashMap&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                mp.putIfAbsent(mat[i][j], <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;());</span><br><span class="line">                mp.get(mat[i][j]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; keys = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(mp.keySet());</span><br><span class="line">        Collections.sort(keys);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keys) &#123;</span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; pos = mp.get(key);</span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// 存放相同数值的答案，便于后续更新 row 和 col</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : pos) &#123;</span><br><span class="line">                res.add(Math.max(row[arr[<span class="number">0</span>]], col[arr[<span class="number">1</span>]]) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = pos.get(i);</span><br><span class="line">                <span class="keyword">int</span> d = res.get(i);</span><br><span class="line">                row[arr[<span class="number">0</span>]] = Math.max(row[arr[<span class="number">0</span>]], d);</span><br><span class="line">                col[arr[<span class="number">1</span>]] = Math.max(col[arr[<span class="number">1</span>]], d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(row).max().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心-—-Lexicographically-Smallest-Beautiful-String"><a href="#贪心-—-Lexicographically-Smallest-Beautiful-String" class="headerlink" title="贪心 — Lexicographically Smallest Beautiful String"></a>贪心 — Lexicographically Smallest Beautiful String</h1><blockquote><p>Lexicographically Smallest Beautiful String</p><p>A string is beautiful if:</p><ul><li>It consists of the first k letters of the English lowercase alphabet.</li><li>It does not contain any substring of length 2 or more which is a palindrome.</li></ul><p>You are given a beautiful string s of length n and a positive integer k.</p><p>Return the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.</p><p>A string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.</p><ul><li>For example, “abcd” is lexicographically larger than “abcc” because the first position they differ is at the fourth character, and d is greater than c.</li></ul></blockquote><p>首先分析一下美丽字符串的第二个条件：不包含任何长度为 2 或者更长的回文字符串。长度为 2 的回文字符串是两个相同字符构成的字符串。长度为 3 的回文字符串中也有两个相同字符，但下标之差为 2。而任何长度为 2 或者更长的回文字符串，都包含一个长度为 2 或者 3 的回文字符串。因此，<strong>只要一个字符串中的任何字符，都不与它前两个字符相同，这个字符串就不包含任何长度为 2 或者更长的回文字符串</strong>。</p><p>接下来看其他要求，返回的美丽字符串需要字典序大于 s 并且字典序最小。贪心的思路是修改 s 的末尾字符，一点点将字符变大，如果在变大的同时能够满足美丽字符串的两个条件，那么我们就找到了要求的美丽字符串。修改后的字符不能与前两个字符相同，因此我们在将字符变大的时候只需要将字符逐步变大三次，就能判断出修改当前字符能否满足美丽字符串的条件。如果修改末尾字符达不到美丽字符串的条件，则我们需要将被修改的字符改为倒数第二个字符，仍然按照之前的思路一点点增大，并判断是否满足美丽字符串的两个条件。我们从末尾字符开始，往前一点点判断是否可以修改当前字符来找到目标美丽字符串。一旦我们第一次找到了合适的下标，我们就可以来修改字符来达到目标条件。</p><p>首先我们需要修改寻找到的下标的字符，将其修改为最小的满足美丽字符串条件的字符。接下来需要修改它右边的字符。因为之前修改的字符已经能保证返回的字符串在字典序上大于 s，我们只需要将后续的字符修改得尽可能小即可，因为每个字符需要与前两个字符不同，因此每个字符只需要遍历 <code>‘a’∼‘c’</code> 即可。因为 $k≥ 4$，所以接下来修改的字符一定都能满足美丽字符串的条件。</p><p>在代码实现上，我们先用一个循环从 $n−1$ 开始，往前遍历来寻找第一个被修改的字符，找到之后，再用另一个函数 $generate(s,idx,offset)$ 来生成修改后的字符，其中 $idx$ 是我们找到的下标，$offset$ 是将这个下标的字符增大的偏移量。最后返回修改后的字符，如果我们未能找到目标下标，则返回空字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestBeautifulString</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(s.charAt(i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// s.charAt(i) - &#x27;a&#x27; + j 需要+1才能与k比较，因为k从1计数</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) - <span class="string">&#x27;a&#x27;</span> + j + <span class="number">1</span> &lt;= k &amp;&amp; !blockedCharacters.contains((<span class="keyword">char</span>) (s.charAt(i) + j))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> generate(s, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String s, <span class="keyword">int</span> idx, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        res[idx] += offset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Set&lt;Character&gt; blockedCharacters = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    blockedCharacters.add(res[i - j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// abc里面一定有一个可用的，因为blockedCharacters只有两个字符</span></span><br><span class="line">                <span class="keyword">if</span> (!blockedCharacters.contains((<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j))) &#123;</span><br><span class="line">                    res[i] = (<span class="keyword">char</span>) (<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/">https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/solutions/2809597/ju-zhen-zhong-yan-ge-di-zeng-de-dan-yuan-ff4v/</a><br>[2] <a href="https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/">https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/solutions/2814311/zi-dian-xu-zui-xiao-de-mei-li-zi-fu-chua-dr81/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周双周赛和周赛都没打，之前两周积累的问题有些多了，先只处理每日一题吧。&lt;/p&gt;
&lt;p&gt;本周主题：动态规划、贪心&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240619每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/description&quot;&gt;Maximum Strictly Increasing Cells in a Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240622每日一题—&lt;a href=&quot;https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/&quot;&gt;Lexicographically Smallest Beautiful String&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP2</title>
    <link href="http://silencezheng.top/2024/08/18/article133/"/>
    <id>http://silencezheng.top/2024/08/18/article133/</id>
    <published>2024-08-18T10:44:02.000Z</published>
    <updated>2024-08-18T10:52:27.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周周赛菜了…赶紧记一下。</p><p>本周主题：差分数组、动态规划</p><p>题目：</p><ul><li>240615每日一题—<a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/">Maximum Beauty of an Array After Applying Operation</a></li><li>240616周赛第三题—<a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/">Maximum Total Damage With Spell Casting</a></li><li>LC198打家劫舍—<a href="https://leetcode.cn/problems/house-robber/description/">House Robber</a><span id="more"></span></li></ul><h1 id="差分数组（Difference-Array）"><a href="#差分数组（Difference-Array）" class="headerlink" title="差分数组（Difference Array）"></a>差分数组（Difference Array）</h1><p>作用：开辟一块空间用于压缩对原数组上连续子数组的操作。</p><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>考虑数组 $a=[1,3,3,5,8]$，对其中的相邻元素两两作差（右边减左边），得到数组 $[2,0,2,3]$。然后在开头补上 $a[0]$，得到差分数组：$d=[1,2,0,2,3]$</p><p>这有什么用呢？如果从左到右累加 ddd 中的元素，我们就「还原」回了 $a$ 数组 $[1,3,3,5,8]$。这类似求导与积分的概念。</p><p>这又有什么用呢？现在把连续子数组 $a[1],a[2],a[3]$ 都加上 $10$，得到 $a’=[1,13,13,15,8]$。再次两两作差，并在开头补上 $a’[0]$，得到差分数组：$d’=[1,12,0,2,−7]$</p><p>对比 $d$ 和 $d’$，可以发现只有 $d[1]$ 和 $d[4]$ 变化了，这意味着<strong>对 $a$ 中连续子数组的操作，可以转变成对差分数组 $d$ 中两个数的操作</strong>。</p><h2 id="定义和性质"><a href="#定义和性质" class="headerlink" title="定义和性质"></a>定义和性质</h2><p>对于数组 $a$，定义其差分数组（difference array）为</p><script type="math/tex; mode=display">d[i] = \begin{cases} a[0],&i=0\\ a[i]-a[i-1],&i\ge 1 \end{cases}​</script><p>性质 1：从左到右累加 $d$ 中的元素，可以得到数组 $a$。</p><p>性质 2：如下两个操作是等价的。</p><ul><li>把 $a$ 的子数组 $a[i],a[i+1],\cdots,a[j]$ 都加上 $x$。</li><li>把 $d[i]$ 增加 $x$，把 $d[j+1]$ 减少 $x$。</li></ul><p>利用性质 2，我们只需要 $O(1)$ 的时间就可以完成对 $a$ 的子数组的操作。最后利用性质 1 从差分数组复原出数组 $a$。</p><p>注：也可以这样理解，$d[i]$ 表示把下标 $≥i$ 的数都加上 $d[i]$。</p><h2 id="例题：Maximum-Beauty-of-an-Array-After-Applying-Operation"><a href="#例题：Maximum-Beauty-of-an-Array-After-Applying-Operation" class="headerlink" title="例题：Maximum Beauty of an Array After Applying Operation"></a>例题：Maximum Beauty of an Array After Applying Operation</h2><blockquote><p><strong>Maximum Beauty of an Array After Applying Operation</strong></p><p>You are given a 0-indexed array nums and a non-negative integer k.</p><p>In one operation, you can do the following:</p><p>Choose an index i that hasn’t been chosen before from the range [0, nums.length - 1].<br>Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].<br>The beauty of the array is the length of the longest subsequence consisting of equal elements.</p><p>Return the maximum possible beauty of the array nums after applying the operation any number of times.</p><p>Note that you can apply the operation to each index only once.</p><p>A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.</p><p>Constraints:</p><ul><li>1 &lt;= nums.length &lt;= 1e5</li><li>0 &lt;= nums[i], k &lt;= 1e5</li></ul></blockquote><p>自然想到的思路是把每个元素看作是一个可换空间，将所有可换空间在一个足够大的空间中进行叠加，被最多可换空间覆盖到的地方即为所求结果。或者，把每个元素考虑为对其对应可换空间中的每一个位置投一票，最终票数最多的位置为所求结果。</p><p>从数据范围上分析，区间大小应该为[-1e5, 2e5]。将区间为负数的部分用<code>offset</code>来表示，则可以写出以下解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumBeauty</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="comment">// 多开3个空间，为了存0、存差分数组上限和匹配下标</span></span><br><span class="line">        <span class="keyword">int</span>[] diffArr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)<span class="number">3e5</span>+<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> ofst = (<span class="keyword">int</span>)<span class="number">1e5</span>+<span class="number">1</span>; <span class="comment">// diffArr[ofst]为0所在位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            diffArr[x-k+ofst]++;</span><br><span class="line">            diffArr[x+k+ofst+<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;diffArr.length;i++)&#123;</span><br><span class="line">            diffArr[i] += diffArr[i-<span class="number">1</span>];</span><br><span class="line">            res = Math.max(res, diffArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>周赛第三题属于值域上的打家劫舍，因此先来了解一下打家劫舍类型题目，其特点是<strong>对某一元素的选择会对其相邻区域造成影响</strong>。此类问题通常可以通过动态规划求解。</p><blockquote><p>House Robber</p><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p><p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p></blockquote><p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p><p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 $k(k&gt;2)$ 间房屋，有两个选项:</p><ol><li>偷窃第 $k$ 间房屋，那么就不能偷窃第 $k-1$ 间房屋，偷窃总金额为前 $k-2$ 间房屋的最高总金额与第 $k$ 间房屋的金额之和。</li><li>不偷窃第 $k$ 间房屋，偷窃总金额为前 $k-1$ 间房屋的最高总金额。</li></ol><p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 $k$ 间房屋能偷窃到的最高总金额。</p><p>用 $d p[i]$ 表示前 $i$ 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p><script type="math/tex; mode=display">d p[i]=\max (d p[i-2]+\operatorname{nums}[i], d p[i-1])</script><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=\operatorname{nums}[0] & \text { 只有一间房屋，则偷窃该房屋 } \\ d p[1]=\max (n u m s[0], n u m s[1]) & \text { 只有两间房屋，选择其中金额较高的房屋进行偷窃 }\end{cases}</script><p>最终的答案即为 $d p[n-1]$, 其中 $n$ 是数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，可以考虑使用滚动数组优化空间使用。上述方法使用了数组存储结果，考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。得到优化解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题：Maximum-Total-Damage-With-Spell-Casting"><a href="#例题：Maximum-Total-Damage-With-Spell-Casting" class="headerlink" title="例题：Maximum Total Damage With Spell Casting"></a>例题：Maximum Total Damage With Spell Casting</h2><blockquote><p>Maximum Total Damage With Spell Casting</p><p>A magician has various spells.</p><p>You are given an array power, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p><p>It is a known fact that if a magician decides to cast a spell with a damage of power[i], they cannot cast any spell with a damage of power[i] - 2, power[i] - 1, power[i] + 1, or power[i] + 2.</p><p>Each spell can be cast only once.</p><p>Return the maximum possible total damage that a magician can cast.</p></blockquote><p>这道题不是从空间上限制选取，而是从值域上限制，因此我们可以考虑对原数组进行排序，使元素选取与空域产生一定相关性，方便状态记录。排序后，考虑聚合相等值的元素，每一步选取实际上都是选取了一组元素。</p><p>用$nums$表示聚合后的排序数组，$total(nums[k])$表示元素$nums[k]$的值总和，用 $dp[i]$ 表示前 $i$ 个元素能造成的最高总伤害，那么对于$nums[k]$选或不选：</p><ul><li>不选，$dp[i] = dp[i-1]$;</li><li>选，则值在$[nums[k]-2, nums[k]-1]$的元素不能选，令$j$为最小满足$nums[j]&gt;=nums[k]-2$的元素，则$dp[i] = dp[j-1] + total(nums[k])$。</li></ul><p>对两种情况取最大值，有如下的状态转移方程：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1], dp[j-1] + total(nums[i]))</script><p>假设一种最坏的情况，$nums$中所有的元素都是连续的，那么在遇到元素$nums[i]$时，我们至少要保存三个状态才能够完成状态转移，即$dp[i-1], dp[i-2], dp[i-3]$，此时他们的末尾值分别对应$nums[i]-1,nums[i]-2,nums[i]-3$，则$j = i-2$，状态可能从$dp[i-3]$转移。也就是说，$dp[j-1]$的取值范围是$dp[i-1], dp[i-2], dp[i-3]$。</p><p>边界条件为：</p><script type="math/tex; mode=display">\begin{cases}d p[0]=total(\operatorname{nums}[0]) \\ d p[1]=\begin{cases} \max (total(\operatorname{nums}[0]), total(\operatorname{nums}[1])),&nums[0]-2<=nums[1]<nums[0] \\ dp[0]+total(\operatorname{nums}[1]), &nums[0]<nums[1]-2 \end{cases}\end{cases}</script><p>此时发现问题：面对下标为$2$的元素，并不存在状态$dp[-1]$供其转移（$dp[j-1]$的下界）。于是如果从$nums[2]$开始遍历则应该添加此状态（置0），或从$nums[3]$开始遍历。</p><p>注意到当前状态仅与前三个状态有关，则可以用长度为$3$的滚动数组进行优化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maximumTotalDamage</span><span class="params">(<span class="keyword">int</span>[] power)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : power) &#123;</span><br><span class="line">            map.merge(x, (<span class="keyword">long</span>) x, Long::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer[] nums = map.keySet().toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 三个状态</span></span><br><span class="line">        <span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = map.get(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">2</span>] = nums[<span class="number">0</span>]&lt;nums[<span class="number">1</span>]-<span class="number">2</span>?dp[<span class="number">1</span>]+map.get(nums[<span class="number">1</span>]):Math.max(dp[<span class="number">1</span>], map.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j放到外面，可以避免每次都从0开始查</span></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 定位j</span></span><br><span class="line">            <span class="keyword">while</span> (nums[j] &lt; nums[i]-<span class="number">2</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> pos = j==i?<span class="number">2</span>:(j==i-<span class="number">1</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> tmp = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[pos]+map.get(nums[i]));</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果把2换为k呢？一样的，多增加几个状态就行了，滚动数组法只需要k+1个状态。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/">https://leetcode.cn/problems/house-robber/solutions/263856/da-jia-jie-she-by-leetcode-solution/</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/">https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/solutions/2812389/tao-lu-da-jia-jie-she-pythonjavacgo-by-e-p9b5/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这周周赛菜了…赶紧记一下。&lt;/p&gt;
&lt;p&gt;本周主题：差分数组、动态规划&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240615每日一题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/&quot;&gt;Maximum Beauty of an Array After Applying Operation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240616周赛第三题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/&quot;&gt;Maximum Total Damage With Spell Casting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;LC198打家劫舍—&lt;a href=&quot;https://leetcode.cn/problems/house-robber/description/&quot;&gt;House Robber&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP1</title>
    <link href="http://silencezheng.top/2024/08/18/article132/"/>
    <id>http://silencezheng.top/2024/08/18/article132/</id>
    <published>2024-08-17T16:14:09.000Z</published>
    <updated>2024-08-17T16:15:40.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。</p><p>本周主题：记忆化搜索、动态规划、01背包</p><p>题目：</p><ul><li>240609每日一题—<a href="https://leetcode.cn/problems/burst-balloons/description/">Burst Balloons</a></li><li>240608双周赛最后两题—<a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/">Find the Maximum Length of a Good Subsequence</a></li><li>240609周赛最后两题—<a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/">Maximum Total Reward Using Operations</a><span id="more"></span><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><blockquote><p><strong>Burst Balloons</strong><br>You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.</p><p>If you burst the ith balloon, you will get nums[i - 1] <em> nums[i] </em> nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</p><p>Return the maximum coins you can collect by bursting the balloons wisely.</p></blockquote></li></ul><p>这道题的第一个关键思路是逆向思维，戳气球的操作会导致两个气球从不相邻变成相邻，使后续操作处理困难，将戳气球的过程反过来看成每次添加一个气球，直到形成原数组。定义方法 $solve$，令 $solve(i,j)$ 表示将开区间 $(i,j)$ 内的位置全部填满气球能够得到的最多硬币数。由于是开区间，因此区间两端的气球的编号就是 $i$ 和 $j$，对应着 $val[i]$ 和 $val[j]$。</p><p>第二个思路比较简单，在原数组左右各增加一个$1$，即左右边界时的得分。</p><p>下面，对于$solve(i,j)$：</p><ul><li>当 $i≥j−1$ 时，开区间中没有气球，$solve(i,j)$ 的值为 0；</li><li>当 $i&lt;j−1$ 时，我们枚举开区间内的全部位置 $mid$，令 $mid$ 为当前区间第一个添加的气球，该操作能得到的硬币数为 $val[i]×val[mid]×val[j]$。同时我们递归地计算分割出的两区间对 $solve(i,j)$ 的贡献，这三项之和的最大值，即为 $solve(i,j)$ 的值。这样问题就转化为求 $solve(i,mid)$ 和 $solve(mid,j)$ ，可以写出方程：<script type="math/tex; mode=display">{solve}(i,j)= \begin{cases}{} \displaystyle \max_{\textit{mid} = i + 1}^{j - 1}val[i] \times \textit{val}[\textit{mid}] \times \textit{val}[j] + \textit{solve}(i, \textit{mid}) + \textit{solve}(\textit{mid}, j) ,&i < j - 1 \\ 0, & i \geq j - 1 \end{cases}</script></li></ul><p>由于在枚举mid的过程中，一定会产生相同子区间，即存在重复计算，此时可以采用记忆化的方式存储计算结果，优化时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>]; <span class="comment">// 增加边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>]; <span class="comment">// 记忆化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right]; <span class="comment">// 已计算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/burst-balloons/solutions/336390/chuo-qi-qiu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h1 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h1><blockquote><p>有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_{i}$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>在上述例题中，若每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。</p><p>例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$。</p><p>设 DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值。</p><p>考虑转移。假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，当其不放入背包时，背包的容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；当其放入背包时，背包的容量会增大 $w_{i}$，即前一个状态的背包容量必须是 $j-w_{i}$，通过本轮加上 $w_{i}$ 达到 $j$，同时背包中物品的总价值会增大 $v_{i}$，故这种情况下的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。</p><p>由此可以得出状态转移方程：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i-1,j-w_{i}}+v_{i})</script><p>依据该状态转移方程可以写出解法1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = w.length;</span><br><span class="line"><span class="comment">// 容量维度多开辟一个位置，因为要用索引表示容量，需要匹配到 W</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][W+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 对于dp[0][j]，所有j&lt;w[0]的位置初始化为0，其余位置初始化为 v[0]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;w[<span class="number">0</span>])&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于dp[i][0]，背包容量为0时无法装物，价值为0，对于其余位置，是由其上层的状态计算出的，也一并初始化为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    Arrays.fills(dp[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=w[i]) dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[n-1][W]即为结果</span></span><br></pre></td></tr></table></figure><p>如果直接采用二维数组对状态进行记录，可能会出现 MLE（Memory Limit Exceeded）。可以考虑改用<strong>滚动数组</strong>的形式来优化。</p><blockquote><p>滚动数组</p><p>在动态规划问题中，通常需要存储一系列状态值，每个状态值可能依赖于前几个状态。随着计算的进行，较早的状态值可能不再需要。例如，在求解斐波那契数列时，只需要保留最近两个值即可计算下一个值，之前的值则可以被覆盖重用。</p><p>思想：通过观察dp方程来判断需要使用哪些数据，可以抛弃哪些数据，一旦找到关系，就可以用新的数据不断覆盖旧的数据量来减少空间的使用。</p></blockquote><p>由于在二维解法中，对于当前层（当前物品）状态有影响的只有上一层（前一物品），即对 $f_i$ 有影响的只有 $f_{i-1}$，则可以去掉第一维，用一个重复更新的一维数组记录状态，直接用 $f_{j}$ 来表示处理到当前物品时背包容量为 $j$ 的最大价值，得出以下方程：</p><script type="math/tex; mode=display">f_j=\max \left(f_j,f_{j-w_i}+v_i\right)</script><p>这里，$f_{j-w_i} + v_i$代表如果选择放入第$i$个物品，则在背包容量为$j-w_i$时的价值加上这个物品的价值。而$max$操作保证了在是否选择放入第$i$个物品之间取最优解。</p><p>大部分背包问题的转移方程都是在此基础上推导出来的。</p><p>对于代码实现方面，<strong>滚动数组的实现要注意内层循环应从后向前逆序遍历</strong>，这可以避免在 $j\geqslant w_{i}$ 时，$f_{i,j}$ 被 $f_{i,j-w_{i}}$ 所影响，即避免小背包容量下取物对后续大背包容量下状态计算的影响。</p><p>举例来说，假设<em>物品4</em>的重量为$1$，在二维解法中<code>dp[4][5]</code>应该由<code>dp[3][5]</code>和<code>dp[3][4]</code>得出，<code>dp[4][6]</code>应该由<code>dp[3][6]</code>和<code>dp[3][5]</code>得出，而在正序遍历的一维解法中，<code>f[5]</code>会先被计算，可能存在<code>f[5]</code>存储<code>dp[3][4]</code>状态的情况，此时<code>f[6]</code>的计算就无法获取<code>dp[3][5]</code>，造成计算错误。这个计算错误事实上是对<strong>同一物品的多次装包</strong>，因为<code>dp[3][4]</code>表示取<em>物品4</em>(下标为3)，若下一步<code>f[6]</code>再选择<code>f[5]+v[3]</code>则表示又取了一次<em>物品4</em>，这在01背包中是不允许的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">13010</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];  <span class="comment">// 读入数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = W; l &gt;= w[i]; l--) <span class="comment">// l &gt;= w[i]保证背包能装下，防止越界</span></span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的：</span></span><br><span class="line"><span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//   for (int l = 0; l &lt;= W - w[i]; l++)</span></span><br><span class="line"><span class="comment">//     f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);</span></span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。</p><p>可以借鉴 0-1 背包的思路，进行状态定义：设 $f_{i,j}$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。</p><p>可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n^3)$ 的。</p><p>状态转移方程如下：</p><script type="math/tex; mode=display">f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)</script><p>考虑进行优化。可以发现，对于 $f_{i,j}$，只要通过 $f_{i,j-w_i}$ 转移就可以了。因此状态转移方程为：</p><script type="math/tex; mode=display">f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)</script><p>理由是当我们这样转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。</p><p>实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxW = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, W, w[maxn], v[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[maxW];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; W &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = w[i]; l &lt;= W; l++)</span><br><span class="line">      <span class="keyword">if</span> (f[l - w[i]] + v[i] &gt; f[l]) f[l] = f[l - w[i]] + v[i];  <span class="comment">// 核心状态方程</span></span><br><span class="line">  cout &lt;&lt; f[W];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题1-Maximum-Total-Reward-Using-Operations"><a href="#例题1-Maximum-Total-Reward-Using-Operations" class="headerlink" title="例题1: Maximum Total Reward Using Operations"></a>例题1: Maximum Total Reward Using Operations</h2><blockquote><p><strong>Maximum Total Reward Using Operations I &amp; II</strong></p><p>You are given an integer array rewardValues of length n, representing the values of rewards.</p><p>Initially, your total reward x is 0, and all indices are unmarked. You are allowed to perform the following operation any number of times:</p><ul><li>Choose an unmarked index i from the range [0, n - 1].</li><li>If rewardValues[i] is greater than your current total reward x, then add rewardValues[i] to x (i.e., x = x + rewardValues[i]), and mark the index i.</li></ul><p>Return an integer denoting the maximum total reward you can collect by performing the operations optimally.</p></blockquote><p>首先，<code>rewardValues</code>中的数应该从小到大选，于是可以对其进行排序。排序后，可以看作01背包问题处理，背包的重量限制转化成了<code>rewardValues[i]</code>与reward<code>x</code>的制约关系。因此定义 <code>f[i][j]</code> 表示选取前<code>i</code>个<code>rewardValues</code>下<code>x</code>能达到的最大值<code>j</code>。由于<code>x</code>所能达到的最大值不确定，在实现中应选取一个尽可能大的值。</p><p>考虑转移，对于<code>f[i][j]</code>，是否选择<code>rewardValues[i]</code>：</p><ul><li>不选，<code>f[i][j] = f[i-1][j]</code>，即分数与上轮相同。</li><li>选择，<code>f[i][j] = f[i-1][j-rewardValues[i]]</code>，即上一轮的分数 <code>j-rewardValues[i]</code> 必须满足 <code>j-rewardValues[i]&lt;rewardValues[i]</code>, 同时为防止越界，<code>j-rewardValues[i]</code>需要大于等于0。综上，需满足 <code>rewardValues[i] &lt;= j &lt; 2*rewardValues[i]</code>。</li></ul><p>这里由于<code>f[i][j]</code>不需要存储“价值”，<code>j</code>自然表示了可以达到的最大值，因此<code>f[i][j]</code>通过布尔值表示是否可达即可，则有<code>f[i][j] = f[i-1][j] || f[i-1][j-rewardValues[i]]</code>。</p><p>写出二维解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rewardValues.length;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// int m = Integer.MAX_VALUE;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对物品从小到大排序</span></span><br><span class="line">        Arrays.sort(rewardValues);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 全部初始化为false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">// 初始化第一行</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 不选</span></span><br><span class="line">        dp[<span class="number">0</span>][rewardValues[<span class="number">0</span>]] = <span class="keyword">true</span>; <span class="comment">// 选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化第一列，即一直不选。</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 对于[1, rewardValues[i]]区间，复制上一层表示可以不选。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对于可选取区间，计算新得分。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=rewardValues[i];j&lt;<span class="number">2</span>*rewardValues[i];j++)&#123;</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-rewardValues[i]]);</span><br><span class="line">                <span class="comment">// if(dp[i][j]) System.out.println(i+&quot;, &quot;+j);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回最后一行的最大真值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n-<span class="number">1</span>][i]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维解法对于数据范围大的情况会存在MLE，因此参照01背包问题，考虑使用滚动数组进行优化。原计算可以简化为：<code>f[j] = f[j] || f[j-rewardValues[i]]</code>，同时注意逆序遍历。另外，由于最终结果可以由<code>j</code>的值表示，故可以进一步优化数组为位运算，采用一个<code>BigInteger</code>表示布尔数组。</p><p>下面考虑如何用位运算表示布尔运算，假设之前已经遍历过的元素为<code>1, 2, 3</code>，则此时状态应为：<code>0000 0011 1111</code>，即可达分数区间为<code>[0, 5]</code>，此时假设下一个元素为<code>5</code>，则需要对区间<code>[5, 10)</code>进行布尔计算，计算的本质是将当前状态的区间<code>[0, 5)</code>与区间<code>[5, 10)</code>进行<code>or</code>运算。因此可以通过构造一个“<em>把区间<code>[0, 5)</code>移动到区间<code>[5, 10)</code>位置上且其余部分为<code>0</code></em>”的mask来与原状态进行<code>or</code>运算，既计算了目标区间，又不影响其他状态。构造的方法是先构造区间<code>[0, 5)</code>上全为<code>1</code>的mask，而后与原状态进行<code>and</code>操作提取目标区间，再将目标区间左移到<code>[5, 10)</code>的位置上得到最终的mask。</p><p>对于上面的例子来说，我们首先构造一个初始mask<code>0000 0000 0001</code>，而后对其左移<code>rewardValues[i]</code>位，这里即$5$位，得到<code>0000 0001 0000</code>，减$1$得到目标区间全真值mask<code>0000 0000 1111</code>，再左移<code>rewardValues[i]</code>位到目标区间，得到<code>0001 1110 0000</code>，与原状态进行<code>or</code>运算，得到：<code>0001 1111 1111</code>，即可取的分数范围为<code>[0, 8]</code>，符合题意。参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTotalReward</span><span class="params">(<span class="keyword">int</span>[] rewardValues)</span> </span>&#123;</span><br><span class="line">        BigInteger f = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : Arrays.stream(rewardValues).distinct().sorted().toArray()) &#123;</span><br><span class="line">            BigInteger mask = BigInteger.ONE.shiftLeft(v).subtract(BigInteger.ONE);</span><br><span class="line">            f = f.or(f.and(mask).shiftLeft(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f.bitLength() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题2-Find-the-Maximum-Length-of-a-Good-Subsequence"><a href="#例题2-Find-the-Maximum-Length-of-a-Good-Subsequence" class="headerlink" title="例题2: Find the Maximum Length of a Good Subsequence"></a>例题2: Find the Maximum Length of a Good Subsequence</h2><blockquote><p>Find the Maximum Length of a Good Subsequence I &amp; II</p><p>You are given an integer array nums and a non-negative integer k. A sequence of integers seq is called good if there are at most k indices i in the range [0, seq.length - 2] such that seq[i] != seq[i + 1].</p><p>Return the maximum possible length of a good subsequence of nums.</p><p>A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p></blockquote><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>这道01背包没想清楚，先来特殊思路：<strong>处理相邻元素不同的DP问题</strong></p><p>把有$k$个相邻下标元素不同的子序列称为k序列。用 $c n t[k]$ 记录以 $x$ 结尾的 $k$ 序列的最大长度。考虑以 $nums[i]$ 结尾的 $k$ 序列, $nums [i]$ 要么接在以 $nums[i]$ 结尾的 $k$ 序列后，要么接在某个以 $n u m s<a href="j&lt;i">j</a>$ 结尾的 $k-1$ 序列后。所以状态转移方程即为</p><script type="math/tex; mode=display">\operatorname{cnt}[k][\operatorname{nums}[i]]=\max \left(\operatorname{cnt}[k][\operatorname{nums}[i]], \max _{j<i}\{\operatorname{cnt}[k-1][\operatorname{nums}[j]]\}\right)+1</script><p>这里我们不需要关心是否 $n u m s[j] \neq n u m s[i]$ ，即 $k-1$ 序列是否已经以 $nums[i]$ 结尾，因为在同样以 $nums[i]$ 结尾的情况下， $k-1$ 序列的长度一定小于 $k$ 序列的长度。</p><p>$c n t[k-1]$ 的最大值可以在哈希表基础上维护值有序来实现。但实际上，我们不需要维护 $c n t[k-1]$ 的所有值, 由于 $k-1$ 序列的最大长度单调不减, 所以只需要维护 $c n t[k-1]$ 的最大值就可以了。</p><p>在一些要求相邻状态不同的DP问题中，在处理当前状态时，不一定非要与所有前置状态比较, 只需要记录 $d p$ 最大和次大值对应的前置状态即可。这样的思路同样适用于本题。</p><p>注意由于$nums[i]$的范围比较大，Java实现的时候要用Map来存防止OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumLength</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; cnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] mx = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            cnt.put(i, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> kk = k; kk &gt;= <span class="number">0</span>; kk--) &#123;</span><br><span class="line">                <span class="comment">// 考虑到更新顺序，需要倒序枚举</span></span><br><span class="line">                <span class="keyword">int</span> currentValue = kk&gt;<span class="number">0</span>?mx[kk - <span class="number">1</span>]:<span class="number">0</span>;</span><br><span class="line">                currentValue = Math.max(currentValue, cnt.get(kk).getOrDefault(x, <span class="number">0</span>))+<span class="number">1</span>;</span><br><span class="line">                cnt.get(kk).put(x, currentValue);</span><br><span class="line">                mx[kk] = Math.max(mx[kk], cnt.get(kk).getOrDefault(x, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getMax(mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] mx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : mx) &#123;</span><br><span class="line">            max = Math.max(max, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://oi-wiki.org/dp">https://oi-wiki.org/dp</a><br>[2] <a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/">https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/solutions/2805413/bitset-you-hua-0-1-bei-bao-by-endlessche-m1xn/</a><br>[3] <a href="https://blog.csdn.net/txyyt_wst/article/details/130206572">https://blog.csdn.net/txyyt_wst/article/details/130206572</a><br>[4] <a href="https://blog.csdn.net/m0_46427179/article/details/107419492">https://blog.csdn.net/m0_46427179/article/details/107419492</a><br>[5] <a href="https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/">https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/solutions/2805181/chu-li-xiang-lin-yuan-su-bu-tong-de-dpwe-gobq/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p><p><strong>关于最后一个例题我自己的思考如下（不知道为什么是错的），没时间浪费了先存档以后再思考，先理解正确解法：</strong></p><p><code>Good Subsequence</code>通俗理解一下就是一个有不超过<code>k</code>个<strong>前后不相同元素对</strong>的子序列，即题目需要在元素尽可能少不同的情况下使子序列尽可能的长。</p><p>由于 k 是非负整数，因此长度等于 1 的子序列一定是好子序列。对于任意一个子序列，在后面添加一个元素之后，子序列的长度增加 1，相邻不同元素对的数量不变或增加 1，因此可以使用动态规划计算最长好子序列的长度。</p><p>由于是”子序列“问题，其实也还是从全集中选择若干元素的问题，由于元素不能重复选，则还是0-1背包问题。这里背包的重量限制转化为<strong>前后不相同元素对</strong>数量的限制，对于元素<code>x = nums[i]</code>，定义<code>dp[i][j]</code>为遍历前<code>i</code>个元素时<strong>前后不相同元素对</strong>数量不超过<code>j</code>时的子序列最大长度。</p><p><strong>TODO:如果定义为前<code>i</code>个元素，则实现时遇到相等长度情况应该如何处理？即dp[a][j]==dp[b][j]，如果只取最后一个，那么后面和dp[?][j-1]比的时候也是相同亦可？</strong></p><p>这里需要注意一下如何定义，参考01背包问题，“前i个元素”一致，“背包容量”与“前后不相同元素对数量”一致，且此约束条件应转换为不超过<code>j</code>而不是等于<code>j</code>。</p><p>则对于<code>x</code>的选取分为三种情况：</p><ol><li>不选，<code>dp[i][j] = dp[i-1][j]</code>；</li><li>选择，且<code>x</code>与子序列的前一个数相同，则<code>dp[i][j] = dp[?][j]+1</code>；</li><li>选择，且<code>x</code>与子序列的前一个数不同，则<code>dp[i][j] = dp[?][j-1]+1</code>。</li></ol><p>这里使用了<code>?</code>来表示前一个数<code>y</code>的下标，<code>y</code>需要通过遍历得到。</p><p>由此可以得到状态转移方程为：</p><ul><li>情况A（不选）：<code>dp[i][j] = dp[i-1][j]+1</code></li><li>情况B（选）：<code>dp[i][j] = max(dp[?][j], dp[?][j-1])+1</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;新开一个系列，LeetCode刷题周记，每周刷题有感悟可以总结一下。&lt;/p&gt;
&lt;p&gt;本周主题：记忆化搜索、动态规划、01背包&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240609每日一题—&lt;a href=&quot;https://leetcode.cn/problems/burst-balloons/description/&quot;&gt;Burst Balloons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240608双周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/description/&quot;&gt;Find the Maximum Length of a Good Subsequence&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;240609周赛最后两题—&lt;a href=&quot;https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/description/&quot;&gt;Maximum Total Reward Using Operations&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode周记 EP7</title>
    <link href="http://silencezheng.top/2024/08/07/article131/"/>
    <id>http://silencezheng.top/2024/08/07/article131/</id>
    <published>2024-08-07T06:28:14.000Z</published>
    <updated>2024-08-19T16:23:04.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回国了，开始好好准备找工。</p><p>本周主题：快速幂</p><p>题目：</p><ul><li>240730每日一题—<a href="https://leetcode.cn/problems/double-modular-exponentiation/description">Double Modular Exponentiation</a><span id="more"></span></li></ul><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 $x^{64}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^8 \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}</script><p>的顺序，从 $x$ 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 $x^{64}$ 的值，而不需要对 $x$ 乘 63 次 $x$ 。</p><p>再举一个例子，如果我们要计算 $x^{77}$ ，我们可以按照：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^9 \rightarrow x^{19} \rightarrow x^{38} \rightarrow x^{77}</script><p>的顺序, 在 $x \rightarrow x^2, x^2 \rightarrow x^4, x^{19} \rightarrow x^{38}$ 这些步骤中, 我们直接把上一次的结果进行平方，而在 $x^4 \rightarrow x^9, x^9 \rightarrow x^{19}, x^{38} \rightarrow x^{77}$ 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 $x$ 。</p><p>直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后, 还需不需要额外乘 $x$ 。但如果我们从右往左看, 分治的思想就十分明显了：</p><ul><li>当我们要计算 $x^n$ 时，我们可以先递归地计算出 $y=x^{\lfloor n / 2\rfloor}$ ，其中 $\lfloor a\rfloor$表示对 $a$ 进行下取整；</li><li>根据递归计算的结果, 如果 $n$ 为偶数, 那么 $x^n=y^2$; 如果 $n$ 为奇数,那么 $x^n=y^2 \times x$ ；</li><li>递归的边界为 $n=0$, 任意数的 0 次方均为 1 。</li></ul><p>由于每次递归都会使得指数减少一半，因此递归的层数为 O(logn)，算法可以在很快的时间内得到结果。</p><p>下面是快速幂算法的递归实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进一步，由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。我们还是以 $x^{77}$ 作为例子：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow^{+} x^9 \rightarrow^{+} x^{19} \rightarrow x^{38} \rightarrow^{+} x^{77}</script><p>并且把需要额外乘 $x$ 的步骤打上了 + 标记。可以发现：</p><ul><li>$x^{38} \rightarrow^{+} x^{77}$ 中额外乘的 $x$ 在 $x^{77}$ 中贡献了 $x$ ；</li><li>$x^9 \rightarrow^{+} x^{19}$ 中额外乘的 $x$ 在之后被平方了 2 次，因此在 $x^{77}$ 中贡献了 $x^{2^2}=x^4$</li><li>$x^4 \rightarrow^{+} x^9$ 中额外乘的 $x$ 在之后被平方了 3 次，因此在 $x^{77}$ 中贡献了 $x^{2^3}=x^8$</li><li>最初的 $x$ 在之后被平方了 6 次，因此在 $x^{77}$ 中贡献了 $x^{2^6}=x^{64}$ 。</li></ul><p>我们把这些贡献相乘， $x \times x^4 \times x^8 \times x^{64}$ 恰好等于 $x^{77}$ 。而这些贡献的指数部分又是什么呢？它们都是 2 的幂次，这是因为每个额外乘的 $x$ 在之后都会被平方若干次。而这些指数 $1 ， 4 ， 8$ 和 $64 ，$ 恰好就对应了 77 的二进制表示 $(1001101)_2$ 中的每个 1 ！</p><p>因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 $n$ 的二进制拆分为</p><script type="math/tex; mode=display">n=2^{i_0}+2^{i_1}+\cdots+2^{i_k}</script><p>那么</p><script type="math/tex; mode=display">x^n=x^{2^{i_0}} \times x^{2^{i_1}} \times \cdots \times x^{2^{i_k}}</script><p>这样以来, 我们从 $x$ 开始不断地进行平方, 得到 $x^2, x^4, x^8, x^{16}, \cdots$, 如果 $n$的第 $k$ 个（从右往左，从 0 开始计数）二进制位为 1 ，那么我们就将对应的贡献 $x^{2^k}$ 计入答案。</p><p>下面是快速幂的迭代实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x0</span></span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="例题：Double-Modular-Exponentiation"><a href="#例题：Double-Modular-Exponentiation" class="headerlink" title="例题：Double Modular Exponentiation"></a>例题：Double Modular Exponentiation</h2><blockquote><p>Double Modular Exponentiation</p><p>You are given a 0-indexed 2D array variables where variables[i] = [ai, bi, ci, mi], and an integer target.</p><p>An index i is good if the following formula holds:</p><ul><li>0 &lt;= i &lt; variables.length</li><li>((ai^bi % 10)^ci) % mi == target</li></ul><p>Return an array consisting of good indices in any order.</p></blockquote><p>计算式中重复出现的模式是“幂+取模”，于是可以把快速幂和取模融合在一起。</p><p>另一个知识点是“加法和乘法”的取模，有如下公式：<br>$(a+b) \bmod m=((a \bmod m)+(b \bmod m)) \bmod m$ $(a \cdot b) \bmod m=((a \bmod m) \cdot(b \bmod m)) \bmod m$</p><p>因此我们可以在计算过程中（例如循环），对加法和乘法的结果取模，而不是在循环结束后再取模。</p><p>更多模相关的内容请看：<a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getGoodIndices</span><span class="params">(<span class="keyword">int</span>[][] variables, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; variables.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] v = variables[i];</span><br><span class="line">            <span class="keyword">if</span> (powMod(powMod(v[<span class="number">0</span>], v[<span class="number">1</span>], <span class="number">10</span>), v[<span class="number">2</span>], v[<span class="number">3</span>]) == target) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">powMod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// (a*b) mod c = ((a mod c) * (b mod c)) mod c</span></span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                res = res * x % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            y &gt;&gt;= <span class="number">1</span>; <span class="comment">// 相当于y/=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/circle/discuss/mDfnkW/">https://leetcode.cn/circle/discuss/mDfnkW/</a><br>[2] <a href="https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/">https://leetcode.cn/problems/powx-n/solutions/238559/powx-n-by-leetcode-solution/</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回国了，开始好好准备找工。&lt;/p&gt;
&lt;p&gt;本周主题：快速幂&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;240730每日一题—&lt;a href=&quot;https://leetcode.cn/problems/double-modular-exponentiation/description&quot;&gt;Double Modular Exponentiation&lt;/a&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="http://silencezheng.top/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组（速食版）</title>
    <link href="http://silencezheng.top/2024/06/06/article130/"/>
    <id>http://silencezheng.top/2024/06/06/article130/</id>
    <published>2024-06-05T19:43:00.000Z</published>
    <updated>2024-06-05T19:44:07.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快速计算任意连续子数组元素和的数据结构。</p><p>树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为<br>Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。<br><span id="more"></span></p><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><blockquote><p>给你一个数组，如何快速地计算任意一段连续子数组的元素和？</p></blockquote><p><img src="/assets/post_img/article130/szsz.png" alt="bit"></p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>下标从 $left$ 到 $right$ 的子数组元素和，可以看成是下标从 1 到 $right$ 的子数组元素和，减去下标从 1 到 $left−1$ 的子数组元素和。例如数组 [3,1,4,1,5,9]，子数组 [4,1,5] 的元素和，等于 [3,1,4,1,5] 的元素和，减去 [3,1] 的元素和。</p><p>按照这个方法，算出每个前缀 [1,i]（表示下标从 1 到 i 的连续子数组）的元素和，就可以 $O(1)$ 地查询（计算任意连续子数组的元素和）了。</p><h2 id="如果更新呢？"><a href="#如果更新呢？" class="headerlink" title="如果更新呢？"></a>如果更新呢？</h2><p>如果修改下标为1的元素，则所有前缀都需要更新（因为所有前缀包含该元素），意味着更新操作时间复杂度为$O(n)$。此时查询与更新的综合时间复杂度还是$O(n)$。</p><p>自然的，想到应该将前缀元素和继续进行拆分，令更新某元素时，仅影响部分“子前缀”，此时只需要更新影响到的部分即可。</p><p>因此，需要找到一种合适的拆分方法，能够把任意前缀拆分成若干<strong>子前缀</strong>，使更新操作的执行范围缩小到部分子前缀中。</p><h2 id="对于想继续探索的同学"><a href="#对于想继续探索的同学" class="headerlink" title="对于想继续探索的同学"></a>对于想继续探索的同学</h2><p>推荐文献[3]，较为全面的阐述了树状数组的来世今生，本文以让读者尽快掌握用法为主，不过多展开深入。</p><h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h2><p>BIT的重要概念，抛开相关性质不谈，先说计算，lowbit(x)表示取数x的最低位1，常用<code>lowbit(x) = x &amp; -x</code>计算。</p><p>举例：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span><span class="punctuation">,</span> lowbit(<span class="keyword">x</span>) <span class="operator">=</span> <span class="keyword">x</span> &amp; -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">计算过程：</span><br><span class="line">   <span class="keyword">x</span> <span class="operator">=</span> <span class="number">1010</span></span><br><span class="line">  -<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0110</span></span><br><span class="line"><span class="keyword">x</span>&amp;-<span class="keyword">x</span> <span class="operator">=</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><h2 id="树状数组-c-n-的查询与更新"><a href="#树状数组-c-n-的查询与更新" class="headerlink" title="树状数组 c[n] 的查询与更新"></a>树状数组 <code>c[n]</code> 的查询与更新</h2><p>对于原数组<code>a[n]</code>构建对应的树状数组<code>c[n]</code>，可推导得出：<code>c[x] = a[x-lowbit(x)+1] + ... + a[x]</code>，即区间<code>[x-lowbit(x)+1, x]</code>的元素和。</p><p>定义<code>query(x)</code>为查询原数组区间<code>[1, x]</code>上的元素和，则可写出利用<code>c[n]</code>实现$O(logn)$的查询代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 减去所有的lowbit后i为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i ; i -= lowbit(i))</span><br><span class="line">            ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        ans += c[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义<code>add(x, v)</code>为修改位置为在索引<code>x</code>的元素，加上<code>v</code>。则可写出利用<code>c[n]</code>实现$O(logn)$的更新代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = 树状数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)&#123;</span><br><span class="line">        c[x] += v;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容很好理解，抓住<code>c[x]</code>的定义就行了。</p><h2 id="树状数组-c-n-的构造"><a href="#树状数组-c-n-的构造" class="headerlink" title="树状数组 c[n] 的构造"></a>树状数组 <code>c[n]</code> 的构造</h2><p>最简单的，遍历原数组，调用<code>n</code>次<code>add</code>方法进行构造，时间复杂度$O(nlogn)$：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        add(i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更快速的，考虑<code>c[x]</code>表示原数组区间<code>[x-lowbit(x)+1, x]</code>的元素和，可以先对原数组求一个前缀和数组<code>s[n]</code>，利用前缀和来更新树状数组，即<code>c[x] = s[x] - s[x-lowbit(x)]</code>，此时构造的时间复杂度为$O(n)$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 求a的前缀和</span></span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 用前缀和求出c</span></span><br><span class="line">c[i] = s[i] - s[i - lowbit(i)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆分规则—逆序"><a href="#拆分规则—逆序" class="headerlink" title="拆分规则—逆序"></a>拆分规则—逆序</h2><p>按照逆序处理，每次处理的bit都是当前编号的最后的为1位。将每次处理的bit定义为<strong>lowbit</strong>。</p><p>对于前缀 $[1,i]$：</p><ul><li>如果 $i$ 是 2 的幂，那么 $[1,i]$ 无需拆分。</li><li>如果 $i$ 不是 2 的幂，那么先拆分出一个长为 $lowbit(i)$ 的关键区间 $[i−lowbit(i)+1,i]$，问题转换成剩下的 $[1,i−lowbit(i)]$ 如何拆分，这是一个规模更小的子问题。</li></ul><h1 id="例题一：分数字到两个数组"><a href="#例题一：分数字到两个数组" class="headerlink" title="例题一：分数字到两个数组"></a>例题一：<a href="https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/">分数字到两个数组</a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryIndexedTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryIndexedTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; tree.length) &#123;</span><br><span class="line">            tree[i]++;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] resultArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sortedNums = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            index.put(sortedNums[i], i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">0</span>]));</span><br><span class="line">        List&lt;Integer&gt; arr2 = <span class="keyword">new</span> ArrayList&lt;&gt;(List.of(nums[<span class="number">1</span>]));</span><br><span class="line">        BinaryIndexedTree tree1 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        BinaryIndexedTree tree2 = <span class="keyword">new</span> BinaryIndexedTree(n);</span><br><span class="line">        tree1.add(index.get(nums[<span class="number">0</span>]));</span><br><span class="line">        tree2.add(index.get(nums[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = arr1.size() - tree1.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">int</span> count2 = arr2.size() - tree2.get(index.get(nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr1.size() &lt;= arr2.size())) &#123;</span><br><span class="line">                arr1.add(nums[i]);</span><br><span class="line">                tree1.add(index.get(nums[i]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.add(nums[i]);</span><br><span class="line">                tree2.add(index.get(nums[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr1) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: arr2) &#123;</span><br><span class="line">            nums[i++] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/">https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/</a><br>[2] <a href="https://blog.csdn.net/qq_63786973/article/details/127416700">https://blog.csdn.net/qq_63786973/article/details/127416700</a><br>[3] <a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">https://www.cnblogs.com/Last--Whisper/p/13823614.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;快速计算任意连续子数组元素和的数据结构。&lt;/p&gt;
&lt;p&gt;树状数组或二元索引树（英语：Binary Indexed Tree），又以其发明者命名为&lt;br&gt;Fenwick树。最早由 PeterM.Fenwick于1994年以 《A New Data Structure for Cumulative Frequency Tables》为题发表在 《SOFTWARE PRACTICE AND EXPERIENCE》。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排列组合</title>
    <link href="http://silencezheng.top/2024/06/01/article129/"/>
    <id>http://silencezheng.top/2024/06/01/article129/</id>
    <published>2024-06-01T12:59:03.000Z</published>
    <updated>2024-08-23T17:06:48.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排列组合计算公式推导及代码实现。<br><span id="more"></span></p><h1 id="加法原理、乘法原理"><a href="#加法原理、乘法原理" class="headerlink" title="加法原理、乘法原理"></a>加法原理、乘法原理</h1><p><strong>分类计数原理</strong>：完成一件事情，存在$n$类方法，第1类有$m_1$种方式，第2类有$m_2$种方式，…，第$n$类有$m_n$种方式，则完成此事共有$N = m_1 + m_2 + … + m_n$种不同方法。 </p><p><strong>分步计数原理</strong>：若完成某事需经过$n$个步骤，第1步有$m_1$种方法，第2步有$m_2$种方法，…，第$n$步有$m_n$种方法，则总共有$N = m_1 \times m_2 \times \cdots \times m_n$种不同方法。</p><p><strong>区别</strong>：分类计数原理是加法规则，各类方法数相加求和；分步计数原理是乘法规则，各步骤方法数相乘得总数。</p><h1 id="排列（Arrangement）"><a href="#排列（Arrangement）" class="headerlink" title="排列（Arrangement）"></a>排列（Arrangement）</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>从$n$个不同元素中选取$m(m \leq n)$个元素的所有不同排列的个数，叫做从$n$个不同元素中选取$m$个元素的排列数，记作$\mathrm{A}_n^m$。 </p><h2 id="排列数公式"><a href="#排列数公式" class="headerlink" title="排列数公式"></a>排列数公式</h2><script type="math/tex; mode=display">\mathrm{A}_n^m = n(n-1)(n-2)\cdots(n-m+1) = \frac{n!}{(n-m)!}, \quad n, m \in \mathbb{N}^*, m \leq n</script><p>推导：从$n$个不同元素中选取$m$个元素进行排序，按计数原理分布进行，取第一个有$n$种取法，取第二个有$n-1$种取法…取第$m$个有$n-m+1$种取法，根据分步乘法原理推导出上式。</p><h2 id="排列数性质"><a href="#排列数性质" class="headerlink" title="排列数性质"></a>排列数性质</h2><ul><li>$\mathrm{A}_n^m = n\mathrm{A}_{n-1}^{m-1}$：为“某特定位置”先安排，再安排其余位置。</li><li>$\mathrm{A}_n^m = m\mathrm{A}_{n-1}^{m-1} + \mathrm{A}_{n-1}^m$：含特定元素的排列有$m\mathrm{A}_{n-1}^{m-1}$种，不含特定元素的排列有$\mathrm{A}_{n-1}^m$种。</li></ul><h1 id="组合（Combination）"><a href="#组合（Combination）" class="headerlink" title="组合（Combination）"></a>组合（Combination）</h1><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>从$n$个不同元素中选取$m$（$m \leq n$）个元素的所有不同组合的数目，称为从$n$个不同元素中取出$m$个元素的组合数，用符号$\mathrm{C}_n^m$表示。</p><h2 id="组合数公式"><a href="#组合数公式" class="headerlink" title="组合数公式"></a>组合数公式</h2><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!},\quad n,m\in \mathbb{N}^*,m\leq n</script><script type="math/tex; mode=display">\mathrm{C}_n^0=\mathrm{C}_n^n=1</script><p>证明：通过排列与组合的关系以及排列公式推导证明。</p><p>将排列问题$\mathrm{A}_n^m$分为两步：</p><ol><li><p><strong>第一步</strong>：从$n$个球中抽取$m$个，不考虑顺序，即组合问题$\mathrm{C}_n^m$；</p></li><li><p><strong>第二步</strong>：将抽出的$m$个球排序，即全排列$\mathrm{A}_m^m$。</p></li></ol><p>依据乘法原理，$\mathrm{A}_n^m=\mathrm{C}_n^m \mathrm{A}_m^m$，因此</p><script type="math/tex; mode=display">\mathrm{C}_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}</script><h2 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h2><ul><li>$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$：反转组合，未选的变选，选了的变未选，组合数相同。</li><li>递推公式$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$：含特定元素组合数为$\mathrm{C}_{n-1}^{m-1}$，不含特定元素组合数为$\mathrm{C}_{n-1}^m$。</li></ul><p><strong>示例</strong><br>令（$n=5$），($m=2$)。</p><p>从1，2，3，4，5中取出2个元素的组合$\mathrm{C}_n^m$：</p><p>12 13 14 15 23 24 25 34 35 45</p><p>这些组合要么含”1”，要么不含。</p><ul><li>含”1”的组合：12 13 14 15 → 挖去”1”得2 3 4 5 → 等价于从2，3，4，5中取出1个元素的组合。（此处m-1为1）</li><li>不含”1”的组合：23 24 25 34 35 45 → 等价于从2，3，4，5中取出2个元素的组合。（此处m为2）</li></ul><p>总方案数是上述两种情况的和，即$\mathrm{C}_n^m=\mathrm{C}_{n-1}^m+\mathrm{C}_{n-1}^{m-1}$。</p><h2 id="组合数求和公式"><a href="#组合数求和公式" class="headerlink" title="组合数求和公式"></a>组合数求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><p>直观理解：从$n$个球中抽取0到$n$个球的组合数之和。</p><p>严谨证明可采用数学归纳法：</p><ol><li>当$n=1$，$\mathrm{C}_1^0+\mathrm{C}_1^1=2=2$成立。</li><li>假设$n=k$时公式成立，$\sum_{i=0}^{k} \mathrm{C}_k^i=2^n$，则$n=k+1$时亦成立。</li><li>由1、2归纳得公式对所有$n\in \mathbb{N}^*$成立。</li></ol><p>或用二项式定理简证：</p><script type="math/tex; mode=display">(a+b)^n=\sum_{k=0}^{n}\mathrm{C}_n^k a^{n-k}b^k</script><p>设$a=b=1$，</p><script type="math/tex; mode=display">\sum_{i=0}^{n} \mathrm{C}_n^i=2^n</script><h3 id="相关公式"><a href="#相关公式" class="headerlink" title="相关公式"></a>相关公式</h3><p>由$\mathrm{C}_n^m = \mathrm{C}_n^{n-m}$推导：</p><script type="math/tex; mode=display">\mathrm{C}_n^0 + \mathrm{C}_n^2 + \mathrm{C}_n^4 + ... = \mathrm{C}_n^1 + \mathrm{C}_n^3 + \mathrm{C}_n^5 + ... =2^{n-1}</script><h2 id="Java：组合求和"><a href="#Java：组合求和" class="headerlink" title="Java：组合求和"></a>Java：组合求和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">factorialWithRecursion</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorialWithRecursion(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">combination</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> numerator = factorialWithRecursion(n);</span><br><span class="line">    <span class="keyword">long</span> denominator1 = factorialWithRecursion(m);</span><br><span class="line">    <span class="keyword">long</span> denominator2 = factorialWithRecursion(n-m);</span><br><span class="line">    <span class="keyword">return</span> numerator/(denominator1*denominator2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓展：组合数的加权求和公式"><a href="#拓展：组合数的加权求和公式" class="headerlink" title="拓展：组合数的加权求和公式"></a>拓展：组合数的加权求和公式</h2><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>通常被称为 <strong>组合数的加权求和公式</strong> 或者 <strong>组合数的加权和公式</strong>。这个公式用于计算组合数 $\binom{n}{i}$ 与下标 $i$ 的乘积之和。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>二项式系数</strong>：$\binom{n}{i}$ 是从 $n$ 个元素中选择 $i$ 个元素的不同方式的数量。</li><li><strong>二项式定理</strong>：$\sum_{i=0}^{n} \binom{n}{i} = 2^n$，表示所有二项式系数的和等于 $2^n$。</li></ul><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ol><li><strong>简化求和</strong>：从 $i=1$ 开始求和，因为 $i=0$ 时 $i \binom{n}{i} = 0$。</li><li><strong>利用组合数性质</strong>：$i \binom{n}{i} = n \binom{n-1}{i-1}$。</li><li><strong>改变求和变量</strong>：令 $j = i-1$，则 $i = j + 1$。</li><li><strong>利用二项式定理</strong>：$\sum_{j=0}^{n-1} \binom{n-1}{j} = 2^{n-1}$。</li></ol><p>最终得到公式：</p><script type="math/tex; mode=display">\sum_{i=0}^{n} i \binom{n}{i} = n \cdot 2^{n-1}</script><p>这个公式是组合数学中的一个重要结论，有助于快速计算组合数的加权求和。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://www.cnblogs.com/1024th/p/10623541.html">https://www.cnblogs.com/1024th/p/10623541.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;排列组合计算公式推导及代码实现。&lt;br&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://silencezheng.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-Plus之预定义CRUD</title>
    <link href="http://silencezheng.top/2024/03/24/article128/"/>
    <id>http://silencezheng.top/2024/03/24/article128/</id>
    <published>2024-03-24T08:54:43.000Z</published>
    <updated>2024-08-19T15:18:57.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>探究MyBatis Plus提供的预定义CRUD接口的实现方式。<br><span id="more"></span></p><h1 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h1><p>MBP提供两种包含预定义CRUD的接口：</p><ol><li><code>com.baomidou.mybatisplus.extension.service.IService</code></li><li><code>com.baomidou.mybatisplus.core.mapper.BaseMapper</code></li></ol><p>其中<code>IService</code>接口是针对业务逻辑层的封装，并提供了批处理操作。<code>BaseMapper</code>则是对DAO层CRUD的封装。</p><h1 id="BaseMapper"><a href="#BaseMapper" class="headerlink" title="BaseMapper"></a>BaseMapper</h1><p><code>BaseMapper</code>的接口规范很简单，看代码就能明白，重点是了解MBP如何实现的<code>BaseMapper</code>。</p><p>在使用MyBatis的情况下，我们定义了Mapper接口，然后会在对应的XML文件中提供动态SQL及映射关系，或者直接在Mapper接口方法上添加注解，MyBatis将XML中的配置或者注解作为元数据进行解析，然后将解析后的SQL语句存至<code>org.apache.ibatis.session.Configuration</code>。MBP在MyBatis的基础上只做增强不做改变，则只要能够实现原pipeline将元数据解析成动态SQL存至<code>org.apache.ibatis.session.Configuration</code>即可。</p><p>MyBatis Plus的整体思路是使用自己的组件替换MyBatis中的组件，以实现自定义的逻辑。其中<code>MybatisPlusAutoConfiguration</code>类替代了MyBatis的自动配置类，这个类中包含<code>MybatisPlusProperties</code>属性。<code>MybatisPlusProperties</code>包含<code>mapperLocations</code>字段用于解析Mapper XML文件的位置，并汇总为<code>Resource</code>数组。</p><p>在<code>MybatisPlusAutoConfiguration#sqlSessionFactory</code>函数中，包含XML位置的<code>Resource</code>数组被设置到<code>MybatisSqlSessionFactoryBean.mapperLocations</code>下（<code>MybatisSqlSessionFactoryBean</code>也是MBP替换组件）。而后在<code>MybatisSqlSessionFactoryBean#buildSqlSessionFactory</code>函数中，XML文件被逐个读取并解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">                    targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                xmlMapperBuilder.parse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">            LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>XMLMapperBuilder</code>在解析过程中会调用<code>XMLMapperBuilder#bindMapperForNamespace</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = <span class="keyword">this</span>.builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var4) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.configuration.hasMapper(boundType)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">            <span class="keyword">this</span>.configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的<code>configuration</code>为<code>MybatisSqlSessionFactoryBean</code>传入的<code>targetConfiguration</code>，即<code>MybatisConfiguration</code>（MBP替换组件）。此时<code>MybatisMapperRegistry#addMapper</code>调用<code>MybatisMapperRegistry#addMapper</code>方法。</p><p><code>MybatisMapperRegistry</code>也是一个MBP替换组件，继承并替换掉原本的<code>MapperRegistry</code>，其<code>addMapper</code>方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MybatisMapperProxyFactory(type));</span><br><span class="line">            MybatisMapperAnnotationBuilder parser = <span class="keyword">new</span> MybatisMapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                <span class="keyword">this</span>.knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用MBP自定义的<code>MybatisMapperAnnotationBuilder#parse</code>方法，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">        loadXmlResource();</span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">        String mapperName = type.getName();</span><br><span class="line">        assistant.setCurrentNamespace(mapperName);</span><br><span class="line">        parseCache();</span><br><span class="line">        parseCacheRef();</span><br><span class="line">        InterceptorIgnoreHelper.InterceptorIgnoreCache cache = InterceptorIgnoreHelper.initSqlParserInfoCache(type);</span><br><span class="line">        <span class="keyword">for</span> (Method method : type.getMethods()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canHaveStatement(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (getAnnotationWrapper(method, <span class="keyword">false</span>, Select.class, SelectProvider.class).isPresent()</span><br><span class="line">                &amp;&amp; method.getAnnotation(ResultMap.class) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                parseResultMap(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InterceptorIgnoreHelper.initSqlParserInfoCache(cache, mapperName, method);</span><br><span class="line">                parseStatement(method);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                configuration.addIncompleteMethod(<span class="keyword">new</span> MybatisMethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注入 CURD 动态 SQL</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (GlobalConfigUtils.isSupperMapperChildren(configuration, type)) &#123;</span><br><span class="line">                parserInjector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteMethod(<span class="keyword">new</span> InjectorResolver(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过全局缓存工具<code>GlobalConfigUtils</code>获取<code>ISqlInjector</code>实例，调用<code>ISqlInjector#inspectInject</code>方法进行CRUD方法注入。在实现上，实际上是由<code>AbstractSqlInjector</code>实现了<code>ISqlInjector</code>接口，然后又由<code>DefaultSqlInjector</code>继承<code>AbstractSqlInjector</code>实现最终注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSqlInjector</span> <span class="keyword">implements</span> <span class="title">ISqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspectInject</span><span class="params">(MapperBuilderAssistant builderAssistant, Class&lt;?&gt; mapperClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; modelClass = ReflectionKit.getSuperClassGenericType(mapperClass, Mapper.class, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (modelClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String className = mapperClass.toString();</span><br><span class="line">            Set&lt;String&gt; mapperRegistryCache = GlobalConfigUtils.getMapperRegistryCache(builderAssistant.getConfiguration());</span><br><span class="line">            <span class="keyword">if</span> (!mapperRegistryCache.contains(className)) &#123;</span><br><span class="line">                TableInfo tableInfo = TableInfoHelper.initTableInfo(builderAssistant, modelClass);</span><br><span class="line">                List&lt;AbstractMethod&gt; methodList = <span class="keyword">this</span>.getMethodList(mapperClass, tableInfo);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    <span class="comment">// 循环注入自定义方法</span></span><br><span class="line">                    methodList.forEach(m -&gt; m.inject(builderAssistant, mapperClass, modelClass, tableInfo));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.debug(mapperClass.toString() + <span class="string">&quot;, No effective injection method was found.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapperRegistryCache.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取 注入的方法</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapperClass 当前mapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入的方法集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.1.2 add  mapperClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass,TableInfo tableInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSqlInjector</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlInjector</span> <span class="keyword">extends</span> <span class="title">AbstractSqlInjector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractMethod&gt; <span class="title">getMethodList</span><span class="params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tableInfo.havePK()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> DeleteById(),</span><br><span class="line">                <span class="keyword">new</span> DeleteBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> UpdateById(),</span><br><span class="line">                <span class="keyword">new</span> SelectById(),</span><br><span class="line">                <span class="keyword">new</span> SelectBatchByIds(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(String.format(<span class="string">&quot;%s ,Not found @TableId annotation, Cannot use Mybatis-Plus &#x27;xxById&#x27; Method.&quot;</span>,</span><br><span class="line">                tableInfo.getEntityType()));</span><br><span class="line">            <span class="keyword">return</span> Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Insert(),</span><br><span class="line">                <span class="keyword">new</span> Delete(),</span><br><span class="line">                <span class="keyword">new</span> DeleteByMap(),</span><br><span class="line">                <span class="keyword">new</span> Update(),</span><br><span class="line">                <span class="keyword">new</span> SelectByMap(),</span><br><span class="line">                <span class="keyword">new</span> SelectCount(),</span><br><span class="line">                <span class="keyword">new</span> SelectMaps(),</span><br><span class="line">                <span class="keyword">new</span> SelectMapsPage(),</span><br><span class="line">                <span class="keyword">new</span> SelectObjs(),</span><br><span class="line">                <span class="keyword">new</span> SelectList(),</span><br><span class="line">                <span class="keyword">new</span> SelectPage()</span><br><span class="line">            ).collect(toList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每一个函数都是继承了<code>com.baomidou.mybatisplus.core.injector.AbstractMethod</code>的类，包含一个<code>inject</code>注入方法。</p><h1 id="IService"><a href="#IService" class="headerlink" title="IService"></a>IService</h1><p><code>IService</code>的实现在<code>com.baomidou.mybatisplus.extension.service.impl.ServiceImpl</code>。</p><p><code>IService</code>依赖于Spring容器，而<code>BaseMapper</code>不依赖，原因是<code>IService</code>实例中会注入一个<code>BaseMapper</code>实例用于做CRUD操作，也就是上面的那一套。</p><p><code>IService</code>还支持批量操作，这部分源码比较好看，调用链路是：<code>com.baomidou.mybatisplus.extension.toolkit.SqlHelper#executeBatch -&gt; org.apache.ibatis.session#flushStatements</code></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://blog.csdn.net/wjw465150/article/details/126896276">https://blog.csdn.net/wjw465150/article/details/126896276</a><br>[2] <a href="https://blog.csdn.net/zzuhkp/article/details/120174101">https://blog.csdn.net/zzuhkp/article/details/120174101</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;探究MyBatis Plus提供的预定义CRUD接口的实现方式。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="MyBatis" scheme="http://silencezheng.top/tags/MyBatis/"/>
    
    <category term="源码阅读" scheme="http://silencezheng.top/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>回归问题指标计算</title>
    <link href="http://silencezheng.top/2024/03/10/article127/"/>
    <id>http://silencezheng.top/2024/03/10/article127/</id>
    <published>2024-03-10T10:56:26.000Z</published>
    <updated>2024-05-01T17:34:10.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回归问题指标计算入门。<br><span id="more"></span></p><h1 id="RSE-Relative-Squared-Error"><a href="#RSE-Relative-Squared-Error" class="headerlink" title="RSE (Relative Squared Error)"></a><strong>RSE (Relative Squared Error)</strong></h1><p>相对平方误差是预测值与实际值之间的平方差与实际值的平方差的比率。计算公式如下：</p><script type="math/tex; mode=display">RSE = \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}</script><p>其中，$ y_i $ 是第 $ i $ 个观测值，$ \hat{y}_i $ 是对应的预测值，$ \bar{y} $ 是观测值的均值，$ n $ 是样本数量。</p><h1 id="RAE-Relative-Absolute-Error"><a href="#RAE-Relative-Absolute-Error" class="headerlink" title="RAE (Relative Absolute Error)"></a><strong>RAE (Relative Absolute Error)</strong></h1><p>相对绝对误差是预测值与实际值之间的绝对差与实际值的绝对差的比率。计算公式如下：</p><script type="math/tex; mode=display">RAE = \frac{\sum_{i=1}^{n} |y_i - \hat{y}_i|}{\sum_{i=1}^{n} |y_i - \bar{y}|}</script><h1 id="MSE-Mean-Squared-Error"><a href="#MSE-Mean-Squared-Error" class="headerlink" title="MSE (Mean Squared Error)"></a><strong>MSE (Mean Squared Error)</strong></h1><p>均方误差是预测值与实际值之间的平方差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MSE = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2</script><h1 id="RMSE-Root-Mean-Squared-Error"><a href="#RMSE-Root-Mean-Squared-Error" class="headerlink" title="RMSE (Root Mean Squared Error)"></a><strong>RMSE (Root Mean Squared Error)</strong></h1><p>均方根误差是均方误差的平方根，它提供了预测误差的标准化度量。计算公式如下：</p><script type="math/tex; mode=display">RMSE = \sqrt{MSE}</script><h1 id="MAE-Mean-Absolute-Error"><a href="#MAE-Mean-Absolute-Error" class="headerlink" title="MAE (Mean Absolute Error)"></a><strong>MAE (Mean Absolute Error)</strong></h1><p>平均绝对误差是一种常用的回归问题评价指标，用于衡量预测值与真实值之间的偏差程度。它的计算基于所有预测值与对应真实值之间绝对误差的平均值，因此对所有个体错误给予相同权重，不考虑误差的方向，只关注其大小。MAE的计算公式如下：</p><script type="math/tex; mode=display">\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|</script><p>其中：</p><ul><li>$n$ 表示样本的数量。</li><li>$y_i$ 表示第 $ i $ 个样本的真实值。</li><li>$ \hat{y}_i $ 表示第 $ i $ 个样本的预测值。</li><li>$ | \cdot | $ 表示绝对值函数，确保误差值为非负。</li></ul><h1 id="MAPE-Mean-Absolute-Percentage-Error"><a href="#MAPE-Mean-Absolute-Percentage-Error" class="headerlink" title="MAPE (Mean Absolute Percentage Error)"></a><strong>MAPE (Mean Absolute Percentage Error)</strong></h1><p>平均绝对百分比误差是预测值与实际值之间的绝对百分比误差的平均值。计算公式如下：</p><script type="math/tex; mode=display">MAPE = \frac{100}{n} \sum_{i=1}^{n} \left| \frac{y_i - \hat{y}_i}{y_i} \right|</script><h1 id="Correlation-Pearson-Correlation-Coefficient"><a href="#Correlation-Pearson-Correlation-Coefficient" class="headerlink" title="Correlation (Pearson Correlation Coefficient)"></a><strong>Correlation (Pearson Correlation Coefficient)</strong></h1><p>相关系数衡量了预测值与实际值之间的线性关系强度和方向。计算公式如下：</p><script type="math/tex; mode=display">\text{Correlation} = \frac{\sum_{i=1}^{n} (y_i - \bar{y})(\hat{y}_i - \bar{\hat{y}})}{\sqrt{\sum_{i=1}^{n} (y_i - \bar{y})^2 \sum_{i=1}^{n} (\hat{y}_i - \bar{\hat{y}})^2}}</script><p>其中，$ \bar{y} $ 和 $ \bar{\hat{y}} $ 分别是观测值和预测值的均值。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;回归问题指标计算入门。&lt;br&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://silencezheng.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发体验</title>
    <link href="http://silencezheng.top/2024/02/08/article126/"/>
    <id>http://silencezheng.top/2024/02/08/article126/</id>
    <published>2024-02-07T18:40:36.000Z</published>
    <updated>2024-02-07T18:44:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。</p><p>但在做课题调研时我习惯使用<code>[n]</code>作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫<code>Reference Extension</code>吧。<br><span id="more"></span></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>0、更新npm、cnpm：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install 18</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装cnpm</span></span><br><span class="line">npm install -g cnpm -registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>1、安装 Yeoman 和 VS Code Extension Generator：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g yo generator-code</span><br></pre></td></tr></table></figure></p><p>2、创建一个新的插件项目<code>Reference Extension</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yo code</span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Reference Extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? reference-extension</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? Literature Citation Extension</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? Yes</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? npm</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> reference-extension</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>主要实现两个功能：</p><ol><li><code>[n]</code>格式索引增加项时自动递增（实际只实现了一部分）。</li><li><code>[n]</code>格式索引重新索引，包含删除项与增加项（实际只实现了一部分）。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 VSCode 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活插件的入口函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册命令：自动递增索引</span></span><br><span class="line">    <span class="keyword">let</span> disposableAutoIncrement = vscode.commands.registerTextEditorCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前光标位置</span></span><br><span class="line">            <span class="keyword">const</span> currentPosition = editor.selection.active;</span><br><span class="line">            <span class="keyword">const</span> currentLine = currentPosition.line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前行的文本内容，并匹配是否以 [n] 格式结尾</span></span><br><span class="line">            <span class="keyword">const</span> currentLineText = editor.document.lineAt(currentLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = currentLineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                <span class="comment">// 获取匹配到的数字，并计算下一个数字</span></span><br><span class="line">                <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">const</span> nextNumber = currentNumber + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自增逻辑</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// TODO： 这段有问题，要修改，而且还是没有做到回车前触发。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = currentLine + <span class="number">1</span>; line &lt; editor.document.lineCount; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> matchBelow = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (matchBelow) &#123;</span><br><span class="line">                            <span class="keyword">const</span> currentNumberBelow = <span class="built_in">parseInt</span>(matchBelow[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndexBelow = currentNumberBelow + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 替换下方方括号中的数字</span></span><br><span class="line">                            <span class="keyword">const</span> startPosBelow = <span class="keyword">new</span> vscode.Position(line, <span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">const</span> endPosBelow = <span class="keyword">new</span> vscode.Position(line, matchBelow[<span class="number">0</span>].length);</span><br><span class="line">                            editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPosBelow, endPosBelow), <span class="string">`[<span class="subst">$&#123;newIndexBelow&#125;</span>] <span class="subst">$&#123;matchBelow[<span class="number">2</span>]&#125;</span>`</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果下方没有符合 [n] 格式索引的项，结束循环</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> newPosition = <span class="keyword">new</span> vscode.Position(currentLine + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    editBuilder.insert(newPosition, <span class="string">`[<span class="subst">$&#123;nextNumber&#125;</span>] `</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册命令：重新索引所有行的方括号</span></span><br><span class="line">    <span class="comment">// TODO：实际上只实现了删除一个索引时将下方索引都自动减1</span></span><br><span class="line">    <span class="keyword">let</span> disposableReindex = vscode.commands.registerCommand(<span class="string">&#x27;rext.reindex&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前活动的文本编辑器</span></span><br><span class="line">        <span class="keyword">const</span> editor = vscode.window.activeTextEditor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (editor) &#123;</span><br><span class="line">            <span class="comment">// 获取当前行的行号</span></span><br><span class="line">            <span class="keyword">const</span> currentLine = editor.selection.active.line;</span><br><span class="line">            <span class="keyword">const</span> startLine = currentLine;</span><br><span class="line">            <span class="keyword">const</span> endLine = editor.document.lineCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义当前列表的索引</span></span><br><span class="line">            <span class="keyword">let</span> currentListIndex: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：匹配一下</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 查找当前列表的索引</span></span><br><span class="line">            <span class="keyword">const</span> lineText = editor.document.lineAt(startLine).text;</span><br><span class="line">            <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                currentListIndex = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TEMP：自动减1</span></span><br><span class="line">            <span class="keyword">if</span> (currentListIndex !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="comment">// TODO：重新索引列表中的方括号数字</span></span><br><span class="line">                editor.edit(<span class="function"><span class="params">editBuilder</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> line = startLine; line &lt; endLine; line++) &#123;</span><br><span class="line">                        <span class="keyword">const</span> lineText = editor.document.lineAt(line).text;</span><br><span class="line">                        <span class="keyword">const</span> match = lineText.match(<span class="regexp">/\[(\d+)\]\s+(.*)/</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                            <span class="comment">// 获取当前方括号中的数字和新索引</span></span><br><span class="line">                            <span class="keyword">const</span> currentNumber = <span class="built_in">parseInt</span>(match[<span class="number">1</span>]);</span><br><span class="line">                            <span class="keyword">const</span> newIndex = currentNumber - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果当前数字不等于新索引，替换方括号中的数字</span></span><br><span class="line">                            <span class="keyword">if</span> (currentNumber !== newIndex) &#123;</span><br><span class="line">                                <span class="keyword">const</span> startPos = <span class="keyword">new</span> vscode.Position(line, match.index!);</span><br><span class="line">                                <span class="keyword">const</span> endPos = <span class="keyword">new</span> vscode.Position(line, match.index! + match[<span class="number">0</span>].length);</span><br><span class="line">                                editBuilder.replace(<span class="keyword">new</span> vscode.Range(startPos, endPos), <span class="string">`[<span class="subst">$&#123;newIndex&#125;</span>] `</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听文档内容变化事件</span></span><br><span class="line">    vscode.workspace.onDidChangeTextDocument(<span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.document.languageId === <span class="string">&#x27;markdown&#x27;</span> &amp;&amp; event.document.fileName.endsWith(<span class="string">&#x27;.md&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> range = event.contentChanges[<span class="number">0</span>].range;</span><br><span class="line">            <span class="comment">// 检查是否按下了回车键</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.autoIncrement&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否删除了某一行</span></span><br><span class="line">            <span class="keyword">if</span> (event.contentChanges[<span class="number">0</span>].text === <span class="string">&#x27;&#x27;</span> &amp;&amp; range.start.line !== range.end.line) &#123;</span><br><span class="line">                vscode.commands.executeCommand(<span class="string">&#x27;rext.reindex&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令注册到上下文订阅中，确保插件在激活期间有效</span></span><br><span class="line">    context.subscriptions.push(disposableAutoIncrement, disposableReindex);</span><br><span class="line"></span><br><span class="line">    process.stdout.write(<span class="string">&#x27;Debugging message\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件被停用时调用的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这代码写的很糙，只实现了部分功能，但是也确实没时间去学<code>markdown-it</code>的插件实现了，以后再去实现吧（正常来说我要实现的东西通过<code>markdown-it</code>自定义插件插入的形式实现更方便…在插件上写插件😂）。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>项目F5进行调试，创建一个Markdown文件，写入对应情景内容，别忘了在<code>package.json</code>中设置触发条件。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>要想发布插件到市场，需要创建在Azure DevOps上创建个人访问令牌，如果没有组织则需要先创建组织。可以用GitHub账户登陆Azure DevOps创建组织，比如<code>dev.azure.com/SilenceZheng66</code>。</p><p>然后创建项目，在项目中创建PAT（Personal Access Tokens）并记住它。下面需要在<a href="https://marketplace.visualstudio.com/manage/createpublisher">Visual Studio Marketplace</a>创建一个publisher，这里需要注意的是这里必须使用刚才创建个人访问令牌的微软账号，这里的publisher需要和package.json里的publisher字段一致。</p><p>准备就绪后，下载<code>vsce</code>，用来打包/发布/管理插件的命令行工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g vsce</span><br></pre></td></tr></table></figure><p>执行发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">vsce login SilenceZheng66</span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">vsce publish --no-dependencies</span><br></pre></td></tr></table></figure><p>使用webpack打包插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cnpm i --save-dev webpack webpack-cli ts-loader</span><br><span class="line"></span><br><span class="line"><span class="comment"># package.json 脚本如下：</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;vscode:prepublish&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>,</span><br><span class="line"><span class="string">&quot;compile&quot;</span>: <span class="string">&quot;webpack --mode none&quot;</span>,</span><br><span class="line"><span class="string">&quot;watch&quot;</span>: <span class="string">&quot;webpack --mode none --watch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html">https://rackar.github.io/vscode-ext-doccn/get-started/your-first-extension.html</a><br>[2] <a href="https://github.com/yzhang-gh/vscode-markdown">https://github.com/yzhang-gh/vscode-markdown</a><br>[3] <a href="https://juejin.cn/post/7327570230775201826">https://juejin.cn/post/7327570230775201826</a><br>[4] <a href="https://zhuanlan.zhihu.com/p/459554765">https://zhuanlan.zhihu.com/p/459554765</a><br>[5] <a href="https://juejin.cn/post/6844903921555603470">https://juejin.cn/post/6844903921555603470</a><br>[6] <a href="https://markdown-it.github.io">https://markdown-it.github.io</a><br>[7] <a href="https://juejin.cn/post/7076649162653040647">https://juejin.cn/post/7076649162653040647</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;VS Code是我的主力文字编辑器，目前我的所有博客与课题调研工作都是使用它进行编辑的。Markdown格式也是我最喜欢的文本格式，它让我可以快速整理想法而仅仅考虑基本的格式。&lt;/p&gt;
&lt;p&gt;但在做课题调研时我习惯使用&lt;code&gt;[n]&lt;/code&gt;作为参考文献序号，VS Code不能对这种序号进行自动递增和重新索引，于是我想开发一款插件实现这两个功能，插件的名字就叫&lt;code&gt;Reference Extension&lt;/code&gt;吧。&lt;br&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://silencezheng.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>SpEL使用入门</title>
    <link href="http://silencezheng.top/2023/12/30/article125/"/>
    <id>http://silencezheng.top/2023/12/30/article125/</id>
    <published>2023-12-29T17:00:25.000Z</published>
    <updated>2023-12-29T17:02:59.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。</p><p>SpEL是单独模块（<code>org.springframework.expression</code>），只依赖于core模块，不依赖于其他模块，可以单独使用。<br><span id="more"></span></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>首先从一个简单的“literal string expression”例子引入，所谓“literal string”就是指代码中直接使用双引号括起来的字符串（起码在Java下是这样）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先创建了解析器<code>ExpressionParser</code>，负责解析表达式字符串，表达式字符串是由周围的单引号表示的字符串字面量。而后解析表达式，<code>Expression</code>接口负责评估所定义的表达式字符串。最后对表达式进行求值，获取信息。</p><p>通过这一流程可以总结SpEL在求表达式值时的一般步骤：</p><ol><li>创建解析器</li><li>解析表达式</li><li>构造上下文</li><li>表达式求值</li></ol><p>其中第三步构造上下文是一个可选步骤，当需要准备上下文变量时会使用。</p><p>PS：在调用 <code>parser.parseExpression</code> 和 <code>exp.getValue</code> 时，可能分别抛出两个异常：<code>ParseException</code> 和 <code>EvaluationException</code>。<br>PPS：Evaluate可以理解为“求值”或“计算”。</p><h2 id="一些功能"><a href="#一些功能" class="headerlink" title="一些功能"></a>一些功能</h2><p>SpEL支持多种功能，如调用方法、访问属性和调用构造函数，这里用一个例子快速过一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用concat方法</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);</span><br><span class="line">String message = (String) exp.getValue();  <span class="comment">// Hello World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问属性，invokes &#x27;getBytes()&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问嵌套属性，invokes &#x27;getBytes().length&#x27;</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes.length&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> length = (Integer) exp.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;new String(&#x27;hello world&#x27;).toUpperCase()&quot;</span>);</span><br><span class="line">String message = exp.getValue(String.class); <span class="comment">// HELLO WORLD</span></span><br></pre></td></tr></table></figure><h2 id="更常见的用法"><a href="#更常见的用法" class="headerlink" title="更常见的用法"></a>更常见的用法</h2><p>SpEL更常见的用法是提供一个表达式字符串，针对特定对象实例（称为根对象）进行求值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并设置一个日历对象</span></span><br><span class="line">GregorianCalendar c = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">c.set(<span class="number">1856</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数参数分别为name, birthday, nationality</span></span><br><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, c.getTime(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>); <span class="comment">// 将&quot;name&quot;解析为表达式</span></span><br><span class="line">String name = (String) exp.getValue(tesla);</span><br><span class="line"><span class="comment">// name == &quot;Nikola Tesla&quot;</span></span><br></pre></td></tr></table></figure><h2 id="全部语法"><a href="#全部语法" class="headerlink" title="全部语法"></a>全部语法</h2><p>关于如何编写正确的表达式，可以参见 <a href="https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html">https://docs.spring.io/spring-framework/reference/core/expressions/language-ref.html</a></p><h1 id="EvaluationContext（求值上下文）"><a href="#EvaluationContext（求值上下文）" class="headerlink" title="EvaluationContext（求值上下文）"></a>EvaluationContext（求值上下文）</h1><p><code>EvaluationContext</code>接口用于计算表达式，以解析属性、方法或字段，并帮助执行类型转换。Spring 提供了两种实现：</p><ul><li><p><code>SimpleEvaluationContext</code>：该接口公开了基本 SpEL 功能和配置选项的子集，适用于不需要完整 SpEL 语言语法且应受到有意义限制的表达式类别，包括但不限于数据绑定表达式和基于属性的过滤器。</p></li><li><p><code>StandardEvaluationContext</code>：提供全套 SpEL 功能和配置选项，可以用它来指定默认根对象，并配置所有可用的求值相关策略。</p></li></ul><p><code>SimpleEvaluationContext</code> 只支持 SpEL 语法的一个子集。它不包括 Java 类型引用、构造函数和 Bean 引用。它还要求使用者明确选择对表达式中属性和方法的支持级别，默认情况下，<code>create()</code>静态工厂方法只能对属性进行读取访问。用户还可以获取一个构建器来配置所需的特定支持级别，针对以下一种或几种组合：</p><ul><li>Custom PropertyAccessor only (no reflection)</li><li>Data binding properties for read-only access</li><li>Data binding properties for read and write</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>默认情况下，SpEL 使用 Spring core 中的转换服务（org.springframework.core.convert.ConversionService）。该转换服务为常见转换提供了许多内置转换器，但也具有完全可扩展性，因此您可以在类型间添加自定义转换。此外，它还具有泛型感知功能。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换，以保持遇到的任何对象的类型正确性。</p><p>举个例子，假设使用 <code>setValue()</code> 进行赋值是为了设置 List 属性。该属性的类型实际上是 <code>List&lt;Boolean&gt;</code>。SpEL会识别到在将列表元素放入其中之前，需要将其转换为布尔值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Boolean&gt; booleanList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">simple.booleanList.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;false&quot; is passed in here as a String. SpEL and the conversion service</span></span><br><span class="line"><span class="comment">// will recognize that it needs to be a Boolean and convert it accordingly.</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;booleanList[0]&quot;</span>).setValue(context, simple, <span class="string">&quot;false&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b is false</span></span><br><span class="line">Boolean b = simple.booleanList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h1><p>可以使用解析器配置对象（org.springframework.expression.spel.SpelParserConfiguration）来配置 SpEL 表达式解析器，该配置对象可控制某些表达式组件的行为。例如，在对数组或集合进行索引时，指定索引处的元素为空，SpEL 会自动创建该元素。这在使用由一连串属性引用组成的表达式时非常有用。如果用户对数组或列表进行索引，并指定一个超出数组或列表当前大小的索引，SpEL 可以自动增长数组或列表以容纳该索引。为了在指定的索引处添加元素，SpEL 将尝试使用元素类型的默认构造函数创建元素，然后再设置指定的值。如果元素类型没有默认构造函数，则会将空值添加到数组或列表中。如果没有转换器（内置或自定义的）知道如何设置值，空值将保留在数组或列表的指定索引处。</p><p>下面的示例演示了如何自动增长列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn on:</span></span><br><span class="line"><span class="comment">// - auto null reference initialization</span></span><br><span class="line"><span class="comment">// - auto collection growing</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">&quot;list[3]&quot;</span>);</span><br><span class="line"></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">Object o = expression.getValue(demo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.list will now be a real collection of 4 entries</span></span><br><span class="line"><span class="comment">// Each entry is a new empty String</span></span><br></pre></td></tr></table></figure><h1 id="表达式编译（提升求值速度）"><a href="#表达式编译（提升求值速度）" class="headerlink" title="表达式编译（提升求值速度）"></a>表达式编译（提升求值速度）</h1><p>Spring Framework 4.1 包含一个基本的表达式编译器。表达式通常是<strong>解释型</strong>的，这在求值过程中提供了很大的动态灵活性，但无法提供最佳性能。对于偶尔使用表达式的情况，这并无大碍，但当其他组件（如 Spring Integration）使用表达式时，性能可能会变得非常重要，而且对动态性也没有真正的需求。</p><p>SpEL 编译器旨在满足这一需求。在评估过程中，编译器会生成一个 Java 类，在运行时体现表达式的行为，并使用该类实现更快的表达式求值。由于缺乏围绕表达式的类型，编译器在执行编译时会使用在表达式的解释求值过程中收集到的信息。例如，编译器并不能纯粹从表达式中知道属性引用的类型，但在第一次解释求值时，编译器就能知道它是什么类型。当然，如果各种表达式元素的类型随着时间的推移而发生变化，那么根据这些派生信息进行编译就会带来麻烦。因此，编译最适合类型信息不会在重复求值时发生变化的表达式。</p><p>例如对于基本表达式<code>someArray[0].someProperty.someOtherProperty &lt; 0.1</code>来说，由于涉及数组访问、一些属性去引用和数值操作，因此性能提升非常明显。在一个迭代 50000 次的微型基准运行示例中，使用解释器求值需要 75 毫秒，而使用该表达式的编译版本仅需 3 毫秒。</p><h2 id="编译器配置"><a href="#编译器配置" class="headerlink" title="编译器配置"></a>编译器配置</h2><p>编译器默认情况下是不开启的，可以通过两种不同的方式开启它。</p><ol><li>通过使用解析器配置过程打开</li><li>在将SpEL嵌入到其他组件中时，还可以使用Spring属性来打开</li></ol><p>编译器可以在三种模式下运行，这些模式在 org.springframework.expression.spel.SpelCompilerMode 枚举中：</p><ul><li><code>OFF</code> (默认)：编译器关闭。</li><li><code>IMMEDIATE</code>：在立即模式下，表达式会尽快编译。通常是在第一次解释求值之后。如果编译表达式失败（通常是由于类型改变），表达式求值的调用者将收到异常。</li><li><code>MIXED</code>：在混合模式下，表达式会随着时间的推移在解释模式和编译模式之间默默切换。经过一定次数的解释运行后，它们会切换到编译形式，如果编译形式出了问题（如前面所述的类型改变），表达式会自动再次切换回解释形式。之后，它可能会生成另一个编译形式并切换到它。基本上，用户在 <code>IMMEDIATE</code> 模式下获得的异常会在内部处理。</li></ul><p><code>IMMEDIATE</code> 模式之所以存在，是因为 <code>MIXED</code> 模式可能会给有副作用的表达式造成问题。如果一个编译表达式在部分成功后崩溃，那么它可能已经执行了影响系统状态的操作。如果发生了这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能会运行两次。</p><p>选择模式后，使用 <code>SpelParserConfiguration</code> 配置解析器。下面的示例演示了如何进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,</span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"></span><br><span class="line">Expression expr = parser.parseExpression(<span class="string">&quot;payload&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyMessage message = <span class="keyword">new</span> MyMessage();</span><br><span class="line"></span><br><span class="line">Object payload = expr.getValue(message);</span><br></pre></td></tr></table></figure><p>在指定编译器模式时，还可以指定一个类加载器（允许传递空值）。编译后的表达式将定义在一个子类加载器中，该类加载器将根据所提供的任何类型创建。重要的是，如果指定了类加载器，要确保它能看到表达式求值过程中涉及的所有类型。如果未指定类加载器，则会使用默认类加载器（通常是表达式求值过程中运行线程的上下文类加载器）。</p><p>配置编译器的第二种方法适用于 SpEL 嵌入其他组件的情况，这种情况下可能无法通过配置对象进行配置。在这种情况下，可以通过 JVM 系统属性（或 SpringProperties 机制）将 <code>spring.expression.compiler.mode</code> 属性设置为<code>SpelCompilerMode</code>枚举值。</p><h2 id="编译器的局限性"><a href="#编译器的局限性" class="headerlink" title="编译器的局限性"></a>编译器的局限性</h2><p>自 Spring Framework 4.1 以来，基本的编译框架已经到位。不过，该框架还不支持编译所有类型的表达式。最初的重点是可能在性能关键型上下文中使用的常见表达式。以下几种表达式暂时无法编译：</p><ul><li>涉及赋值的表达式</li><li>依赖转换服务的表达式</li><li>使用自定义解析器或访问器的表达式</li><li>使用选择或投影的表达式</li></ul><h1 id="使用SpEL定义Bean"><a href="#使用SpEL定义Bean" class="headerlink" title="使用SpEL定义Bean"></a>使用SpEL定义Bean</h1><p>用户可以在基于XML或注解的配置元数据中使用SpEL表达式来定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法形式为<code>#&#123; &lt;expression string&gt; &#125;</code>。这里忽略XML配置方式，用的不多了。</p><h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>要指定默认值，可在字段、方法、方法或构造函数参数上添加<code>@Value</code>注解。</p><p>1、设置一个字段的默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> <span class="comment">// 读取的是服务部署机器的region</span></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、注入属性set方法默认值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValueTestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultLocale</span><span class="params">(String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDefaultLocale</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过这种方式，当Spring容器创建 <code>PropertyValueTestBean</code> 对象时，它将调用 <code>setDefaultLocale</code> 方法并传入系统属性中 ‘user.region’ 对应的值，从而设置 <code>defaultLocale</code> 成员变量的值。</p><p>3、<code>@Autowired</code>和构造函数也可以使用 <code>@Value</code> 注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(MovieFinder movieFinder,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123; systemProperties[&#x27;user.region&#x27;] &#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Case2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String defaultLocale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;user.country&#x27;]&#125;&quot;)</span> String defaultLocale)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line"><span class="keyword">this</span>.defaultLocale = defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h1><p>一些值得关注的功能…</p><h2 id="ClassType表达式"><a href="#ClassType表达式" class="headerlink" title="ClassType表达式"></a>ClassType表达式</h2><p>使用<code>T(Type)</code>来表示<code>java.lang.Class</code>实例，<code>Type</code>必须是类全限定名（<code>java.lang</code>包下的类除外）。使用ClassType表达式还可以访问类静态方法及类静态字段。</p><p>下面的例子展示了如何使用ClassType表达式和如何进行条件判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang包内的不需要使用全限定名</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(String)&quot;</span>).getValue(Class.class);</span><br><span class="line"><span class="comment">// 类静态字段访问</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;T(Integer).MAX_VALUE&quot;</span>).getValue(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">// 类静态方法调用</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;#&#123;T(java.lang.Math).random() * 100.0&#125;&quot;</span>, ParserContext.TEMPLATE_EXPRESSION).getValue(Double.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件判断：</span></span><br><span class="line"><span class="comment">// 算数运算表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;1 + 1&quot;</span>).getValue(Integer.class);</span><br><span class="line"><span class="comment">// 关系表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2==2&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 逻辑表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;2&gt;1 and (NOT true or NOT false)&quot;</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="comment">// instanceof表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;xyz&#x27; instanceof T(Integer)&quot;</span>).getValue(Boolean.class);</span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line">parser.parseExpression(<span class="string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);</span><br></pre></td></tr></table></figure></p><h2 id="函数、对象、变量的定义及引用"><a href="#函数、对象、变量的定义及引用" class="headerlink" title="函数、对象、变量的定义及引用"></a>函数、对象、变量的定义及引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        StringBuilder backwards = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            backwards.append(input.charAt(input.length() - <span class="number">1</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backwards.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        context.setVariable(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;路人甲java&quot;</span>);</span><br><span class="line">        context.setVariable(<span class="string">&quot;lesson&quot;</span>, <span class="string">&quot;Spring系列&quot;</span>);</span><br><span class="line">        <span class="comment">//获取name变量，lesson变量</span></span><br><span class="line">        String name = parser.parseExpression(<span class="string">&quot;#name&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(name);</span><br><span class="line">        String lesson = parser.parseExpression(<span class="string">&quot;#lesson&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(lesson);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义对象</span></span><br><span class="line">        <span class="comment">// StandardEvaluationContext构造器传入root对象，可以通过#root来访问root对象</span></span><br><span class="line">        context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">&quot;我是root对象&quot;</span>);</span><br><span class="line">        String rootObj = parser.parseExpression(<span class="string">&quot;#root&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(rootObj);</span><br><span class="line">        <span class="comment">// #this用来访问当前上下文中的对象</span></span><br><span class="line">        String thisObj = parser.parseExpression(<span class="string">&quot;#this&quot;</span>).getValue(context, String.class);</span><br><span class="line">        log.info(thisObj);</span><br><span class="line">        <span class="comment">// 定义List对象，过滤List并做投影运算</span></span><br><span class="line">        List&lt;Integer&gt; primes = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>));</span><br><span class="line">        context.setVariable(<span class="string">&quot;primes&quot;</span>, primes);  <span class="comment">// 注册对象变量</span></span><br><span class="line">        List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(<span class="string">&quot;#primes.?[#this&gt;10]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(primesGreaterThanTen.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义方法</span></span><br><span class="line">        context.registerFunction(<span class="string">&quot;reverseString&quot;</span>, SpELTest.class.getDeclaredMethod(<span class="string">&quot;reverseString&quot;</span>, String.class));</span><br><span class="line">        log.info(parser.parseExpression(<span class="string">&quot;#reverseString(&#x27;hello&#x27;)&quot;</span>).getValue(context, String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><p>SpEL引入了Groovy语言中的安全导航运算符<code>(对象|属性)?.属性</code>，用来避免<code>?.</code>前边的表达式为null时抛出空指针异常，转而返回null。还可以使用<code>?:</code>选择在表达式为null时返回默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="keyword">new</span> Date(), <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(tesla);</span><br><span class="line">tesla.setName(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// null时取默认值</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?:&#x27;Unknown&#x27;&quot;</span>).getValue(context, String.class));</span><br><span class="line"><span class="comment">// null时安全调用</span></span><br><span class="line">log.info(parser.parseExpression(<span class="string">&quot;name?.length()&quot;</span>).getValue(context, Integer.class).toString());</span><br></pre></td></tr></table></figure><h2 id="List运算"><a href="#List运算" class="headerlink" title="List运算"></a>List运算</h2><p>在 SpEL 中，<code>?[]</code> 和 <code>![]</code> 分别表示集合选择（collection selection）和集合投影（collection projection）。<code>?[]</code> 表达式用于选择满足指定条件的集合元素，<code>![]</code> 表达式用于对集合进行投影操作。</p><blockquote><p>集合投影或集合映射的基本思想是：通过对集合中的每个元素应用一个表达式，生成一个新的集合，该集合包含了原始集合中的元素经过某种转换后的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// author: SilenceZheng66</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELCollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inventor</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String nationality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inventor tesla = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla&quot;</span>, <span class="string">&quot;Bei Jin&quot;</span>);</span><br><span class="line">        Inventor tesla1 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla1&quot;</span>, <span class="string">&quot;Shang Hai&quot;</span>);</span><br><span class="line">        Inventor tesla2 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla2&quot;</span>, <span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Inventor tesla3 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla3&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        Inventor tesla4 = <span class="keyword">new</span> Inventor(<span class="string">&quot;Nikola Tesla4&quot;</span>, <span class="string">&quot;Serbian&quot;</span>);</span><br><span class="line">        List&lt;Inventor&gt; inventors = Arrays.asList(tesla, tesla1, tesla2, tesla3, tesla4);</span><br><span class="line"></span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        context.setVariable(<span class="string">&quot;inventors&quot;</span>, inventors);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对List做各类运算：</span></span><br><span class="line">        <span class="comment">// 过滤，选择所有 nationality 字段为 &#x27;Serbian&#x27; 的 Inventor 对象</span></span><br><span class="line">        List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.?[nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 nationality 字段，并返回一个新的 List</span></span><br><span class="line">        List&lt;Inventor&gt; list1 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list1.toString());</span><br><span class="line">        <span class="comment">// 投影，对所有对象的 nationality 字段是否为 &#x27;Serbian&#x27; 进行判断，并返回一个新的布尔类型List</span></span><br><span class="line">        List&lt;Inventor&gt; list2 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![nationality==&#x27;Serbian&#x27;]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list2.toString());</span><br><span class="line">        <span class="comment">// 投影，选择所有 Inventor 对象的 serbian 字段，并返回一个新的 List，与list1等同。</span></span><br><span class="line">        List&lt;Inventor&gt; list3 = (List&lt;Inventor&gt;) parser.parseExpression(<span class="string">&quot;#inventors.![#this.getNationality()]&quot;</span>).getValue(context);</span><br><span class="line">        log.info(list3.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问Map"><a href="#访问Map" class="headerlink" title="访问Map"></a>访问Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问map</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">params.put(<span class="string">&quot;backOrderCode&quot;</span>, <span class="string">&quot;H12345764564&quot;</span>);</span><br><span class="line">context.setVariable(<span class="string">&quot;params&quot;</span>, params);</span><br><span class="line">Object object = parser.parseExpression(<span class="string">&quot;#params[backOrderCode]&quot;</span>).getValue(context);</span><br><span class="line">log.info(object.toString());</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] <a href="https://zhuanlan.zhihu.com/p/174786047">https://zhuanlan.zhihu.com/p/174786047</a><br>[2] <a href="https://zhuanlan.zhihu.com/p/149920813">https://zhuanlan.zhihu.com/p/149920813</a><br>[3] <a href="https://docs.spring.io/spring-framework/reference/core/expressions.html">https://docs.spring.io/spring-framework/reference/core/expressions.html</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;SpEL即Spring表达式语言（Spring Expression Language），它能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合。&lt;/p&gt;
&lt;p&gt;SpEL是单独模块（&lt;code&gt;org.springframework.expression&lt;/code&gt;），只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;br&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://silencezheng.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://silencezheng.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>空洞卷积</title>
    <link href="http://silencezheng.top/2023/12/25/article124/"/>
    <id>http://silencezheng.top/2023/12/25/article124/</id>
    <published>2023-12-24T18:01:57.000Z</published>
    <updated>2023-12-24T18:07:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。<br><span id="more"></span></p><h2 id="提出"><a href="#提出" class="headerlink" title="提出"></a>提出</h2><p>空洞卷积最初的提出是为了解决图像分割的问题，常见的图像分割算法通常使用池化层和卷积层来增加感受域，同时也缩小了特征图尺寸(resolution)，然后再利用上采样还原图像尺寸，特征图缩小再放大的过程造成了精度上的损失，因此需要一种操作可以在增加感受域的同时保持特征图的尺寸不变，从而代替下采样和上采样操作，在这种需求下，空洞卷积就诞生了。当然，跳跃连接（skip connection）也是另一种弥补信息损失的方法。</p><p>空洞卷积自2016在ICLR上被提出后，本身是用在图像分割领域，但立马被Deepmind拿来应用到语音(WaveNet)和NLP领域，它在物体检测也发挥了重要的作用。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在常规卷积运算中，固定大小的滤波器在输入特征图上滑动，滤波器中的值与输入特征图中的相应值相乘以产生单个输出值。输出特征图中神经元的感受域被定义为滤波器可以“看到”的输入特征图中的区域。感受域的大小由滤波器的大小和卷积的步长决定。</p><p>相反，在膨胀卷积运算中，通过在滤波器值之间插入间隙来“扩张”滤波器。<strong>膨胀率</strong>(dilation rate) 决定了间隙的大小，它是一个可以调整的超参数。当膨胀率为 1 时，膨胀卷积简化为常规卷积。</p><p>膨胀率在不增加参数数量的情况下有效地增加了滤波器的感受域，因为滤波器的大小仍然相同，但值之间有间隙。这在需要更大感受域的情况下很有用，但增加滤波器的大小会导致参数数量和计算复杂性的增加。</p><p>下图描述了正常卷积与扩张卷积之间的差异，附加参数$l$（膨胀因子）表示输入扩张了多少。换句话说，根据该参数的值，滤波器中会跳过$(l-1)$个像素。</p><p><img src="/assets/post_img/article124/normalvsdilatedconv.png" alt="dc"></p><p>膨胀卷积的公式可表示如下：</p><script type="math/tex; mode=display">\left(F_{* l} k\right)(p)=\sum_{(s+l t=p)} F(s) k(t)</script><p>其中，$F(s)$为输入特征，$s$为各采样位置，$k(t)$表示卷积核$k$在$t$处的权重，${*l}$表示膨胀因子为$l$的膨胀卷积。</p><p>$(F_{* l} k)(p)$为在位置$p$处的输出。求和条件还需要再看下…</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在Pytorch中实现空洞卷积十分简单，只需要指定dilation参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DilatedCNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(DilatedCNN,self).__init__()</span><br><span class="line">    self.convlayers = nn.Sequential(</span><br><span class="line">      nn.Conv2d(in_channels = <span class="number">3</span>, out_channels = <span class="number">6</span>, kernel_size = <span class="number">9</span>, stride = <span class="number">1</span>, padding = <span class="number">0</span>, dilation=<span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Conv2d(in_channels=<span class="number">6</span>, out_channels=<span class="number">16</span>, kernel_size = <span class="number">3</span>, stride = <span class="number">1</span>, padding= <span class="number">0</span>, dilation = <span class="number">2</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">    )</span><br><span class="line">    self.fclayers = nn.Sequential(</span><br><span class="line">      nn.Linear(<span class="number">2304</span>,<span class="number">120</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">120</span>,<span class="number">84</span>),</span><br><span class="line">      nn.ReLU(),</span><br><span class="line">      nn.Linear(<span class="number">84</span>,<span class="number">10</span>)</span><br><span class="line">    )</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">    x = self.convlayers(x)</span><br><span class="line">    x = x.view(-<span class="number">1</span>,<span class="number">2304</span>)</span><br><span class="line">    x = self.fclayers(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="可能产生的问题"><a href="#可能产生的问题" class="headerlink" title="可能产生的问题"></a>可能产生的问题</h2><ol><li>网格效应（The Gridding Effect）</li><li>Long-ranged information might be not relevant.</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/113285797">https://zhuanlan.zhihu.com/p/113285797</a><br>[2] <a href="https://www.geeksforgeeks.org/dilated-convolution/">https://www.geeksforgeeks.org/dilated-convolution/</a><br>[3] <a href="https://developer.orbbec.com.cn/v/blog_detail/892">https://developer.orbbec.com.cn/v/blog_detail/892</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>首发于 <a href="https://silencezheng.top">silencezheng.top</a>，转载请注明出处。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;空洞卷积，Dilated Convolution，也可译为膨胀卷积或扩张卷积，可以使网络在不增加参数数量的情况下拥有更大的感受域。&lt;br&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://silencezheng.top/tags/Python/"/>
    
    <category term="深度学习" scheme="http://silencezheng.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
